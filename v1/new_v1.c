/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/
/*  modify  */
#define LOBYTE(x)   (*((uint8_t *)&(x)))
#define HIBYTE(x)   (*(((uint8_t *)&(x)) + 1))
#define LOWORD(x)   (*((uint16_t *)&(x)))
#define HIWORD(x)   (*(((uint16_t *)&(x)) + 1))
#define LODWORD(x)  (*((uint32_t *)&(x)))
#define HIDWORD(x)  (*(((uint32_t *)&(x)) + 1))
#define BYTE1(x) (*(((uint8_t *)&(x)) + 1))
#define BYTE2(x) (*(((uint8_t *)&(x)) + 2))
#define BYTE6(x) (*(((uint8_t *)&(x)) + 6))

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include "defs.h"
#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations
#define _DWORD unsigned int
#define _BYTE unsigned char
#define _WORD unsigned short int
#define _UNKNOWN unsigned int
#define bool int
#define _QWORD uint64_t
#define _BOOL2 int

int free2(void *ptr) {
    free(ptr);
    return 0; 
}

int init_proc();
void ftext();
int sub_408C40(void);
int *sub_408D10(_DWORD, _DWORD);
int *trace(int a1, int a2, ...);
int   sub_408E68(int a1);
int httpd_main();
int *preparesslkey();
int   main(int argc, char **argv, char **envp);
BOOL   websReapChildren(int a1, int a2);
int   websStartupServer(int a1);
int   websConnValid(int a1);
char *  websSetEnv(int a1);
int   websSetQuery(int a1);
void   websTimeoutCancel(int a1);
int   websSetTimeStamp(int *a1);
int   websWriteComplete(int a1, int a2, int a3);
int websWriteFmt(int a1, int a2, ...);
int   websWritePartial(int a1, int a2, signed int a3);
int   websConnAlloc(int a1);
int   websAccept(int a1, int a2, int a3, int a4);
int *  websConnFree(int a1);
int *  websConnClose(int a1, int a2);
int *  websTimeout(_DWORD *a1, int a2);
_DWORD *websShutdownServer();
char *  websCommonWriteHeader(int a1, int a2, int a3, char *a4, int a5);
char *  websGetRealm(int a1);
int   websWriteNormalHeader(int a1, int a2, int a3, char *a4, int a5);
int *  websConnResponse(_DWORD *a1, int a2, char *a3);
int *websConnError(int a1, int a2, int a3, ...);
int   sub_40C7E0(int a1, char *a2);
int   websReadEvent(_DWORD *a1);
int   websSocketEvent(int a1, unsigned int a2, _DWORD *a3);
int   websWriteActiveHeader(_DWORD *a1, int a2, int a3, char *a4, int a5);
int websWriteSpecialHeader(int a1, int a2, int a3, char *a4, int a5, int a6, ...);
int   websJsonWriteHeader(int a1, int a2);
int *  websReplyNoContent(int a1);
int   websReplyUnSupportMsg(int a1);
int   websTimeoutSched(int a1, int a2, int a3);
int   websTimeoutResched(int a1, int a2);
void   websTimeoutUnsched(int a1);
int websTimeoutProcess();
int   allocDecodePasswordByName(int a1, int a2);
int   allocEncodePasswordByName(int a1, int a2);
int   websWritePasswordByString(int a1, char *a2);
int   websWritePasswordByName(int a1, int a2);
int   nipcaWritePasswordByString(int a1, char *a2);
int   getSysInfoBuffer(int a1, int a2, int a3);
int   AllocateMACAddress(int a1, int a2);
int   get_pantilt_range(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int   pantilt_cmd(int *a1);
int   websPatchRequest(_DWORD *a1, char *a2);
int *  websetReplayPage(int a1, int a2, char *a3, char *a4);
int   websAddUser(int a1, int a2, int a3);
int   websDeleteUser(int a1);
int *  webAddReplyMessage(int a1, char *a2, int a3);
int   AllocPassFromConfigByUser(int a1, int a2, int *a3);
int   AllocPrintableString(_BYTE *a1);
int   AllocXMLString(_BYTE *a1);
int   WriteHexString(int a1, unsigned __int8 *a2);
int   WritePrintableString(int a1, _BYTE *a2);
int   WriteMacString(int a1, unsigned __int8 *a2, int a3);
int   WriteTimerString(int a1, int a2, unsigned __int16 a3, unsigned __int16 a4, unsigned __int16 a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8);
int   getStringConfig(int a1, int a2, int a3, _DWORD *a4);
int   getHashMd5StringConfig(int a1, int a2, int a3, _DWORD *a4);
int   getHexStringConfig(int a1, int a2, int a3, _DWORD *a4);
int   getPrintableStringConfig(int a1, int a2, int a3, _DWORD *a4);
int   getIntConfig(int a1, int a2, int a3, _DWORD *a4);
int   getBitRateValue(int a1);
int   getRadioConfig(int a1, int a2, int a3, _DWORD *a4);
int   getCheckConfig(int a1, int a2, int a3, _DWORD *a4);
int   getSelectString(int a1, int a2, _BYTE **a3, int a4, _DWORD *a5);
int   getSelectStringOfMatchValue(int a1, int a2, int a3, _BYTE **a4, int a5, _DWORD *a6);
int   getStringOfValueSelect(int a1, int a2, _BYTE **a3, int a4, _DWORD *a5);
int   getSysInfoShort(int a1);
int   getChannelSelectString(int a1, int a2, char **a3, int a4, _DWORD *a5);
int   getLogoSelectString(int a1, int a2, char **a3, int a4, _DWORD *a5);
int   getStringOfMatchValue(int a1, int a2, int a3, _BYTE **a4, int a5, _DWORD *a6);
int   getCurrentTimeString(int a1, int a2);
int   getStringVar(int a1, int a2, int a3);
int   getHexStringVar(int a1, int a2, int a3);
int   getPrintableStringVar(int a1, int a2, int a3);
int *  copyStringHexVar(int a1, char *a2, int a3, int a4);
int   websConfigGetFromVar(int a1, int a2, char *a3, char **a4);
int   websGetSelectString(_DWORD *a1, int a2);
int   getSysInfoLong(int a1);
int   setSysInfoNone(int a1);
int   setSysInfoBuffer(int a1, int a2, int a3);
int   setSysInfoShort(int a1, __int16 a2);
int   setSysInfoLong(int a1, int a2);
int   websgetSysInfoString(int a1, int a2);
int   websgetSysInfoPrintableString(int a1, int a2);
int   websgetSysInfoLong(int a1, int a2);
int   websgetSysInfoShort(int a1, int a2);
int   websgetSysInfoNetAddress(int a1, int a2);
int   set_reboot_time(int a1, int a2);
int   switch_language(int a1, int a2);
_BYTE *  ParseSetPoition(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _BYTE *a5);
_BYTE *  skipSpace(_BYTE *a1);
int *  websSetVar(int a1, char *a2, char *a3);
int   websTestVar(int a1, int a2);
int   websGetVar(int a1, int a2, int a3);
BOOL   websTestVarValue(int a1, int a2, int a3);
void   websDeleteVar(int a1, char *a2);
int   websCloseVar(int a1);
int   websParaDefine(void *a1, int a2);
int websParaOpen();
int websParaClose();
int   websParaRequest(int a1, char *a2);
int   websSetFormDefine(void *a1, int a2);
int websSetFormOpen();
int websSetFormClose();
int   websSetFormProcessor(int a1, int a2, int a3, int a4, int a5);
int   websDecode64(int a1, char *a2, unsigned int a3);
int   websEncode64(_BYTE *a1, char *a2, int a3);
int   websReplacePathIntrenal(int a1);
int   websInternalForwardURL(int *a1);
void   websKernalParameter(int a1);
BOOL   checkASPFile(int a1);
int   checkPatchFile(int a1);
int   checkCgiPostRequest(int a1);
int   checkSessionKeyRequest(int a1);
int websEnableErrorMessage();
int websDisableErrorMessage();
void *  websGetErrorMessage(int a1);
_DWORD *  umGetUser(int a1);
int   umAddUser(void *a1, void *a2, int a3);
void   umDelUser(int a1);
int websEnableAllUser();
int websDisableAllUser();
int websEnableHtmlFile();
int websStartAuthentication();
int websEndAuthentication();
int   websGetAuthenticateRealm(int a1);
int   websCheckRealm(int a1);
void websRefreshCookieDigest();
int websSocketOpen();
int   websSocketGetPtr(int a1);
int   websSocketSetBlock(int a1, int a2);
int   websSocketRead(int a1, int a2, int a3);
int   websSocketGets(int a1, int *a2);
int   websSocketFlush(int a1);
int   websSocketWrite(int a1, int a2, int a3);
int   websSocketEof(int a1);
int   websSocketSelect(int a1, int a2);
_DWORD *  websSocketCreateEvent(int a1, int a2, int a3, int a4);
_DWORD *  websSocketDeleteEvent(int a1);
_DWORD *  websSocketFree(int a1);
int   sub_419114(_DWORD *a1);
_DWORD *  websSocketCloseConnection(int a1);
_DWORD **websSocketEventPoll();
_DWORD *websSocketClose();
int   websSocketOpenConnection(int a1, int a2, unsigned int a3);
int   websSocketGetPort(int a1);
int   mmalloc(int a1);
int   AllocEntryId(_DWORD *a1);
int   FreeEntryId(int *a1, int a2);
int   AllocEntry(int *a1, int *a2, int a3);
unsigned int   memPoolLen(_DWORD *a1);
int   memPoolOpen(int *a1, int a2, int a3);
_BYTE *  memPoolFlush(_DWORD *a1);
int   memPoolClose(_DWORD *a1);
int   memPoolPutMaxBlockSize(_DWORD *a1);
unsigned int   memPoolGetMaxBlockSize(_DWORD *a1);
int   sub_41A754(int *a1);
int   memPoolPutBlock(int *a1, int a2, int a3);
int   memPoolPutChar(int *a1, char a2);
_BYTE *  memPoolPutBlockPtrAdj(_DWORD *a1, int a2);
_BYTE *  memPoolGetBlockPtrAdj(_DWORD *a1, int a2);
int   memsearch(int a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4);
int   findStrInFile(int a1, int a2, unsigned __int8 *a3, int a4);
int   getMemInFile(int a1, int a2, int a3);
int   sub_41B230(int *a1, int a2);
int   MD5Init(_DWORD *a1);
int   MD5Update(int *a1, int a2, unsigned int a3);
int   MD5Final(_DWORD *a1, int a2);
int   hmac_md5(int a1, unsigned int a2, _DWORD *a3, int a4, _DWORD *a5);
int   Sleep(int a1);
int   strdupWithoutNull(void *a1);
int   vallocFmtString(int *a1, int a2, int a3, int a4);
int doSystem(int a1, ...);
int allocFmtString(int *a1, int a2, int a3, ...);
int   strndupWithoutNull(int a1, int a2);
int   webncasestrcmp(int a1, int a2);
_BYTE *  strlower(_BYTE *a1);
_BYTE *  strupper(_BYTE *a1);
_BYTE *  stritoa(int a1, _BYTE *a2, int a3);
char *  websRemoveDuplicateChars(char *a1, char a2);
int websGetTempFileName();
__int64   hexarraytohexstring(unsigned __int8 *a1, _BYTE *a2, unsigned int a3);
unsigned int   hexstringtohexarray(char *a1, int a2);
int   websProcessUrlAndCheckRealm(int a1);
int   websUrlProcessRequest(int a1);
int   websSafeUrl(char *a1);
int   websDecodeUrl(char *a1, char *a2, int a3);
int   websParseUrlInfo(char *a1, int *a2, int *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, char **a7);
char *  websGetUrlType(char *a1, char *a2);
int   websConnValidateUrl(int a1, void *a2);
int   websConnValidateUrlPath(int a1, void *a2);
BOOL   DigestCalcHA1(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int   DigestCalcResponse(int a1, int a2, int a3, int a4, _BYTE *a5, int a6, int a7, int a8, int a9);
int   websGetDigestNonce(int a1);
int   websCheckDigestRealm(int a1);
int websSSLOpen();
int   websSSLAccept(int a1, int a2, int a3, int a4);
int   websSSLRead(int **a1, int a2, int a3);
int   websSSLGets(int a1, int *a2);
int *  sub_420570(int a1, unsigned int a2, _DWORD *a3);
int   websSSLWrite(int **a1, int a2, signed int a3);
int   websSSLEof(int a1);
int websSSLFlush();
int   webssslWriteClosureAlert(_DWORD ***a1);
int   websSSLFree(int **a1);
int websSSLClose();
int   sslRead(int *a1, int a2, int a3, _DWORD *a4);
int   sslWrite(int *a1, int a2, signed int a3, int *a4);
int   sslWriteClosureAlert(_DWORD **a1);
int   sslFreeConnection(int **a1);
int   sslAccept(int **a1, int a2, int a3, int a4);
int   checkrangestring(int a1, int a2, int a3, int a4, int a5);
int   checkcameraname(int a1, int a2, int a3, int a4, int a5);
int   checkusername(int a1, int a2, int a3, int a4, int a5);
int   checkmaxstring(int a1, int a2, int a3, int a4);
int   checkwepkey(int a1, int a2, int a3, int a4);
int   checkpresharedkey(int a1, int a2, int a3, int a4, int a5);
int   checkdatestring(int a1, char *a2, int a3);
int   checktimestring(int a1, char *a2, int a3);
int   checkhhmmstring(int a1, char *a2, int a3);
int   checkislong(int a1, char *a2, int a3);
int   checklongrange(int a1, char *a2, int a3, int a4, int a5);
int   checktimezoneindex(int a1, char *a2, int a3, int a4, int a5);
int   checktimezone(int a1, char *a2, int a3, int a4, int a5);
BOOL   checkenumrange(int a1, int a2, _BYTE **a3);
BOOL   checkMatchValue(int a1, char *a2, int a3, _BYTE **a4, _BYTE **a5);
int   CheckVarRange(int a1, char *a2, int *a3);
int   websGetVarCheck(int a1, char *a2, int *a3);
int   CheckAuthorizationModeVar(int a1);
BOOL   AuthorizationModeChanged(int a1);
int   WriteAuthorizationModeVar(int a1);
int   OSDTimeChanged(int a1);
int   CheckSystemVar(int a1);
int   WriteSystemVar(int a1);
int   CheckNetworkVar(int a1);
int   SystemNetworkChanged(int a1);
int   SystemDDNSChanged(int a1);
int   WriteNetworkVar(int a1);
int   SystemWirelessChanged(int a1);
int   CheckWirelessVar(int a1);
int   WriteWirelessVar(int a1);
int   CheckStreamVar(int a1);
int   StreamImageChanged(int a1);
int   StreamVideoChanged(int a1);
int   StreamAudioChanged(int a1);
int   WriteStreamVar(int a1);
int   CheckEmailVar(int a1);
int   SystemEmailChanged(int a1);
int   WriteEmailVar(int a1);
int   CheckFTPVar(int a1);
int   SystemFTPChanged(int a1);
int   WriteFTPVar(int a1);
int   CheckDateVar(int a1);
int   SystemDateChanged(int a1);
int   WriteDateVar(int a1);
int   CheckMotionVar(int a1);
int   WriteMotionVar(int a1);
int   SystemMotionChanged(int a1);
int   CheckDayNightVar(int a1);
int   SystemDayNightChanged(int a1);
int   WriteDayNightVar(int a1);
int   CheckSoundDBVar(int a1);
int   SystemSoundDBChanged(int a1);
int   WriteSoundDBVar(int a1);
int   CheckCIFSVar(int a1);
int   SystemCIFSChanged(int a1);
int   WriteCIFSVar(int a1);
int   sub_42FACC(int a1);
int   sub_42FBA4(int a1);
int   sub_42FC28(int a1);
int *  sub_42FCE8(int a1);
int *  sub_42FE04(int a1);
int *  sub_430028(int a1);
int *  sub_4301CC(int a1);
int *  sub_43032C(int a1);
int *  sub_4303B8(int a1);
int *  sub_4305F0(int a1);
int *  sub_43064C(int a1);
int *  sub_430EA0(int a1);
int *  sub_4312FC(int a1);
int *  sub_431708(int a1);
int *  sub_431A80(int a1);
int *  sub_431C74(int a1);
int *  sub_4320E8(int a1);
int *  sub_432984(int a1);
int *  sub_433054(int a1);
int *  sub_433804(int a1);
int *  sub_433CD0(int a1);
int *  sub_4340E4(int a1);
int *  sub_434394(int a1);
int *  sub_434838(int a1);
int *  sub_434BE4(int a1);
int *  sub_434E50(int a1);
int *  sub_435134(int a1);
int *  sub_4353E4(int a1);
int *  sub_435544(int a1);
int *  sub_435B30(int a1);
int formDefineManagement();
int   getMTDPartSize(int a1);
int   sub_436254(int a1);
int   sub_4363F8(int a1, signed int a2, int a3, _DWORD *a4, char *a5, int a6, unsigned int a7, _DWORD *a8, int a9);
int   uploadconfig(_DWORD *a1);
int   uploadfirmware(_DWORD *a1);
int   npcuploadfirmware(int a1);
int   websCgibinProcessor(int a1);
void websCgiReapChildren();
int *  authorizationmode(int a1);
int *  iocontrol(int a1);
int *  snapimage(int a1);
int *  resetdevice(int a1);
int *  getconfig(int a1, char *a2);
int   gotopresetion(int a1);
int *  pantiltcontrol(int a1);
int *  ptzpresetlist(int a1);
int *  ptzpreset(int a1);
int *  ptzmovepos(int a1);
int *  ptzmoverel(int a1);
int *  ptzhome(int a1);
int *  ptzpatrolpan(int a1);
int *  ptzptdc(int a1);
int *  audiodetection(int a1);
int *  nipcauserverify(int a1);
int *  nipcacamerainfo(int a1);
int *  nipcarebootdevice(int a1);
int *  nipcafactoryreset(int a1);
int *  nipcamicrophone(int a1);
int *  nipcaportalinfo(int a1);
int   websFrameProcessor(int a1);
void websFrameReapChildren();
int *  imagepush(int a1, int a2, char *a3, int a4, int a5);
int *  h264videopush(int a1, int a2, char *a3, int a4, int a5);
int   websStreamProcessor(int a1, int a2, int a3, int a4, char *a5);
void websStreamReapChildren();
int InitBlowfish();
int   CBlowfish(int a1, unsigned int a2);
int   Blowfish_EnCode(int a1, int *a2, unsigned int a3);
int   Blowfish_DeCode(int a1, int *a2, unsigned int a3);
int *  sub_440E20(int *a1);
int   websGetFileProcessor(int a1, int a2, int a3, void *a4);
int   websForkGetFileProcessor(int a1);
int websSDCardReapChildren();
int   sub_4418E8(int a1);
int   sub_441930(int a1);
int   sub_441B88(int a1);
int   sub_441E04(int a1);
int   sub_441F60(int a1);
int   sub_441FE8(int a1);
int   sub_442070(int a1);
int   sub_4420F8(int a1);
int   sub_442214(int a1);
int   sub_4423C8(int a1);
int   sub_4424E4(int a1);
int   sub_442500(int a1);
int   sub_44251C(int a1);
int   sub_442538(int a1);
int   sub_442554(int a1, int a2, _DWORD *a3);
int   sub_44257C(int a1, int a2, _DWORD *a3);
int   sub_4425A4(int a1, int a2, _DWORD *a3);
int   sub_4425CC(int a1, int a2, _DWORD *a3);
int   sub_4425F4(int a1, int a2, _DWORD *a3);
int   sub_44261C(int a1, int a2, _DWORD *a3);
int   sub_442644(int a1, int a2, _DWORD *a3);
int   sub_4427B8(int a1, int a2, _DWORD *a3);
int   sub_4427E0(int a1, int a2, _DWORD *a3);
int   sub_442808(int a1, int a2, _DWORD *a3);
int   sub_442830(int a1, int a2, _DWORD *a3);
int   sub_44287C(int a1, int a2, _DWORD *a3);
int   sub_4428A4(int a1, int a2, _DWORD *a3);
int   sub_4428CC(int a1, int a2, _DWORD *a3);
int   sub_4428F4(int a1, int a2, _DWORD *a3);
int   sub_44291C(int a1, int a2, _DWORD *a3);
int   sub_442964(int a1, int a2, _DWORD *a3);
int   sub_44298C(int a1, int a2, _DWORD *a3);
int   sub_4429B4(int a1, int a2, _DWORD *a3);
int   sub_4429FC(int a1, int a2, _DWORD *a3);
int   sub_442A24(int a1, int a2, _DWORD *a3);
int   sub_442A4C(int a1, int a2, _DWORD *a3);
int   sub_442A94(int a1, int a2, _DWORD *a3);
int   sub_442ABC(int a1, int a2, _DWORD *a3);
int formDefineInternet();
int   sub_442FB8(int a1);
int   sub_443048(int a1, int a2, int *a3);
int   sub_443138(int a1);
int   sub_4431CC(int a1);
int   sub_443254(int a1);
int   sub_44329C(int a1);
int   sub_443304(int a1);
int   sub_443320(int a1);
int   sub_44333C(int a1);
int   sub_443494(int a1, int a2, _DWORD *a3);
int   sub_443C8C(int a1);
int   sub_4440A0(int a1, int a2, _DWORD *a3);
int   sub_4440C8(int a1, int a2, _DWORD *a3);
int   sub_4440F0(int a1, int a2, _DWORD *a3);
int   sub_444158(int a1, int a2, _DWORD *a3);
int   sub_444180(int a1, int a2, _DWORD *a3);
int   sub_4441C8(int a1, int a2, _DWORD *a3);
int   sub_4441F0(int a1, int a2, _DWORD *a3);
int   sub_444238(int a1, int a2, _DWORD *a3);
int   sub_444284(int a1, int a2, _DWORD *a3);
int   sub_4442AC(int a1, int a2, _DWORD *a3);
int   sub_4442D4(int a1, int a2, _DWORD *a3);
int   sub_44431C(int a1, int a2, _DWORD *a3);
int   sub_444344(int a1, int a2, _DWORD *a3);
int   sub_44438C(int a1, int a2, _DWORD *a3);
int   sub_44457C(int a1, int a2, _DWORD *a3);
int   sub_444764(int a1, int a2, _DWORD *a3);
int   sub_44478C(int a1, int a2, _DWORD *a3);
int   sub_4447B4(int a1, int a2, _DWORD *a3);
int   sub_4447DC(int a1, int a2, _DWORD *a3);
int   sub_444804(int a1, int a2, _DWORD *a3);
int   sub_444850(int a1, int a2, _DWORD *a3);
int   sub_444A20(int a1, int a2, _DWORD *a3);
int   sub_444BF0(int a1, int a2, _DWORD *a3);
int   sub_444DC0(int a1, int a2, _DWORD *a3);
int   sub_444F90(int a1, int a2, _DWORD *a3);
int   sub_445160(int a1, int a2, _DWORD *a3);
int   sub_445188(int a1, int a2, _DWORD *a3);
int   sub_4451B0(int a1, int a2, _DWORD *a3);
int   sub_4451D8(int a1, int a2, _DWORD *a3);
int   sub_445200(int a1, int a2, _DWORD *a3);
int   sub_445228(int a1);
int   sub_445244(int a1, int a2, _DWORD *a3);
int   sub_44526C(int a1, int a2, _DWORD *a3);
int   sub_445294(int a1, int a2, _DWORD *a3);
int   sub_4452BC(int a1, int a2, _DWORD *a3);
int   sub_4452E4(int a1, int a2, _DWORD *a3);
int   sub_44530C(int a1, int a2, _DWORD *a3);
int   sub_445354(int a1, int a2, _DWORD *a3);
int   sub_445544(int a1, int a2, _DWORD *a3);
int   sub_44568C(int a1, int a2, _DWORD *a3);
int   sub_4456B4(int a1, int a2, _DWORD *a3);
int   sub_4456DC(int a1, int a2, _DWORD *a3);
int   sub_445704(int a1, int a2, _DWORD *a3);
int   sub_4458D4(int a1, int a2, _DWORD *a3);
int   sub_4458FC(int a1, int a2, _DWORD *a3);
int   sub_445944(int a1, int a2, _DWORD *a3);
int   sub_44596C(int a1, int a2, _DWORD *a3);
int   sub_445B3C(int a1, int a2, _DWORD *a3);
int   sub_445F38(int a1);
int   sub_445F54(int a1, int a2, _DWORD *a3);
int   sub_445F7C(int a1, int a2, _DWORD *a3);
int   sub_445FC4(int a1);
int formDefineWireless();
int   sub_446860(int a1);
int   sub_446888(int a1);
int   sub_4469B8(int a1);
int   sub_4469DC(int a1);
int   sub_446ADC(int a1);
int   sub_446CC0(int a1);
int   sub_446D24(int a1);
int   sub_446D48(int a1);
int   sub_446DAC(int a1);
int   sub_446E50(int a1);
int   sub_446FA4(int a1);
int   sub_44714C(int a1);
int   sub_447304(int a1);
int   sub_4473B8(int a1, int a2, _DWORD *a3);
int   sub_447624(int a1, int a2, _DWORD *a3);
int   sub_447B98(int a1);
int   sub_447BBC(int a1);
int   sub_447C14(int a1);
int   sub_447C38(_DWORD *a1);
int   sub_447C58(int a1);
int   sub_447C78(int a1);
int   sub_447C94(int a1);
int   sub_447CB0(int a1);
int   sub_447CCC(int a1);
int   sub_447DD4(int a1, int a2, _DWORD *a3);
int   sub_447EDC(int a1, int a2, _DWORD *a3);
int   sub_4480DC(int a1, int a2, int *a3);
int   sub_4481EC(int a1);
int   sub_448294(int a1);
int   sub_4482B0(int a1);
int   sub_4482CC(int a1, int a2, _DWORD *a3);
int   sub_448388(int a1);
int   sub_448504(int a1);
int   sub_4485A8(int a1);
int   sub_4485CC(int a1);
int   sub_4485F0(int a1, int a2, _DWORD *a3);
int   sub_448618(int a1, int a2, _DWORD *a3);
int   sub_448640(int a1, int a2, _DWORD *a3);
int   sub_448668(int a1, int a2, _DWORD *a3);
int   sub_448860(int a1, int a2, _DWORD *a3);
int   sub_448888(int a1, int a2, _DWORD *a3);
int   sub_4488B0(int a1, int a2, _DWORD *a3);
int   sub_4488D8(int a1, int a2, _DWORD *a3);
int   sub_448900(int a1, int a2, _DWORD *a3);
int   sub_448928(int a1, int a2, _DWORD *a3);
int   sub_448950(int a1, int a2, _DWORD *a3);
int   sub_448978(int a1, int a2, _DWORD *a3);
int   sub_4489A0(int a1, int a2, _DWORD *a3);
int   sub_4490C0(int a1, int a2, _DWORD *a3);
int   sub_4491F4(int a1, int a2, _DWORD *a3);
int   sub_44921C(int a1, int a2, _DWORD *a3);
int   sub_449244(int a1, int a2, _DWORD *a3);
int   sub_44926C(int a1, int a2, _DWORD *a3);
int   sub_449294(int a1, int a2, _DWORD *a3);
int   sub_4492BC(int a1, int a2, _DWORD *a3);
int   sub_449414(int a1, int a2, _DWORD *a3);
int   sub_449650(int a1);
int   sub_449670(int a1, int a2, _DWORD *a3);
int   sub_449698(int a1, int a2, _DWORD *a3);
int   sub_4496C0(int a1);
int   sub_4496E0(int a1);
int   sub_449700(int a1);
int   sub_449720(int a1);
int   sub_449740(int a1);
int   sub_449760(int a1);
int   sub_449780(int a1, int a2, _DWORD *a3);
int   sub_4497A8(int a1, int a2, _DWORD *a3);
int   sub_4497D0(int a1, int a2, _DWORD *a3);
int   sub_4497F8(int a1, int a2, _DWORD *a3);
int   sub_449820(int a1, int a2, _DWORD *a3);
int   sub_449848(int a1, int a2, _DWORD *a3);
int   sub_449870(int a1, int a2, _DWORD *a3);
int   sub_449898(int a1, int a2, _DWORD *a3);
int   sub_4498C0(int a1, int a2, _DWORD *a3);
int   sub_4498E8(int a1, int a2, _DWORD *a3);
int   sub_449910(int a1, int a2, _DWORD *a3);
int   sub_449938(int a1);
int formDefineDevice();
int   sub_44A310(int a1);
int   sub_44A384(int a1);
int   sub_44A3F8(int a1);
int   sub_44A46C(int a1);
int   sub_44A534(int a1);
int   sub_44A678(int a1, int a2, _DWORD *a3);
int   sub_44A6A0(int a1, int a2, _DWORD *a3);
int   sub_44A6C8(int a1, int a2, _DWORD *a3);
int   sub_44A6F0(int a1, int a2, _DWORD *a3);
int   sub_44A738(int a1, int a2, _DWORD *a3);
int   sub_44A760(int a1, int a2, _DWORD *a3);
int   sub_44A788(int a1, int a2, _DWORD *a3);
int   sub_44A8FC(int a1, int a2, _DWORD *a3);
int   sub_44A924(int a1, int a2, _DWORD *a3);
int   sub_44A94C(int a1, int a2, _DWORD *a3);
int   sub_44A974(int a1, int a2, _DWORD *a3);
int   sub_44A99C(int a1, int a2, _DWORD *a3);
int   sub_44A9C4(int a1, int a2, _DWORD *a3);
int   sub_44A9EC(int a1, int a2, _DWORD *a3);
int   sub_44AB60(int a1, int a2, _DWORD *a3);
int   sub_44AB88(int a1, int a2, _DWORD *a3);
int   sub_44ABB0(int a1, int a2, _DWORD *a3);
int   sub_44ABD8(int a1, int a2, _DWORD *a3);
int   sub_44AC00(int a1, int a2, _DWORD *a3);
int   sub_44AC28(int a1, int a2, _DWORD *a3);
int   sub_44AC50(int a1, int a2, _DWORD *a3);
int   sub_44AC78(int a1, int a2, _DWORD *a3);
int   sub_44ACA0(int a1, int a2, _DWORD *a3);
int   sub_44ACC8(int a1, int a2, _DWORD *a3);
int   sub_44ACF0(int a1, int a2, _DWORD *a3);
int   sub_44AD18(int a1, int a2, _DWORD *a3);
int   sub_44AD40(int a1, int a2, _DWORD *a3);
int   sub_44AD68(int a1, int a2, _DWORD *a3);
int   sub_44AD90(int a1, int a2, _DWORD *a3);
int   sub_44ADDC(int a1, int a2, _DWORD *a3);
int   sub_44AE04(int a1, int a2, _DWORD *a3);
int   sub_44AE2C(int a1, int a2, _DWORD *a3);
int   sub_44AE54(int a1, int a2, _DWORD *a3);
int   sub_44AFC8(int a1, int a2, _DWORD *a3);
int   sub_44AFF0(int a1, int a2, _DWORD *a3);
int   sub_44B018(int a1, int a2, _DWORD *a3);
int   sub_44B040(int a1, int a2, _DWORD *a3);
int   sub_44B068(int a1, int a2, _DWORD *a3);
int   sub_44B090(int a1, int a2, _DWORD *a3);
int   sub_44B0B8(int a1, int a2, _DWORD *a3);
int   sub_44B0E0(int a1, int a2, _DWORD *a3);
int   sub_44B108(int a1, int a2, _DWORD *a3);
int   sub_44B130(int a1, int a2, _DWORD *a3);
int   sub_44B158(int a1, int a2, _DWORD *a3);
int   sub_44B180(int a1, int a2, _DWORD *a3);
int   sub_44B1A8(int a1, int a2, _DWORD *a3);
int   sub_44B1D0(int a1, int a2, _DWORD *a3);
int   sub_44B1F8(int a1, int a2, _DWORD *a3);
int   sub_44B244(int a1, int a2, _DWORD *a3);
int   sub_44B26C(int a1, int a2, _DWORD *a3);
int   sub_44B294(int a1, int a2, _DWORD *a3);
int   sub_44B2BC(int a1, int a2, _DWORD *a3);
int   sub_44B2E4(int a1, int a2, _DWORD *a3);
int   sub_44B30C(int a1, int a2, _DWORD *a3);
int   sub_44B334(int a1, int a2, _DWORD *a3);
int   sub_44B35C(int a1, int a2, _DWORD *a3);
int   sub_44B384(int a1, int a2, _DWORD *a3);
int   sub_44B3AC(int a1, int a2, _DWORD *a3);
int   sub_44B3D4(int a1, int a2, _DWORD *a3);
int   sub_44B3FC(int a1, int a2, _DWORD *a3);
int   sub_44B424(int a1, int a2, _DWORD *a3);
int   sub_44B44C(int a1, int a2, _DWORD *a3);
int   sub_44B474(int a1, int a2, _DWORD *a3);
int   sub_44B49C(int a1, int a2, _DWORD *a3);
int   sub_44B4C4(int a1, int a2, _DWORD *a3);
int   sub_44B4EC(int a1, int a2, _DWORD *a3);
int   sub_44B514(int a1, int a2, _DWORD *a3);
int   sub_44B53C(int a1, int a2, _DWORD *a3);
int   sub_44B564(int a1, int a2, _DWORD *a3);
int   sub_44B58C(int a1, int a2, _DWORD *a3);
int   sub_44B5B4(int a1, int a2, _DWORD *a3);
int   sub_44B5DC(int a1, int a2, _DWORD *a3);
int   sub_44B604(int a1, int a2, _DWORD *a3);
int   sub_44B62C(int a1, int a2, _DWORD *a3);
int   sub_44B654(int a1, int a2, _DWORD *a3);
int   sub_44B67C(int a1, int a2, _DWORD *a3);
int   sub_44B6A4(int a1, int a2, _DWORD *a3);
int   sub_44B6CC(int a1, int a2, _DWORD *a3);
int   sub_44B6F4(int a1, int a2, _DWORD *a3);
int   sub_44B868(int a1, int a2, _DWORD *a3);
int   sub_44B890(int a1, int a2, _DWORD *a3);
int   sub_44B8B8(int a1, int a2, _DWORD *a3);
int   sub_44B8E0(int a1, int a2, _DWORD *a3);
int   sub_44B908(int a1, int a2, _DWORD *a3);
int   sub_44B930(int a1, int a2, _DWORD *a3);
int   sub_44B958(int a1, int a2, _DWORD *a3);
int   sub_44B980(int a1, int a2, _DWORD *a3);
int   sub_44B9A8(int a1, int a2, _DWORD *a3);
int   sub_44B9D0(int a1, int a2, _DWORD *a3);
int   sub_44B9F8(int a1, int a2, _DWORD *a3);
int formDefineNetworkAPI();
int   checklivefile(int a1, int a2);
int *  getHttpLiveStream(int a1);
int   sub_44CBB8(int a1);
int   sub_44CBD8(int a1);
int   sub_44CBF8(int a1);
int   sub_44CC58(int a1);
int   sub_44CC74(int a1);
int   sub_44CD94(int a1);
int   sub_44CF08(int a1, int a2, _DWORD *a3);
int   sub_44D070(int a1, int a2, _DWORD *a3);
int   sub_44D204(int a1);
int   sub_44D228(int a1, int a2, _DWORD *a3);
int   sub_44D250(int a1);
int   sub_44D2A8(int a1);
int   sub_44D4F8(int a1);
int   sub_44D750(int a1, int a2, _DWORD *a3);
int   sub_44D778(int a1, int a2, _DWORD *a3);
int   sub_44D8B0(int a1, int a2, _DWORD *a3);
int   sub_44DA2C(int a1, int a2, _DWORD *a3);
int   sub_44DA54(int a1, int a2, _DWORD *a3);
int   sub_44DA7C(int a1, int a2, _DWORD *a3);
int   sub_44DAC8(int a1, int a2, _DWORD *a3);
int   sub_44DBB0(int a1, int a2, _DWORD *a3);
int   sub_44DBD8(int a1, int a2, _DWORD *a3);
int   sub_44DC20(int a1);
int   sub_44DCC4(int a1);
int   sub_44DD64(int a1);
int   sub_44DE04(int a1);
int   sub_44DEA4(int a1, int a2, _DWORD *a3);
int   sub_44DECC(int a1, int a2, _DWORD *a3);
int   sub_44DEF4(int a1, int a2, _DWORD *a3);
int   sub_44DF1C(int a1, int a2, _DWORD *a3);
int   sub_44DF64(int a1, int a2, _DWORD *a3);
int   sub_44DF8C(int a1, int a2, _DWORD *a3);
int   sub_44DFB4(int a1, int a2, _DWORD *a3);
int   sub_44DFFC(int a1, int a2, _DWORD *a3);
int   sub_44E024(int a1, int a2, _DWORD *a3);
int   sub_44E04C(int a1, int a2, _DWORD *a3);
int   sub_44E098(int a1, int a2, _DWORD *a3);
int   sub_44E0C0(int a1, int a2, _DWORD *a3);
int   sub_44E0E8(int a1, int a2, _DWORD *a3);
int   sub_44E130(int a1, int a2, _DWORD *a3);
int   sub_44E158(int a1, int a2, _DWORD *a3);
int   sub_44E180(int a1, int a2, _DWORD *a3);
int   sub_44E1A8(int a1, int a2, _DWORD *a3);
int   sub_44E1D0(int a1, int a2, _DWORD *a3);
int   sub_44E1F8(int a1, int a2, _DWORD *a3);
int   sub_44E220(int a1, int a2, _DWORD *a3);
int   sub_44E248(int a1, int a2, _DWORD *a3);
int   sub_44E270(int a1, int a2, _DWORD *a3);
int   sub_44E2B8(int a1, int a2, _DWORD *a3);
int   sub_44E2E0(int a1);
int   sub_44E420(int a1);
int   sub_44E444(int a1);
int   sub_44E5E0(int a1);
int   sub_44E77C(int a1, int a2, _DWORD *a3);
int   sub_44E7A4(int a1, int a2, _DWORD *a3);
int   sub_44E7EC(int a1, int a2, _DWORD *a3);
int   sub_44E814(int a1, int a2, _DWORD *a3);
int   sub_44E85C(int a1, int a2, _DWORD *a3);
int   sub_44E884(int a1, int a2, _DWORD *a3);
int   sub_44E8AC(int a1, int a2, _DWORD *a3);
int   sub_44EA48(int a1, int a2, _DWORD *a3);
int   sub_44EEB8(int a1, int a2, _DWORD *a3);
int   sub_44F1C0(int a1, int a2, _DWORD *a3);
int   sub_44F1E8(int a1, int a2, _DWORD *a3);
int   sub_44F210(int a1, int a2, _DWORD *a3);
int   sub_44F324(int a1, int a2, _DWORD *a3);
int   sub_44F34C(int a1, int a2, _DWORD *a3);
int   sub_44F374(int a1, int a2, _DWORD *a3);
int   sub_44F39C(int a1, int a2, _DWORD *a3);
int   sub_44F3C4(int a1, int a2, _DWORD *a3);
int   sub_44F3EC(int a1, int a2, _DWORD *a3);
int   sub_44F414(int a1, int a2, _DWORD *a3);
int   sub_44F43C(int a1, int a2, _DWORD *a3);
int   sub_44F464(int a1, int a2, _DWORD *a3);
int   sub_44F48C(int a1, int a2, _DWORD *a3);
int   sub_44F4B4(int a1, int a2, _DWORD *a3);
int   sub_44F4DC(int a1, int a2, _DWORD *a3);
int   sub_44F504(int a1, int a2, _DWORD *a3);
int   sub_44F52C(int a1, int a2, _DWORD *a3);
int   sub_44F554(int a1, int a2, _DWORD *a3);
int   sub_44F57C(int a1, int a2, _DWORD *a3);
int   sub_44F5A4(int a1, int a2, _DWORD *a3);
int   sub_44F5CC(int a1, int a2, _DWORD *a3);
int   sub_44F5F4(int a1, int a2, _DWORD *a3);
int   sub_44F61C(int a1, int a2, _DWORD *a3);
int   sub_44F644(int a1, int a2, _DWORD *a3);
int   sub_44F66C(int a1, int a2, _DWORD *a3);
int   sub_44F694(int a1, int a2, _DWORD *a3);
int   sub_44F6BC(int a1, int a2, _DWORD *a3);
int   sub_44F6E4(int a1, int a2, _DWORD *a3);
int   sub_44F70C(int a1, int a2, _DWORD *a3);
int   sub_44F734(int a1, int a2, _DWORD *a3);
int   sub_44F75C(int a1, int a2, _DWORD *a3);
int   sub_44F784(int a1, int a2, _DWORD *a3);
int   sub_44F7AC(int a1, int a2, _DWORD *a3);
int   sub_44F7D4(int a1, int a2, _DWORD *a3);
int   sub_44F7FC(int a1, int a2, _DWORD *a3);
int   sub_44F824(int a1, int a2, _DWORD *a3);
int   sub_44F84C(int a1, int a2, _DWORD *a3);
int   sub_44F874(int a1, int a2, _DWORD *a3);
int   sub_44F89C(int a1, int a2, _DWORD *a3);
int   sub_44F8C4(int a1, int a2, _DWORD *a3);
int   sub_44F8EC(int a1);
int formDefineMedia();
int   websGetAntiTblCount(int a1);
void   websAntiTblUnsched(int a1);
int   websAntiBruteProcessor(char **a1);
int websAntiBruteReapChildren();
int   aesencrypt(int a1, unsigned int a2, int a3, unsigned int a4, _DWORD *a5);
int   aesdecrypt(int a1, unsigned int a2, int a3, unsigned int a4, _DWORD *a5);
int   allocDecryptbyHexKey(int a1, unsigned int a2, int a3, unsigned int a4);
int   allocEncryptbyHexKey(int a1, unsigned int a2, int a3, unsigned int a4);
int   allocDecryptbyKey(int a1, unsigned __int8 *a2);
int   allocEncryptbyKey(int a1, unsigned __int8 *a2);
int   matrixSslOpenWithConfig(int a1);
int matrixSslClose();
int   matrixSslNewKeys(_DWORD *a1, int a2);
int   psTestUserEcID(int a1, unsigned int a2);
int   curveIdToFlag(int a1);
int   matrixSslGenEphemeralEcKey(int a1, int a2, unsigned __int8 *a3);
int   matrixSslDeleteKeys(int a1);
int   sub_4522A0(int a1, char *a2, int a3, int a4, char *a5, int a6);
int   matrixSslLoadRsaKeys(int a1, char *a2, int a3, int a4, char *a5);
int   matrixUpdateSession(int a1);
int   matrixSslDeleteSession(int a1);
int   matrixSslNewSession(int *a1, int a2, _DWORD *a3, _DWORD *a4);
int   matrixClearSession(int a1, int a2);
BOOL   matrixSslHandshakeIsComplete(int a1);
void   matrixSslSetCertValidator(int a1, int a2);
int   matrixRegisterSession(int a1);
int   matrixResumeSession(int a1);
int matrixSessionTicketLen();
int   matrixCreateSessionTicket(int a1, int a2, int *a3);
int   matrixUnlockSessionTicket(int a1, int a2, int a3);
int   matrixSslGetSessionId(int a1, int a2);
int   matrixServerSetKeysSNI(int a1);
int   sslResetContext(int a1);
int   matrixValidateCertsExt(int a1, _DWORD *a2, int a3, unsigned __int8 *a4, int *a5, int a6, int a7, unsigned int *a8);
int   matrixUserCertValidator(int a1, int a2, int a3, int (  *a4)(int, int, int));
int   matrixSslNewServerSession(_DWORD *a1, int a2, int a3, int a4);
int   matrixSslGetReadbuf(_DWORD *a1, _DWORD *a2);
int   matrixSslGetOutdata(_DWORD *a1, _DWORD *a2);
int   matrixSslGetWritebuf(int a1, int *a2, unsigned int a3);
int   matrixSslEncodeWritebuf(int a1, int a2);
int   matrixSslReceivedData(int a1, int a2, char **a3, int *a4);
int   matrixSslProcessedData(_DWORD *a1, char **a2, int *a3);
int   matrixSslEncodeClosureAlert(_DWORD *a1);
int   matrixSslSentData(_DWORD *a1, int a2);
int   matrixSslDecode(unsigned __int16 *a1, int *a2, char **a3, int a4, _DWORD *a5, int *a6, int *a7, unsigned __int8 *a8, _BYTE *a9);
int   matrixSslGetEncodedSize(int a1, int a2);
int   sub_459804(int a1, int a2, int a3, int a4, _DWORD *a5, int a6);
int   sub_459D0C(int a1, _DWORD *a2);
int   sub_45A220(int a1);
int   clearFlightList(int a1);
int   freePkaAfter(int a1);
int   psWriteRecordInfo(int a1, char a2, __int16 a3, char *a4, int a5);
int   psWriteHandshakeHeader(int a1, char a2, int a3, __int16 a4, int a5, int a6, _BYTE *a7);
int   sub_45AD54(int a1, unsigned __int8 a2, unsigned __int8 a3, _WORD *a4, _BYTE *a5, int *a6, int a7, int *a8);
int   sub_45B4B0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int *a8);
int   sub_45B710(int a1, _DWORD *a2);
int   sslWritePad(_BYTE *a1, unsigned __int8 a2);
int   sub_45BE58(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int *a8);
int   sslEncodeClosureAlert(int a1, _DWORD *a2, _DWORD *a3);
int   matrixSslEncode(int a1, int a2, int a3, int a4, _WORD *a5);
int   sub_45C7D0(int a1, int *a2);
int   sub_45CF80(int a1, int *a2);
int   sub_45DA18(int a1, int *a2, int a3);
int   matrixSslEncodeClientHello(int a1, _DWORD *a2, unsigned __int16 *a3, unsigned __int8 a4, _DWORD *a5, int a6, int a7);
int   sub_45F5A0(int a1, int *a2);
int   sub_45FE18(int a1, int *a2);
int   sub_46097C(_DWORD *a1, _DWORD *a2, int a3, int a4);
int   sslEncodeResponse(int a1, int *a2, int *a3);
int   sub_463EB0(int a1);
int   tlsDeriveKeys(int a1);
int   tlsExtendedDeriveKeys(int a1);
int   tlsHMACSha1(int a1, int a2, char a3, int a4, unsigned int a5, int a6);
int   tlsHMACSha2(int a1, int a2, char a3, int a4, unsigned int a5, _DWORD *a6, int a7);
int   sslCreateKeys(int a1);
int   sslActivateReadCipher(int a1);
int   sslActivateWriteCipher(int a1);
int sub_464E5C();
int   csAesGcmInit(int a1, int a2, unsigned __int8 a3);
unsigned int   csAesGcmEncrypt(int a1, _BYTE *a2, _BYTE *a3, unsigned int a4);
int   csAesGcmDecrypt(int a1, _DWORD *a2, _BYTE *a3, int a4);
int   csAesInit(int a1, int a2, unsigned __int8 a3);
unsigned int   csAesEncrypt(int a1, int a2, _BYTE *a3, unsigned int a4);
unsigned int   csAesDecrypt(int a1, unsigned int *a2, int a3, unsigned int a4);
int   sub_465398(int a1, int a2, int a3, int a4);
int   sub_4653EC(int a1, int a2, int a3, int a4);
int sub_465440();
int sub_465448();
int   sub_465450(int a1, char a2, int a3, unsigned int a4, int a5);
int   sub_465528(int a1, char a2, int a3, unsigned int a4, int a5);
int   haveKeyMaterial(_DWORD *a1, int a2, __int16 a3);
__int16 *  sslGetCipherSpec(int a1, unsigned __int16 a2);
int   chooseCipherSuite(int a1, unsigned int a2, int a3);
int   eccSuitesSupported(int a1, _WORD *a2, unsigned __int8 a3);
BOOL   csCheckCertAgainstCipherSuite(int a1, int a2);
int   sslGetCipherSpecList(int a1, _BYTE *a2, int a3);
int   sslGetCipherSpecListLen(int a1);
int   matrixSslSetKexFlags(int a1);
int dtlsGenCookieSecret();
int   dtlsComputeCookie(int a1, int a2, unsigned int a3);
int   matrixDtlsSetPmtu(int a1);
int matrixDtlsGetPmtu();
char *  sub_466FCC(int a1, int a2, int a3, int a4, char *a5);
int   dtlsWriteCertificateRequest(int a1, int a2, int a3, int a4, int a5, char *a6);
int   dtlsWriteCertificate(int a1, int a2, int a3, char *a4);
int   dtlsIncrRsn(int a1);
int   dtlsEncryptFragRecord(int a1, int *a2, int a3, _DWORD *a4);
int   dtlsHsHashFragMsg(int a1);
int   dtlsCompareEpoch(int a1, int a2);
int   dtlsChkReplayWindow(int a1, int a2);
int   dtlsInitFrag(int a1);
int   dtlsSeenFrag(int a1, int a2, int *a3);
int   incrTwoByte(int a1, _BYTE *a2, int a3);
_BYTE *  zeroSixByte(int a1);
int   parseClientHello(unsigned int a1, unsigned __int8 **a2, unsigned __int8 *a3);
int   parseClientKeyExchange(int a1, signed int a2, unsigned __int8 **a3, int a4);
int   parseCertificateVerify(int a1, int a2, unsigned __int8 **a3, int a4);
int   parseServerHello(int a1, int a2, unsigned __int8 **a3, unsigned __int8 *a4);
int   parseServerKeyExchange(int a1, _DWORD *a2, unsigned __int8 **a3, int a4);
int   parseCertificateStatus(int a1, int a2, unsigned __int8 **a3, unsigned __int8 *a4);
int   parseServerHelloDone(int a1, int a2, int *a3);
int   parseCertificateRequest(int a1, int a2, unsigned __int8 **a3, int a4);
int   parseFinished(int a1, int a2, int a3, int *a4, int a5);
int   parseCertificate(int a1, unsigned __int8 **a2, int a3);
int   sslInitHSHash(_DWORD *a1);
int   sslUpdateHSHash(int a1, int a2, unsigned __int16 a3);
int   sslSha1RetrieveHSHash(_DWORD *a1, _DWORD *a2);
int   sslSha384RetrieveHSHash(int a1, _DWORD *a2);
int   sslSha512RetrieveHSHash(int a1, _DWORD *a2);
int   sslSha1SnapshotHSHash(int a1, int a2);
int   sslSha384SnapshotHSHash(int a1, _DWORD *a2);
int   sslSha512SnapshotHSHash(int a1, int a2);
int   extMasterSecretSnapshotHSHash(int *a1, _DWORD *a2, int a3);
int   sslSnapshotHSHash(int *a1, int a2, int a3);
int   prf(int a1, unsigned __int16 a2, int a3, unsigned __int16 a4, int a5, unsigned __int16 a6);
int   prf2(int a1, unsigned __int16 a2, int a3, unsigned __int16 a4, int a5, unsigned __int16 a6, unsigned int a7);
int   matrixPskGetHint(int a1, _DWORD *a2, _BYTE *a3);
int   matrixSslPskGetKeyId(int a1, _DWORD *a2, _BYTE *a3);
int   matrixSslPskGetKey(int a1, int a2, unsigned __int8 a3, _DWORD *a4, _BYTE *a5);
int   parseClientHelloExtensions(int a1, unsigned __int8 **a2, unsigned __int16 a3);
int   parseServerHelloExtensions(int a1, int a2, int a3, unsigned __int8 **a4, unsigned __int16 a5);
int   psAesClearCBC(unsigned __int8 *a1);
int   psAesInitCBC(int a1, int a2, unsigned int *a3, unsigned __int8 a4, int a5);
int   psAesEncryptCBC(int a1, int a2, _BYTE *a3, unsigned int a4);
int   psAesDecryptCBC(int a1, unsigned int *a2, int a3, unsigned int a4);
int   psAesInitGCM(int a1, unsigned int *a2, unsigned __int8 a3);
int   sub_46DEAC(int a1, unsigned int *a2, _DWORD *a3);
int   sub_46E090(int a1, _BYTE *a2, _BYTE *a3, unsigned int a4, char a5);
int   psAesEncryptGCM(int a1, _BYTE *a2, _BYTE *a3, unsigned int a4);
int   psAesReadyGCM(int a1, _DWORD *a2, int a3, unsigned __int16 a4);
int   sub_46E8E8(_DWORD *a1);
int   psAesGetGCMTag(int a1, unsigned __int8 a2, _BYTE *a3);
int   psAesDecryptGCM(int a1, _BYTE *a2, unsigned int a3, _BYTE *a4, unsigned int a5);
BOOL   sub_46EE00(_DWORD *a1);
int   psSha1Init(_DWORD *a1);
int   psSha1Update(int *a1, int a2, unsigned int a3);
int   psSha1Final(__int64 *a1, int a2);
int   sub_46F42C(int a1, int a2);
int   psSha256Init(_DWORD *a1);
int   psSha256Update(int *a1, int a2, unsigned int a3);
int   psSha256Final(int a1, int a2);
int   sub_46FAB4(int a1, int a2);
int   psSha512Init(_DWORD *a1);
int   psSha512Update(int *a1, int a2, unsigned int a3);
int   psSha512Final(int a1, int a2);
int   psSha384Init(_DWORD *a1);
int   psSha384Update(int *a1, int a2, unsigned int a3);
int   psSha384Final(int a1, _DWORD *a2);
int   psMd5Sha1Init(__int64 *a1);
int   psMd5Sha1Update(int *a1, int a2, unsigned int a3);
int   psMd5Sha1Final(__int64 *a1, int a2);
int   psMd5Init(_DWORD *a1);
int   sub_470974(_DWORD *a1);
int   psMd5Final(__int64 *a1, int a2);
int   psMd5Update(int *a1, int a2, unsigned int a3);
int   psHmacMd5Update(int a1, int a2, unsigned int a3);
int   psHmacMd5Init(int a1, int a2, unsigned __int16 a3);
int   psHmacMd5Final(int a1, int a2);
int   psHmacMd5(int a1, unsigned __int16 a2, int a3, unsigned int a4, int a5, int a6, unsigned __int16 *a7);
int   psHmacSha1Update(int a1, int a2, unsigned int a3);
int   psHmacSha1Init(int a1, int a2, unsigned __int16 a3);
int   psHmacSha1Final(int a1, int a2);
int   psHmacSha1(int a1, unsigned __int16 a2, int a3, unsigned int a4, int a5, int a6, unsigned __int16 *a7);
int   psHmacSha256Update(int a1, int a2, unsigned int a3);
int   psHmacSha256Init(int a1, int a2, unsigned __int16 a3);
int   psHmacSha256Final(int a1, int a2);
int   psHmacSha256(int a1, unsigned __int16 a2, int a3, unsigned int a4, _DWORD *a5, _DWORD *a6, unsigned __int16 *a7);
int   psHmacSha384Update(int a1, int a2, unsigned int a3);
int   psHmacUpdate(int a1, int a2, unsigned int a3);
int   psHmacSha384Init(int a1, int a2, unsigned __int16 a3);
int   psHmacInit(int a1, unsigned int a2, int a3, unsigned __int16 a4);
int   psHmacSha384Final(int a1, _DWORD *a2);
int   psHmacFinal(int a1, _DWORD *a2);
int   psHmacSha384(int a1, unsigned __int16 a2, int a3, unsigned int a4, _DWORD *a5, _DWORD *a6, unsigned __int16 *a7);
int   pkcs1Pad(int a1, unsigned __int16 a2, _BYTE *a3, unsigned __int16 a4, char a5);
int   pkcs1Unpad(_BYTE *a1, unsigned __int16 a2, _BYTE *a3, unsigned __int16 a4, char a5);
int   psPkcs5Pbkdf2(int a1, unsigned __int16 a2, int a3, unsigned int a4, int a5, int a6, int a7);
int   psPkcs8ParsePrivBin(int a1, unsigned __int8 *a2, int a3, int a4, int a5);
int   psPkcs5Pbkdf1(int a1, unsigned int a2, int a3, int a4, _DWORD *a5);
int   psPkcs1DecodePrivFile(int a1, int a2, int a3, unsigned int **a4, unsigned __int16 *a5);
int   psPkcs1ParsePrivFile(int a1, int a2, int a3, int a4);
int   sub_474004(int a1, int a2, unsigned int a3, int a4, _BYTE *a5, int a6);
int   psPkcs1PssDecode(int a1, int a2, unsigned int a3, unsigned __int8 *a4, int a5, unsigned int a6, int a7, unsigned int a8, _DWORD *a9);
int   sub_474B4C(unsigned __int8 **a1, int a2, int a3, int a4);
int   getSerialNum(int a1, unsigned __int8 **a2, unsigned __int16 a3, int *a4, unsigned __int16 *a5);
int   sub_4750A4(int a1, unsigned __int8 **a2, unsigned __int16 a3, int a4, int *a5, _WORD *a6);
int   psX509GetSignature(int a1, unsigned __int8 **a2, unsigned __int16 a3, int *a4, _WORD *a5);
int   psX509FreeDNStruct(_DWORD *a1);
int   x509FreeExtensions(_DWORD *a1);
int   psX509FreeCert(int a1);
int   psX509ValidateGeneralName(unsigned __int8 *a1);
int   sub_475E88(int a1, unsigned __int8 **a2, unsigned __int16 a3, unsigned __int8 *a4, int *a5, __int16 a6);
int   sub_476464(int a1, unsigned __int8 *a2, __int16 a3, unsigned __int16 a4, int *a5, _WORD *a6);
int   sub_476A3C(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int16 a4, int a5, unsigned __int16 *a6);
int   psX509GetDNAttributes(int a1, unsigned __int8 **a2, unsigned __int16 a3, int a4, unsigned int a5);
int   getExplicitExtensions(int a1, unsigned __int8 **a2, unsigned __int16 a3, int a4, int a5, char a6);
int   psX509ParseCert(int a1, unsigned __int8 *a2, int a3, int *a4, unsigned int a5);
int   psX509ParseCertFile(int a1, char *a2, _DWORD *a3, unsigned int a4);
int   psX509AuthenticateCert(int a1, int a2, int a3, int *a4);
int   psOcspParseResponse(int a1, int a2, unsigned __int8 **a3, unsigned __int8 *a4, int a5);
int   psOcspResponseCheckDates(int a1, int a2, int *a3, int *a4, int *a5, int *a6, int a7);
int   psOcspResponseValidate(int a1, int a2, int a3, _BYTE **a4, void *a5);
int   psOcspResponseValidateOld(int a1, int a2, int a3, _BYTE **a4);
int   psCryptoOpen(int a1);
int psCryptoClose();
int   pstm_init_size(int a1, int *a2, unsigned __int16 a3);
int   pstm_init(int a1, int *a2);
int   pstm_grow(int *a1, unsigned __int16 a2);
int   pstm_copy(int a1, int *a2);
int   pstm_clamp(int *a1);
void   pstm_clear(_DWORD *a1);
void   pstm_clear_multi(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8);
int   pstm_cmp_mag(_DWORD *a1, _DWORD *a2);
int   pstm_cmp(_DWORD *a1, _DWORD *a2);
int   pstm_cmp_d(unsigned int **a1, unsigned int a2);
int   pstm_init_for_read_unsigned_bin(int a1, int *a2, unsigned __int16 a3);
int   pstm_read_unsigned_bin(int *a1, _BYTE *a2, unsigned __int16 a3);
int   pstm_read_asn(int a1, unsigned __int8 **a2, unsigned __int16 a3, int *a4);
signed int   pstm_set(int a1, int a2);
int   pstm_unsigned_bin_size(_DWORD *a1);
int   pstm_sub_s(int *a1, int *a2, int *a3);
int   sub_47EB54(_DWORD *a1, _DWORD *a2, int *a3);
int   pstm_add(int *a1, int *a2, int *a3);
int   pstm_read_radix(int a1, int *a2, unsigned __int8 *a3, unsigned __int16 a4, unsigned __int8 a5);
int   pstm_sub(int *a1, int *a2, int *a3);
int   pstm_montgomery_setup(int **a1, _DWORD *a2);
int   pstm_montgomery_calc_normalization(int *a1, int *a2);
int   sub_47FDB8(int a1, __int16 a2, int *a3);
int   pstm_div_2d(int a1, int a2, __int16 a3, int *a4, int *a5);
int   pstm_div_2(int a1, int *a2);
int   pstm_init_copy(int a1, int *a2, int a3, char a4);
int   pstm_div(int a1, int a2, int a3, int *a4, int *a5);
int   pstm_mod(int a1, int a2, int a3, int *a4);
int   pstm_mulmod(int a1, int *a2, int *a3, int a4, int *a5);
int   pstm_exptmod(int a1, int *a2, _DWORD *a3, int *a4, int *a5);
int   pstm_to_unsigned_bin(int a1, int *a2, int a3);
int   pstm_invmod(int a1, int a2, int *a3, int *a4);
int   pstm_montgomery_reduce(int a1, int *a2, int *a3, int a4, _DWORD *a5, unsigned __int16 a6);
int   pstm_mul_comba(int a1, int *a2, int *a3, int *a4, int a5, unsigned __int16 a6);
int   pstm_sqr_comba(int a1, int *a2, int *a3, int a4, unsigned __int16 a5);
int psOpenPrng();
int psClosePrng();
int   psGetPrngLocked(int a1, unsigned __int16 a2);
int   psEccInitKey(int a1, _DWORD *a2, int a3);
void   psEccClearKey(int a1);
int   psEccNewKey(int a1, int *a2, int a3);
int   psEccCopyKey(int a1, int a2);
int   psEccDeleteKey(int *a1);
int   psEccSize(int a1);
int   getEccParamByOid(int a1, char **a2);
int   getEccParamById(unsigned __int16 a1, char **a2);
int   psGetEccCurveIdList(int a1, _BYTE *a2);
int   userSuppliedEccList(_BYTE *a1, _BYTE *a2, unsigned int a3);
int compiledInEcFlags();
int *  sub_48695C(int a1, int a2);
int   psEccX963ImportKey(int a1, _BYTE *a2, unsigned __int16 a3, int a4, unsigned __int8 *a5);
int   psEccParsePrivKey(int a1, unsigned __int8 *a2, unsigned __int16 a3, int a4, char *a5);
int   psEccParsePrivFile(int a1, int a2, int a3, int a4);
int   getEcPubKey(int a1, unsigned __int8 **a2, __int16 a3, int a4, int a5);
int   psEccX963ExportKey(int a1, int a2, _BYTE *a3, _WORD *a4);
int   sub_487E0C(int a1, int a2, int *a3, int *a4, int *a5, int *a6);
int   sub_4889CC(int a1, _DWORD *a2, _DWORD *a3, int *a4, int *a5, int *a6, int *a7);
int   sub_489818(int a1, int *a2, int *a3, int *a4);
int   sub_489B40(int a1, int a2, int *a3, int *a4, int a5, unsigned __int8 a6, int *a7);
int   psEccGenSharedSecret(int a1, int a2, int a3, int a4, _WORD *a5);
int   psEccGenKey(int a1, int a2, unsigned __int8 *a3);
int   psEccDsaVerify(int a1, int a2, _BYTE *a3, unsigned __int16 a4, unsigned __int8 *a5, unsigned __int16 a6, _DWORD *a7);
int   psEccDsaSign(int a1, int a2, _BYTE *a3, unsigned __int16 a4, _BYTE *a5, _WORD *a6, unsigned __int8 a7);
int   psInitPubKey(int a1, int a2, char a3);
void   psClearPubKey(int a1);
int   psHashLenToSigAlg(unsigned __int16 a1, unsigned __int8 a2);
int   psVerifySig(int a1, _BYTE *a2, unsigned __int16 a3, unsigned __int8 *a4, unsigned __int16 a5, int a6, int a7, _DWORD *a8);
int   psRsaInitKey(int a1, int a2);
void   psRsaClearKey(int a1);
int   psRsaCopyKey(int a1, int a2);
int   psRsaSize(int a1);
int   psRsaCmpPubKey(_DWORD *a1, _DWORD *a2);
int   psRsaParseAsnPubKey(int a1, unsigned __int8 **a2, unsigned __int16 a3, int a4, int a5);
int   psRsaParsePkcs1PrivKey(int a1, unsigned __int8 *a2, unsigned __int16 a3, int a4);
int   psRsaCrypt(int a1, int a2, _BYTE *a3, unsigned __int16 a4, _BYTE *a5, _WORD *a6, char a7);
int   psRsaEncryptPub(int a1, int a2, int a3, unsigned __int16 a4, _BYTE *a5, unsigned __int16 a6);
int   psRsaDecryptPub(int a1, int a2, _BYTE *a3, unsigned __int16 a4, _BYTE *a5, unsigned __int16 a6);
int   psRsaEncryptPriv(int a1, int a2, int a3, unsigned __int16 a4, unsigned __int8 *a5, unsigned __int16 a6);
int   privRsaEncryptSignedElement(int a1, int a2, int a3, unsigned __int16 a4, unsigned __int8 *a5, unsigned __int16 a6);
int   pubRsaDecryptSignedElementExt(int a1, int a2, _BYTE *a3, unsigned __int16 a4, int a5, unsigned __int16 a6);
int   pubRsaDecryptSignedElement(int a1, int a2, _BYTE *a3, unsigned __int16 a4, int a5, unsigned __int16 a6);
int   psRsaDecryptPriv(int a1, int a2, _BYTE *a3, unsigned __int16 a4, _BYTE *a5, unsigned __int16 a6);
int   psAesEncryptBlock(int a1, unsigned int *a2, _BYTE *a3);
int   psAesDecryptBlock(int a1, unsigned int *a2, _BYTE *a3);
int   psAesInitBlockKey(int a1, unsigned int *a2, unsigned __int8 a3, int a4);
int   sub_48F248(int a1, int a2, _DWORD *a3);
int   sub_48F5CC(unsigned int *a1, _DWORD *a2);
int   psDes3Init(_DWORD *a1, int a2, int a3);
int   psDes3Decrypt(_DWORD *a1, int a2, int a3, unsigned int a4);
int   getAsnTagLenUnsafe(_BYTE *a1);
int   getAsnLength32(unsigned __int8 **a1, int a2, unsigned int *a3, int a4);
int   getAsnLength(unsigned __int8 **a1, unsigned __int16 a2, _WORD *a3);
int   getAsnSequence32(unsigned __int8 **a1, int a2, unsigned int *a3, int a4);
int   getAsnSequence(_DWORD *a1, unsigned __int16 a2, _WORD *a3);
int   sub_490330(unsigned __int8 **a1, unsigned int a2, unsigned int *a3, int a4);
int   getAsnSet(unsigned __int8 **a1, unsigned __int16 a2, _WORD *a3);
int   getAsnEnumerated(char **a1, int a2, int *a3);
int   getAsnInteger(char **a1, int a2, int *a3);
unsigned int   asnParseOid(_BYTE *a1, unsigned __int16 a2, unsigned int *a3);
int   sub_490BB8(int *a1, int a2, int a3);
int   getAsnOID(unsigned __int8 **a1, int a2, int *a3, unsigned __int8 a4, _WORD *a5);
int   getAsnAlgorithmIdentifier(unsigned int **a1, int a2, int *a3, _WORD *a4);
int   psBase64decode(int a1, unsigned __int16 a2, int a3, _WORD *a4);
int psCrlOpen();
int   sub_491BCC(int a1);
int   sub_491DB4(_DWORD *a1);
int psCrlClose();
int   psCRL_determineRevokedStatusBDT(int a1, _DWORD *a2);
int   psCRL_determineRevokedStatus(int a1);
int   memset_s(unsigned __int8 *a1, unsigned int a2, int a3, unsigned int a4);
void psCoreClose();
int   memcmpct(int a1, int a2, int a3);
int   psErrorStr(char *a1, int a2);
int   psCoreOpen(int a1);
int   psError(int a1);
int   psErrorInt(char *a1, int a2);
int   psFreeList(_DWORD *a1);
int   psParseList(int a1, char *a2, int a3, _DWORD *a4);
int   psBurnStack(unsigned int a1);
int   psBrokenDownTimeAdd(_DWORD *a1, int a2);
int   psGetBrokenDownGMTime(_DWORD *a1, int a2);
int   psBrokenDownTimeImport(int *a1, _BYTE *a2, unsigned int a3, unsigned int a4);
int   psBrokenDownTimeCmp(int a1, int a2);
int   psToUtf8String(int a1, int a2, int a3, unsigned int a4, int *a5, int *a6, int a7);
__int64   psDynBufInit(int a1, int *a2, int a3);
_UNKNOWN **  psDynBufUninit(int a1);
int   psDynBufDetach(_DWORD *a1, _DWORD *a2);
unsigned int   sub_493C10(unsigned int *a1);
int   sub_493D8C(unsigned int *a1, int a2, unsigned int a3);
unsigned int   psDynBufAppendSize(unsigned int *a1, unsigned int a2);
_BYTE *  psDynBufAppendUtf8(unsigned int *a1, unsigned int a2);
int   psParseBufFromStaticData(_DWORD *a1, int a2, int a3);
unsigned int   psParseBufTrySkipBytes(_DWORD *a1, int a2, unsigned int a3);
unsigned int   psParseBufSkipBytes(_DWORD *a1, int a2, unsigned int a3);
unsigned int   psParseBufTryReadTagSub(int a1, char *a2, unsigned __int8 a3);
unsigned int   psParseBufReadTagSub(int *a1, char *a2, unsigned __int8 a3);
unsigned int   psParseBufReadTagRef(int *a1, _DWORD *a2, unsigned __int8 a3);
int   psParseBufFinish(int *a1);
unsigned int   psParseBufTrySkipTag(int a1, unsigned __int8 a2);
int osdepTimeOpen();
void osdepTimeClose();
int   psGetTime(int a1);
int   psDiffMsecs(int a1, int a2, int a3, int a4);
int osdepMutexOpen();
void osdepMutexClose();
int psLockMutex();
int psUnlockMutex();
int psDestroyMutex();
int osdepEntropyClose();
int   psGetEntropy(int a1, int a2);
int psGetTraceFile();
int   psTraceInt(char *a1, int a2);
int   psTraceStr(char *a1, int a2);
int osdepEntropyOpen();
int   psCreateMutex(int a1, int a2);
int   psTrace(int a1);
int   psGetFileBufFp(int a1, int a2, int *a3, int *a4);
int   psGetFileBuf(int a1, int a2, int *a3, int *a4);
int sub_495F20();
int term_proc();
// int   getsockname(_DWORD, _DWORD, _DWORD); weak
// int   free2(_DWORD); weak
// int   vfprintf(_DWORD, _DWORD, _DWORD); weak
// int   close(_DWORD); weak
// int   _register_frame_info(_DWORD, _DWORD); weak
// int   getpgid(_DWORD); weak
// int   fcntl(_DWORD, _DWORD); weak
// int   Jv_RegisterClasses(_DWORD, _DWORD); weak
// int   fputs(_DWORD, _DWORD); weak
// int   strchr(_DWORD, _DWORD); weak
// void   __noreturn _assert(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int   nvram_init(_DWORD); weak
// int   open(_DWORD, _DWORD); weak
// int   strlen(_DWORD); weak
// int   pthread_mutex_init(_DWORD, _DWORD); weak
// int   tempnam(_DWORD, _DWORD); weak
// int   strspn(_DWORD, _DWORD); weak
// int   fileno(_DWORD); weak
// int   atoi(_DWORD); weak
// void   __noreturn exit(_DWORD); weak
// int _errno_location(void); weak
// int   pthread_mutex_lock(_DWORD); weak
// int   rewind(_DWORD); weak
// int pthread_mutex_destroy(void); weak
// int   access(_DWORD, _DWORD); weak
// int   fwrite(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int   stat(_DWORD, _DWORD); weak
// int   strftime(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int   pthread_mutexattr_init(_DWORD); weak
// int   nvram_close(_DWORD); weak
// int   nvram_bufset(_DWORD, _DWORD, _DWORD); weak
// int   strcspn(_DWORD, _DWORD); weak
// int sprintf(_DWORD, char *, ...); weak
// int   pthread_mutex_unlock(_DWORD, _DWORD); weak
// int   shutdown(_DWORD, _DWORD); weak
// int   strcmp(_DWORD, _DWORD); weak
// int   pthread_mutexattr_setpshared(_DWORD, _DWORD); weak
// int   nvram_commit(_DWORD); weak
// int   time(_DWORD); weak
// int   inet_ntoa(_DWORD); weak
// int   fclose(_DWORD); weak
// int   srand(_DWORD); weak
// int   memset(_DWORD, _DWORD, _DWORD); weak
// int   localtime(_DWORD); weak
// int   fopen(_DWORD, _DWORD); weak
// int   gettimeofday(_DWORD, _DWORD); weak
// int   _uClibc_main(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int   fread(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int   sigaction(_DWORD, _DWORD, _DWORD); weak
// int sscanf(_DWORD, char *, ...); weak
// int   fork(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int   listen(_DWORD, _DWORD); weak
// int   memcmp(_DWORD, _DWORD, _DWORD); weak
// int   strtok(_DWORD, _DWORD); weak
// int   realloc(_DWORD, _DWORD); weak
// int   strcasecmp(_DWORD, _DWORD); weak
// int   strncpy(_DWORD, _DWORD, _DWORD); weak
// int   strncmp(_DWORD, _DWORD, _DWORD); weak
// int   read(_DWORD, _DWORD, _DWORD); weak
// int   signal(_DWORD, _DWORD); weak
// int rand(void); weak
// int   strstr(_DWORD, _DWORD); weak
// int   crc32(_DWORD, _DWORD, _DWORD); weak
// int   memchr(_DWORD, _DWORD, _DWORD); weak
// int   fseek(_DWORD, _DWORD, _DWORD); weak
// int   setsockopt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int   _deregister_frame_info(_DWORD); weak
// int   inet_addr(_DWORD); weak
// int   bind(_DWORD, _DWORD, _DWORD); weak
// int   strcat(_DWORD, _DWORD); weak
// int   ctime(_DWORD); weak
// int fprintf(_DWORD, char *, ...); weak
// int   fstat(_DWORD, _DWORD); weak
// double   atof(_DWORD); weak
// int   write(_DWORD, _DWORD, _DWORD); weak
// int   nanosleep(_DWORD, _DWORD); weak
// int   strrchr(_DWORD, _DWORD); weak
// int   accept(_DWORD, _DWORD, _DWORD); weak
// int   strtol(_DWORD, _DWORD, _DWORD); weak
// int   gmtime_r(_DWORD, _DWORD); weak
// void __noreturn abort(void); weak
// int   send(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int   strncasecmp(_DWORD, _DWORD, _DWORD); weak
// int   nvram_bufget(_DWORD, _DWORD); weak
// int   mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int   lseek(_DWORD, _DWORD, _DWORD); weak
// int   select(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int   socket(_DWORD, _DWORD, _DWORD); weak
// int   vsnprintf(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int   sleep(_DWORD); weak
// int   remove(_DWORD); weak
// int   malloc(_DWORD); weak
// int   feof(_DWORD); weak
// int   system(_DWORD); weak
// int   puts(_DWORD); weak
// int   pthread_mutexattr_destroy(_DWORD); weak
// int   setvbuf(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int   memcpy(_DWORD, _DWORD, _DWORD); weak
// int   fgets(_DWORD, _DWORD, _DWORD); weak
// int getpid(void); weak
// int   execve(_DWORD, _DWORD, _DWORD); weak
// int   usleep(_DWORD); weak
// int   getenv(_DWORD); weak
// int   atol(_DWORD); weak
// int   munmap(_DWORD, _DWORD); weak
// int snprintf(_DWORD, _DWORD, char *, ...); weak
// int   memmove(_DWORD); weak
// int   strerror(_DWORD); weak
// int   sigemptyset(_DWORD); weak
// int   recv(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int printf(char *, ...); weak
// int   ioctl(_DWORD, _DWORD, _DWORD); weak
// int   waitpid(_DWORD, _DWORD, _DWORD); weak
// int   strcpy(_DWORD, _DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_490000; // weak
_UNKNOWN *off_49E60C = (_UNKNOWN *)0x434141; // weak
_DWORD dword_49F330[64] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998
}; // weak
_UNKNOWN unk_49F430; // weak
_BYTE byte_49F6D0[64] =
{
  7,
  12,
  17,
  22,
  7,
  12,
  17,
  22,
  7,
  12,
  17,
  22,
  7,
  12,
  17,
  22,
  5,
  9,
  14,
  20,
  5,
  9,
  14,
  20,
  5,
  9,
  14,
  20,
  5,
  9,
  14,
  20,
  4,
  11,
  16,
  23,
  4,
  11,
  16,
  23,
  4,
  11,
  16,
  23,
  4,
  11,
  16,
  23,
  6,
  10,
  15,
  21,
  6,
  10,
  15,
  21,
  6,
  10,
  15,
  21,
  6,
  10,
  15,
  21
}; // weak
_UNKNOWN unk_49F710; // weak
_UNKNOWN unk_49F750; // weak
unsigned __int8 byte_49F820[64] =
{
  0u,
  1u,
  2u,
  3u,
  4u,
  5u,
  6u,
  7u,
  8u,
  9u,
  10u,
  11u,
  12u,
  13u,
  14u,
  15u,
  1u,
  6u,
  11u,
  0u,
  5u,
  10u,
  15u,
  4u,
  9u,
  14u,
  3u,
  8u,
  13u,
  2u,
  7u,
  12u,
  5u,
  8u,
  11u,
  14u,
  1u,
  4u,
  7u,
  10u,
  13u,
  0u,
  3u,
  6u,
  9u,
  12u,
  15u,
  2u,
  0u,
  7u,
  14u,
  5u,
  12u,
  3u,
  10u,
  1u,
  8u,
  15u,
  6u,
  13u,
  4u,
  11u,
  2u,
  9u
}; // weak
_UNKNOWN unk_49FA24; // weak
int dword_49FA44 = 1; // weak
_UNKNOWN *off_49FFD0 = (_UNKNOWN *)0x495255; // weak
_UNKNOWN unk_4A0300; // weak
__int16 word_4A0308 = 48; // weak
_UNKNOWN unk_4A03E0; // weak
_UNKNOWN unk_4A053C; // weak
_UNKNOWN unk_4A0544; // weak
char a0123456789abcd[74] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/secp521r1"; // weak
unsigned __int8 byte_4A1200[1040] =
{
  82u,
  82u,
  82u,
  82u,
  9u,
  9u,
  9u,
  9u,
  106u,
  106u,
  106u,
  106u,
  213u,
  213u,
  213u,
  213u,
  48u,
  48u,
  48u,
  48u,
  54u,
  54u,
  54u,
  54u,
  165u,
  165u,
  165u,
  165u,
  56u,
  56u,
  56u,
  56u,
  191u,
  191u,
  191u,
  191u,
  64u,
  64u,
  64u,
  64u,
  163u,
  163u,
  163u,
  163u,
  158u,
  158u,
  158u,
  158u,
  129u,
  129u,
  129u,
  129u,
  243u,
  243u,
  243u,
  243u,
  215u,
  215u,
  215u,
  215u,
  251u,
  251u,
  251u,
  251u,
  124u,
  124u,
  124u,
  124u,
  227u,
  227u,
  227u,
  227u,
  57u,
  57u,
  57u,
  57u,
  130u,
  130u,
  130u,
  130u,
  155u,
  155u,
  155u,
  155u,
  47u,
  47u,
  47u,
  47u,
  255u,
  255u,
  255u,
  255u,
  135u,
  135u,
  135u,
  135u,
  52u,
  52u,
  52u,
  52u,
  142u,
  142u,
  142u,
  142u,
  67u,
  67u,
  67u,
  67u,
  68u,
  68u,
  68u,
  68u,
  196u,
  196u,
  196u,
  196u,
  222u,
  222u,
  222u,
  222u,
  233u,
  233u,
  233u,
  233u,
  203u,
  203u,
  203u,
  203u,
  84u,
  84u,
  84u,
  84u,
  123u,
  123u,
  123u,
  123u,
  148u,
  148u,
  148u,
  148u,
  50u,
  50u,
  50u,
  50u,
  166u,
  166u,
  166u,
  166u,
  194u,
  194u,
  194u,
  194u,
  35u,
  35u,
  35u,
  35u,
  61u,
  61u,
  61u,
  61u,
  238u,
  238u,
  238u,
  238u,
  76u,
  76u,
  76u,
  76u,
  149u,
  149u,
  149u,
  149u,
  11u,
  11u,
  11u,
  11u,
  66u,
  66u,
  66u,
  66u,
  250u,
  250u,
  250u,
  250u,
  195u,
  195u,
  195u,
  195u,
  78u,
  78u,
  78u,
  78u,
  8u,
  8u,
  8u,
  8u,
  46u,
  46u,
  46u,
  46u,
  161u,
  161u,
  161u,
  161u,
  102u,
  102u,
  102u,
  102u,
  40u,
  40u,
  40u,
  40u,
  217u,
  217u,
  217u,
  217u,
  36u,
  36u,
  36u,
  36u,
  178u,
  178u,
  178u,
  178u,
  118u,
  118u,
  118u,
  118u,
  91u,
  91u,
  91u,
  91u,
  162u,
  162u,
  162u,
  162u,
  73u,
  73u,
  73u,
  73u,
  109u,
  109u,
  109u,
  109u,
  139u,
  139u,
  139u,
  139u,
  209u,
  209u,
  209u,
  209u,
  37u,
  37u,
  37u,
  37u,
  114u,
  114u,
  114u,
  114u,
  248u,
  248u,
  248u,
  248u,
  246u,
  246u,
  246u,
  246u,
  100u,
  100u,
  100u,
  100u,
  134u,
  134u,
  134u,
  134u,
  104u,
  104u,
  104u,
  104u,
  152u,
  152u,
  152u,
  152u,
  22u,
  22u,
  22u,
  22u,
  212u,
  212u,
  212u,
  212u,
  164u,
  164u,
  164u,
  164u,
  92u,
  92u,
  92u,
  92u,
  204u,
  204u,
  204u,
  204u,
  93u,
  93u,
  93u,
  93u,
  101u,
  101u,
  101u,
  101u,
  182u,
  182u,
  182u,
  182u,
  146u,
  146u,
  146u,
  146u,
  108u,
  108u,
  108u,
  108u,
  112u,
  112u,
  112u,
  112u,
  72u,
  72u,
  72u,
  72u,
  80u,
  80u,
  80u,
  80u,
  253u,
  253u,
  253u,
  253u,
  237u,
  237u,
  237u,
  237u,
  185u,
  185u,
  185u,
  185u,
  218u,
  218u,
  218u,
  218u,
  94u,
  94u,
  94u,
  94u,
  21u,
  21u,
  21u,
  21u,
  70u,
  70u,
  70u,
  70u,
  87u,
  87u,
  87u,
  87u,
  167u,
  167u,
  167u,
  167u,
  141u,
  141u,
  141u,
  141u,
  157u,
  157u,
  157u,
  157u,
  132u,
  132u,
  132u,
  132u,
  144u,
  144u,
  144u,
  144u,
  216u,
  216u,
  216u,
  216u,
  171u,
  171u,
  171u,
  171u,
  0u,
  0u,
  0u,
  0u,
  140u,
  140u,
  140u,
  140u,
  188u,
  188u,
  188u,
  188u,
  211u,
  211u,
  211u,
  211u,
  10u,
  10u,
  10u,
  10u,
  247u,
  247u,
  247u,
  247u,
  228u,
  228u,
  228u,
  228u,
  88u,
  88u,
  88u,
  88u,
  5u,
  5u,
  5u,
  5u,
  184u,
  184u,
  184u,
  184u,
  179u,
  179u,
  179u,
  179u,
  69u,
  69u,
  69u,
  69u,
  6u,
  6u,
  6u,
  6u,
  208u,
  208u,
  208u,
  208u,
  44u,
  44u,
  44u,
  44u,
  30u,
  30u,
  30u,
  30u,
  143u,
  143u,
  143u,
  143u,
  202u,
  202u,
  202u,
  202u,
  63u,
  63u,
  63u,
  63u,
  15u,
  15u,
  15u,
  15u,
  2u,
  2u,
  2u,
  2u,
  193u,
  193u,
  193u,
  193u,
  175u,
  175u,
  175u,
  175u,
  189u,
  189u,
  189u,
  189u,
  3u,
  3u,
  3u,
  3u,
  1u,
  1u,
  1u,
  1u,
  19u,
  19u,
  19u,
  19u,
  138u,
  138u,
  138u,
  138u,
  107u,
  107u,
  107u,
  107u,
  58u,
  58u,
  58u,
  58u,
  145u,
  145u,
  145u,
  145u,
  17u,
  17u,
  17u,
  17u,
  65u,
  65u,
  65u,
  65u,
  79u,
  79u,
  79u,
  79u,
  103u,
  103u,
  103u,
  103u,
  220u,
  220u,
  220u,
  220u,
  234u,
  234u,
  234u,
  234u,
  151u,
  151u,
  151u,
  151u,
  242u,
  242u,
  242u,
  242u,
  207u,
  207u,
  207u,
  207u,
  206u,
  206u,
  206u,
  206u,
  240u,
  240u,
  240u,
  240u,
  180u,
  180u,
  180u,
  180u,
  230u,
  230u,
  230u,
  230u,
  115u,
  115u,
  115u,
  115u,
  150u,
  150u,
  150u,
  150u,
  172u,
  172u,
  172u,
  172u,
  116u,
  116u,
  116u,
  116u,
  34u,
  34u,
  34u,
  34u,
  231u,
  231u,
  231u,
  231u,
  173u,
  173u,
  173u,
  173u,
  53u,
  53u,
  53u,
  53u,
  133u,
  133u,
  133u,
  133u,
  226u,
  226u,
  226u,
  226u,
  249u,
  249u,
  249u,
  249u,
  55u,
  55u,
  55u,
  55u,
  232u,
  232u,
  232u,
  232u,
  28u,
  28u,
  28u,
  28u,
  117u,
  117u,
  117u,
  117u,
  223u,
  223u,
  223u,
  223u,
  110u,
  110u,
  110u,
  110u,
  71u,
  71u,
  71u,
  71u,
  241u,
  241u,
  241u,
  241u,
  26u,
  26u,
  26u,
  26u,
  113u,
  113u,
  113u,
  113u,
  29u,
  29u,
  29u,
  29u,
  41u,
  41u,
  41u,
  41u,
  197u,
  197u,
  197u,
  197u,
  137u,
  137u,
  137u,
  137u,
  111u,
  111u,
  111u,
  111u,
  183u,
  183u,
  183u,
  183u,
  98u,
  98u,
  98u,
  98u,
  14u,
  14u,
  14u,
  14u,
  170u,
  170u,
  170u,
  170u,
  24u,
  24u,
  24u,
  24u,
  190u,
  190u,
  190u,
  190u,
  27u,
  27u,
  27u,
  27u,
  252u,
  252u,
  252u,
  252u,
  86u,
  86u,
  86u,
  86u,
  62u,
  62u,
  62u,
  62u,
  75u,
  75u,
  75u,
  75u,
  198u,
  198u,
  198u,
  198u,
  210u,
  210u,
  210u,
  210u,
  121u,
  121u,
  121u,
  121u,
  32u,
  32u,
  32u,
  32u,
  154u,
  154u,
  154u,
  154u,
  219u,
  219u,
  219u,
  219u,
  192u,
  192u,
  192u,
  192u,
  254u,
  254u,
  254u,
  254u,
  120u,
  120u,
  120u,
  120u,
  205u,
  205u,
  205u,
  205u,
  90u,
  90u,
  90u,
  90u,
  244u,
  244u,
  244u,
  244u,
  31u,
  31u,
  31u,
  31u,
  221u,
  221u,
  221u,
  221u,
  168u,
  168u,
  168u,
  168u,
  51u,
  51u,
  51u,
  51u,
  136u,
  136u,
  136u,
  136u,
  7u,
  7u,
  7u,
  7u,
  199u,
  199u,
  199u,
  199u,
  49u,
  49u,
  49u,
  49u,
  177u,
  177u,
  177u,
  177u,
  18u,
  18u,
  18u,
  18u,
  16u,
  16u,
  16u,
  16u,
  89u,
  89u,
  89u,
  89u,
  39u,
  39u,
  39u,
  39u,
  128u,
  128u,
  128u,
  128u,
  236u,
  236u,
  236u,
  236u,
  95u,
  95u,
  95u,
  95u,
  96u,
  96u,
  96u,
  96u,
  81u,
  81u,
  81u,
  81u,
  127u,
  127u,
  127u,
  127u,
  169u,
  169u,
  169u,
  169u,
  25u,
  25u,
  25u,
  25u,
  181u,
  181u,
  181u,
  181u,
  74u,
  74u,
  74u,
  74u,
  13u,
  13u,
  13u,
  13u,
  45u,
  45u,
  45u,
  45u,
  229u,
  229u,
  229u,
  229u,
  122u,
  122u,
  122u,
  122u,
  159u,
  159u,
  159u,
  159u,
  147u,
  147u,
  147u,
  147u,
  201u,
  201u,
  201u,
  201u,
  156u,
  156u,
  156u,
  156u,
  239u,
  239u,
  239u,
  239u,
  160u,
  160u,
  160u,
  160u,
  224u,
  224u,
  224u,
  224u,
  59u,
  59u,
  59u,
  59u,
  77u,
  77u,
  77u,
  77u,
  174u,
  174u,
  174u,
  174u,
  42u,
  42u,
  42u,
  42u,
  245u,
  245u,
  245u,
  245u,
  176u,
  176u,
  176u,
  176u,
  200u,
  200u,
  200u,
  200u,
  235u,
  235u,
  235u,
  235u,
  187u,
  187u,
  187u,
  187u,
  60u,
  60u,
  60u,
  60u,
  131u,
  131u,
  131u,
  131u,
  83u,
  83u,
  83u,
  83u,
  153u,
  153u,
  153u,
  153u,
  97u,
  97u,
  97u,
  97u,
  23u,
  23u,
  23u,
  23u,
  43u,
  43u,
  43u,
  43u,
  4u,
  4u,
  4u,
  4u,
  126u,
  126u,
  126u,
  126u,
  186u,
  186u,
  186u,
  186u,
  119u,
  119u,
  119u,
  119u,
  214u,
  214u,
  214u,
  214u,
  38u,
  38u,
  38u,
  38u,
  225u,
  225u,
  225u,
  225u,
  105u,
  105u,
  105u,
  105u,
  20u,
  20u,
  20u,
  20u,
  99u,
  99u,
  99u,
  99u,
  85u,
  85u,
  85u,
  85u,
  33u,
  33u,
  33u,
  33u,
  12u,
  12u,
  12u,
  12u,
  125u,
  125u,
  125u,
  125u,
  58u,
  127u,
  242u,
  225u,
  176u,
  15u,
  113u,
  245u,
  196u,
  229u,
  160u,
  173u,
  25u,
  201u,
  228u,
  152u
}; // weak
unsigned int dword_4A1610[256] =
{
  1374988112u,
  2118214995u,
  437757123u,
  975658646u,
  1001089995u,
  530400753u,
  2902087851u,
  1273168787u,
  540080725u,
  2910219766u,
  2295101073u,
  4110568485u,
  1340463100u,
  3307916247u,
  641025152u,
  3043140495u,
  3736164937u,
  632953703u,
  1172967064u,
  1576976609u,
  3274667266u,
  2169303058u,
  2370213795u,
  1809054150u,
  59727847u,
  361929877u,
  3211623147u,
  2505202138u,
  3569255213u,
  1484005843u,
  1239443753u,
  2395588676u,
  1975683434u,
  4102977912u,
  2572697195u,
  666464733u,
  3202437046u,
  4035489047u,
  3374361702u,
  2110667444u,
  1675577880u,
  3843699074u,
  2538681184u,
  1649639237u,
  2976151520u,
  3144396420u,
  4269907996u,
  4178062228u,
  1883793496u,
  2403728665u,
  2497604743u,
  1383856311u,
  2876494627u,
  1917518562u,
  3810496343u,
  1716890410u,
  3001755655u,
  800440835u,
  2261089178u,
  3543599269u,
  807962610u,
  599762354u,
  33778362u,
  3977675356u,
  2328828971u,
  2809771154u,
  4077384432u,
  1315562145u,
  1708848333u,
  101039829u,
  3509871135u,
  3299278474u,
  875451293u,
  2733856160u,
  92987698u,
  2767645557u,
  193195065u,
  1080094634u,
  1584504582u,
  3178106961u,
  1042385657u,
  2531067453u,
  3711829422u,
  1306967366u,
  2438237621u,
  1908694277u,
  67556463u,
  1615861247u,
  429456164u,
  3602770327u,
  2302690252u,
  1742315127u,
  2968011453u,
  126454664u,
  3877198648u,
  2043211483u,
  2709260871u,
  2084704233u,
  4169408201u,
  0u,
  159417987u,
  841739592u,
  504459436u,
  1817866830u,
  4245618683u,
  260388950u,
  1034867998u,
  908933415u,
  168810852u,
  1750902305u,
  2606453969u,
  607530554u,
  202008497u,
  2472011535u,
  3035535058u,
  463180190u,
  2160117071u,
  1641816226u,
  1517767529u,
  470948374u,
  3801332234u,
  3231722213u,
  1008918595u,
  303765277u,
  235474187u,
  4069246893u,
  766945465u,
  337553864u,
  1475418501u,
  2943682380u,
  4003061179u,
  2743034109u,
  4144047775u,
  1551037884u,
  1147550661u,
  1543208500u,
  2336434550u,
  3408119516u,
  3069049960u,
  3102011747u,
  3610369226u,
  1113818384u,
  328671808u,
  2227573024u,
  2236228733u,
  3535486456u,
  2935566865u,
  3341394285u,
  496906059u,
  3702665459u,
  226906860u,
  2009195472u,
  733156972u,
  2842737049u,
  294930682u,
  1206477858u,
  2835123396u,
  2700099354u,
  1451044056u,
  573804783u,
  2269728455u,
  3644379585u,
  2362090238u,
  2564033334u,
  2801107407u,
  2776292904u,
  3669462566u,
  1068351396u,
  742039012u,
  1350078989u,
  1784663195u,
  1417561698u,
  4136440770u,
  2430122216u,
  775550814u,
  2193862645u,
  2673705150u,
  1775276924u,
  1876241833u,
  3475313331u,
  3366754619u,
  270040487u,
  3902563182u,
  3678124923u,
  3441850377u,
  1851332852u,
  3969562369u,
  2203032232u,
  3868552805u,
  2868897406u,
  566021896u,
  4011190502u,
  3135740889u,
  1248802510u,
  3936291284u,
  699432150u,
  832877231u,
  708780849u,
  3332740144u,
  899835584u,
  1951317047u,
  4236429990u,
  3767586992u,
  866637845u,
  4043610186u,
  1106041591u,
  2144161806u,
  395441711u,
  1984812685u,
  1139781709u,
  3433712980u,
  3835036895u,
  2664543715u,
  1282050075u,
  3240894392u,
  1181045119u,
  2640243204u,
  25965917u,
  4203181171u,
  4211818798u,
  3009879386u,
  2463879762u,
  3910161971u,
  1842759443u,
  2597806476u,
  933301370u,
  1509430414u,
  3943906441u,
  3467192302u,
  3076639029u,
  3776767469u,
  2051518780u,
  2631065433u,
  1441952575u,
  404016761u,
  1942435775u,
  1408749034u,
  1610459739u,
  3745345300u,
  2017778566u,
  3400528769u,
  3110650942u,
  941896748u,
  3265478751u,
  371049330u,
  3168937228u,
  675039627u,
  4279080257u,
  967311729u,
  135050206u,
  3635733660u,
  1683407248u,
  2076935265u,
  3576870512u,
  1215061108u,
  3501741890u
}; // weak
unsigned __int8 byte_4A1A10[1024] =
{
  99u,
  99u,
  99u,
  99u,
  124u,
  124u,
  124u,
  124u,
  119u,
  119u,
  119u,
  119u,
  123u,
  123u,
  123u,
  123u,
  242u,
  242u,
  242u,
  242u,
  107u,
  107u,
  107u,
  107u,
  111u,
  111u,
  111u,
  111u,
  197u,
  197u,
  197u,
  197u,
  48u,
  48u,
  48u,
  48u,
  1u,
  1u,
  1u,
  1u,
  103u,
  103u,
  103u,
  103u,
  43u,
  43u,
  43u,
  43u,
  254u,
  254u,
  254u,
  254u,
  215u,
  215u,
  215u,
  215u,
  171u,
  171u,
  171u,
  171u,
  118u,
  118u,
  118u,
  118u,
  202u,
  202u,
  202u,
  202u,
  130u,
  130u,
  130u,
  130u,
  201u,
  201u,
  201u,
  201u,
  125u,
  125u,
  125u,
  125u,
  250u,
  250u,
  250u,
  250u,
  89u,
  89u,
  89u,
  89u,
  71u,
  71u,
  71u,
  71u,
  240u,
  240u,
  240u,
  240u,
  173u,
  173u,
  173u,
  173u,
  212u,
  212u,
  212u,
  212u,
  162u,
  162u,
  162u,
  162u,
  175u,
  175u,
  175u,
  175u,
  156u,
  156u,
  156u,
  156u,
  164u,
  164u,
  164u,
  164u,
  114u,
  114u,
  114u,
  114u,
  192u,
  192u,
  192u,
  192u,
  183u,
  183u,
  183u,
  183u,
  253u,
  253u,
  253u,
  253u,
  147u,
  147u,
  147u,
  147u,
  38u,
  38u,
  38u,
  38u,
  54u,
  54u,
  54u,
  54u,
  63u,
  63u,
  63u,
  63u,
  247u,
  247u,
  247u,
  247u,
  204u,
  204u,
  204u,
  204u,
  52u,
  52u,
  52u,
  52u,
  165u,
  165u,
  165u,
  165u,
  229u,
  229u,
  229u,
  229u,
  241u,
  241u,
  241u,
  241u,
  113u,
  113u,
  113u,
  113u,
  216u,
  216u,
  216u,
  216u,
  49u,
  49u,
  49u,
  49u,
  21u,
  21u,
  21u,
  21u,
  4u,
  4u,
  4u,
  4u,
  199u,
  199u,
  199u,
  199u,
  35u,
  35u,
  35u,
  35u,
  195u,
  195u,
  195u,
  195u,
  24u,
  24u,
  24u,
  24u,
  150u,
  150u,
  150u,
  150u,
  5u,
  5u,
  5u,
  5u,
  154u,
  154u,
  154u,
  154u,
  7u,
  7u,
  7u,
  7u,
  18u,
  18u,
  18u,
  18u,
  128u,
  128u,
  128u,
  128u,
  226u,
  226u,
  226u,
  226u,
  235u,
  235u,
  235u,
  235u,
  39u,
  39u,
  39u,
  39u,
  178u,
  178u,
  178u,
  178u,
  117u,
  117u,
  117u,
  117u,
  9u,
  9u,
  9u,
  9u,
  131u,
  131u,
  131u,
  131u,
  44u,
  44u,
  44u,
  44u,
  26u,
  26u,
  26u,
  26u,
  27u,
  27u,
  27u,
  27u,
  110u,
  110u,
  110u,
  110u,
  90u,
  90u,
  90u,
  90u,
  160u,
  160u,
  160u,
  160u,
  82u,
  82u,
  82u,
  82u,
  59u,
  59u,
  59u,
  59u,
  214u,
  214u,
  214u,
  214u,
  179u,
  179u,
  179u,
  179u,
  41u,
  41u,
  41u,
  41u,
  227u,
  227u,
  227u,
  227u,
  47u,
  47u,
  47u,
  47u,
  132u,
  132u,
  132u,
  132u,
  83u,
  83u,
  83u,
  83u,
  209u,
  209u,
  209u,
  209u,
  0u,
  0u,
  0u,
  0u,
  237u,
  237u,
  237u,
  237u,
  32u,
  32u,
  32u,
  32u,
  252u,
  252u,
  252u,
  252u,
  177u,
  177u,
  177u,
  177u,
  91u,
  91u,
  91u,
  91u,
  106u,
  106u,
  106u,
  106u,
  203u,
  203u,
  203u,
  203u,
  190u,
  190u,
  190u,
  190u,
  57u,
  57u,
  57u,
  57u,
  74u,
  74u,
  74u,
  74u,
  76u,
  76u,
  76u,
  76u,
  88u,
  88u,
  88u,
  88u,
  207u,
  207u,
  207u,
  207u,
  208u,
  208u,
  208u,
  208u,
  239u,
  239u,
  239u,
  239u,
  170u,
  170u,
  170u,
  170u,
  251u,
  251u,
  251u,
  251u,
  67u,
  67u,
  67u,
  67u,
  77u,
  77u,
  77u,
  77u,
  51u,
  51u,
  51u,
  51u,
  133u,
  133u,
  133u,
  133u,
  69u,
  69u,
  69u,
  69u,
  249u,
  249u,
  249u,
  249u,
  2u,
  2u,
  2u,
  2u,
  127u,
  127u,
  127u,
  127u,
  80u,
  80u,
  80u,
  80u,
  60u,
  60u,
  60u,
  60u,
  159u,
  159u,
  159u,
  159u,
  168u,
  168u,
  168u,
  168u,
  81u,
  81u,
  81u,
  81u,
  163u,
  163u,
  163u,
  163u,
  64u,
  64u,
  64u,
  64u,
  143u,
  143u,
  143u,
  143u,
  146u,
  146u,
  146u,
  146u,
  157u,
  157u,
  157u,
  157u,
  56u,
  56u,
  56u,
  56u,
  245u,
  245u,
  245u,
  245u,
  188u,
  188u,
  188u,
  188u,
  182u,
  182u,
  182u,
  182u,
  218u,
  218u,
  218u,
  218u,
  33u,
  33u,
  33u,
  33u,
  16u,
  16u,
  16u,
  16u,
  255u,
  255u,
  255u,
  255u,
  243u,
  243u,
  243u,
  243u,
  210u,
  210u,
  210u,
  210u,
  205u,
  205u,
  205u,
  205u,
  12u,
  12u,
  12u,
  12u,
  19u,
  19u,
  19u,
  19u,
  236u,
  236u,
  236u,
  236u,
  95u,
  95u,
  95u,
  95u,
  151u,
  151u,
  151u,
  151u,
  68u,
  68u,
  68u,
  68u,
  23u,
  23u,
  23u,
  23u,
  196u,
  196u,
  196u,
  196u,
  167u,
  167u,
  167u,
  167u,
  126u,
  126u,
  126u,
  126u,
  61u,
  61u,
  61u,
  61u,
  100u,
  100u,
  100u,
  100u,
  93u,
  93u,
  93u,
  93u,
  25u,
  25u,
  25u,
  25u,
  115u,
  115u,
  115u,
  115u,
  96u,
  96u,
  96u,
  96u,
  129u,
  129u,
  129u,
  129u,
  79u,
  79u,
  79u,
  79u,
  220u,
  220u,
  220u,
  220u,
  34u,
  34u,
  34u,
  34u,
  42u,
  42u,
  42u,
  42u,
  144u,
  144u,
  144u,
  144u,
  136u,
  136u,
  136u,
  136u,
  70u,
  70u,
  70u,
  70u,
  238u,
  238u,
  238u,
  238u,
  184u,
  184u,
  184u,
  184u,
  20u,
  20u,
  20u,
  20u,
  222u,
  222u,
  222u,
  222u,
  94u,
  94u,
  94u,
  94u,
  11u,
  11u,
  11u,
  11u,
  219u,
  219u,
  219u,
  219u,
  224u,
  224u,
  224u,
  224u,
  50u,
  50u,
  50u,
  50u,
  58u,
  58u,
  58u,
  58u,
  10u,
  10u,
  10u,
  10u,
  73u,
  73u,
  73u,
  73u,
  6u,
  6u,
  6u,
  6u,
  36u,
  36u,
  36u,
  36u,
  92u,
  92u,
  92u,
  92u,
  194u,
  194u,
  194u,
  194u,
  211u,
  211u,
  211u,
  211u,
  172u,
  172u,
  172u,
  172u,
  98u,
  98u,
  98u,
  98u,
  145u,
  145u,
  145u,
  145u,
  149u,
  149u,
  149u,
  149u,
  228u,
  228u,
  228u,
  228u,
  121u,
  121u,
  121u,
  121u,
  231u,
  231u,
  231u,
  231u,
  200u,
  200u,
  200u,
  200u,
  55u,
  55u,
  55u,
  55u,
  109u,
  109u,
  109u,
  109u,
  141u,
  141u,
  141u,
  141u,
  213u,
  213u,
  213u,
  213u,
  78u,
  78u,
  78u,
  78u,
  169u,
  169u,
  169u,
  169u,
  108u,
  108u,
  108u,
  108u,
  86u,
  86u,
  86u,
  86u,
  244u,
  244u,
  244u,
  244u,
  234u,
  234u,
  234u,
  234u,
  101u,
  101u,
  101u,
  101u,
  122u,
  122u,
  122u,
  122u,
  174u,
  174u,
  174u,
  174u,
  8u,
  8u,
  8u,
  8u,
  186u,
  186u,
  186u,
  186u,
  120u,
  120u,
  120u,
  120u,
  37u,
  37u,
  37u,
  37u,
  46u,
  46u,
  46u,
  46u,
  28u,
  28u,
  28u,
  28u,
  166u,
  166u,
  166u,
  166u,
  180u,
  180u,
  180u,
  180u,
  198u,
  198u,
  198u,
  198u,
  232u,
  232u,
  232u,
  232u,
  221u,
  221u,
  221u,
  221u,
  116u,
  116u,
  116u,
  116u,
  31u,
  31u,
  31u,
  31u,
  75u,
  75u,
  75u,
  75u,
  189u,
  189u,
  189u,
  189u,
  139u,
  139u,
  139u,
  139u,
  138u,
  138u,
  138u,
  138u,
  112u,
  112u,
  112u,
  112u,
  62u,
  62u,
  62u,
  62u,
  181u,
  181u,
  181u,
  181u,
  102u,
  102u,
  102u,
  102u,
  72u,
  72u,
  72u,
  72u,
  3u,
  3u,
  3u,
  3u,
  246u,
  246u,
  246u,
  246u,
  14u,
  14u,
  14u,
  14u,
  97u,
  97u,
  97u,
  97u,
  53u,
  53u,
  53u,
  53u,
  87u,
  87u,
  87u,
  87u,
  185u,
  185u,
  185u,
  185u,
  134u,
  134u,
  134u,
  134u,
  193u,
  193u,
  193u,
  193u,
  29u,
  29u,
  29u,
  29u,
  158u,
  158u,
  158u,
  158u,
  225u,
  225u,
  225u,
  225u,
  248u,
  248u,
  248u,
  248u,
  152u,
  152u,
  152u,
  152u,
  17u,
  17u,
  17u,
  17u,
  105u,
  105u,
  105u,
  105u,
  217u,
  217u,
  217u,
  217u,
  142u,
  142u,
  142u,
  142u,
  148u,
  148u,
  148u,
  148u,
  155u,
  155u,
  155u,
  155u,
  30u,
  30u,
  30u,
  30u,
  135u,
  135u,
  135u,
  135u,
  233u,
  233u,
  233u,
  233u,
  206u,
  206u,
  206u,
  206u,
  85u,
  85u,
  85u,
  85u,
  40u,
  40u,
  40u,
  40u,
  223u,
  223u,
  223u,
  223u,
  140u,
  140u,
  140u,
  140u,
  161u,
  161u,
  161u,
  161u,
  137u,
  137u,
  137u,
  137u,
  13u,
  13u,
  13u,
  13u,
  191u,
  191u,
  191u,
  191u,
  230u,
  230u,
  230u,
  230u,
  66u,
  66u,
  66u,
  66u,
  104u,
  104u,
  104u,
  104u,
  65u,
  65u,
  65u,
  65u,
  153u,
  153u,
  153u,
  153u,
  45u,
  45u,
  45u,
  45u,
  15u,
  15u,
  15u,
  15u,
  176u,
  176u,
  176u,
  176u,
  84u,
  84u,
  84u,
  84u,
  187u,
  187u,
  187u,
  187u,
  22u,
  22u,
  22u,
  22u
}; // weak
unsigned int dword_4A1E10[256] =
{
  3328402341u,
  4168907908u,
  4000806809u,
  4135287693u,
  4294111757u,
  3597364157u,
  3731845041u,
  2445657428u,
  1613770832u,
  33620227u,
  3462883241u,
  1445669757u,
  3892248089u,
  3050821474u,
  1303096294u,
  3967186586u,
  2412431941u,
  528646813u,
  2311702848u,
  4202528135u,
  4026202645u,
  2992200171u,
  2387036105u,
  4226871307u,
  1101901292u,
  3017069671u,
  1604494077u,
  1169141738u,
  597466303u,
  1403299063u,
  3832705686u,
  2613100635u,
  1974974402u,
  3791519004u,
  1033081774u,
  1277568618u,
  1815492186u,
  2118074177u,
  4126668546u,
  2211236943u,
  1748251740u,
  1369810420u,
  3521504564u,
  4193382664u,
  3799085459u,
  2883115123u,
  1647391059u,
  706024767u,
  134480908u,
  2512897874u,
  1176707941u,
  2646852446u,
  806885416u,
  932615841u,
  168101135u,
  798661301u,
  235341577u,
  605164086u,
  461406363u,
  3756188221u,
  3454790438u,
  1311188841u,
  2142417613u,
  3933566367u,
  302582043u,
  495158174u,
  1479289972u,
  874125870u,
  907746093u,
  3698224818u,
  3025820398u,
  1537253627u,
  2756858614u,
  1983593293u,
  3084310113u,
  2108928974u,
  1378429307u,
  3722699582u,
  1580150641u,
  327451799u,
  2790478837u,
  3117535592u,
  0u,
  3253595436u,
  1075847264u,
  3825007647u,
  2041688520u,
  3059440621u,
  3563743934u,
  2378943302u,
  1740553945u,
  1916352843u,
  2487896798u,
  2555137236u,
  2958579944u,
  2244988746u,
  3151024235u,
  3320835882u,
  1336584933u,
  3992714006u,
  2252555205u,
  2588757463u,
  1714631509u,
  293963156u,
  2319795663u,
  3925473552u,
  67240454u,
  4269768577u,
  2689618160u,
  2017213508u,
  631218106u,
  1269344483u,
  2723238387u,
  1571005438u,
  2151694528u,
  93294474u,
  1066570413u,
  563977660u,
  1882732616u,
  4059428100u,
  1673313503u,
  2008463041u,
  2950355573u,
  1109467491u,
  537923632u,
  3858759450u,
  4260623118u,
  3218264685u,
  2177748300u,
  403442708u,
  638784309u,
  3287084079u,
  3193921505u,
  899127202u,
  2286175436u,
  773265209u,
  2479146071u,
  1437050866u,
  4236148354u,
  2050833735u,
  3362022572u,
  3126681063u,
  840505643u,
  3866325909u,
  3227541664u,
  427917720u,
  2655997905u,
  2749160575u,
  1143087718u,
  1412049534u,
  999329963u,
  193497219u,
  2353415882u,
  3354324521u,
  1807268051u,
  672404540u,
  2816401017u,
  3160301282u,
  369822493u,
  2916866934u,
  3688947771u,
  1681011286u,
  1949973070u,
  336202270u,
  2454276571u,
  201721354u,
  1210328172u,
  3093060836u,
  2680341085u,
  3184776046u,
  1135389935u,
  3294782118u,
  965841320u,
  831886756u,
  3554993207u,
  4068047243u,
  3588745010u,
  2345191491u,
  1849112409u,
  3664604599u,
  26054028u,
  2983581028u,
  2622377682u,
  1235855840u,
  3630984372u,
  2891339514u,
  4092916743u,
  3488279077u,
  3395642799u,
  4101667470u,
  1202630377u,
  268961816u,
  1874508501u,
  4034427016u,
  1243948399u,
  1546530418u,
  941366308u,
  1470539505u,
  1941222599u,
  2546386513u,
  3421038627u,
  2715671932u,
  3899946140u,
  1042226977u,
  2521517021u,
  1639824860u,
  227249030u,
  260737669u,
  3765465232u,
  2084453954u,
  1907733956u,
  3429263018u,
  2420656344u,
  100860677u,
  4160157185u,
  470683154u,
  3261161891u,
  1781871967u,
  2924959737u,
  1773779408u,
  394692241u,
  2579611992u,
  974986535u,
  664706745u,
  3655459128u,
  3958962195u,
  731420851u,
  571543859u,
  3530123707u,
  2849626480u,
  126783113u,
  865375399u,
  765172662u,
  1008606754u,
  361203602u,
  3387549984u,
  2278477385u,
  2857719295u,
  1344809080u,
  2782912378u,
  59542671u,
  1503764984u,
  160008576u,
  437062935u,
  1707065306u,
  3622233649u,
  2218934982u,
  3496503480u,
  2185314755u,
  697932208u,
  1512910199u,
  504303377u,
  2075177163u,
  2824099068u,
  1841019862u,
  739644986u
}; // weak
_UNKNOWN unk_4A2210; // weak
_UNKNOWN unk_4A2238; // weak
_UNKNOWN unk_4A2338; // weak
_UNKNOWN unk_4A2438; // weak
_DWORD dword_4A2538[68] =
{
  268439616,
  4096,
  262144,
  268701760,
  268435456,
  268439616,
  64,
  268435456,
  262208,
  268697600,
  268701760,
  266240,
  268701696,
  266304,
  4096,
  64,
  268697600,
  268435520,
  268439552,
  4160,
  266240,
  262208,
  268697664,
  268701696,
  4160,
  0,
  0,
  268697664,
  268435520,
  268439552,
  266304,
  262144,
  266304,
  262144,
  268701696,
  4096,
  64,
  268697664,
  4096,
  266304,
  268439552,
  64,
  268435520,
  268697600,
  268697664,
  268435456,
  262144,
  268439616,
  0,
  268701760,
  262208,
  268435520,
  268697600,
  268439552,
  268439616,
  0,
  268701760,
  266240,
  266240,
  4160,
  4160,
  262208,
  268435456,
  268701696,
  -504201414,
  -177139792,
  -1381964348,
  -1729836775
}; // weak
_UNKNOWN unk_4A2648; // weak
_UNKNOWN unk_4A2748; // weak
_UNKNOWN unk_4A2848; // weak
_DWORD dword_4A2948[64] =
{
  2097152,
  69206018,
  67110914,
  0,
  2048,
  67110914,
  2099202,
  69208064,
  69208066,
  2097152,
  0,
  67108866,
  2,
  67108864,
  69206018,
  2050,
  67110912,
  2099202,
  2097154,
  67110912,
  67108866,
  69206016,
  69208064,
  2097154,
  69206016,
  2048,
  2050,
  69208066,
  2099200,
  2,
  67108864,
  2099200,
  67108864,
  2099200,
  2097152,
  67110914,
  67110914,
  69206018,
  69206018,
  2,
  2097154,
  67108864,
  67110912,
  2097152,
  69208064,
  2050,
  2099202,
  69208064,
  2050,
  67108866,
  69208066,
  69206016,
  2099200,
  0,
  2,
  69208066,
  0,
  2099202,
  69206016,
  2048,
  67108866,
  67110912,
  2048,
  2097154
}; // weak
_UNKNOWN unk_4A2A48; // weak
unsigned __int8 byte_4A2AA8[48] =
{
  13u,
  16u,
  10u,
  23u,
  0u,
  4u,
  2u,
  27u,
  14u,
  5u,
  20u,
  9u,
  22u,
  18u,
  11u,
  3u,
  25u,
  7u,
  15u,
  6u,
  26u,
  19u,
  12u,
  1u,
  40u,
  51u,
  30u,
  36u,
  46u,
  54u,
  29u,
  39u,
  50u,
  44u,
  32u,
  47u,
  43u,
  48u,
  38u,
  55u,
  33u,
  52u,
  45u,
  41u,
  49u,
  35u,
  28u,
  31u
}; // weak
unsigned __int8 byte_4A2AD8[16] = { 1u, 2u, 4u, 6u, 8u, 10u, 12u, 14u, 15u, 17u, 19u, 21u, 23u, 25u, 27u, 28u }; // weak
_DWORD dword_4A2AE8[8] = { 128, 64, 32, 16, 8, 4, 2, 1 }; // weak
unsigned __int8 byte_4A2B08[56] =
{
  56u,
  48u,
  40u,
  32u,
  24u,
  16u,
  8u,
  0u,
  57u,
  49u,
  41u,
  33u,
  25u,
  17u,
  9u,
  1u,
  58u,
  50u,
  42u,
  34u,
  26u,
  18u,
  10u,
  2u,
  59u,
  51u,
  43u,
  35u,
  62u,
  54u,
  46u,
  38u,
  30u,
  22u,
  14u,
  6u,
  61u,
  53u,
  45u,
  37u,
  29u,
  21u,
  13u,
  5u,
  60u,
  52u,
  44u,
  36u,
  28u,
  20u,
  12u,
  4u,
  27u,
  19u,
  11u,
  3u
}; // weak
_UNKNOWN unk_4A2BE0; // weak
_UNKNOWN unk_4A2BF0; // weak
_UNKNOWN unk_4A2BFC; // weak
_UNKNOWN unk_4A2C08; // weak
_UNKNOWN unk_4A2C18; // weak
_UNKNOWN unk_4A2C28; // weak
_UNKNOWN unk_4A2C34; // weak
_UNKNOWN unk_4A2C40; // weak
_UNKNOWN unk_4A2C4C; // weak
_UNKNOWN unk_4A2CA0; // weak
_UNKNOWN unk_4A2CA8; // weak
_UNKNOWN unk_4A2CB4; // weak
_UNKNOWN unk_4A2CC0; // weak
_UNKNOWN unk_4A2CCC; // weak
_UNKNOWN unk_4A2CDC; // weak
_UNKNOWN unk_4A2CEC; // weak
_UNKNOWN unk_4A2CF8; // weak
_UNKNOWN unk_4A2D04; // weak
_UNKNOWN unk_4A2D14; // weak
_UNKNOWN unk_4A2D20; // weak
_UNKNOWN unk_4A2D2C; // weak
_UNKNOWN unk_4A2D38; // weak
_UNKNOWN unk_4A2D44; // weak
_UNKNOWN unk_4A2D54; // weak
_UNKNOWN unk_4A2D60; // weak
_UNKNOWN unk_4A2D6C; // weak
_UNKNOWN unk_4A2D78; // weak
_UNKNOWN unk_4A2D84; // weak
_UNKNOWN unk_4A2D90; // weak
_UNKNOWN unk_4A2D9C; // weak
_UNKNOWN unk_4A2DA8; // weak
_UNKNOWN unk_4A2DB4; // weak
_UNKNOWN unk_4A2DC4; // weak
_UNKNOWN unk_4A2DD0; // weak
char byte_4A2DDC[4] = { '\0', '\0', '\0', '\0' }; // weak
_UNKNOWN unk_4A2DE0; // weak
_UNKNOWN unk_4A2DEC; // weak
_UNKNOWN unk_4A2DF8; // weak
_UNKNOWN unk_4A2E04; // weak
_UNKNOWN unk_4A2E14; // weak
_UNKNOWN unk_4A2E20; // weak
_UNKNOWN unk_4A2E30; // weak
_UNKNOWN unk_4A2E3C; // weak
_UNKNOWN unk_4A2E48; // weak
_UNKNOWN unk_4A2E54; // weak
_UNKNOWN unk_4A2E60; // weak
_UNKNOWN unk_4A2E6C; // weak
_UNKNOWN unk_4A2E78; // weak
_UNKNOWN unk_4A2E88; // weak
_UNKNOWN unk_4A2E94; // weak
_UNKNOWN unk_4A2EA4; // weak
_UNKNOWN unk_4A2EB0; // weak
_UNKNOWN unk_4A2EB8; // weak
_UNKNOWN unk_4A2EC8; // weak
_UNKNOWN unk_4A2ED4; // weak
_UNKNOWN unk_4A2EE0; // weak
_UNKNOWN unk_4A2EEC; // weak
_UNKNOWN unk_4A2EFC; // weak
_UNKNOWN unk_4A2F08; // weak
_UNKNOWN unk_4A2F14; // weak
_UNKNOWN unk_4A2F20; // weak
_UNKNOWN unk_4A2F2C; // weak
_UNKNOWN unk_4A2F38; // weak
_UNKNOWN unk_4A2F44; // weak
_UNKNOWN unk_4A2F50; // weak
_UNKNOWN unk_4A2F60; // weak
_UNKNOWN unk_4A2F6C; // weak
_UNKNOWN unk_4A2F78; // weak
_UNKNOWN unk_4A2F84; // weak
_UNKNOWN unk_4A2F90; // weak
_UNKNOWN unk_4A2F9C; // weak
_UNKNOWN unk_4A2FAC; // weak
_UNKNOWN unk_4A2FBC; // weak
_UNKNOWN unk_4A2FC8; // weak
_UNKNOWN unk_4A2FD4; // weak
_UNKNOWN unk_4A2FE0; // weak
_UNKNOWN unk_4A33E4; // weak
int dword_4E33E8 = -1; // weak
int dword_4E33F8 = 0; // weak
unsigned int dword_4E33F4;
int *fdata = &dword_4E33F4; // weak
int minTilt = 0; // weak
int maxTilt = 0; // weak
int minPan = 0; // weak
int maxPan = 0; // weak
int Debug_Trace_Level = 16; // weak
int WebSrv_HTTPS_Port = 443; // weak
int WebSrv_HTTP_Port = 80; // weak
unsigned int aVarRunAlphapdP;
_UNKNOWN *off_4E342C = &aVarRunAlphapdP; // weak
int websConnErrors = 200; // weak
int PendRebootMode = 0; // weak
int PendRebootCMD = 0; // weak
int LockCriticalCMD = 0; // weak
int websConnLast = -1; // weak
char aWebs[5] = "Webs"; // weak
char aNipca[6] = "NIPCA"; // weak
int dword_4E35D0 = 0; // weak
_UNKNOWN unk_4E35D4; // weak
int dword_4E3654 = -1; // weak
int dword_4E3658 = 0; // weak
char *bitrate_select[11] =
{
  "64 Kbps",
  "128 Kbps",
  "256 Kbps",
  "384 Kbps",
  "512 Kbps",
  "768 Kbps",
  "1 Mbps",
  "1.5 Mbps",
  "2 Mbps",
  "2.5 Mbps",
  "3 Mbps"
}; // weak
_UNKNOWN *recordtime_select = (_UNKNOWN *)0x49F898; // weak
_UNKNOWN *degree_select = (_UNKNOWN *)0x49F8F8; // weak
_UNKNOWN audiovol_select; // weak
__int16 *wepencry_select = &word_4A0308; // weak
_UNKNOWN *ipmode_select = (_UNKNOWN *)0x49F8F8; // weak
char *speed_select[3] = { "10M", "100M", "1000M" }; // weak
__int16 *secondportenable_value = &word_4A0308; // weak
char *lightfreq_select[3] = { "50 Hz", "60 Hz", "Auto" }; // weak
char *compress_select[5] = { "Very Low", "Low", "Medium", "High", "Very High" }; // weak
_UNKNOWN *encryption_select = (_UNKNOWN *)0x49AE98; // weak
char *connectionmode_select[2] = { "Infrastructure", "Adhoc" }; // weak
char *off_4E3784 = "Adhoc"; // weak
char *resolution_select[3] = { "160x112", "320x240", "640x480" }; // weak
char *framerate_select = "Auto"; // weak
__int16 *framerate_value = &word_4A0308; // weak
_UNKNOWN *frame_select = (_UNKNOWN *)0x49F8F8; // weak
_UNKNOWN *frame_value = (_UNKNOWN *)0x49F8F8; // weak
char *motioninterval_select = "0.5"; // weak
__int16 *motioninterval_value = &word_4A0308; // weak
_UNKNOWN *apclient_select = (_UNKNOWN *)0x49F8F8; // weak
char *wepkey_select[4] = { "Key 1", "Key 2", "Key 3", "Key 4" }; // weak
_UNKNOWN *wepkey_value = (_UNKNOWN *)0x49F8F8; // weak
char *txrate_select[13] =
{
  "Fully Automatic",
  "1 Mb",
  "2 Mb",
  "5.5 Mb",
  "11 Mb",
  "6 Mb",
  "9 Mb",
  "12 Mb",
  "18 Mb",
  "24 Mb",
  "36 Mb",
  "48 Mb",
  "54 Mb"
}; // weak
__int16 *txrate_value = &word_4A0308; // weak
_UNKNOWN *channel_select = (_UNKNOWN *)0x49F8F8; // weak
char (*ptz_status)[4] = &byte_4A2DDC; // weak
char *duples_select[2] = { "Half Duplex", "Full Duplex" }; // weak
char *Korean_noyes_select[2] = { "&#50500;&#45768;&#50724;", "&#50696;" }; // weak
char *Spanish_noyes_select[2] = { "No", "S&iacute;" }; // weak
char *Italian_noyes_select[2] = { "No", "S&igrave;" }; // weak
char *French_noyes_select[2] = { "Non", "Oui" }; // weak
char *German_noyes_select[2] = { "Nein", "Ja" }; // weak
char *Taiwan_noyes_select[2] = { "&#21542;", "&#26159;" }; // weak
char *Chinese_noyes_select[2] = { "&#21542;", "&#26159;" }; // weak
char *noyes_select[2] = { "No", "Yes" }; // weak
_UNKNOWN *disableenable_select = (_UNKNOWN *)0x49AE98; // weak
char *encrypscan_status[5] = { "No", "WEP", "WPA", "WPA-PSK", "WPA-None" }; // weak
char *encryption_status[6] = { "No", "WEP", "WPA-PSK:TKIP", "WPA2-PSK:TKIP", "WPA-PSK:AES", "WPA2-PSK:AES" }; // weak
char *off_4E39D8[4] = { "WPA-PSK:TKIP", "WPA2-PSK:TKIP", "WPA-PSK:AES", "WPA2-PSK:AES" }; // weak
char *off_4E39DC[3] = { "WPA2-PSK:TKIP", "WPA-PSK:AES", "WPA2-PSK:AES" }; // weak
char *off_4E39E0[2] = { "WPA-PSK:AES", "WPA2-PSK:AES" }; // weak
char *off_4E39E4 = "WPA2-PSK:AES"; // weak
_UNKNOWN *UPnP_status = (_UNKNOWN *)0x49AE98; // weak
_UNKNOWN *DDNS_status = (_UNKNOWN *)0x49AE98; // weak
char *CIFSTest_status[10] =
{
  "No test conducted.",
  "Testing.....",
  "Test succeeded.",
  "Invalid network folder.",
  "Can not connect to network folder.",
  "Invalid username/password.",
  "TCP/IP socket error.",
  "Can not write network folder.",
  "Insufficient disk space.",
  "Failure."
}; // weak
char *EmailTest_status[11] =
{
  "No test conducted.",
  "Testing.....",
  "Test succeeded.",
  "Invalid SMTP server address.",
  "Can not connect to SMTP server.",
  "SMTP server reject.",
  "TCP/IP socket error.",
  "Invalid username/password.",
  "Image not available.",
  "Can not send e-mail.",
  "Failure."
}; // weak
char *FtpTest_status[15] =
{
  "No test conducted.",
  "Testing.....",
  "Test succeeded.",
  "Invalid FTP server address.",
  "Image not available.",
  "Can not connect to FTP server.",
  "Invalid username/password.",
  "TCP/IP socket error.",
  "Can not upload image file.",
  "Fail to change directory.",
  "Not support PASV mode.",
  "Not support PORT mode.",
  "Insufficient disk space.",
  "Can not create folder.",
  "Failure."
}; // weak
int TimeZoneList[186] =
{
  1,
  -720,
  2,
  -660,
  3,
  -600,
  4,
  -540,
  5,
  -480,
  6,
  -480,
  7,
  -420,
  8,
  -420,
  9,
  -420,
  10,
  -360,
  11,
  -360,
  12,
  -360,
  13,
  -360,
  14,
  -300,
  15,
  -300,
  16,
  -300,
  17,
  -240,
  18,
  -240,
  19,
  -240,
  20,
  -240,
  21,
  -180,
  22,
  -210,
  23,
  -180,
  24,
  -180,
  25,
  -180,
  26,
  -180,
  27,
  -120,
  28,
  -60,
  29,
  -60,
  30,
  0,
  31,
  0,
  32,
  60,
  33,
  60,
  34,
  60,
  35,
  60,
  36,
  60,
  37,
  120,
  38,
  120,
  39,
  120,
  40,
  120,
  41,
  120,
  42,
  120,
  43,
  120,
  44,
  180,
  45,
  60,
  46,
  180,
  47,
  180,
  48,
  180,
  49,
  240,
  50,
  210,
  51,
  180,
  52,
  240,
  53,
  240,
  54,
  240,
  55,
  270,
  56,
  300,
  57,
  330,
  58,
  330,
  59,
  345,
  60,
  300,
  61,
  360,
  62,
  360,
  63,
  390,
  64,
  420,
  65,
  420,
  66,
  480,
  67,
  480,
  68,
  480,
  69,
  480,
  70,
  480,
  71,
  540,
  72,
  540,
  73,
  570,
  74,
  570,
  75,
  540,
  76,
  600,
  77,
  600,
  78,
  600,
  79,
  600,
  80,
  600,
  81,
  660,
  82,
  720,
  83,
  720,
  84,
  780,
  85,
  420,
  86,
  480,
  87,
  120,
  88,
  240,
  89,
  720,
  90,
  660,
  91,
  780,
  92,
  180,
  0,
  0
}; // weak
_UNKNOWN unk_4E3AD8; // weak
char WebWlanModeStr[15] = "Wireless Mode="; // weak
char WebTXRateStr[8] = "TXRate="; // weak
char WebConnectStr[13] = "ConnectTime="; // weak
char WebMACStr[12] = "MACAddress="; // weak
char WebSignalStr[8] = "Signal="; // weak
char WebModeStr[6] = "Mode="; // weak
char WebEncryptionStr[12] = "Encryption="; // weak
char WebChannelStr[9] = "Channel="; // weak
char WebBSSIDStr[7] = "BSSID="; // weak
char WebSSIDStr[6] = "SSID="; // weak
char WebDownloadFile[13] = "DownloadFile"; // weak
char WebConfigFile[11] = "ConfigFile"; // weak
char WebFileMark[16] = "UPLOAD_FILEMARK"; // weak
char WebCRLF[3] = "\r\n"; // weak
char WebMultiParaName[39] = "content-disposition: form-data; name=\""; // weak
char Webboundary[19] = "--video boundary--"; // weak
char Webcontenttypeh264[25] = "Content-type: video/h264"; // weak
char Webcontenttypejpeg[25] = "Content-type: image/jpeg"; // weak
char WebAccTimeStr[16] = "AccessDateTime="; // weak
char WebIPAddrStr[15] = "UserIPAddress="; // weak
char WebSetValue[22] = "\" onclick=\"SetValue('"; // weak
char WebSsidRadioSeclect[47] = "<input type=radio name=\"SSIDSelection\" value=\""; // weak
char WebSpace[7] = "&nbsp;"; // weak
char WebPanTiltVertical[17] = "PanTiltVertical="; // weak
char WebPanTiltHorizontal[19] = "PanTiltHorizontal="; // weak
char WebPanTiltName[6] = "Name="; // weak
char WebPanTiltPosition[10] = "Position="; // weak
char WebTrashEnd[41] = "')\"><IMG src=\"Trash.jpg\" border=0></A>\r\n"; // weak
char WebTrashStart[33] = "<A href=\"javascript:DeleteUser('"; // weak
char WebEditEnd[40] = "')\"><IMG src=\"Edit.jpg\" border=0></A>\r\n"; // weak
char WebEditStart[33] = "<A href=\"javascript:ModifyUser('"; // weak
char WebPrivStr[15] = "UserPrivilege="; // weak
char WebPassStr[14] = "UserPassword="; // weak
char WebUserStr[10] = "UserName="; // weak
char WebNewLine[3] = "\r\n"; // weak
char WebTrendnetNewColumn[25] = "</td><td class=\"bggrey\">"; // weak
char WebTrendnetRowStart[24] = "<tr><td class=\"bggrey\">"; // weak
char WebRowEnd[13] = "</td></tr>\r\n"; // weak
char WebNewColumn[10] = "</td><td>"; // weak
char WebRowStart[9] = "<tr><td>"; // weak
char WebOptionEnd[12] = "</OPTION>\r\n"; // weak
char WebOptionCheck[18] = "<OPTION selected>"; // weak
char WebOptionStart[9] = "<OPTION>"; // weak
char WebNotFound[9] = "NotFound"; // weak
char WiFiPatchMacAddress[16] = "#@$mac address="; // weak
char WiFiPatchWlanEnable[20] = "#@$wireless enable="; // weak
char WiFiPatchUserPass[13] = "#@$password="; // weak
char WiFiPatchUserName[13] = "#@$username="; // weak
char WiFiPatchIPAddress[15] = "#@$ip address="; // weak
char WebWiFiToken[4] = "#@$"; // weak
_UNKNOWN webMultiLanguageList; // weak
char *off_4E417C = "English"; // weak
char *webDDNSProviderList[4] = { "www.dlinkddns.com", "www.dlinkddns.com", "www.DynDNS.org", "www.DynDNS.org" }; // weak
int websSetFormFuncList = 0; // weak
int websParaFuncList = 0; // weak
_UNKNOWN *websForceCheckSessionKeyList = (_UNKNOWN *)0x499070; // weak
char *websCgiPostRequestList = "/stream/notify_stream.cgi"; // weak
_UNKNOWN websPathFileList; // weak
char *off_4E4234 = "/api/wifisetup.exe"; // weak
char *websPostCgiList[51] =
{
  "WebDebugLevel",
  "/cgi/dbglevel.cgi",
  "/setform/setDebugLevel",
  "ConfigReboot",
  "/cgi/system.cgi",
  "/setform/setSystemAdmin",
  "ConfigReboot",
  "/cgi/datetime.cgi",
  "/setform/setSystemDate",
  "ConfigReboot",
  "/cgi/user.cgi",
  "/setform/setSystemControl",
  "UserAdd",
  "/cgi/userlist.cgi",
  "/setform/setSystemAddUser",
  "UserDelete",
  "/cgi/userlist.cgi",
  "/setform/setSystemDeleteUser",
  "ConfigReboot",
  "/cgi/image.cgi",
  "/setform/setSystemStream",
  "ConfigReboot",
  "/cgi/network.cgi",
  "/setform/setSystemNetwork",
  "ConfigReboot",
  "/cgi/wireless.cgi",
  "/setform/setSystemWireless",
  "ConfigReboot",
  "/cgi/upload.cgi",
  "/setform/setSystemFTP",
  "ConfigReboot",
  "/cgi/email.cgi",
  "/setform/setSystemEmail",
  "ConfigReboot",
  "/cgi/audiocfg.cgi",
  "/setform/setSystemStream",
  "ConfigReboot",
  "/cgi/motion.cgi",
  "/setform/setSystemMotion",
  "ConfigTemp",
  "/cgi/motion.cgi",
  "/setform/setSystemMotion",
  "ConfigReboot",
  "/cgi/daynight.cgi",
  "/setform/setDayNightMode",
  "ConfigReboot",
  "/cgi/sdbdetection.cgi",
  "/setform/setSystemSoundDB",
  "ConfigReboot",
  "/cgi/cifs.cgi",
  "/setform/setSystemCIFS"
}; // weak
char *off_4E4244[50] =
{
  "/cgi/dbglevel.cgi",
  "/setform/setDebugLevel",
  "ConfigReboot",
  "/cgi/system.cgi",
  "/setform/setSystemAdmin",
  "ConfigReboot",
  "/cgi/datetime.cgi",
  "/setform/setSystemDate",
  "ConfigReboot",
  "/cgi/user.cgi",
  "/setform/setSystemControl",
  "UserAdd",
  "/cgi/userlist.cgi",
  "/setform/setSystemAddUser",
  "UserDelete",
  "/cgi/userlist.cgi",
  "/setform/setSystemDeleteUser",
  "ConfigReboot",
  "/cgi/image.cgi",
  "/setform/setSystemStream",
  "ConfigReboot",
  "/cgi/network.cgi",
  "/setform/setSystemNetwork",
  "ConfigReboot",
  "/cgi/wireless.cgi",
  "/setform/setSystemWireless",
  "ConfigReboot",
  "/cgi/upload.cgi",
  "/setform/setSystemFTP",
  "ConfigReboot",
  "/cgi/email.cgi",
  "/setform/setSystemEmail",
  "ConfigReboot",
  "/cgi/audiocfg.cgi",
  "/setform/setSystemStream",
  "ConfigReboot",
  "/cgi/motion.cgi",
  "/setform/setSystemMotion",
  "ConfigTemp",
  "/cgi/motion.cgi",
  "/setform/setSystemMotion",
  "ConfigReboot",
  "/cgi/daynight.cgi",
  "/setform/setDayNightMode",
  "ConfigReboot",
  "/cgi/sdbdetection.cgi",
  "/setform/setSystemSoundDB",
  "ConfigReboot",
  "/cgi/cifs.cgi",
  "/setform/setSystemCIFS"
}; // weak
_UNKNOWN websAuthenticationPathList; // weak
char *off_4E4328 = "/media/"; // weak
_UNKNOWN unk_4E432C; // weak
_UNKNOWN websForceAuthenticPathList; // weak
char *off_4E45C8 = "/frame/dgimage.cgi"; // weak
_UNKNOWN websReplacePathList; // weak
_UNKNOWN *off_4E4620 = (_UNKNOWN *)0x497250; // weak
int WebCurrentLanguage = 0; // weak
int WebErrMsgCount = 0; // weak
int WebErrMsgList = 0; // weak
int WebAuthFileList = 0; // weak
int WebAuthUserList = 0; // weak
char ForwardH264[11] = "/hview.htm"; // weak
char ForwardHome[10] = "/home.htm"; // weak
char WebInteralSnapImgCGI[21] = "/frame/snapimage.cgi"; // weak
char WebErrMsgFile[12] = "/errmsg.htm"; // weak
char WebAuthFile[10] = "/html.htm"; // weak
_BYTE byte_4E4E88[64] =
{
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  43,
  47
}; // weak
int socketLastAcceptFd = -1; // weak
int socketHighestFd = -1; // weak
int socketLast = -1; // weak
int dword_4E4ED4 = 0; // weak
_UNKNOWN unk_4E4ED8; // weak
_BYTE byte_4E4F18[16] = { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70 }; // weak
char *websMimeList[3] = { "application/java", ".class", "application/java" }; // weak
char *off_4E4FF0 = "/etc_ro/web"; // weak
int (*off_4E4FF4)() = &websAntiBruteProcessor; // weak
int dword_4E5034 = 0; // weak
int dword_4E5038 = -1; // weak
char DBCSVector12 = '\x81'; // weak
_UNKNOWN DBCSVector; // weak
char aXxxxxxxxxxxxxx_0[26] = "xxxxxxxxxxxxxxxxxxxxxxxxx"; // weak
int dword_4E506C = -1; // weak
_UNKNOWN framesupportPathList; // weak
char *off_4E5074 = "/frame/snapimage.cgi"; // weak
int dword_4E5150 = -1; // weak
_UNKNOWN StearmSupportPathList; // weak
char *off_4E5158[2] = { "/stream/audio.cgi", "/bin/audiopush" }; // weak
int dword_4E5250 = -1; // weak
_UNKNOWN ks3; // weak
_DWORD ks2[256] =
{
  -381855128,
  -1803468553,
  -162781668,
  -1805047500,
  1091903735,
  1979897079,
  -1124832466,
  -727580568,
  -737663887,
  857797738,
  1136121015,
  1342202287,
  507115054,
  -1759230650,
  337727348,
  -1081374656,
  1301675037,
  -1766485585,
  1895095763,
  1721773893,
  -1078195732,
  62756741,
  2142006736,
  835421444,
  -1762973773,
  1442462017,
  -635090970,
  -1412822374,
  676362277,
  1392781812,
  170690266,
  -373920261,
  1759253602,
  -683120384,
  1745797284,
  664899054,
  1329594018,
  -393761396,
  -1249058810,
  2062866102,
  -1429332356,
  -751345684,
  -830954599,
  1080764994,
  553557557,
  -638351943,
  -298199125,
  991055499,
  499776247,
  1265440854,
  648242737,
  -354183246,
  980351604,
  -581221582,
  1749149687,
  -898096901,
  -83167922,
  -654396521,
  1161844396,
  -1169648345,
  1431517754,
  545492359,
  -26498633,
  -795437749,
  1437099964,
  -1592419752,
  -861329053,
  -1713251533,
  -1507177898,
  1060185593,
  1593081372,
  -1876348548,
  -34019326,
  69676912,
  -2135222948,
  86519011,
  -1782508216,
  -456757982,
  1220612927,
  -955283748,
  133810670,
  1090789135,
  1078426020,
  1569222167,
  845107691,
  -711212847,
  -222510705,
  1091646820,
  628848692,
  1613405280,
  -537335645,
  526609435,
  236106946,
  48312990,
  -1352249391,
  -892239595,
  1797494240,
  859738849,
  992217954,
  -289490654,
  -2051890674,
  -424014439,
  -562951028,
  765654824,
  -804095931,
  -1783130883,
  1685915746,
  -405998096,
  1414112111,
  -2021832454,
  -1013056217,
  -214004450,
  172450625,
  -1724973196,
  980381355,
  -185008841,
  -1475158944,
  -1578377736,
  -1726226100,
  -613520627,
  -964995824,
  1835478071,
  660984891,
  -590288892,
  -248967737,
  -872349789,
  -1254551662,
  1762651403,
  1719377915,
  -824476260,
  -1601057013,
  -652910941,
  -1156370552,
  1364962596,
  2073328063,
  1983633131,
  926494387,
  -871278215,
  -2144935273,
  -198299347,
  1749200295,
  -966120645,
  309677260,
  2016342300,
  1779581495,
  -1215147545,
  111262694,
  1274766160,
  443224088,
  298511866,
  1025883608,
  -488520759,
  1145181785,
  168956806,
  -653464466,
  -710153686,
  1689216846,
  -628709281,
  -1094719096,
  1692713982,
  -1648590761,
  -252198778,
  1618508792,
  1610833997,
  -771914938,
  -164094032,
  2001055236,
  -684262196,
  -2092799181,
  -266425487,
  -1333771897,
  1006657119,
  2006996926,
  -1108824540,
  1430667929,
  -1084739999,
  1314452623,
  -220332638,
  -193663176,
  -2021016126,
  1399257539,
  -927756684,
  -1267338667,
  1190975929,
  2062231137,
  -1960976508,
  -2073424263,
  -1856006770,
  1181637006,
  548689776,
  -1932175983,
  -922558900,
  -1190417183,
  -1149106736,
  296247880,
  1970579870,
  -1216407114,
  -525738999,
  1714227617,
  -1003338189,
  -396747006,
  166772364,
  1251581989,
  493813264,
  448347421,
  195405023,
  -1584991729,
  677966185,
  -591930749,
  1463355134,
  -1578971493,
  1338867538,
  1343315457,
  -1492745222,
  -1610435132,
  233230375,
  -1694987225,
  2000651841,
  -1017099258,
  1638401717,
  -266896856,
  -1057650976,
  6314154,
  819756386,
  300326615,
  590932579,
  1405279636,
  -1027467724,
  -1144263082,
  -1866680610,
  -335774303,
  -833020554,
  1862657033,
  1266418056,
  963775037,
  2089974820,
  -2031914401,
  1917689273,
  448879540,
  -744572676,
  -313240200,
  150775221,
  -667058989,
  1303187396,
  508620638,
  -1318983944,
  -1568336679,
  1817252668,
  1876281319,
  1457606340,
  908771278,
  -574175177,
  -677760460,
  -1838972398,
  1729034894,
  1080033504
}; // weak
_DWORD ks1[256] =
{
  1266315497,
  -1246549692,
  -613086930,
  -1004984797,
  -1385257296,
  1235738493,
  -1662099272,
  -1880247706,
  -324367247,
  1771706367,
  1449415276,
  -1028546847,
  422970021,
  1963543593,
  -1604775104,
  -468174274,
  1062508698,
  1531092325,
  1804592342,
  -1711849514,
  -1580033017,
  -269995787,
  1294809318,
  -265986623,
  1289560198,
  -2072974554,
  1669523910,
  35572830,
  157838143,
  1052438473,
  1016535060,
  1802137761,
  1753167236,
  1386275462,
  -1214491899,
  -1437595849,
  1040679964,
  2145300060,
  -1904392980,
  1461121720,
  -1338320329,
  -263189491,
  -266592508,
  33600511,
  -1374882534,
  1018524850,
  629373528,
  -603381315,
  -779021319,
  2091462646,
  -1808644237,
  586499841,
  988145025,
  935516892,
  -927631820,
  -1695294041,
  -1455136442,
  265290510,
  -322386114,
  -1535828415,
  -499593831,
  1005194799,
  847297441,
  406762289,
  1314163512,
  1332590856,
  1866599683,
  -167115585,
  750260880,
  613907577,
  1450815602,
  -1129346641,
  -560302305,
  -644675568,
  -1282691566,
  -590397650,
  1427272223,
  778793252,
  1343938022,
  -1618686585,
  2052605720,
  1946737175,
  -1130390852,
  -380928628,
  -327488454,
  -612033030,
  1661551462,
  -1000029230,
  -283371449,
  840292616,
  -582796489,
  616741398,
  312560963,
  711312465,
  1351876610,
  322626781,
  1910503582,
  271666773,
  -2119403562,
  1594956187,
  70604529,
  -677132437,
  1007753275,
  1495573769,
  -225450259,
  -1745748998,
  -1631928532,
  504708206,
  -2031925904,
  -353800271,
  -2045878774,
  1514023603,
  1998579484,
  1312622330,
  694541497,
  -1712906993,
  -2143385130,
  1382467621,
  776784248,
  -1676627094,
  -971698502,
  -1797068168,
  -1510196141,
  503983604,
  -218673497,
  907881277,
  423175695,
  432175456,
  1378068232,
  -149744970,
  -340918674,
  -356311194,
  -474200683,
  -1501837181,
  -1317062703,
  26017576,
  -1020076561,
  -1100195163,
  1700274565,
  1756076034,
  -288447217,
  -617638597,
  720338349,
  1533947780,
  354530856,
  688349552,
  -321042571,
  1637815568,
  332179504,
  -345916010,
  53804574,
  -1442618417,
  -1250730864,
  1282449977,
  -711025141,
  -877994476,
  -288586052,
  1617046695,
  -1666491221,
  -1292663698,
  1686838959,
  431878346,
  -1608291911,
  1700445008,
  1080580658,
  1009431731,
  832498133,
  -1071531785,
  -1688990951,
  -2023776103,
  -1778935426,
  1648197032,
  -130578278,
  -1746719369,
  300782431,
  375919233,
  238389289,
  -941219882,
  -1763778655,
  2019080857,
  1475708069,
  455242339,
  -1685863425,
  448939670,
  -843904277,
  1395535956,
  -1881585436,
  1841049896,
  1491858159,
  885456874,
  -30872223,
  -293847949,
  1565136089,
  -396052509,
  1108368660,
  540939232,
  1173283510,
  -1549095958,
  -613658859,
  -87339056,
  -951913406,
  -278217803,
  1699691293,
  1103962373,
  -669091426,
  -2038084153,
  -464828566,
  1031889488,
  -815619598,
  1535977030,
  -58162272,
  -1043876189,
  2132092099,
  1774941330,
  1199868427,
  1452454533,
  157007616,
  -1390851939,
  342012276,
  595725824,
  1480756522,
  206960106,
  497939518,
  591360097,
  863170706,
  -1919713727,
  -698356495,
  1814182875,
  2094937945,
  -873565088,
  1082520231,
  -831049106,
  -1509457788,
  435703966,
  -386934699,
  1641649973,
  -1452693590,
  -989067582,
  1510255612,
  -2146710820,
  -1639679442,
  -1018874748,
  -36346107,
  236887753,
  -613164077,
  274041037,
  1734335097,
  -479771840,
  -976997275,
  1899903192,
  1026095262,
  -244449504,
  356393447,
  -1884275382,
  -421290197,
  -612127241
}; // weak
_DWORD ks0[256] =
{
  -785314906,
  -1730169428,
  805139163,
  -803545161,
  -1193168915,
  1780907670,
  -1166241723,
  -248741991,
  614570311,
  -1282315017,
  134345442,
  -2054226922,
  1667834072,
  1901547113,
  -1537671517,
  -191677058,
  227898511,
  1921955416,
  1904987480,
  -2112533778,
  2069144605,
  -1034266187,
  -1674521287,
  720527379,
  -976113629,
  677414384,
  -901678824,
  -1193592593,
  -1904616272,
  1614419982,
  1822297739,
  -1340175810,
  -686458943,
  -1120842969,
  2024746970,
  1432378464,
  -430627341,
  -1437226092,
  1464375394,
  1676153920,
  1439316330,
  715854006,
  -1261675468,
  289532110,
  -1588296017,
  2087905683,
  -1276242927,
  1668267050,
  732546397,
  1947742710,
  -832815594,
  -1685613794,
  -1344882125,
  1814351708,
  2050118529,
  680887927,
  999245976,
  1800124847,
  -994056165,
  1713906067,
  1641548236,
  -81679983,
  1216130144,
  1575780402,
  -276538019,
  -377129551,
  -601480446,
  -345695352,
  596196993,
  -745100091,
  258830323,
  -2081144263,
  772490370,
  -1534844924,
  1774776394,
  -1642095778,
  566650946,
  -152474470,
  1728879713,
  -1412200208,
  1783734482,
  -665571480,
  -1777359064,
  -1420741725,
  1861159788,
  326777828,
  -1170476976,
  2130389656,
  -1578015459,
  967770486,
  1724537150,
  -2109534584,
  -1930525159,
  1164943284,
  2105845187,
  998989502,
  -529566248,
  -2050940813,
  1075463327,
  1455516326,
  1322494562,
  910128902,
  469688178,
  1117454909,
  936433444,
  -804646328,
  -619713837,
  1240580251,
  122909385,
  -2137449605,
  634681816,
  -152510729,
  -469872614,
  -1233564613,
  -1754472259,
  79693498,
  -1045868618,
  1084186820,
  1583128258,
  426386531,
  1761308591,
  1047286709,
  322548459,
  995290223,
  1845252383,
  -1691314900,
  -863943356,
  -1352745719,
  -1092366332,
  -567063811,
  1712269319,
  422464435,
  -1060394921,
  1170764815,
  -771006663,
  -1177289765,
  1434042557,
  442511882,
  -694091578,
  1076654713,
  1738483198,
  -81812532,
  -1901729288,
  -617471240,
  1014306527,
  -43947243,
  793779912,
  -1392160085,
  842905082,
  -48003232,
  1395751752,
  1040244610,
  -1638115397,
  -898659168,
  445077038,
  -552113701,
  -717051658,
  679411651,
  -1402522938,
  -1940957837,
  1767581616,
  -1144366904,
  -503340195,
  -1192226400,
  284835224,
  -48135240,
  1258075500,
  768725851,
  -1705778055,
  -1225243291,
  -762426948,
  1274779536,
  -505548070,
  -1530167757,
  1660621633,
  -823867672,
  -283063590,
  913787905,
  -797008130,
  737222580,
  -1780753843,
  -1366257256,
  -357724559,
  1804850592,
  -795946544,
  -1345903136,
  -1908647121,
  -1904896841,
  -1879645445,
  -233690268,
  -2004305902,
  -1878134756,
  1336762016,
  1754252060,
  -774901359,
  -1280786003,
  791618072,
  -1106372745,
  -361419266,
  -1962795103,
  -442446833,
  -1250986776,
  413987798,
  -829824359,
  -1264037920,
  -49028937,
  2093235073,
  -760370983,
  375366246,
  -2137688315,
  -1815317740,
  555357303,
  -424861595,
  2008414854,
  -950779147,
  -73583153,
  -338841844,
  2067696032,
  -700376109,
  -1373733303,
  2428461,
  544322398,
  577241275,
  1471733935,
  610547355,
  -267798242,
  1432588573,
  1457497770,
  2025931657,
  -648391809,
  545086370,
  48609733,
  -2094660746,
  1653985193,
  298326376,
  1316178497,
  -1287180854,
  2064951626,
  458293330,
  -1705826027,
  -703637697,
  -1130641692,
  727753846,
  -2115603456,
  146436021,
  1461446943,
  -224990101,
  705550613,
  -1235000031,
  -407242314,
  -13368024,
  -981117340,
  1404054877,
  -1449160799,
  146425753,
  1854211946
}; // weak
int dword_4E6254 = -1; // weak
char livefilestart[24] = "/media/http_live/stream"; // weak
int dword_4E6274 = -1; // weak
int dword_4E6278 = -1; // weak
_BYTE AES_Sbox[256] =
{
  99,
  124,
  119,
  123,
  -14,
  107,
  111,
  -59,
  48,
  1,
  103,
  43,
  -2,
  -41,
  -85,
  118,
  -54,
  -126,
  -55,
  125,
  -6,
  89,
  71,
  -16,
  -83,
  -44,
  -94,
  -81,
  -100,
  -92,
  114,
  -64,
  -73,
  -3,
  -109,
  38,
  54,
  63,
  -9,
  -52,
  52,
  -91,
  -27,
  -15,
  113,
  -40,
  49,
  21,
  4,
  -57,
  35,
  -61,
  24,
  -106,
  5,
  -102,
  7,
  18,
  128,
  -30,
  -21,
  39,
  -78,
  117,
  9,
  -125,
  44,
  26,
  27,
  110,
  90,
  -96,
  82,
  59,
  -42,
  -77,
  41,
  -29,
  47,
  -124,
  83,
  -47,
  0,
  -19,
  32,
  -4,
  -79,
  91,
  106,
  -53,
  -66,
  57,
  74,
  76,
  88,
  -49,
  -48,
  -17,
  -86,
  -5,
  67,
  77,
  51,
  -123,
  69,
  -7,
  2,
  127,
  80,
  60,
  -97,
  -88,
  81,
  -93,
  64,
  -113,
  -110,
  -99,
  56,
  -11,
  -68,
  -74,
  -38,
  33,
  16,
  -1,
  -13,
  -46,
  -51,
  12,
  19,
  -20,
  95,
  -105,
  68,
  23,
  -60,
  -89,
  126,
  61,
  100,
  93,
  25,
  115,
  96,
  -127,
  79,
  -36,
  34,
  42,
  -112,
  -120,
  70,
  -18,
  -72,
  20,
  -34,
  94,
  11,
  -37,
  -32,
  50,
  58,
  10,
  73,
  6,
  36,
  92,
  -62,
  -45,
  -84,
  98,
  -111,
  -107,
  -28,
  121,
  -25,
  -56,
  55,
  109,
  -115,
  -43,
  78,
  -87,
  108,
  86,
  -12,
  -22,
  101,
  122,
  -82,
  8,
  -70,
  120,
  37,
  46,
  28,
  -90,
  -76,
  -58,
  -24,
  -35,
  116,
  31,
  75,
  -67,
  -117,
  -118,
  112,
  62,
  -75,
  102,
  72,
  3,
  -10,
  14,
  97,
  53,
  87,
  -71,
  -122,
  -63,
  29,
  -98,
  -31,
  -8,
  -104,
  17,
  105,
  -39,
  -114,
  -108,
  -101,
  30,
  -121,
  -23,
  -50,
  85,
  40,
  -33,
  -116,
  -95,
  -119,
  13,
  -65,
  -26,
  66,
  104,
  65,
  -103,
  45,
  15,
  -80,
  84,
  -69,
  22
}; // weak
unsigned __int8 AES_ShiftRowTab[16] = { 0u, 5u, 10u, 15u, 4u, 9u, 14u, 3u, 8u, 13u, 2u, 7u, 12u, 1u, 6u, 11u }; // weak
char byte_4E638C = 'N'; // weak
__int16 word_4E63AC[560] =
{
  -16340,
  6,
  3074,
  0,
  8192,
  4,
  20068,
  70,
  20248,
  70,
  20692,
  70,
  0,
  0,
  0,
  0,
  -16336,
  7,
  3074,
  0,
  8192,
  4,
  20068,
  70,
  20248,
  70,
  20692,
  70,
  0,
  0,
  0,
  0,
  -16348,
  6,
  1026,
  0,
  8240,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  -16344,
  7,
  1026,
  0,
  8240,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  -16341,
  6,
  2561,
  0,
  4096,
  4,
  20068,
  70,
  20248,
  70,
  20692,
  70,
  0,
  0,
  0,
  0,
  -16337,
  7,
  2561,
  0,
  4096,
  4,
  20068,
  70,
  20248,
  70,
  20692,
  70,
  0,
  0,
  0,
  0,
  -16349,
  6,
  513,
  0,
  4128,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  -16345,
  7,
  513,
  0,
  4128,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  -16374,
  6,
  258,
  0,
  8212,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  -16364,
  7,
  258,
  0,
  8212,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  -16375,
  6,
  257,
  0,
  4116,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  -16365,
  7,
  257,
  0,
  4116,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  157,
  1,
  3074,
  0,
  8192,
  4,
  20068,
  70,
  20248,
  70,
  20692,
  70,
  0,
  0,
  0,
  0,
  -16338,
  8,
  3074,
  0,
  8192,
  4,
  20068,
  70,
  20248,
  70,
  20692,
  70,
  0,
  0,
  0,
  0,
  -16334,
  9,
  3074,
  0,
  8192,
  4,
  20068,
  70,
  20248,
  70,
  20692,
  70,
  0,
  0,
  0,
  0,
  -16346,
  8,
  1026,
  0,
  8240,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  -16342,
  9,
  1026,
  0,
  8240,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  61,
  1,
  514,
  0,
  8224,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  -16339,
  8,
  2561,
  0,
  4096,
  4,
  20068,
  70,
  20248,
  70,
  20692,
  70,
  0,
  0,
  0,
  0,
  156,
  1,
  2561,
  0,
  4096,
  4,
  20068,
  70,
  20248,
  70,
  20692,
  70,
  0,
  0,
  0,
  0,
  -16335,
  9,
  2561,
  0,
  4096,
  4,
  20068,
  70,
  20248,
  70,
  20692,
  70,
  0,
  0,
  0,
  0,
  -16347,
  8,
  513,
  0,
  4128,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  60,
  1,
  513,
  0,
  4128,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  -16343,
  9,
  513,
  0,
  4128,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  -16379,
  8,
  258,
  0,
  8212,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  53,
  1,
  258,
  0,
  8212,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  -16369,
  9,
  258,
  0,
  8212,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  -16380,
  8,
  257,
  0,
  4116,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  47,
  1,
  257,
  0,
  4116,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  -16370,
  9,
  257,
  0,
  4116,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  175,
  5,
  1026,
  0,
  8240,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  174,
  5,
  513,
  0,
  4128,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  141,
  5,
  258,
  0,
  8212,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  140,
  5,
  257,
  0,
  4116,
  4112,
  21052,
  70,
  21264,
  70,
  21332,
  70,
  21584,
  70,
  21800,
  70,
  0,
  0,
  0,
  0,
  0,
  0,
  20060,
  70,
  21400,
  70,
  21484,
  70,
  21568,
  70,
  21576,
  70
}; // weak
_DWORD dword_4E680C[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
char byte_4E682C = '\0'; // weak
char byte_4E682D = '\0'; // weak
char byte_4E682E = '\0'; // weak
char byte_4E682F = '\0'; // weak
char byte_4E684C = 'N'; // weak
__int16 word_4E686C = 0; // weak
char byte_4E6870[] = { 'B' }; // weak
int dword_4E6960 = 0; // weak
char byte_4E6964 = 'N'; // weak
unsigned __int8 byte_4E6984[12] = { 31u, 28u, 31u, 30u, 31u, 30u, 31u, 31u, 30u, 31u, 30u, 31u }; // weak
_UNKNOWN *psStaticAllocationsPool = &psStaticAllocationsPool; // weak
int dword_4E6994 = -1; // weak
int dword_4E6998 = -1; // weak
int dword_4E699C = 0; // weak
_UNKNOWN unk_4E69A0; // weak
char byte_4E7C80; // weak
_UNKNOWN unk_4E7C84; // weak
int gotsigterm; // weak
int websConnList; // weak
int websSrvPort; // weak
char websSrvHostName; // weak
char byte_4E7CB0; // weak
char byte_4E7CB4; // weak
char byte_4E7CB8; // weak
char byte_4E7CBC; // weak
char byte_4E7CC0; // weak
char byte_4E7CC4; // weak
char byte_4E7CC8; // weak
char websSrvIpAddr; // weak
char byte_4E7CD0; // weak
char byte_4E7CD4; // weak
char byte_4E7CD8; // weak
int dword_4E7CDC; // weak
char byte_4E7CE0; // weak
char byte_4E7CE4; // weak
char byte_4E7CE8; // weak
int dword_4E7CEC; // weak
int dword_4E7CF0; // weak
int socketList; // weak
int dword_4E7CF8; // weak
int dword_4E7CFC; // weak
int dword_4E7D00; // weak
_UNKNOWN key; // weak
int keylen; // weak
_DWORD c[1024]; // weak
int dword_4E8D40; // weak
int dword_4E8D44; // weak
int dword_4E8D80; // weak
int dword_4E8D84; // weak
int dword_4E8D88; // weak
_UNKNOWN liverec; // weak
int dword_4E8E8C; // weak
int dword_4E8E90; // weak
_BYTE AES_Sbox_Inv[256]; // weak
_BYTE AES_ShiftRowTab_Inv[16]; // weak
_UNKNOWN AES_xtime; // weak
_UNKNOWN unk_4E90A4; // weak
_UNKNOWN unk_4E90BC; // weak
_UNKNOWN unk_4E90D4; // weak
_UNKNOWN unk_4E90D8; // weak
_UNKNOWN unk_4E90F4; // weak
_UNKNOWN unk_4E912C; // weak
_UNKNOWN unk_4E9138; // weak
int dword_4E9E54; // weak
int dword_4E9E58; // weak
int dword_4E9E5C; // weak
_UNKNOWN unk_4E9E60; // weak
_UNKNOWN unk_4E9E80; // weak
int dword_4E9E98; // weak
_UNKNOWN unk_4E9E9C; // weak
_UNKNOWN unk_4E9EB4; // weak
// extern int _ctype_tolower; weak
// extern int stderr; weak
// extern int _ctype_toupper; weak
// extern int _ctype_b; weak
// extern int stdout; weak


//----- (00408B50) --------------------------------------------------------
int init_proc()
{
  sub_408D10();
  return sub_495F20();
}

//----- (00408BE0) --------------------------------------------------------
void __noreturn ftext()
{
  int v0; // $v0
  int v1; // [sp-10h] [-20h] BYREF
  int v2; // [sp+10h] [+0h]
  char v3; // [sp+14h] [+4h] BYREF

  _uClibc_main(main, v2, &v3, init_proc, term_proc, v0, &v1);
  while ( 1 )
    ;
}
// 408C2C: variable 'v0' is possibly undefined
// 4E9FB0: using guessed type int   _uClibc_main(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00408C40) --------------------------------------------------------
int sub_408C40()
{
  int result; // $v0
  void (*v1)(void); // $t9

  result = (unsigned __int8)byte_4E7C80;
  if ( !byte_4E7C80 )
  {
    while ( 1 )
    {
      v1 = (void (*)(void))*fdata;
      if ( !*fdata )
        break;
      ++fdata;
      v1();
    }
    result = 1;
    if ( &_deregister_frame_info )
    {
      _deregister_frame_info(&unk_4A33E4);
      result = 1;
    }
    byte_4E7C80 = 1;
  }
  return result;
}
// 4E340C: using guessed type int *fdata;
// 4E7C80: using guessed type char byte_4E7C80;
// 4EA000: using guessed type int   _deregister_frame_info(_DWORD);

//----- (00408D10) --------------------------------------------------------
int (*(**sub_408D10(void)))(_DWORD, _DWORD);
{
  void *v0; // $a1
  int (  **result)(_DWORD, _DWORD); // $v0

  v0 = &unk_4E7C84;
  if ( &_register_frame_info )
    _register_frame_info(&unk_4A33E4, &unk_4E7C84);
  result = (int (  **)(_DWORD, _DWORD))dword_4E33F8;
  if ( dword_4E33F8 )
  {
    result = &Jv_RegisterClasses;
    if ( &Jv_RegisterClasses )
      return (int (  **)(_DWORD, _DWORD))Jv_RegisterClasses(&dword_4E33F8, v0);
  }
  return result;
}
// 408DA0: variable 'v0' is possibly undefined
// 4E33F8: using guessed type int dword_4E33F8;
// 4E9EFC: using guessed type int   _register_frame_info(_DWORD, _DWORD);
// 4E9F0C: using guessed type int   Jv_RegisterClasses(_DWORD, _DWORD);

//----- (00408DC0) --------------------------------------------------------
int *trace(int a1, int a2, ...)
{
  int *result; // $v0
  va_list va; // [sp+30h] [+18h] BYREF

  va_start(va, a2);
  result = &Debug_Trace_Level;
  if ( (Debug_Trace_Level & a1) == a1 )
  {
    if ( a2 )
    {
      fprintf(stderr, "%s: ", "alphapd");
      return (int *)vfprintf(stderr, a2, (int *)va);
    }
  }
  return result;
}
// 4E3420: using guessed type int Debug_Trace_Level;
// 4E9EF4: using guessed type int   vfprintf(_DWORD, _DWORD, _DWORD);
// 4E9F70: using guessed type int stderr;
// 4EA014: using guessed type int fprintf(_DWORD, char *, ...);

//----- (00408E68) --------------------------------------------------------
int   sub_408E68(int a1)
{
  int result; // $v0
  char *v2; // $a1

  result = 2;
  v2 = "SIGINT!";
  if ( a1 == 2 || (v2 = "SIGTERM!", a1 == 15) )
  {
    result = (int)trace(0, (int)v2);
    gotsigterm = 1;
  }
  return result;
}
// 4E7CA0: using guessed type int gotsigterm;

//----- (00408EE4) --------------------------------------------------------
int httpd_main()
{
  int result; // $v0
  unsigned int SysInfoLong; // $v0
  BOOL v2; // $t2

  result = gotsigterm;
  if ( !gotsigterm )
  {
    while ( 1 )
    {
      SysInfoLong = getSysInfoLong(56);
      if ( ((SysInfoLong >> 9) & 1) != 0 )
        break;
      v2 = (SysInfoLong & 0x200) != 0;
      if ( ((SysInfoLong >> 15) & 1) != 0 )
        goto LABEL_12;
      if ( (SysInfoLong & 0x10000) != 0 )
        break;
LABEL_7:
      websSocketEventPoll();
      usleep(1000);
      websCgiReapChildren();
      usleep(1000);
      websFrameReapChildren();
      usleep(1000);
      websStreamReapChildren();
      usleep(1000);
      websSDCardReapChildren();
      usleep(1000);
      websTimeoutProcess();
      usleep(1000);
      websAntiBruteReapChildren();
      result = usleep(1000);
      if ( gotsigterm )
        return result;
    }
    v2 = (SysInfoLong & 0x200) != 0;
LABEL_12:
    if ( v2 )
    {
      setSysInfoLong(58, 512);
    }
    else if ( ((SysInfoLong >> 15) & 1) != 0 )
    {
      setSysInfoLong(58, 0x8000);
    }
    else if ( (SysInfoLong & 0x10000) != 0 )
    {
      setSysInfoLong(58, 0x10000);
    }
    websEndAuthentication();
    nvram_close(0);
    nvram_init(0);
    websStartAuthentication();
    trace(16, (int)"reload configuration!\n");
    goto LABEL_7;
  }
  return result;
}
// 4E7CA0: using guessed type int gotsigterm;
// 4E9F1C: using guessed type int   nvram_init(_DWORD);
// 4E9F64: using guessed type int   nvram_close(_DWORD);
// 4EA090: using guessed type int   usleep(_DWORD);

//----- (004091B8) --------------------------------------------------------
int *preparesslkey()
{
  _BYTE *v0; // $s1
  _BYTE *v1; // $s2
  int v2; // $s2
  _BYTE *v3; // $s1
  int v4; // $s0
  int v5; // $v0
  int v6; // $a1
  int v7; // $s2
  _BYTE *v8; // $s1
  int v9; // $s0
  int v10; // $v0
  int v11; // $a1
  int v13; // $s3
  int v14; // $a1
  int v15; // $s0
  int v16; // $v0
  int v17; // $s1
  int v18; // $s0
  int v19; // $v0
  int v20; // $a1
  _BYTE v21[4096]; // [sp+18h] [-1000h] BYREF

  v0 = (_BYTE *)nvram_bufget(0, "SSLCertificate1");
  v1 = (_BYTE *)nvram_bufget(0, "SSLCertificate2");
  if ( *v0 && *v1 )
  {
    v13 = fopen("/etc_ro/servercert.pem", "w+");
    if ( v13 )
    {
      v15 = strlen(v0);
      while ( v15 > 0 )
      {
        v16 = fwrite(v0, 1, v15, v13);
        v15 -= v16;
        v0 += v16;
        if ( v16 < 0 )
        {
          trace(16, (int)"failure to write /etc_ro/servercert.pem");
          break;
        }
      }
      fclose(v13);
    }
    else
    {
      trace(16, (int)"cannot open /etc_ro/servercert.pem");
    }
    v17 = fopen("/etc_ro/serverkey.pem", "w+");
    if ( v17 )
    {
      v18 = strlen(v1);
      do
      {
        if ( v18 <= 0 )
          return (int *)((int (  *)(int))fclose)(v17);
        v19 = fwrite(v1, 1, v18, v17);
        v18 -= v19;
        v1 += v19;
      }
      while ( v19 >= 0 );
      trace(16, (int)"failure to write /etc_ro/serverkey.pem");
      return (int *)((int (  *)(int))fclose)(v17);
    }
    else
    {
      return trace(16, (int)"cannot open /etc_ro/serverkey.pem");
    }
  }
  else
  {
    doSystem((int)"/etc_ro/gensslkey.sh");
    v2 = fopen("/etc_ro/servercert.pem", "r");
    if ( v2 )
    {
      memset(v21, 0, sizeof(v21));
      v3 = v21;
      v4 = 4096;
      while ( 1 )
      {
        v5 = fread(v3, 1, v4, v2);
        v3 += v5;
        v4 -= v5;
        if ( v5 < 0 )
          break;
        if ( feof(v2) )
          goto LABEL_7;
      }
      trace(16, (int)"failure to read /etc_ro/servercert.pem");
LABEL_7:
      nvram_bufset(0, "SSLCertificate1", v21);
      fclose(v2);
    }
    else
    {
      trace(16, (int)"cannot open /etc_ro/servercert.pem");
    }
    v7 = fopen("/etc_ro/serverkey.pem", "r");
    if ( v7 )
    {
      memset(v21, 0, sizeof(v21));
      v8 = v21;
      v9 = 4096;
      while ( 1 )
      {
        v10 = fread(v8, 1, v9, v7);
        v8 += v10;
        v9 -= v10;
        if ( v10 < 0 )
          break;
        if ( feof(v7) )
        {
          nvram_bufset(0, "SSLCertificate2", v21);
          fclose(v7);
          return (int *)nvram_commit(0);
        }
      }
      trace(16, (int)"failure to read /etc_ro/serverkey.pem");
      nvram_bufset(0, "SSLCertificate2", v21);
      fclose(v7);
      return (int *)nvram_commit(0);
    }
    else
    {
      trace(16, (int)"cannot open /etc_ro/serverkey.pem");
      return (int *)nvram_commit(0);
    }
  }
}
// 409308: variable 'v6' is possibly undefined
// 4093C0: variable 'v11' is possibly undefined
// 40947C: variable 'v14' is possibly undefined
// 4095BC: variable 'v20' is possibly undefined
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F54: using guessed type int   fwrite(_DWORD, _DWORD, _DWORD, _DWORD);
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9F98: using guessed type int   fclose(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FA8: using guessed type int   fopen(_DWORD, _DWORD);
// 4E9FB4: using guessed type int   fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA06C: using guessed type int   feof(_DWORD);

//----- (00409630) --------------------------------------------------------
int   main(int argc, char **argv, char **envp)
{
  int v3; // $s5
  int v4; // $s1
  int v5; // $v0
  char *v6; // $a1
  int i; // $s0
  int v8; // $v0
  int v9; // $s0
  int v10; // $v0
  int v11; // $a1
  int v12; // $s0
  int v13; // $v0
  int v14; // $a2
  char *v15; // $a1
  void *v16; // $a2
  int v17; // $a0
  char *v18; // $a1
  int v20; // $s1
  _BYTE *v21; // $s0
  int v22; // $a2
  int v23; // $a0
  int v24; // $a0
  int v25; // $a0
  int v26; // $a0
  int v27; // $a0
  int v28; // $a0
  int v29; // $a0
  int v30; // $a0
  int v31; // $a0
  int v32; // $a0
  _DWORD v33[2]; // [sp+20h] [-208h] BYREF
  _BYTE v34[136]; // [sp+28h] [-200h] BYREF
  _DWORD v35[2]; // [sp+B0h] [-178h] BYREF
  _BYTE v36[360]; // [sp+B8h] [-170h] BYREF
  int v37; // [sp+220h] [-8h] BYREF

  v3 = WebSrv_HTTP_Port;
  trace(0, "Startup!\n", envp);
  v37 = 0;
  v4 = fopen(off_4E342C, "r");
  if ( v4 )
  {
    while ( 1 )
    {
      v5 = fgets(v33, 512, v4);
      v6 = "%d";
      if ( !v5 )
        break;
      if ( sscanf(v33, "%d", &v37) >= 0 )
      {
        for ( i = 10; ; --i )
        {
          v8 = getpgid(v37);
          v6 = "wait last alphapd exit = %d(%d)\n";
          if ( v8 < 0 || i <= 0 )
            break;
          trace(16, "wait last alphapd exit = %d(%d)\n", v37);
          sleep(1);
        }
        break;
      }
    }
    fclose(v4);
  }
  doSystem("rm -f /etc_ro/web/pack/dbgulf.lzma");
  v9 = fopen(off_4E342C, "w+");
  if ( v9 )
  {
    v10 = getpid();
    fprintf(v9, "%d", v10);
    fclose(v9);
    v12 = 0;
    while ( 1 )
    {
      v13 = fopen("/var/run/nvramd.pid", "r");
      v15 = "waiting for nvram_daemon";
      if ( v13 )
        break;
      if ( v12 )
        v15 = ". ";
      ++v12;
      trace(16, v15, v14);
      Sleep(1);
      v17 = 0;
      if ( v12 >= 15 )
      {
        v18 = "please execute nvram_daemon first!";
        goto LABEL_16;
      }
    }
    fclose(v13);
    nvram_init(0);
    preparesslkey();
    switch_language(0, 0);
    v20 = nvram_bufget(0, "SecondHTTPPortEnable");
    v21 = (_BYTE *)nvram_bufget(0, "SecondHTTPPort");
    if ( v20 && !strcmp(v20, "3") && v21 && *v21 )
      v3 = atoi(v21);
    doSystem("rm -f /etc_ro/web/crossdomain.xml");
    v33[1] = sub_408E68;
    sigemptyset(v34);
    v33[0] = 0;
    sigaction(15, v33, 0);
    v35[1] = sub_408E68;
    sigemptyset(v36);
    v35[0] = 0;
    sigaction(2, v35, 0);
    signal(13, 1);
    if ( websStartupServer(v3) >= 0 )
    {
      trace(0, "Version %s running at address %s:%d\n", "2.1.8");
      websParaOpen(v23);
      websSetFormOpen(v24);
      websEnableErrorMessage(v25);
      websStartAuthentication(v26);
      httpd_main(v27);
      websEndAuthentication(v28);
      websDisableErrorMessage(v29);
      websSetFormClose(v30);
      websParaClose(v31);
      websShutdownServer(v32);
    }
    trace(0, "Shutdown!\n", v22);
    return 0;
  }
  else
  {
    v16 = &loc_490000;
    v18 = "cannot open pid file";
    v17 = 16;
LABEL_16:
    trace(v17, v18, v16);
    return -1;
  }
}
// 4097EC: variable 'v11' is possibly undefined
// 40982C: variable 'v14' is possibly undefined
// 409868: variable 'v16' is possibly undefined
// 409A74: variable 'v23' is possibly undefined
// 409A8C: variable 'v24' is possibly undefined
// 409AA4: variable 'v25' is possibly undefined
// 409ABC: variable 'v26' is possibly undefined
// 409AD4: variable 'v27' is possibly undefined
// 409AEC: variable 'v28' is possibly undefined
// 409B04: variable 'v29' is possibly undefined
// 409B1C: variable 'v30' is possibly undefined
// 409B34: variable 'v31' is possibly undefined
// 409B4C: variable 'v32' is possibly undefined
// 409B68: variable 'v22' is possibly undefined
// 408DC0: using guessed type int   trace(_DWORD, _DWORD, _DWORD);
// 408E68: using guessed type int sub_408E68();
// 408EE4: using guessed type int   httpd_main(_DWORD);
// 4091B8: using guessed type int preparesslkey(void);
// 409BF8: using guessed type int   websStartupServer(_DWORD);
// 40BC80: using guessed type int   websShutdownServer(_DWORD);
// 413DBC: using guessed type int   switch_language(_DWORD, _DWORD);
// 414B90: using guessed type int   websParaOpen(_DWORD);
// 414C18: using guessed type int   websParaClose(_DWORD);
// 415494: using guessed type int   websSetFormOpen(_DWORD);
// 4154B0: using guessed type int   websSetFormClose(_DWORD);
// 416590: using guessed type int   websEnableErrorMessage(_DWORD);
// 416788: using guessed type int   websDisableErrorMessage(_DWORD);
// 417150: using guessed type int   websStartAuthentication(_DWORD);
// 4171DC: using guessed type int   websEndAuthentication(_DWORD);
// 41CA14: using guessed type int   Sleep(_DWORD);
// 41CC54: using guessed type int   doSystem(_DWORD);
// 4E3428: using guessed type int WebSrv_HTTP_Port;
// 4E342C: using guessed type _UNKNOWN *off_4E342C;
// 4E9F04: using guessed type int   getpgid(_DWORD);
// 4E9F1C: using guessed type int   nvram_init(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F98: using guessed type int   fclose(_DWORD);
// 4E9FA8: using guessed type int   fopen(_DWORD, _DWORD);
// 4E9FB8: using guessed type int   sigaction(_DWORD, _DWORD, _DWORD);
// 4E9FBC: using guessed type int sscanf(_DWORD, char *, ...);
// 4E9FE4: using guessed type int   signal(_DWORD, _DWORD);
// 4EA014: using guessed type int fprintf(_DWORD, char *, ...);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA060: using guessed type int   sleep(_DWORD);
// 4EA084: using guessed type int   fgets(_DWORD, _DWORD, _DWORD);
// 4EA088: using guessed type int getpid(void);
// 4EA0B0: using guessed type int   sigemptyset(_DWORD);

//----- (00409BB0) --------------------------------------------------------
BOOL   websReapChildren(int a1, int a2)
{
  return waitpid(a1, a2, 1) != a1;
}
// 4EA0C4: using guessed type int   waitpid(_DWORD, _DWORD, _DWORD);

//----- (00409BF8) --------------------------------------------------------
int   websStartupServer(int a1)
{
  int SysInfoLong; // $v0
  char *v4; // $s0
  int v5; // $s0
  unsigned int v6; // $v0
  int MACAddress; // $v0
  int v8; // $s1
  char *v9; // $s0
  int v10; // $s0
  int v11; // $v0
  int v12; // $v1
  int v13; // [sp+20h] [-C0h] BYREF
  int v14; // [sp+24h] [-BCh]
  int v15; // [sp+28h] [-B8h]
  int v16; // [sp+2Ch] [-B4h]
  int v17; // [sp+30h] [-B0h]
  int v18; // [sp+34h] [-ACh]
  int v19; // [sp+38h] [-A8h]
  int v20; // [sp+3Ch] [-A4h]
  char v21[64]; // [sp+A0h] [-40h] BYREF

  if ( ++dword_4E35D0 == 1 )
  {
    websConnList = 0;
    websConnLast = -1;
    websSocketOpen();
    SysInfoLong = getSysInfoLong(30);
    if ( !SysInfoLong
      && (v4 = (char *)nvram_bufget(0, "IPAddress"),
          trace(0, (int)"Can't get lan ip from sysinfo!\n"),
          SysInfoLong = inet_addr(v4),
          SysInfoLong == -1) )
    {
      trace(0, (int)"failed to convert %s to binary ip data", v4);
      return -1;
    }
    else
    {
      v5 = inet_ntoa(SysInfoLong);
      v6 = strlen(v5) + 1;
      if ( v6 >= 0x80 )
        v6 = 128;
      memcpy(&v13, v5, v6);
      *(_DWORD *)&byte_4E7CD0 = v14;
      *(_DWORD *)&byte_4E7CD4 = v15;
      *(_DWORD *)&byte_4E7CD8 = v16;
      *(_DWORD *)&websSrvIpAddr = v13;
      dword_4E7CDC = v17;
      *(_DWORD *)&websSrvHostName = v13;
      *(_DWORD *)&byte_4E7CE0 = v18;
      *(_DWORD *)&byte_4E7CB0 = v14;
      *(_DWORD *)&byte_4E7CB4 = v15;
      *(_DWORD *)&byte_4E7CB8 = v16;
      *(_DWORD *)&byte_4E7CE8 = v20;
      *(_DWORD *)&byte_4E7CE4 = v19;
      *(_DWORD *)&byte_4E7CC8 = v20;
      *(_DWORD *)&byte_4E7CBC = v17;
      *(_DWORD *)&byte_4E7CC0 = v18;
      *(_DWORD *)&byte_4E7CC4 = v19;
      memset(v21, 0, sizeof(v21));
      getSysInfoBuffer(1, (int)v21, 64);
      MACAddress = AllocateMACAddress(0, 0);
      v8 = MACAddress;
      if ( MACAddress )
      {
        v9 = (char *)(MACAddress + 10);
        snprintf(aWebs, 128, "%s_%s", v21, (char *)(MACAddress + 10));
        snprintf(&unk_4E35D4, 128, "%s_cgi%s", v21, v9);
        free2(v8);
      }
      v10 = 10;
      while ( 1 )
      {
        v11 = websSocketOpenConnection(a1, (int)websAccept, 0);
        v12 = v10;
        dword_4E7CEC = v11;
        if ( v11 >= 0 )
          break;
        --v10;
        if ( v12 <= 0 )
          break;
        usleep(100000);
      }
      if ( dword_4E7CEC < 0 )
      {
        trace(0, (int)"Can't open a socket on ports %d!\n", a1);
        return -1;
      }
      else
      {
        websSrvPort = a1;
        return a1;
      }
    }
  }
  else
  {
    return websSrvPort;
  }
}
// 4E34CC: using guessed type int websConnLast;
// 4E35D0: using guessed type int dword_4E35D0;
// 4E7CA4: using guessed type int websConnList;
// 4E7CA8: using guessed type int websSrvPort;
// 4E7CAC: using guessed type char websSrvHostName;
// 4E7CB0: using guessed type char byte_4E7CB0;
// 4E7CB4: using guessed type char byte_4E7CB4;
// 4E7CB8: using guessed type char byte_4E7CB8;
// 4E7CBC: using guessed type char byte_4E7CBC;
// 4E7CC0: using guessed type char byte_4E7CC0;
// 4E7CC4: using guessed type char byte_4E7CC4;
// 4E7CC8: using guessed type char byte_4E7CC8;
// 4E7CCC: using guessed type char websSrvIpAddr;
// 4E7CD0: using guessed type char byte_4E7CD0;
// 4E7CD4: using guessed type char byte_4E7CD4;
// 4E7CD8: using guessed type char byte_4E7CD8;
// 4E7CDC: using guessed type int dword_4E7CDC;
// 4E7CE0: using guessed type char byte_4E7CE0;
// 4E7CE4: using guessed type char byte_4E7CE4;
// 4E7CE8: using guessed type char byte_4E7CE8;
// 4E7CEC: using guessed type int dword_4E7CEC;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F94: using guessed type int   inet_ntoa(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA004: using guessed type int   inet_addr(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);
// 4EA090: using guessed type int   usleep(_DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (00409F94) --------------------------------------------------------
int   websConnValid(int a1)
{
  int v1; // $a2
  _DWORD *v2; // $v1

  v1 = 0;
  if ( websConnLast < 0 )
    return 0;
  v2 = (_DWORD *)websConnList;
  while ( 1 )
  {
    ++v1;
    if ( *v2++ == a1 )
      break;
    if ( websConnLast < v1 )
      return 0;
  }
  return 1;
}
// 4E34CC: using guessed type int websConnLast;
// 4E7CA4: using guessed type int websConnList;

//----- (00409FF4) --------------------------------------------------------
char *  websSetEnv(int a1)
{
  char *v1; // $s1
  char *result; // $v0
  char v4[16]; // [sp+20h] [-18h] BYREF
  char *v5; // [sp+30h] [-8h] BYREF

  v1 = (char *)(a1 + 4);
  websSetVar(a1, "REMOTE_HOST", (char *)(a1 + 4));
  websSetVar(a1, "REMOTE_ADDR", v1);
  websSetVar(a1, "QUERY_STRING", *(char **)(a1 + 160));
  websSetVar(a1, "GATEWAY_INTERFACE", "CGI/1.1");
  websSetVar(a1, "SERVER_NAME", &websSrvHostName);
  websSetVar(a1, "SERVER_HOST", &websSrvHostName);
  websSetVar(a1, "PATH_INFO", *(char **)(a1 + 136));
  websSetVar(a1, "SERVER_PROTOCOL", *(char **)(a1 + 176));
  websSetVar(a1, "SERVER_ADDR", (char *)(a1 + 36));
  stritoa(websSrvPort, v4, 16);
  websSetVar(a1, "SERVER_PORT", v4);
  allocFmtString((int *)&v5, 254, (int)"%s/%s", "alphapd", "2.1.8");
  websSetVar(a1, "SERVER_SOFTWARE", v5);
  result = v5;
  if ( v5 )
    return (char *)free2(v5);
  return result;
}
// 4E7CA8: using guessed type int websSrvPort;
// 4E7CAC: using guessed type char websSrvHostName;
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (0040A1E4) --------------------------------------------------------
int   websSetQuery(int a1)
{
  int result; // $v0
  int v3; // $s2
  char *i; // $s0
  _BYTE *v5; // $v0
  char *v6; // $s1
  int v7; // $v0
  int v8; // $v0
  char *Var; // $a3
  char *v10; // [sp+20h] [-8h] BYREF

  result = strdupWithoutNull(*(void **)(a1 + 160));
  v3 = result;
  if ( result )
  {
    result = strtok(result, "&");
    for ( i = (char *)result; result; i = (char *)result )
    {
      v5 = (_BYTE *)strchr(result, 61);
      v6 = v5 + 1;
      if ( v5 )
      {
        *v5 = 0;
        v7 = strlen(i);
        websDecodeUrl(i, i, v7);
        v8 = strlen(v6);
        websDecodeUrl(v6, v6, v8);
      }
      else
      {
        v6 = byte_4A2DDC;
      }
      if ( *i )
      {
        trace(2, (int)"SetEnv=(%s,%s)\n", i, v6);
        Var = (char *)websGetVar(a1, (int)i, 0);
        if ( Var )
        {
          allocFmtString((int *)&v10, 256, (int)"%s %s", Var, v6);
          websSetVar(a1, i, v10);
          if ( v10 )
          {
            free2(v10);
            v10 = 0;
          }
        }
        else
        {
          websSetVar(a1, i, v6);
        }
      }
      result = strtok(0, "&");
    }
    if ( v3 )
      return free2(v3);
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FCC: using guessed type int   strtok(_DWORD, _DWORD);

//----- (0040A410) --------------------------------------------------------
void   websTimeoutCancel(int a1)
{
  int v2; // $a0

  v2 = *(_DWORD *)(a1 + 236);
  if ( v2 >= 0 )
  {
    websTimeoutUnsched(v2);
    *(_DWORD *)(a1 + 236) = -1;
  }
}

//----- (0040A464) --------------------------------------------------------
int   websSetTimeStamp(int *a1)
{
  int result; // $v0

  result = time(0);
  *a1 = result;
  return result;
}
// 4E9F90: using guessed type int   time(_DWORD);

//----- (0040A4A8) --------------------------------------------------------
int   websWriteComplete(int a1, int a2, int a3)
{
  int v3; // $s1
  int v6; // $s4
  unsigned int v7; // $v1
  unsigned int v8; // $a1
  int v9; // $a0
  int v10; // $v0
  signed int v12; // $a2
  int v13; // $v0
  int v14; // $s0
  int v15; // $v0

  v3 = a3;
  v6 = 0;
  if ( a3 <= 0 )
    return v6;
  while ( 1 )
  {
    v7 = *(_DWORD *)(a1 + 228);
    v8 = v7 >> 7;
    if ( ((v7 >> 10) & 1) == 0 )
      break;
    v9 = *(_DWORD *)(a1 + 188);
    if ( v9 < 0 )
    {
      v8 = v7 >> 7;
      break;
    }
    v10 = write(v9, a2, v3);
    if ( v10 < 0 )
      return -1;
    v3 -= v10;
    v6 += v10;
    a2 += v10;
LABEL_6:
    if ( v3 <= 0 )
      return v6;
  }
  if ( (v8 & 1) == 0 )
  {
    v15 = websSocketWrite(*(_DWORD *)(a1 + 212), a2, v3);
    v14 = v15;
    if ( v15 < 0 )
      return -1;
    v3 -= v15;
    websSocketFlush(*(_DWORD *)(a1 + 212));
    v6 += v14;
    goto LABEL_14;
  }
  v12 = v3;
  if ( v3 >= 513 )
    v12 = 512;
  v13 = websSSLWrite(*(int ***)(a1 + 272), a2, v12);
  v14 = v13;
  if ( v13 >= 0 )
  {
    v3 -= v13;
    websSSLFlush();
    v6 += v14;
LABEL_14:
    a2 += v14;
    goto LABEL_6;
  }
  return -1;
}
// 4EA020: using guessed type int   write(_DWORD, _DWORD, _DWORD);

//----- (0040A61C) --------------------------------------------------------
int websWriteFmt(int a1, int a2, ...)
{
  int v3; // $s0
  int result; // $v0
  int v5; // $s1
  int v6; // $s4
  int v7; // $s2
  int v8; // $v0
  int v9; // $s1
  int v10; // $a0
  int v11; // $v0
  unsigned int v12; // $v1
  signed int v13; // $a2
  int v14; // $v0
  int v15; // $s0
  int v16; // $v0
  int v17; // [sp+18h] [-8h] BYREF
  va_list va; // [sp+40h] [+20h] BYREF

  va_start(va, a2);
  v17 = 0;
  if ( vallocFmtString(&v17, 1024, a2, (int)va) >= 1024 )
    trace(2, (int)"websConnWrite lost data, buffer overflow\n");
  v3 = v17;
  result = 0;
  if ( !v17 )
    return result;
  v5 = strlen(v17);
  v6 = 0;
  v7 = v17;
  if ( v5 <= 0 )
  {
    v8 = 0;
    goto LABEL_6;
  }
  while ( 1 )
  {
    while ( 1 )
    {
      v12 = *(_DWORD *)(a1 + 228);
      if ( ((v12 >> 10) & 1) == 0 )
        break;
      v10 = *(_DWORD *)(a1 + 188);
      if ( v10 < 0 )
        break;
      v11 = write(v10, v7, v5);
      if ( v11 < 0 )
        goto LABEL_21;
      v5 -= v11;
      v6 += v11;
      v7 += v11;
      if ( v5 <= 0 )
      {
LABEL_18:
        v3 = v17;
        v8 = v6;
        goto LABEL_6;
      }
    }
    if ( ((v12 >> 7) & 1) != 0 )
      break;
    v16 = websSocketWrite(*(_DWORD *)(a1 + 212), v7, v5);
    v15 = v16;
    if ( v16 < 0 )
      goto LABEL_21;
    v5 -= v16;
    websSocketFlush(*(_DWORD *)(a1 + 212));
    v6 += v15;
LABEL_17:
    v7 += v15;
    if ( v5 <= 0 )
      goto LABEL_18;
  }
  v13 = v5;
  if ( v5 >= 513 )
    v13 = 512;
  v14 = websSSLWrite(*(int ***)(a1 + 272), v7, v13);
  v15 = v14;
  if ( v14 >= 0 )
  {
    v5 -= v14;
    websSSLFlush();
    v6 += v15;
    goto LABEL_17;
  }
LABEL_21:
  v3 = v17;
  v8 = -1;
LABEL_6:
  v9 = v8;
  free2(v3);
  return v9;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4EA020: using guessed type int   write(_DWORD, _DWORD, _DWORD);

//----- (0040A810) --------------------------------------------------------
int   websWritePartial(int a1, int a2, signed int a3)
{
  unsigned int v3; // $a3
  int v5; // $a0
  int v7; // $s0

  v3 = *(_DWORD *)(a1 + 228);
  if ( ((v3 >> 10) & 1) != 0 )
  {
    v5 = *(_DWORD *)(a1 + 188);
    if ( *(int *)(a1 + 188) >= 0 )
      return write(v5, a2, a3);
  }
  if ( ((v3 >> 7) & 1) != 0 )
  {
    v7 = websSSLWrite(*(int ***)(a1 + 272), a2, a3);
    ((void (  *)(int))websSSLFlush)(*(_DWORD *)(a1 + 272));
  }
  else
  {
    v7 = websSocketWrite(*(_DWORD *)(a1 + 212), a2, a3);
    websSocketFlush(*(_DWORD *)(a1 + 212));
  }
  return v7;
}
// 4EA020: using guessed type int   write(_DWORD, _DWORD, _DWORD);

//----- (0040A90C) --------------------------------------------------------
int   websConnAlloc(int a1)
{
  int v2; // $v0
  int v3; // $a2
  int v4; // $a3
  int v5; // $a0
  _DWORD *v6; // $v0

  v2 = AllocEntry(&websConnList, &websConnLast, 340);
  v3 = v2;
  v4 = 4 * v2;
  if ( v2 < 0 )
  {
    trace(16, (int)"webs connection slot full!\n", v2, v4);
    return -1;
  }
  else
  {
    v5 = v2;
    v6 = *(_DWORD **)(v4 + websConnList);
    v6[53] = a1;
    v6[63] = v3;
    v6[56] = 1;
    v6[64] = -1;
    v6[59] = -1;
    v6[34] = 0;
    v6[35] = 0;
    v6[36] = 0;
    v6[37] = 0;
    v6[38] = 0;
    v6[39] = 0;
    v6[40] = 0;
    v6[41] = 0;
    v6[44] = 0;
    v6[43] = 0;
    v6[42] = 0;
    v6[48] = 0;
    v6[49] = 0;
    v6[75] = 0;
    v6[76] = 0;
    v6[77] = 0;
    v6[78] = 0;
    v6[79] = 0;
    v6[80] = 0;
    v6[81] = 0;
    v6[82] = 0;
    v6[33] = 0;
    v6[45] = 0;
    v6[60] = 0;
    v6[61] = 0;
    v6[46] = 0;
    v6[47] = -1;
    v6[74] = 1;
    v6[62] = 0;
    v6[50] = 0;
    v6[51] = 0;
    v6[52] = 0;
    v6[68] = 0;
    v6[83] = 0;
    v6[84] = 0;
    v6[69] = 0;
    v6[70] = 0;
    v6[71] = 0;
    v6[72] = 0;
    v6[73] = 0;
  }
  return v5;
}
// 4E34CC: using guessed type int websConnLast;
// 4E7CA4: using guessed type int websConnList;

//----- (0040AA60) --------------------------------------------------------
int   websAccept(int a1, int a2, int a3, int a4)
{
  int v6; // $v0
  int v8; // $t1
  _DWORD *v9; // $t2
  int v10; // $s1
  unsigned int v11; // $v0
  int v12; // $v0
  int v13; // $v1
  int v14; // $v0
  int v15; // $s0
  _BYTE v17[4]; // [sp+18h] [-18h] BYREF
  int v18; // [sp+1Ch] [-14h]
  int v19; // [sp+28h] [-8h] BYREF

  v6 = AllocEntry(&websConnList, &websConnLast, 340);
  v8 = 4 * v6;
  if ( v6 < 0 )
  {
    trace(16, (int)"webs connection slot full!\n");
    return -1;
  }
  else
  {
    v9 = *(_DWORD **)(v8 + websConnList);
    v9[63] = v6;
    v9[53] = a1;
    v9[56] = 1;
    v9[64] = -1;
    v9[59] = -1;
    v9[34] = 0;
    v9[35] = 0;
    v9[36] = 0;
    v9[37] = 0;
    v9[38] = 0;
    v9[39] = 0;
    v9[40] = 0;
    v9[41] = 0;
    v9[44] = 0;
    v9[43] = 0;
    v9[42] = 0;
    v9[48] = 0;
    v9[49] = 0;
    v9[75] = 0;
    v9[76] = 0;
    v9[77] = 0;
    v9[78] = 0;
    v9[79] = 0;
    v9[80] = 0;
    v9[81] = 0;
    v9[82] = 0;
    v9[33] = 0;
    v9[45] = 0;
    v9[60] = 0;
    v9[61] = 0;
    v9[46] = 0;
    v9[47] = -1;
    v9[74] = 1;
    v9[62] = 0;
    v9[50] = 0;
    v9[51] = 0;
    v9[52] = 0;
    v9[68] = 0;
    v9[83] = 0;
    v9[84] = 0;
    v9[69] = 0;
    v9[70] = 0;
    v9[71] = 0;
    v9[72] = 0;
    v9[73] = 0;
    v10 = *(_DWORD *)(v8 + websConnList);
    *(_DWORD *)(v10 + 216) = a4;
    v11 = strlen(a2) + 1;
    if ( v11 >= 0x21 )
      v11 = 32;
    memcpy(v10 + 4, a2, v11);
    v19 = 16;
    v12 = getsockname(*(_DWORD *)(*(_DWORD *)(4 * a1 + socketList) + 112), v17, &v19);
    v13 = -1;
    if ( v12 >= 0 )
    {
      v15 = inet_ntoa(v18);
      v14 = strlen(v15);
      strncpy(v10 + 36, v15, v14);
      if ( !strcmp(v10 + 4, "127.0.0.1") || !strcmp(v10 + 4, &websSrvIpAddr) || !strcmp(v10 + 4, &websSrvHostName) )
        *(_DWORD *)(v10 + 228) |= 4u;
      websSocketCreateEvent(a1, 2, (int)websSocketEvent, v10);
      *(_DWORD *)(v10 + 236) = websTimeoutSched(60, (int)websTimeout, v10);
      trace(1, (int)"accept request(%s, %s)\n", (char *)(v10 + 36), (char *)(v10 + 4));
      return 0;
    }
    return v13;
  }
}
// 4E34CC: using guessed type int websConnLast;
// 4E7CA4: using guessed type int websConnList;
// 4E7CAC: using guessed type char websSrvHostName;
// 4E7CCC: using guessed type char websSrvIpAddr;
// 4E7CF4: using guessed type int socketList;
// 4E9EEC: using guessed type int   getsockname(_DWORD, _DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F94: using guessed type int   inet_ntoa(_DWORD);
// 4E9FD8: using guessed type int   strncpy(_DWORD, _DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0040AD88) --------------------------------------------------------
int *  websConnFree(int a1)
{
  int v2; // $a1
  _DWORD *v3; // $v1
  int *result; // $v0
  int v6; // $s2
  int v7; // $s3
  int v8; // $a0
  int v9; // $a0
  unsigned int v10; // $v1
  int v11; // $a2
  int v12; // $a0
  int v13; // $a0
  int v14; // $a0
  int v15; // $a0
  int v16; // $a0
  int v17; // $a0
  int v18; // $a0
  int v19; // $a0
  int v20; // $a0
  int v21; // $a0
  int v22; // $a0
  int v23; // $a0
  int v24; // $a0
  int v25; // $a0
  int v26; // $a0
  int v27; // $a0
  int v28; // $a0
  int v29; // $a0
  int v30; // $a0
  int v31; // $a0
  int v32; // $a0
  int v33; // $a0
  int v34; // $a0
  int v35; // $v0
  _DWORD *v36; // $v0
  char *v37; // $v0
  _DWORD *v38; // $v0
  char *v39; // $v0
  int v40; // $a0
  int v41; // $a1

  v2 = 0;
  if ( websConnLast < 0 )
    return trace(16, (int)"websFree=(%s)!\n", "Null wp");
  v3 = (_DWORD *)websConnList;
  while ( 1 )
  {
    ++v2;
    if ( *v3++ == a1 )
      break;
    if ( websConnLast < v2 )
      return trace(16, (int)"websFree=(%s)!\n", "Null wp");
  }
  v6 = *(_DWORD *)(a1 + 288);
  v7 = *(_DWORD *)(a1 + 296);
  websConnLast = FreeEntryId(&websConnList, *(_DWORD *)(a1 + 252));
  v8 = *(_DWORD *)(a1 + 180);
  if ( v8 && !access(v8, 4) && ((*(_DWORD *)(a1 + 228) >> 6) & 1) == 0 && remove(*(_DWORD *)(a1 + 180)) < 0 )
  {
    v38 = (_DWORD *)_errno_location();
    v39 = (char *)strerror(*v38);
    trace(16, (int)"websConnFree remove(%s,%s)\n", *(char **)(a1 + 180), v39);
  }
  v9 = *(_DWORD *)(a1 + 184);
  if ( v9 && !access(v9, 4) && remove(*(_DWORD *)(a1 + 184)) < 0 )
  {
    v36 = (_DWORD *)_errno_location();
    v37 = (char *)strerror(*v36);
    trace(16, (int)"websConnFree remove(%s,%s)\n", *(char **)(a1 + 184), v37);
  }
  v10 = *(_DWORD *)(a1 + 228);
  if ( ((v10 >> 14) & 1) != 0 || (v11 = v10 >> 15, ((v10 >> 23) & 1) != 0) )
  {
    v35 = nvram_bufget(0, "LastDownloadStatus");
    if ( atoi(v35) != 1 )
      doSystem((int)"sleep 3 && /mydlink/opt.local start &");
    --LockCriticalCMD;
    v11 = *(_DWORD *)(a1 + 228) >> 15;
  }
  if ( (v11 & 1) != 0 )
    --LockCriticalCMD;
  v12 = *(_DWORD *)(a1 + 136);
  if ( v12 )
  {
    free2(v12);
    *(_DWORD *)(a1 + 136) = 0;
  }
  v13 = *(_DWORD *)(a1 + 140);
  if ( v13 )
  {
    free2(v13);
    *(_DWORD *)(a1 + 140) = 0;
  }
  v14 = *(_DWORD *)(a1 + 144);
  if ( v14 )
  {
    free2(v14);
    *(_DWORD *)(a1 + 144) = 0;
  }
  v15 = *(_DWORD *)(a1 + 148);
  if ( v15 )
  {
    free2(v15);
    *(_DWORD *)(a1 + 148) = 0;
  }
  v16 = *(_DWORD *)(a1 + 152);
  if ( v16 )
  {
    free2(v16);
    *(_DWORD *)(a1 + 152) = 0;
  }
  v17 = *(_DWORD *)(a1 + 156);
  if ( v17 )
  {
    free2(v17);
    *(_DWORD *)(a1 + 156) = 0;
  }
  v18 = *(_DWORD *)(a1 + 160);
  if ( v18 )
  {
    free2(v18);
    *(_DWORD *)(a1 + 160) = 0;
  }
  v19 = *(_DWORD *)(a1 + 164);
  if ( v19 )
  {
    free2(v19);
    *(_DWORD *)(a1 + 164) = 0;
  }
  v20 = *(_DWORD *)(a1 + 168);
  if ( v20 )
  {
    free2(v20);
    *(_DWORD *)(a1 + 168) = 0;
  }
  v21 = *(_DWORD *)(a1 + 172);
  if ( v21 )
  {
    free2(v21);
    *(_DWORD *)(a1 + 172) = 0;
  }
  v22 = *(_DWORD *)(a1 + 176);
  if ( v22 )
  {
    free2(v22);
    *(_DWORD *)(a1 + 176) = 0;
  }
  v23 = *(_DWORD *)(a1 + 180);
  if ( v23 )
  {
    free2(v23);
    *(_DWORD *)(a1 + 180) = 0;
  }
  v24 = *(_DWORD *)(a1 + 184);
  if ( v24 )
  {
    free2(v24);
    *(_DWORD *)(a1 + 184) = 0;
  }
  v25 = *(_DWORD *)(a1 + 332);
  if ( v25 )
  {
    free2(v25);
    *(_DWORD *)(a1 + 332) = 0;
  }
  v26 = *(_DWORD *)(a1 + 336);
  if ( v26 )
  {
    free2(v26);
    *(_DWORD *)(a1 + 336) = 0;
  }
  v27 = *(_DWORD *)(a1 + 300);
  if ( v27 )
  {
    free2(v27);
    *(_DWORD *)(a1 + 300) = 0;
  }
  v28 = *(_DWORD *)(a1 + 312);
  if ( v28 )
  {
    free2(v28);
    *(_DWORD *)(a1 + 312) = 0;
  }
  v29 = *(_DWORD *)(a1 + 308);
  if ( v29 )
  {
    free2(v29);
    *(_DWORD *)(a1 + 308) = 0;
  }
  v30 = *(_DWORD *)(a1 + 304);
  if ( v30 )
  {
    free2(v30);
    *(_DWORD *)(a1 + 304) = 0;
  }
  v31 = *(_DWORD *)(a1 + 316);
  if ( v31 )
  {
    free2(v31);
    *(_DWORD *)(a1 + 316) = 0;
  }
  v32 = *(_DWORD *)(a1 + 320);
  if ( v32 )
  {
    free2(v32);
    *(_DWORD *)(a1 + 320) = 0;
  }
  v33 = *(_DWORD *)(a1 + 324);
  if ( v33 )
  {
    free2(v33);
    *(_DWORD *)(a1 + 324) = 0;
  }
  v34 = *(_DWORD *)(a1 + 328);
  if ( v34 )
  {
    free2(v34);
    *(_DWORD *)(a1 + 328) = 0;
  }
  websSSLFree(*(int ***)(a1 + 272));
  *(_DWORD *)(a1 + 272) = 0;
  result = (int *)websCloseVar(a1);
  if ( a1 )
    result = (int *)free2(a1);
  if ( v6 <= 0 )
  {
    if ( LockCriticalCMD <= 0 && PendRebootCMD > 0 )
    {
      ++LockCriticalCMD;
      result = (int *)getSysInfoShort(65);
      if ( result != (int *)2 )
      {
        doSystem((int)"sleep %d && reboot &", PendRebootCMD);
        v40 = v6;
        v41 = PendRebootMode;
        return (int *)set_reboot_time(v40, v41);
      }
    }
  }
  else
  {
    result = (int *)LockCriticalCMD;
    if ( LockCriticalCMD > 0 )
    {
      PendRebootCMD = v6;
      PendRebootMode = v7;
      return result;
    }
    ++LockCriticalCMD;
    result = (int *)getSysInfoShort(65);
    if ( result != (int *)2 )
    {
      doSystem((int)"sleep %d && reboot &", v6);
      v40 = v6;
      v41 = v7;
      return (int *)set_reboot_time(v40, v41);
    }
  }
  return result;
}
// 4E34C0: using guessed type int PendRebootMode;
// 4E34C4: using guessed type int PendRebootCMD;
// 4E34C8: using guessed type int LockCriticalCMD;
// 4E34CC: using guessed type int websConnLast;
// 4E7CA4: using guessed type int websConnList;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F40: using guessed type int _errno_location(void);
// 4E9F50: using guessed type int   access(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA064: using guessed type int   remove(_DWORD);
// 4EA0AC: using guessed type int   strerror(_DWORD);

//----- (0040B5BC) --------------------------------------------------------
int *  websConnClose(int a1, int a2)
{
  int v4; // $a1
  _DWORD *v5; // $v1
  int v8; // $a0
  int v9; // $a0
  int v10; // $a0
  int v11; // $a0
  int v12; // $a0
  int v13; // $v0
  int v14; // $s4
  int v15; // $v0
  int v16; // $s5
  int v17; // $s6
  int v18; // $fp
  int v19; // $s2
  int v20; // $s3
  unsigned int v21; // $v1
  int v22; // $a0
  int v23; // $v0
  int v24; // $s2
  int v25; // $s3
  unsigned int v26; // $v1
  int v27; // $a0
  int v28; // $v0
  signed int v29; // $a2
  int v30; // $v0
  int v31; // $s1
  signed int v32; // $a2
  int v33; // $v0
  int v34; // $s1
  int v35; // $v0
  int v36; // $s1
  int v37; // $v0
  int v38; // $s1
  _DWORD *v39; // $v0
  char *v40; // $v0
  _BYTE v41[56]; // [sp+20h] [-98h] BYREF
  int v42; // [sp+58h] [-60h]

  v4 = 0;
  if ( websConnLast < 0 )
    return trace(16, (int)"websConnClose=(%d,%s)!\n", a2, "Null wp");
  v5 = (_DWORD *)websConnList;
  while ( 1 )
  {
    ++v4;
    if ( *v5++ == a1 )
      break;
    if ( websConnLast < v4 )
      return trace(16, (int)"websConnClose=(%d,%s)!\n", a2, "Null wp");
  }
  if ( !*(_DWORD *)(a1 + 136) && a2 == 910 )
    return trace(16, (int)"websConnClose=(%d, wp->path == NULL)!\n", 910);
  if ( ((*(_DWORD *)(a1 + 228) >> 10) & 1) != 0 && *(int *)(a1 + 188) >= 0 )
  {
    websTimeoutResched(*(_DWORD *)(a1 + 236), 60);
    v8 = *(_DWORD *)(a1 + 188);
    if ( v8 >= 0 )
    {
      close(v8);
      *(_DWORD *)(a1 + 188) = -1;
    }
    v9 = *(_DWORD *)(a1 + 184);
    *(_DWORD *)(a1 + 228) &= ~0x400u;
    if ( v9 )
    {
      v13 = open(v9, 0);
      v14 = v13;
      if ( v13 >= 0 )
      {
        if ( fstat(v13, v41) < 0 )
        {
          v39 = (_DWORD *)_errno_location();
          v40 = (char *)strerror(*v39);
          trace(1, (int)"Can't stat %s: %s\n", *(char **)(a1 + 184), v40);
        }
        else
        {
          v16 = mmap(0, v42, 1, 1, v14, 0);
          v15 = strstr(v16, "\r\n\r\n");
          v17 = v42;
          v18 = v15 + 4;
          if ( v15 )
          {
            v19 = v15 - v16;
            v20 = v16;
            while ( v19 > 0 )
            {
              v21 = *(_DWORD *)(a1 + 228);
              if ( ((v21 >> 10) & 1) != 0 && (v22 = *(_DWORD *)(a1 + 188), v22 >= 0) )
              {
                v23 = write(v22, v20, v19);
                if ( v23 < 0 )
                  break;
                v19 -= v23;
                v20 += v23;
              }
              else if ( ((v21 >> 7) & 1) != 0 )
              {
                v32 = v19;
                if ( v19 >= 513 )
                  v32 = 512;
                v33 = websSSLWrite(*(int ***)(a1 + 272), v20, v32);
                v34 = v33;
                if ( v33 < 0 )
                  break;
                v19 -= v33;
                websSSLFlush();
                v20 += v34;
              }
              else
              {
                v35 = websSocketWrite(*(_DWORD *)(a1 + 212), v20, v19);
                v36 = v35;
                if ( v35 < 0 )
                  break;
                v19 -= v35;
                websSocketFlush(*(_DWORD *)(a1 + 212));
                v20 += v36;
              }
            }
            websWriteFmt(a1, (int)"\r\nContent-length: %d\r\n\r\n", v17 - (v18 - v16));
            v24 = v17 - (v18 - v16);
            v25 = v18;
            while ( v24 > 0 )
            {
              v26 = *(_DWORD *)(a1 + 228);
              if ( ((v26 >> 10) & 1) != 0 && (v27 = *(_DWORD *)(a1 + 188), v27 >= 0) )
              {
                v28 = write(v27, v25, v24);
                if ( v28 < 0 )
                  break;
                v24 -= v28;
                v25 += v28;
              }
              else if ( ((v26 >> 7) & 1) != 0 )
              {
                v29 = v24;
                if ( v24 >= 513 )
                  v29 = 512;
                v30 = websSSLWrite(*(int ***)(a1 + 272), v25, v29);
                v31 = v30;
                if ( v30 < 0 )
                  break;
                v24 -= v30;
                websSSLFlush();
                v25 += v31;
              }
              else
              {
                v37 = websSocketWrite(*(_DWORD *)(a1 + 212), v25, v24);
                v38 = v37;
                if ( v37 < 0 )
                  break;
                v24 -= v37;
                websSocketFlush(*(_DWORD *)(a1 + 212));
                v25 += v38;
              }
            }
          }
          munmap(v16, v17);
        }
        close(v14);
      }
    }
  }
  v10 = *(_DWORD *)(a1 + 236);
  if ( v10 >= 0 )
  {
    websTimeoutUnsched(v10);
    *(_DWORD *)(a1 + 236) = -1;
  }
  trace(1, (int)"websConnClose(%s)!\n", *(char **)(a1 + 136));
  websSocketDeleteEvent(*(_DWORD *)(a1 + 212));
  v11 = *(_DWORD *)(a1 + 256);
  if ( v11 >= 0 )
  {
    close(v11);
    *(_DWORD *)(a1 + 256) = -1;
  }
  v12 = *(_DWORD *)(a1 + 188);
  if ( v12 >= 0 )
  {
    close(v12);
    *(_DWORD *)(a1 + 188) = -1;
  }
  if ( *(unsigned __int8 *)(a1 + 228) >> 7 )
  {
    websSSLFlush();
    webssslWriteClosureAlert(*(_DWORD ****)(a1 + 272));
  }
  else
  {
    websSocketSetBlock(*(_DWORD *)(a1 + 212), 1);
    websSocketFlush(*(_DWORD *)(a1 + 212));
  }
  websSocketCloseConnection(*(_DWORD *)(a1 + 212));
  return websConnFree(a1);
}
// 4E34CC: using guessed type int websConnLast;
// 4E7CA4: using guessed type int websConnList;
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9F40: using guessed type int _errno_location(void);
// 4E9FEC: using guessed type int   strstr(_DWORD, _DWORD);
// 4EA018: using guessed type int   fstat(_DWORD, _DWORD);
// 4EA020: using guessed type int   write(_DWORD, _DWORD, _DWORD);
// 4EA048: using guessed type int   mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4EA0A0: using guessed type int   munmap(_DWORD, _DWORD);
// 4EA0AC: using guessed type int   strerror(_DWORD);

//----- (0040BBB0) --------------------------------------------------------
int *  websTimeout(_DWORD *a1, int a2)
{
  int v4; // $v1

  v4 = time(0) - *a1;
  if ( v4 < 60 )
    return (int *)websTimeoutResched(a2, 60 - v4);
  trace(1, (int)"websTimeout!\n");
  websTimeoutUnsched(a2);
  a1[59] = -1;
  return websConnClose((int)a1, 910);
}
// 4E9F90: using guessed type int   time(_DWORD);

//----- (0040BC80) --------------------------------------------------------
_DWORD *websShutdownServer()
{
  _DWORD *result; // $v0
  int v1; // $v1
  int v2; // $s1
  int v3; // $t0
  int v4; // $s0

  result = (_DWORD *)--dword_4E35D0;
  if ( dword_4E35D0 <= 0 )
  {
    if ( dword_4E7CEC >= 0 )
    {
      websSocketCloseConnection(dword_4E7CEC);
      dword_4E7CEC = -1;
    }
    v1 = websConnList;
    v2 = websConnLast;
    if ( websConnList && websConnLast >= 0 )
    {
      v3 = 4 * websConnLast;
      do
      {
        v4 = *(_DWORD *)(v3 + v1);
        --v2;
        if ( v4 )
        {
          websSocketCloseConnection(*(_DWORD *)(v4 + 212));
          websConnFree(v4);
        }
        v1 = websConnList;
        if ( !websConnList )
          break;
        v3 = 4 * v2;
      }
      while ( v2 >= 0 );
    }
    return websSocketClose();
  }
  return result;
}
// 4E34CC: using guessed type int websConnLast;
// 4E35D0: using guessed type int dword_4E35D0;
// 4E7CA4: using guessed type int websConnList;
// 4E7CEC: using guessed type int dword_4E7CEC;

//----- (0040BDA8) --------------------------------------------------------
char *  websCommonWriteHeader(int a1, int a2, int a3, char *a4, int a5)
{
  int *v8; // $v0
  int v9; // $v1
  void *v10; // $a3
  char *result; // $v0
  char *v12; // $s0
  char *v13; // $s0
  int *v14; // $v0
  int v15; // $v1
  int v16; // $v1
  int v17; // [sp+18h] [-8h] BYREF

  if ( a2 == 204 )
    goto LABEL_29;
  if ( a2 < 205 )
  {
    if ( a2 != 200 )
      goto LABEL_4;
LABEL_29:
    v8 = &websConnErrors;
    v16 = websConnErrors;
    if ( websConnErrors )
    {
      while ( v16 != a2 )
      {
        v8 += 2;
        v16 = *v8;
        if ( !*v8 )
        {
          v10 = &unk_4A2DDC;
          goto LABEL_8;
        }
      }
      goto LABEL_35;
    }
LABEL_7:
    v10 = &unk_4A2DDC;
LABEL_8:
    websWriteFmt(a1, (int)"HTTP/1.0 %d %s\r\n", a2, v10);
    goto LABEL_9;
  }
  if ( a2 != 403 )
  {
LABEL_4:
    v8 = &websConnErrors;
    v9 = websConnErrors;
    if ( websConnErrors )
    {
      while ( v9 != a2 )
      {
        v8 += 2;
        v9 = *v8;
        if ( !*v8 )
          goto LABEL_7;
      }
LABEL_35:
      v10 = (void *)v8[1];
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  v14 = &websConnErrors;
  v15 = websConnErrors;
  if ( websConnErrors )
  {
    while ( v15 != 403 )
    {
      v14 += 2;
      v15 = *v14;
      if ( !*v14 )
        goto LABEL_28;
    }
    websWriteFmt(a1, (int)"HTTP/1.1 %d %s\r\n", 403, v14[1]);
  }
  else
  {
LABEL_28:
    websWriteFmt(a1, (int)"HTTP/1.1 %d %s\r\n", 403, &unk_4A2DDC);
  }
LABEL_9:
  websWriteFmt(a1, (int)"Server: %s/%s\r\n", "alphapd", "2.1.8");
  if ( a5 )
    v17 = *(_DWORD *)(a5 + 72);
  else
    time(&v17);
  result = (char *)ctime(&v17);
  v12 = (char *)result;
  if ( result )
  {
    result[strlen(result) - 1] = 0;
    result = (char *)strdupWithoutNull(v12);
    v13 = result;
    if ( result )
    {
      websWriteFmt(a1, (int)"Date: %s\r\n", result);
      if ( a5 && a3 > 0 )
        websWriteFmt(a1, (int)"Last-modified: %s\r\n", v13);
      result = (char *)free2(v13);
    }
  }
  if ( !a5 || a3 <= 0 )
  {
    if ( *(unsigned __int8 *)(a1 + 228) >> 7 )
      result = (char *)websWriteFmt(a1, (int)"Cache-Control: no-cache\r\n");
    else
      result = (char *)websWriteFmt(a1, (int)"Pragma: no-cache\r\nCache-Control: no-cache\r\n");
  }
  if ( a4 )
    result = (char *)websWriteFmt(a1, (int)"Content-type: %s\r\n", a4);
  if ( a3 > 0 )
    return (char *)websWriteFmt(a1, (int)"Content-length: %d\r\n", a3);
  return result;
}
// 4E3430: using guessed type int websConnErrors;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F90: using guessed type int   time(_DWORD);
// 4EA010: using guessed type int   ctime(_DWORD);

//----- (0040C0E0) --------------------------------------------------------
char *  websGetRealm(int a1)
{
  int v1; // $a0
  char *v2; // $a1

  v1 = *(_DWORD *)(a1 + 196);
  v2 = aNipca;
  if ( v1 != 2 && v1 != 5 )
  {
    v2 = aNipca;
    if ( v1 != 3 && v1 != 6 )
      return aWebs;
  }
  return v2;
}

//----- (0040C138) --------------------------------------------------------
int   websWriteNormalHeader(int a1, int a2, int a3, char *a4, int a5)
{
  unsigned int v5; // $v1
  int result; // $v0
  int v9; // $v1
  char *v10; // $s2
  int AuthenticateRealm; // $v1
  char *DigestNonce; // $s0

  v5 = *(_DWORD *)(a1 + 228);
  result = (v5 >> 9) & 1;
  if ( !result )
  {
    *(_DWORD *)(a1 + 228) = v5 | 0x200;
    websCommonWriteHeader(a1, a2, a3, a4, a5);
    if ( a2 == 401 )
    {
      v9 = *(_DWORD *)(a1 + 196);
      if ( v9 == 2 || v9 == 5 || v9 == 3 || v9 == 6 )
        v10 = aNipca;
      else
        v10 = aWebs;
      AuthenticateRealm = websGetAuthenticateRealm(a1);
      if ( !AuthenticateRealm )
        AuthenticateRealm = ((*(_DWORD *)(a1 + 228) >> 13) & 1) != 0;
      if ( AuthenticateRealm == 1 )
      {
        DigestNonce = (char *)websGetDigestNonce(a1);
        websWriteFmt(
          a1,
          (int)"WWW-Authenticate: Digest realm=\"%s\",qop=\"%s\", nonce=\"%s\"\r\n",
          v10,
          "auth",
          DigestNonce);
        free2(DigestNonce);
      }
      else
      {
        websWriteFmt(a1, (int)"WWW-Authenticate: Basic realm=\"%s\"\r\n", v10);
      }
    }
    return websWriteFmt(a1, (int)WebCRLF);
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (0040C2DC) --------------------------------------------------------
int *  websConnResponse(_DWORD *a1, int a2, char *a3)
{
  int v6; // $a0
  int v7; // $a0
  int v8; // $a2
  int v10; // $a0
  _DWORD *v11; // $v0
  char *v12; // $v0

  if ( ((a1[57] >> 10) & 1) != 0 )
  {
    v6 = a1[47];
    if ( v6 >= 0 )
    {
      close(v6);
      v7 = a1[46];
      a1[47] = -1;
      if ( v7 )
      {
        if ( !access(v7, 4) && remove(a1[46]) < 0 )
        {
          v11 = (_DWORD *)_errno_location();
          v12 = (char *)strerror(*v11);
          trace(16, (int)"websConnFree remove(%s,%s)\n", (char *)a1[46], v12);
        }
        v10 = a1[46];
        if ( v10 )
        {
          free2(v10);
          a1[46] = 0;
        }
      }
      a1[57] &= 0xFFFFF9FF;
    }
  }
  if ( a3 )
  {
    v8 = strlen(a3);
    websWriteNormalHeader((int)a1, a2, v8, "text/html", 0);
  }
  else
  {
    websWriteNormalHeader((int)a1, a2, 0, "text/html", 0);
  }
  if ( (((a1[57] >> 1) ^ 1) & 1) == 0 || !a3 || !*a3 )
    return websConnClose((int)a1, a2);
  websWriteFmt((int)a1, (int)"%s\r\n", a3);
  return websConnClose((int)a1, a2);
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F40: using guessed type int _errno_location(void);
// 4E9F50: using guessed type int   access(_DWORD, _DWORD);
// 4EA064: using guessed type int   remove(_DWORD);
// 4EA0AC: using guessed type int   strerror(_DWORD);

//----- (0040C514) --------------------------------------------------------
int *websConnError(int a1, int a2, int a3, ...)
{
  int v6; // $a1
  _DWORD *v7; // $v1
  int *result; // $v0
  int v10; // $v0
  int v11; // $a0
  int v12; // $s1
  char *v13; // $s1
  int *v14; // $v0
  int v15; // $v1
  char *v16; // $a3
  int *v17; // $v0
  int v18; // $v1
  void *v19; // $a3
  char *v20; // [sp+20h] [-8h] BYREF
  char *v21; // [sp+24h] [-4h] BYREF
  va_list va; // [sp+4Ch] [+24h] BYREF

  va_start(va, a3);
  v6 = 0;
  if ( websConnLast < 0 )
    return trace(16, (int)"websConnError=(%d,%s)!\n", a2, "Null wp");
  v7 = (_DWORD *)websConnList;
  while ( 1 )
  {
    ++v6;
    if ( *v7++ == a1 )
      break;
    if ( websConnLast < v6 )
      return trace(16, (int)"websConnError=(%d,%s)!\n", a2, "Null wp");
  }
  v10 = websSafeUrl(*(char **)(a1 + 140));
  v11 = *(_DWORD *)(a1 + 140);
  v12 = v10;
  if ( v11 )
    free2(v11);
  *(_DWORD *)(a1 + 140) = v12;
  v20 = 0;
  vallocFmtString((int *)&v20, 1024, a3, (int)va);
  v13 = (char *)websSafeUrl(v20);
  if ( v20 )
    free2(v20);
  v20 = v13;
  trace(1, (int)"websConnError=(%d,%s)!\n", a2, v13);
  v21 = 0;
  if ( a2 == 403 )
  {
    v17 = &websConnErrors;
    v18 = websConnErrors;
    if ( websConnErrors )
    {
      while ( v18 != 403 )
      {
        v17 += 2;
        v18 = *v17;
        if ( !*v17 )
          goto LABEL_24;
      }
      v19 = (void *)v17[1];
    }
    else
    {
LABEL_24:
      v19 = &unk_4A2DDC;
    }
    allocFmtString((int *)&v21, 1024, (int)"<html><body><h1>The request is forbidden.</h1></body></html>\r\n", v19);
  }
  else
  {
    v14 = &websConnErrors;
    v15 = websConnErrors;
    if ( websConnErrors )
    {
      while ( v15 != a2 )
      {
        v14 += 2;
        v15 = *v14;
        if ( !*v14 )
          goto LABEL_15;
      }
      v16 = (char *)v14[1];
    }
    else
    {
LABEL_15:
      v16 = (char *)&unk_4A2DDC;
    }
    allocFmtString((int *)&v21, 1024, (int)"<html><body><h2>Error: %s</h2>\r\n<p>%s</p></body></html>\r\n", v16, v20);
  }
  result = websConnResponse((_DWORD *)a1, a2, v21);
  if ( v21 )
  {
    result = (int *)free2(v21);
    v21 = 0;
  }
  if ( v20 )
  {
    result = (int *)free2(v20);
    v20 = 0;
  }
  return result;
}
// 4E3430: using guessed type int websConnErrors;
// 4E34CC: using guessed type int websConnLast;
// 4E7CA4: using guessed type int websConnList;
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (0040C7E0) --------------------------------------------------------
int   sub_40C7E0(int a1, char *a2)
{
  char *v4; // $v0
  char *v5; // $s0
  int v6; // $v0
  char *v7; // $v0
  char *v8; // $s1
  void *v9; // $s0
  int v10; // $v0
  char *v11; // $a0
  int v12; // $v0
  _BYTE *v13; // $a0
  _BYTE *v14; // $v0
  int v15; // $v0
  int v16; // $a0
  int Port; // $v0
  char *v18; // $s0
  int v19; // $s0
  int v20; // $s1
  int v21; // $v0
  int v22; // $t0
  int v23; // $v0
  int v24; // $t8
  int v25; // $s3
  char *v27; // $a2
  _DWORD *v28; // $a3
  int v29; // $t3
  int v30; // $t2
  int v31; // $a0
  int v32; // $t1
  int v33; // $t4
  int v34; // $t0
  int v35; // $s1
  _BYTE *v36; // $s3
  unsigned int v37; // $v1
  int v38; // $a0
  int v39; // $v0
  signed int v40; // $a2
  int v41; // $v0
  int v42; // $s0
  int v43; // $v0
  int v44; // $s0
  int v45; // $v0
  _BYTE v46[96]; // [sp+28h] [-78h] BYREF
  int v47; // [sp+88h] [-18h] BYREF
  char *v48; // [sp+8Ch] [-14h] BYREF
  int v49; // [sp+90h] [-10h] BYREF
  _BYTE *v50; // [sp+94h] [-Ch] BYREF
  int v51; // [sp+98h] [-8h] BYREF

  trace(1, (int)"websParseRequestLine(%s)!\n", a2);
  if ( !strcmp(a2, "<policy-file-request/>") )
  {
    v27 = "<cross-domain-policy><allow-access-from domain=\"*\" to-ports=\"*\" /></cross-domain-policy>";
    v28 = v46;
    do
    {
      v29 = *(_DWORD *)v27;
      v30 = *((_DWORD *)v27 + 1);
      v31 = *((_DWORD *)v27 + 2);
      v32 = *((_DWORD *)v27 + 3);
      v27 += 16;
      *v28 = v29;
      v28[1] = v30;
      v28[2] = v31;
      v28[3] = v32;
      v28 += 4;
    }
    while ( v27 != "-policy>" );
    v33 = *(_DWORD *)v27;
    v34 = *((_DWORD *)v27 + 1);
    *((_WORD *)v28 + 4) = *((_WORD *)v27 + 4);
    *v28 = v33;
    v28[1] = v34;
    v35 = strlen(v46) + 1;
    v36 = v46;
    while ( v35 > 0 )
    {
      v37 = *(_DWORD *)(a1 + 228);
      if ( ((v37 >> 10) & 1) != 0 && (v38 = *(_DWORD *)(a1 + 188), v38 >= 0) )
      {
        v39 = write(v38, v36, v35);
        if ( v39 < 0 )
          return -1;
        v35 -= v39;
        v36 += v39;
      }
      else if ( ((v37 >> 7) & 1) != 0 )
      {
        v40 = v35;
        if ( v35 >= 513 )
          v40 = 512;
        v41 = websSSLWrite(*(int ***)(a1 + 272), (int)v36, v40);
        v42 = v41;
        if ( v41 < 0 )
          return -1;
        v35 -= v41;
        websSSLFlush();
        v36 += v42;
      }
      else
      {
        v43 = websSocketWrite(*(_DWORD *)(a1 + 212), (int)v36, v35);
        v44 = v43;
        if ( v43 < 0 )
          return -1;
        v35 -= v43;
        websSocketFlush(*(_DWORD *)(a1 + 212));
        v36 += v44;
      }
    }
    return -1;
  }
  v4 = (char *)strtok(a2, " \t");
  v5 = v4;
  if ( v4 && *v4 )
  {
    if ( strcmp(v4, "GET") )
    {
      if ( !strcmp(v5, "POST") )
      {
        v6 = *(_DWORD *)(a1 + 228) | 1;
      }
      else
      {
        if ( strcmp(v5, "HEAD") )
        {
          websConnError(a1, 400, (int)"Bad request type(%s)", v5);
          return -1;
        }
        v6 = *(_DWORD *)(a1 + 228) | 2;
      }
      *(_DWORD *)(a1 + 228) = v6;
    }
    websSetVar(a1, "HTTP_REQUEST", v5);
    v7 = (char *)strtok(0, " \t\n");
    v8 = v7;
    if ( v7 )
    {
      if ( *v7 )
      {
        v48 = 0;
        v47 = 0;
        v51 = 0;
        v50 = 0;
        v9 = (void *)strtok(0, " \t\n");
        if ( websParseUrlInfo(v8, &v49, (int *)&v50, &v51, &v47, 0, &v48) < 0 )
        {
          websConnError(a1, 400, (int)"Bad URL format");
          return -1;
        }
        *(_DWORD *)(a1 + 140) = strdupWithoutNull(v8);
        v10 = strchr(v8, 63);
        v11 = byte_4A2DDC;
        if ( v10 )
          v11 = (char *)(v10 + 1);
        v12 = strdupWithoutNull(v11);
        v13 = v50;
        *(_DWORD *)(a1 + 160) = v12;
        v14 = strlower(v13);
        *(_DWORD *)(a1 + 136) = strdupWithoutNull(v14);
        v15 = strdupWithoutNull(v9);
        v16 = *(_DWORD *)(a1 + 216);
        *(_DWORD *)(a1 + 176) = v15;
        Port = websSocketGetPort(v16);
        if ( Port < 0 )
          *(_DWORD *)(a1 + 220) = atoi(v51);
        else
          *(_DWORD *)(a1 + 220) = Port;
        v18 = v48;
        if ( !strcmp(v48, ".cgi") )
          *(_DWORD *)(a1 + 228) |= 0x20u;
        if ( checkASPFile((int)v18) )
          *(_DWORD *)(a1 + 228) |= 8u;
        if ( checkPatchFile(a1) )
          *(_DWORD *)(a1 + 228) |= 0x10u;
        free2(v49);
        websGetUrlType(v8, (char *)(a1 + 68));
        websSetVar(a1, "HTTP_AUTHORIZATION", byte_4A2DDC);
        websConnValidateUrlPath(a1, *(void **)(a1 + 136));
        if ( websReplacePathIntrenal(a1) )
        {
          websConnError(a1, 403, (int)"Forbidden");
          return -1;
        }
        if ( (*(_DWORD *)(a1 + 228) & 1) != 0 && checkCgiPostRequest(a1) )
          *(_DWORD *)(a1 + 228) |= 0x20000u;
        v19 = *(_DWORD *)(a1 + 136);
        if ( !strstr(v19, "/cgi-bin/") )
          goto LABEL_37;
        v20 = *(_DWORD *)(a1 + 228) | 0x40;
        *(_DWORD *)(a1 + 228) = v20;
        v21 = strstr(v19, "upload.cgi");
        v22 = v20 & 1;
        if ( !v21 )
        {
          v45 = strstr(v19, "firmwareupgrade.cgi");
          v22 = v20 & 1;
          if ( !v45 )
            goto LABEL_31;
        }
        if ( !v22 )
        {
          websConnError(a1, 405, (int)"Method Not Allowed.");
          return -1;
        }
        if ( LockCriticalCMD > 0 )
          goto LABEL_64;
        ++LockCriticalCMD;
        v19 = *(_DWORD *)(a1 + 136);
        if ( strstr(v19, "upload.cgi") )
        {
          v23 = *(_DWORD *)(a1 + 228) | 0x4000;
        }
        else
        {
          if ( !strstr(v19, "firmwareupgrade.cgi") )
            goto LABEL_31;
          v23 = *(_DWORD *)(a1 + 228) | 0x800000;
        }
        *(_DWORD *)(a1 + 228) = v23;
LABEL_31:
        if ( !strstr(v19, "upload_settings.cgi") )
        {
          v25 = *(_DWORD *)(a1 + 228) & 1;
LABEL_34:
          if ( v25 )
          {
            if ( !*(_DWORD *)(a1 + 180) )
              *(_DWORD *)(a1 + 180) = websGetTempFileName();
          }
LABEL_37:
          trace(16, (int)"websParseRequestLine\n");
          trace(16, (int)"wp->url = %s\n", *(char **)(a1 + 140));
          trace(16, (int)"wp->query = %s\n", *(char **)(a1 + 160));
          trace(16, (int)"wp->path = %s\n", *(char **)(a1 + 136));
          return 0;
        }
        if ( LockCriticalCMD <= 0 )
        {
          ++LockCriticalCMD;
          v24 = *(_DWORD *)(a1 + 228);
          *(_DWORD *)(a1 + 228) = v24 | 0x8000;
          v25 = v24 & 1;
          goto LABEL_34;
        }
LABEL_64:
        websConnError(a1, 503, (int)"Service Unavailable");
        return -1;
      }
    }
  }
  websConnError(a1, 400, (int)"Bad HTTP request");
  return -1;
}
// 4E34C8: using guessed type int LockCriticalCMD;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FCC: using guessed type int   strtok(_DWORD, _DWORD);
// 4E9FEC: using guessed type int   strstr(_DWORD, _DWORD);
// 4EA020: using guessed type int   write(_DWORD, _DWORD, _DWORD);

//----- (0040D014) --------------------------------------------------------
int   websReadEvent(_DWORD *a1)
{
  int v2; // $fp
  int v3; // $v1
  int v4; // $s2
  int v5; // $a2
  int v6; // $v0
  int v7; // $s0
  int v8; // $s1
  int v9; // $v0
  int v10; // $s0
  int v11; // $a0
  int v12; // $a0
  int result; // $v0
  char *v14; // $v0
  int v15; // $v0
  unsigned int v16; // $v1
  int v17; // $a2
  int v18; // $a3
  BOOL v19; // $s7
  int v20; // $v0
  int v21; // $a2
  unsigned int v22; // $v1
  int v23; // $v0
  char *v24; // $s0
  _BYTE *v25; // $v0
  char *v26; // $s1
  int v27; // $v0
  char *v28; // $a1
  int v29; // $v0
  char *v30; // $v1
  bool v31; // dc
  int v32; // $v0
  int v33; // $v0
  char *v34; // $a1
  char *v35; // $a2
  int v36; // $a0
  unsigned int v37; // $s0
  unsigned int v38; // $s7
  int v39; // $a0
  _BYTE *v40; // $s1
  int v41; // $v0
  int v42; // $s2
  int v43; // $v0
  char *v44; // $a1
  int v45; // $a0
  _BYTE *v46; // $s1
  int v47; // $v0
  int v48; // $t0
  int v49; // $v0
  int v50; // $s0
  int v51; // $v0
  int v52; // $v0
  char *v53; // $s1
  int i; // $v0
  _BYTE *j; // $s4
  int v56; // $s2
  char *v57; // $s5
  int v58; // $a0
  char *v59; // $s0
  char v60; // $a2
  char v61; // $s6
  int v62; // $a0
  char v63; // $a2
  int v64; // $a0
  _BYTE *v65; // $v0
  char *v66; // $s0
  char *v67; // $a0
  int v68; // $v0
  _DWORD *v69; // $v0
  char *v70; // $v0
  int v71; // $t5
  int v72; // $v1
  int v73; // $v1
  _DWORD *v74; // $v0
  char *v75; // $v0
  int v76; // $v0
  int v77; // $v0
  int v78; // $v0
  int v79; // $a0
  int v80; // $a0
  int v81; // $a0
  int v82; // $a0
  int v83; // $a0
  int v84; // $a0
  int v85; // $v0
  int v86; // $s0
  int v87; // $v0
  char *v88; // $a1
  int v89; // $v0
  int v90; // $v0
  int v91; // $a0
  int v92; // $v0
  _BYTE v93[264]; // [sp+18h] [-120h] BYREF
  char *v94; // [sp+120h] [-18h]
  int v95; // [sp+124h] [-14h]
  char *v96; // [sp+128h] [-10h] BYREF
  char *v97; // [sp+12Ch] [-Ch] BYREF
  int v98; // [sp+130h] [-8h]

  *a1 = time(0);
  v94 = 0;
  v98 = -1;
  v2 = 0;
  while ( 1 )
  {
    v3 = a1[56];
    v4 = 1000;
    if ( v3 != 16 )
      break;
LABEL_18:
    switch ( v3 )
    {
      case 1:
        v31 = sub_40C7E0((int)a1, v94) < 0;
        v32 = 2;
        if ( v31 )
          goto LABEL_31;
        goto LABEL_71;
      case 2:
        v24 = v94;
        if ( v94 )
        {
          v25 = (_BYTE *)strchr(v94, 58);
          if ( !v25 )
            goto LABEL_32;
          *v25 = 0;
          v26 = skipSpace(v25 + 1);
          strupper(v24);
          v27 = strlen(v24);
          allocFmtString((int *)&v97, v27 + 6, (int)"HTTP_%s", v24);
          v28 = v97;
          if ( v97 )
          {
            v29 = *v97;
            v30 = v97;
            if ( *v97 )
            {
              do
              {
                if ( v29 == 45 )
                  *v30 = 95;
                v29 = *++v30;
              }
              while ( *v30 );
              v28 = v97;
            }
            websSetVar((int)a1, v28, v26);
            if ( v97 )
            {
              free2(v97);
              v97 = 0;
            }
          }
          if ( !strcmp(v24, "AUTHORIZATION") )
          {
            a1[41] = strdupWithoutNull(v26);
            if ( !strncasecmp(v26, "Basic ", 6) )
            {
              memset(v93, 0, 254);
              a1[57] |= 0x1000u;
              websDecode64((int)v93, v26 + 6, 0xFEu);
              v65 = (_BYTE *)strchr(v93, 58);
              v66 = v65 + 1;
              if ( !v65 || (*v65 = 0, v65 == (_BYTE *)-1) )
              {
                v77 = strdupWithoutNull(byte_4A2DDC);
                v67 = byte_4A2DDC;
                a1[43] = v77;
              }
              else
              {
                a1[43] = strdupWithoutNull(v93);
                v67 = v66;
              }
              a1[42] = strdupWithoutNull(v67);
            }
            v52 = strncasecmp(v26, "Digest ", 7);
            v53 = v26 + 7;
            if ( !v52 )
            {
              a1[57] |= 0x2000u;
              for ( i = strchr(v53, 61); i; i = strchr(v53, 61) )
              {
                for ( j = v53; ; ++j )
                {
                  v56 = (char)*j;
                  if ( (isalpha(2 * v56)) == 0
                    && v56 != 47
                    && v56 != 95
                    && v56 != 46 )
                  {
                    v57 = (char *)(i + 1);
                    if ( v56 != 45 )
                      break;
                  }
                }
                *j = 0;
                while ( 1 )
                {
                  v58 = *v57;
                  if ( (isalpha(2 * v58)) != 0
                    || v58 == 47
                    || v58 == 95
                    || v58 == 46
                    || v58 == 45 )
                  {
                    break;
                  }
                  ++v57;
                }
                v59 = v57;
                if ( webncasestrcmp((int)v53, (int)"uri") && webncasestrcmp((int)v53, (int)"cnonce") )
                {
                  while ( 1 )
                  {
                    v60 = *v59;
                    if ( (isalpha(2 * *v59)) == 0
                      && v60 != 47
                      && v60 != 95
                      && v60 != 46
                      && v60 != 45 )
                    {
                      break;
                    }
                    ++v59;
                  }
                }
                else
                {
                  while ( 1 )
                  {
                    v60 = *v59;
                    if ( (isalpha(2 * *v59)) == 0
                      && v60 != 47
                      && v60 != 95
                      && v60 != 46
                      && v60 != 45
                      && v60 != 63
                      && v60 != 38
                      && v60 != 61
                      && v60 != 126
                      && v60 != 64
                      && v60 != 35
                      && v60 != 36
                      && v60 != 37
                      && v60 != 94
                      && v60 != 58
                      && v60 != 59 )
                    {
                      break;
                    }
                    ++v59;
                  }
                }
                *v59 = 0;
                v61 = v60;
                if ( webncasestrcmp((int)v53, (int)"username") )
                {
                  if ( webncasestrcmp((int)v53, (int)"response") )
                  {
                    if ( webncasestrcmp((int)v53, (int)"uri") )
                    {
                      if ( webncasestrcmp((int)v53, (int)"realm") )
                      {
                        if ( webncasestrcmp((int)v53, (int)"nonce") )
                        {
                          if ( webncasestrcmp((int)v53, (int)"nc") )
                          {
                            if ( webncasestrcmp((int)v53, (int)"cnonce") )
                            {
                              if ( !webncasestrcmp((int)v53, (int)"qop") )
                              {
                                v84 = a1[81];
                                if ( v84 )
                                {
                                  free2(v84);
                                  a1[81] = 0;
                                }
                                a1[81] = strdupWithoutNull(v57);
                              }
                            }
                            else
                            {
                              v83 = a1[80];
                              if ( v83 )
                              {
                                free2(v83);
                                a1[80] = 0;
                              }
                              a1[80] = strdupWithoutNull(v57);
                            }
                          }
                          else
                          {
                            v82 = a1[79];
                            if ( v82 )
                            {
                              free2(v82);
                              a1[79] = 0;
                            }
                            a1[79] = strdupWithoutNull(v57);
                          }
                        }
                        else
                        {
                          v81 = a1[76];
                          if ( v81 )
                          {
                            free2(v81);
                            a1[76] = 0;
                          }
                          a1[76] = strdupWithoutNull(v57);
                        }
                      }
                      else
                      {
                        v80 = a1[75];
                        if ( v80 )
                        {
                          free2(v80);
                          a1[75] = 0;
                        }
                        a1[75] = strdupWithoutNull(v57);
                      }
                    }
                    else
                    {
                      v79 = a1[78];
                      if ( v79 )
                      {
                        free2(v79);
                        a1[78] = 0;
                      }
                      a1[78] = strdupWithoutNull(v57);
                    }
                  }
                  else
                  {
                    v64 = a1[77];
                    if ( v64 )
                    {
                      free2(v64);
                      a1[77] = 0;
                    }
                    a1[77] = strdupWithoutNull(v57);
                  }
                }
                else
                {
                  v62 = a1[43];
                  if ( v62 )
                  {
                    free2(v62);
                    a1[43] = 0;
                  }
                  a1[43] = strdupWithoutNull(v57);
                }
                *j = v56;
                v53 = v59;
                *v59 = v61;
                while ( 1 )
                {
                  v63 = *v53;
                  if ( !*v53
                    || (isalpha(2 * *v53)) == 0
                    && v63 != 47
                    && v63 != 95
                    && v63 != 46
                    && v63 != 45 )
                  {
                    break;
                  }
                  ++v53;
                }
                while ( v63
                     && (isalpha(2 * v63)) == 0
                     && v63 != 47
                     && v63 != 95
                     && v63 != 46
                     && v63 != 45 )
                  v63 = *++v53;
                if ( !v63 )
                  break;
              }
              trace(1, (int)"DIGEST=Done\n");
              trace(1, (int)"wp->userName = %s\n", (char *)a1[43]);
              trace(1, (int)"wp->response = %s\n", (char *)a1[77]);
              trace(1, (int)"wp->uri = %s\n", (char *)a1[78]);
              trace(1, (int)"wp->realm = %s\n", (char *)a1[75]);
              trace(1, (int)"wp->nonce = %s\n", (char *)a1[76]);
              trace(1, (int)"wp->nc = %s\n", (char *)a1[79]);
              trace(1, (int)"wp->cnonce = %s\n", (char *)a1[80]);
              trace(1, (int)"wp->qop = %s\n", (char *)a1[81]);
            }
          }
          else
          {
            if ( !strcmp(v24, "REFERER") )
            {
              a1[83] = strdupWithoutNull(v26);
              goto LABEL_32;
            }
            if ( !strcmp(v24, "HOST") )
            {
              a1[84] = strdupWithoutNull(v26);
              goto LABEL_32;
            }
            if ( !strcmp(v24, "CONTENT-LENGTH") )
            {
              v33 = atoi(v26);
              a1[62] = v33;
              if ( v33 < 0 )
                goto LABEL_32;
              a1[57] |= 0x100u;
              v34 = "CONTENT_LENGTH";
              v35 = v26;
              v36 = (int)a1;
              goto LABEL_81;
            }
            if ( !strcmp(v24, "CONTENT-TYPE") )
            {
              v78 = strdupWithoutNull(v26);
              v35 = v26;
              v34 = "CONTENT_TYPE";
              v36 = (int)a1;
              a1[38] = v78;
LABEL_81:
              websSetVar(v36, v34, v35);
              goto LABEL_32;
            }
            if ( !strcmp(v24, "USER-AGENT") )
            {
              if ( strstr(v26, "Windows") || strstr(v26, "windows") )
              {
                a1[60] = 1;
              }
              else if ( strstr(v26, "Macintosh") )
              {
                a1[60] = 2;
              }
              else if ( strstr(v26, "Linux") )
              {
                a1[60] = 3;
              }
              v31 = strstr(v26, "Edge/") == 0;
              v68 = 1;
              if ( !v31 )
              {
LABEL_187:
                a1[61] = v68;
                goto LABEL_32;
              }
              if ( strstr(v26, "KKMAN") )
              {
                a1[61] = 3;
              }
              else if ( strstr(v26, "Opera") )
              {
                a1[61] = 4;
              }
              else
              {
                v89 = strstr(v26, "OPR/");
                if ( v89 )
                {
                  a1[61] = 4;
                  if ( atoi(v89 + 4) >= 36 )
                    a1[61] = 5;
                }
                else if ( strstr(v26, "Firefox") )
                {
                  v90 = strstr(v26, "Firefox/");
                  a1[61] = 6;
                  if ( v90 && atoi(v90 + 8) >= 52 )
                    a1[61] = 7;
                }
                else if ( strstr(v26, "Chrome") && strstr(v26, "Safari") )
                {
                  v91 = strstr(v26, "Chrome/");
                  a1[61] = 8;
                  if ( v91 && atoi(v91 + 7) >= 45 )
                    a1[61] = 9;
                }
                else
                {
                  v31 = strstr(v26, "Safari") != 0;
                  v68 = 10;
                  if ( v31 )
                    goto LABEL_187;
                  if ( strstr(v26, "MSIE") )
                  {
                    v31 = strstr(v26, "Trident/") == 0;
                    v68 = 2;
                    if ( !v31 )
                      goto LABEL_187;
                  }
                  v31 = strstr(v26, "Trident/") != 0;
                  v68 = 2;
                  if ( v31 )
                    goto LABEL_187;
                  v92 = strstr(v26, "MSIE ");
                  if ( v92 && (unsigned int)(atoi(v92 + 5) - 3) < 7 )
                    a1[61] = 2;
                }
              }
            }
          }
        }
        else
        {
          if ( websProcessUrlAndCheckRealm((int)a1) )
            goto LABEL_31;
          v37 = a1[57];
          if ( ((v37 >> 14) & 1) != 0 || (v38 = v37 >> 15, ((v37 >> 23) & 1) != 0) )
          {
            v39 = a1[38];
            if ( !v39 || !strstr(v39, "multipart/form-data;") || (int)a1[62] <= 0x7FFFFF )
            {
LABEL_88:
              websConnError((int)a1, 403, (int)"Forbidden");
              goto LABEL_31;
            }
            doSystem((int)"killall -q schedule");
            doSystem((int)"killall -q mail");
            doSystem((int)"killall -q ftpputimage");
            doSystem((int)"/mydlink/opt.local stop");
            doSystem((int)"killall -q mail_video");
            doSystem((int)"killall -q ftpputvideo");
            doSystem((int)"killall -q cifsrecord");
            doSystem((int)"rm -f /tmp/*.h264");
            doSystem((int)"rm -f /tmp/*.avi");
            doSystem((int)"rm -f /tmp/*.txt");
            doSystem((int)"free");
            v37 = a1[57];
            v38 = v37 >> 15;
          }
          v71 = v37 & 1;
          if ( (v38 & 1) != 0 )
          {
            if ( !strstr(a1[38], "multipart/form-data;") )
              goto LABEL_88;
            v72 = a1[62];
            if ( v72 < 4096 )
              goto LABEL_88;
            v71 = v37 & 1;
            if ( v72 >= 20481 )
              goto LABEL_88;
          }
          if ( !v71 )
            goto LABEL_101;
          if ( ((v37 >> 17) & 1) != 0 )
          {
            trace(1, (int)"WEBS_CGI_POST_REQUEST HEADER Done()!\n");
LABEL_101:
            a1[56] = 16;
            goto LABEL_32;
          }
          if ( ((v37 >> 8) & 1) != 0 )
          {
            v73 = a1[62];
            if ( v73 <= 15728640 )
            {
              v32 = 8;
              if ( v73 )
              {
LABEL_71:
                a1[56] = v32;
                goto LABEL_32;
              }
              goto LABEL_101;
            }
            a1[56] = 8;
            websConnError((int)a1, 400, (int)"Content-Length up to limit.");
LABEL_31:
            v2 = 1;
            goto LABEL_32;
          }
          a1[56] = 4;
        }
        goto LABEL_32;
      case 4:
        v22 = a1[57];
        if ( ((v22 >> 6) & 1) != 0 || ((v22 >> 20) & 1) != 0 )
        {
          if ( v98 < 0 )
          {
            v98 = open(a1[45], 257);
            if ( v98 < 0 )
            {
              v69 = (_DWORD *)_errno_location();
              v70 = (char *)strerror(*v69);
              trace(16, (int)"WEBS_POST_NLEN open error(%s,%s)\n", (char *)a1[45], v70);
            }
          }
          v23 = strlen(v94);
          write(v98, v94, v23);
          write(v98, "\n", 1);
        }
        else
        {
          v46 = (_BYTE *)a1[40];
          if ( !v46 || !*v46 || ((v22 >> 11) & 1) != 0 )
          {
            v2 = 1;
            v47 = strdupWithoutNull(v94);
            v48 = a1[57] | 0x800;
            a1[40] = v47;
            a1[57] = v48;
            goto LABEL_32;
          }
          v86 = strlen(a1[40]);
          v85 = strlen(v94);
          v87 = realloc(v46, v85 + v86 + 2);
          a1[40] = v87;
          if ( v87 )
          {
            v88 = v94;
            *(_BYTE *)(v86 + v87) = 38;
            strcpy(v87 + v86 + 1, v88);
          }
        }
        v2 = 1;
        a1[57] |= 0x800u;
        goto LABEL_32;
      case 8:
        v16 = a1[57];
        if ( ((v16 >> 6) & 1) != 0 || ((v16 >> 20) & 1) != 0 )
        {
          if ( v98 < 0 )
          {
            v98 = open(a1[45], 257);
            if ( v98 < 0 )
            {
              v74 = (_DWORD *)_errno_location();
              v75 = (char *)strerror(*v74);
              trace(16, (int)"WEBS_POST_CLEN open error(%s,%s)\n", (char *)a1[45], v75);
            }
          }
          write(v98, v94, v95);
          goto LABEL_51;
        }
        v40 = (_BYTE *)a1[40];
        if ( v40 )
        {
          if ( *v40 && ((v16 >> 11) & 1) == 0 )
          {
            v50 = strlen(a1[40]);
            v49 = strlen(v94);
            v51 = realloc(v40, v49 + v50 + 2);
            a1[40] = v51;
            if ( !v51 )
              goto LABEL_51;
            v44 = v94;
            v45 = v51 + v50 + 1;
            *(_BYTE *)(v50 + v51) = 38;
            goto LABEL_94;
          }
          if ( v94 )
          {
            v42 = strlen(a1[40]);
            v41 = strlen(v94);
            v43 = realloc(v40, v41 + v42 + 1);
            a1[40] = v43;
            if ( !v43 )
            {
LABEL_51:
              v16 = a1[57];
              goto LABEL_52;
            }
            v44 = v94;
            v45 = v43 + v42;
LABEL_94:
            strcpy(v45, v44);
            goto LABEL_51;
          }
        }
        else
        {
          v76 = strdupWithoutNull(v94);
          v16 = a1[57];
          a1[40] = v76;
        }
LABEL_52:
        v17 = a1[62];
        v18 = v95;
        v19 = v95 < v17;
        a1[57] = v16 | 0x800;
        v20 = v17;
        if ( v19 )
          v20 = v18;
        v21 = v17 - v20;
        a1[62] = v21;
        if ( v21 <= 0 )
        {
          if ( v98 >= 0 )
          {
            close(v98);
            v98 = -1;
          }
          goto LABEL_101;
        }
        if ( v18 <= 0 )
        {
          trace(16, (int)"WEBS_POST_CLEN read error(%d, %d)\n", v21, v18);
          v2 = 1;
        }
LABEL_32:
        if ( v2 )
          goto LABEL_26;
        if ( v94 )
        {
          free2(v94);
          v94 = 0;
        }
        break;
      case 16:
        websUrlProcessRequest((int)a1);
        v2 = 1;
        goto LABEL_32;
      default:
        websConnError((int)a1, 404, (int)"Invalid state");
        goto LABEL_31;
    }
  }
  while ( 1 )
  {
    v8 = v4;
    v96 = 0;
    v94 = 0;
    v95 = 0;
    --v4;
    if ( v3 != 8 )
    {
LABEL_13:
      if ( *((unsigned __int8 *)a1 + 228) >> 7 )
      {
        v9 = websSSLGets(a1[68], (int *)&v96);
        v10 = v9;
        if ( v9 >= 0 )
        {
LABEL_15:
          if ( !v9 )
          {
            if ( a1[56] == 2 )
              goto LABEL_17;
            goto LABEL_21;
          }
          v95 = v10;
          v94 = v96;
          goto LABEL_17;
        }
      }
      else
      {
        v9 = websSocketGets(a1[53], (int *)&v96);
        v10 = v9;
        if ( v9 >= 0 )
          goto LABEL_15;
      }
      if ( *((unsigned __int8 *)a1 + 228) >> 7 )
      {
        if ( a1[56] == 1 )
        {
LABEL_42:
          if ( a1[56] != 4 )
          {
LABEL_20:
            websConnClose((int)a1, 0);
            goto LABEL_21;
          }
          a1[56] = 16;
LABEL_17:
          v3 = a1[56];
          goto LABEL_18;
        }
        v15 = websSSLEof(a1[68]);
      }
      else
      {
        v15 = websSocketEof(a1[53]);
      }
      if ( !v15 )
        goto LABEL_21;
      goto LABEL_42;
    }
    v5 = a1[62];
    if ( v5 >= 257 )
    {
      v5 = 256;
    }
    else if ( v5 <= 0 )
    {
      goto LABEL_13;
    }
    if ( *((unsigned __int8 *)a1 + 228) >> 7 )
    {
      v6 = websSSLRead((int **)a1[68], (int)v93, v5);
      v7 = v6;
      if ( v6 < 0 )
        goto LABEL_20;
    }
    else
    {
      v6 = websSocketRead(a1[53], (int)v93, v5);
      v7 = v6;
      if ( v6 < 0 )
        goto LABEL_20;
    }
    if ( v6 )
      break;
    if ( v8 <= 0 )
      goto LABEL_21;
    usleep(5000);
    v3 = a1[56];
  }
  v93[v6] = 0;
  v14 = (char *)strndupWithoutNull((int)v93, v6);
  v96 = v14;
  if ( v14 )
  {
    v94 = v14;
    v95 = v7;
    goto LABEL_17;
  }
  websConnError((int)a1, 503, (int)"Insufficient memory");
LABEL_21:
  v11 = (int)a1;
  if ( v98 >= 0 )
  {
    close(v98);
    v12 = a1[45];
    v98 = -1;
    if ( v12 )
      remove(v12);
    v11 = (int)a1;
  }
  websConnError(v11, 400, (int)"Receive data failure");
LABEL_26:
  result = v98;
  if ( v98 >= 0 )
    result = close(v98);
  if ( v94 )
  {
    result = free2(v94);
    v94 = 0;
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F40: using guessed type int _errno_location(void);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F90: using guessed type int   time(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);
// 4E9FEC: using guessed type int   strstr(_DWORD, _DWORD);
// 4EA020: using guessed type int   write(_DWORD, _DWORD, _DWORD);
// 4EA040: using guessed type int   strncasecmp(_DWORD, _DWORD, _DWORD);
// 4EA064: using guessed type int   remove(_DWORD);
// 4EA090: using guessed type int   usleep(_DWORD);
// 4EA098: using guessed type int _ctype_b;
// 4EA0AC: using guessed type int   strerror(_DWORD);
// 4EA0C8: using guessed type int   strcpy(_DWORD, _DWORD);

//----- (0040EA48) --------------------------------------------------------
int   websSocketEvent(int a1, unsigned int a2, _DWORD *a3)
{
  int result; // $v0
  int v6; // $a1
  _DWORD *i; // $v1
  int (  *v8)(_DWORD *); // $t9

  result = websConnLast;
  v6 = 0;
  if ( websConnLast >= 0 )
  {
    for ( i = (_DWORD *)websConnList; ; ++i )
    {
      ++v6;
      if ( (_DWORD *)*i == a3 )
        break;
      if ( websConnLast < v6 )
        return result;
    }
    if ( ((a2 >> 1) & 1) != 0 )
      result = websReadEvent(a3);
    if ( ((a2 >> 2) & 1) != 0 )
    {
      v8 = (int (  *)(_DWORD *))a3[67];
      if ( v8 )
        return v8(a3);
    }
  }
  return result;
}
// 4E34CC: using guessed type int websConnLast;
// 4E7CA4: using guessed type int websConnList;

//----- (0040EB1C) --------------------------------------------------------
int   websWriteActiveHeader(_DWORD *a1, int a2, int a3, char *a4, int a5)
{
  int TempFileName; // $a0
  int v11; // $v0
  _DWORD *v12; // $v0
  char *v13; // $v0

  if ( a2 == 200 && !a3 )
  {
    TempFileName = websGetTempFileName();
    a1[46] = TempFileName;
    if ( TempFileName )
    {
      v11 = open(TempFileName, 257);
      a1[47] = v11;
      if ( v11 < 0 )
      {
        v12 = (_DWORD *)_errno_location();
        v13 = (char *)strerror(*v12);
        trace(16, (int)"websWriteActiveHeader open error(%s,%s)\n", (char *)a1[46], v13);
        if ( a1[46] )
        {
          free2(a1[46]);
          a1[46] = 0;
        }
      }
      else
      {
        a1[57] |= 0x400u;
      }
    }
  }
  return websWriteNormalHeader((int)a1, a2, a3, a4, a5);
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9F40: using guessed type int _errno_location(void);
// 4EA0AC: using guessed type int   strerror(_DWORD);

//----- (0040EC60) --------------------------------------------------------
int websWriteSpecialHeader(int a1, int a2, int a3, char *a4, int a5, int a6, ...)
{
  unsigned int v6; // $v1
  int result; // $v0
  int v9; // $s0
  int v10; // $s1
  int v11; // $s2
  int v12; // $a0
  int v13; // $v0
  unsigned int v14; // $v1
  signed int v15; // $a2
  int v16; // $v0
  int v17; // $s0
  int v18; // $v0
  int v19; // [sp+20h] [-8h] BYREF
  va_list va; // [sp+58h] [+30h] BYREF

  va_start(va, a6);
  v6 = *(_DWORD *)(a1 + 228);
  result = (v6 >> 9) & 1;
  if ( !result )
  {
    *(_DWORD *)(a1 + 228) = v6 | 0x200;
    websCommonWriteHeader(a1, a2, a3, a4, a5);
    v19 = 0;
    if ( vallocFmtString(&v19, 1024, a6, (int)va) >= 1024 )
      trace(2, (int)"websWriteSpecialHeader lost data, buffer overflow\n");
    v9 = v19;
    if ( v19 )
    {
      v10 = strlen(v19);
      v11 = v19;
      if ( v10 > 0 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v14 = *(_DWORD *)(a1 + 228);
            if ( ((v14 >> 10) & 1) == 0 )
              break;
            v12 = *(_DWORD *)(a1 + 188);
            if ( v12 < 0 )
              break;
            v13 = write(v12, v11, v10);
            if ( v13 >= 0 )
            {
              v10 -= v13;
              v11 += v13;
              if ( v10 > 0 )
                continue;
            }
            goto LABEL_17;
          }
          if ( ((v14 >> 7) & 1) != 0 )
          {
            v15 = v10;
            if ( v10 >= 513 )
              v15 = 512;
            v16 = websSSLWrite(*(int ***)(a1 + 272), v11, v15);
            v17 = v16;
            if ( v16 < 0 )
            {
LABEL_17:
              v9 = v19;
              break;
            }
            v10 -= v16;
            websSSLFlush();
          }
          else
          {
            v18 = websSocketWrite(*(_DWORD *)(a1 + 212), v11, v10);
            v17 = v18;
            if ( v18 < 0 )
              goto LABEL_17;
            v10 -= v18;
            websSocketFlush(*(_DWORD *)(a1 + 212));
          }
          v11 += v17;
          if ( v10 <= 0 )
            goto LABEL_17;
        }
      }
      free2(v9);
    }
    return websWriteFmt(a1, (int)WebCRLF);
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4EA020: using guessed type int   write(_DWORD, _DWORD, _DWORD);

//----- (0040EE8C) --------------------------------------------------------
int   websJsonWriteHeader(int a1, int a2)
{
  int *v2; // $v0
  int v4; // $v1
  char *v6; // $a3
  int v7; // $a2

  v2 = &websConnErrors;
  v4 = websConnErrors;
  if ( websConnErrors )
  {
    while ( v4 != 200 )
    {
      v2 += 2;
      v4 = *v2;
      if ( !*v2 )
        goto LABEL_4;
    }
    v6 = (char *)v2[1];
  }
  else
  {
LABEL_4:
    v6 = byte_4A2DDC;
  }
  websWriteFmt(a1, (int)"HTTP/1.0 %d %s\r\n", 200, v6);
  websWriteFmt(a1, (int)"Server: %s/%s\r\n", "alphapd", "2.1.8");
  websWriteFmt(a1, (int)"Content-type: application/json\r\n");
  websWriteFmt(a1, (int)"Access-Control-Allow-Origin: *\r\n");
  websWriteFmt(a1, (int)"Pragma: no-cache\r\nCache-Control: no-cache\r\n");
  v7 = a2;
  if ( a2 > 0 )
    websWriteFmt(a1, (int)"Content-length: %d\r\n", a2);
  return websWriteFmt(a1, (int)WebCRLF, v7);
}
// 40EFC0: variable 'v7' is possibly undefined
// 4E3430: using guessed type int websConnErrors;

//----- (0040EFD4) --------------------------------------------------------
int *  websReplyNoContent(int a1)
{
  websWriteNormalHeader(a1, 204, 0, 0, 0);
  return websConnClose(a1, 204);
}

//----- (0040F02C) --------------------------------------------------------
int   websReplyUnSupportMsg(int a1)
{
  int result; // $v0
  char *v3; // $s0
  int v4; // $v0
  _BYTE v5[64]; // [sp+20h] [-40h] BYREF

  result = 1;
  if ( *(_DWORD *)(a1 + 244) == 1 )
  {
    v3 = "<html><body><font size=5 color=red><br><p>The web-based setup page on this device works best in Internet Explor"
         "er.<br>You can find Internet Explorer in the start menu under the following context:</p><b><I>All Apps &gt; Win"
         "dows Accessories &gt; Internet Explorer</I></b></font></body></html>";
    if ( ((*(_DWORD *)(a1 + 228) >> 9) & 1) != 0 )
      return result;
LABEL_8:
    v4 = strlen(v3);
    websWriteNormalHeader(a1, 200, v4, "text/html", 0);
    websWriteFmt(a1, (int)"%s\r\n", v3);
    return (int)websConnClose(a1, 200);
  }
  memset(v5, 0, sizeof(v5));
  result = getSysInfoBuffer(79, (int)v5, 1);
  switch ( v5[0] )
  {
    case 1:
      v3 = "<html><body><font size=5 color=red><br><p>&#24744;&#25152;&#20351;&#29992;&#30340;&#27983;&#35272;&#22120;&#2"
           "1487;&#33021;&#26080;&#27861;&#25509;&#25910;&#22270;&#20687;&#21644;&#35270;&#39057;&#12290;&#22914;&#26524;"
           "&#22312;&#26597;&#30475;&#27492;&#39029;&#38754;&#26102;&#20986;&#29616;&#20219;&#20309;&#38382;&#39064;&#652"
           "92;&#25105;&#20204;&#24314;&#35758;&#24744;&#20351;&#29992;Internet Explorer&#25110;Apple Sarfari&#27983;&#35"
           "272;&#22120;&#12290;</p></font></body></html>";
      break;
    case 2:
      v3 = "<html><body><font size=5 color=red><br><p>&#24744;&#29694;&#22312;&#20351;&#29992;&#30340;&#28687;&#35261;&#2"
           "2120;&#21487;&#33021;&#26377;&#22256;&#38627;&#25509;&#21463;&#22294;&#29255;&#25110;&#26159;&#24433;&#29255;"
           "&#65292;&#22914;&#26524;&#24744;&#36935;&#21040;&#20219;&#20309;&#21839;&#38988;&#65292;&#24314;&#35696;&#247"
           "44;&#20351;&#29992;IE&#28687;&#35261;&#22120;&#25110;Apple Safari</p></font></body></html>";
      break;
    case 3:
      v3 = "<html><body><font size=5 color=red><br><p>Der Browser, den Sie verwenden, hat m&ouml;glicherweise Schwierigke"
           "iten beim Empfangen von Bildern und Videos. Wenn Sie Probleme bei der Darstellung dieser Seite haben, empfehl"
           "en wir Ihnen, Internet Explorer oder Apple Safari zu verwenden.</p></font></body></html>";
      break;
    case 4:
      v3 = "<html><body><font size=5 color=red><br><p>Le navigateur utilis&eacute; &agrave; des difficult&eacute;s &agrav"
           "e; recevoir des images et des vid&eacute;os. Si vous avez des difficult&eacute;s &agrave; voir cette page, es"
           "sayez d'utiliser Internet Explorer ou Apple Safari.</p></font></body></html>";
      break;
    case 5:
      v3 = "<html><body><font size=5 color=red><br><p>Il browser in uso potrebbe non ricevere immagini e video correttame"
           "nte. Se si riscontrano problemi nella visualizzazione di questa pagina, si consiglia di usare Internet Explor"
           "er o Apple Safari.</p></font></body></html>";
      break;
    case 6:
      v3 = "<html><body><font size=5 color=red><br><p>Es posible que el navegador web que utiliza tenga dificultades para"
           " recibir im&aacute;genes y v&iacute;deo. Si tiene problemas para ver esta p&aacute;gina, le sugerimos que uti"
           "lice Internet Explorer o Apple Safari.</p></font></body></html>";
      break;
    case 7:
      result = (int)&loc_490000;
      v3 = "<html><body><font size=5 color=red><br><p>&#51060;&#48120;&#51648;&#50752; &#48708;&#46356;&#50724;&#47484; &"
           "#49688;&#49888;&#54616;&#44592; &#50612;&#47140;&#50868; &#48652;&#46972;&#50864;&#51256;&#47484; &#49324;&#5"
           "0857;&#54616;&#44256; &#51080;&#49845;&#45768;&#45796;. &#51060; &#54168;&#51060;&#51648;&#47484; &#48372;&#4"
           "5716; &#45936; &#47928;&#51228;&#44032; &#48156;&#49373;&#54616;&#47732; &#51064;&#53552;&#45367; &#51061;&#4"
           "9828;&#54540;&#47196;&#47084;&#45208; &#50528;&#54540; &#49324;&#54028;&#47532; &#48652;&#46972;&#50864;&#512"
           "56; &#51473; &#54616;&#45208;&#47484; &#49324;&#50857;&#54644; &#48372;&#49884;&#44592; &#48148;&#46989;&#457"
           "68;&#45796;.</p></font></body></html>";
      break;
    default:
      v3 = "<html><body><font size=5 color=red><br><p>The browser you are using may have difficulty receiving images and "
           "video. If you experience any issues viewing this page, we suggest using Internet Explorer or Apple Safari.</p"
           "></font></body></html>";
      break;
  }
  if ( ((*(_DWORD *)(a1 + 228) >> 9) & 1) == 0 )
    goto LABEL_8;
  return result;
}
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (0040F1EC) --------------------------------------------------------
int   websTimeoutSched(int a1, int a2, int a3)
{
  int v6; // $s1
  int result; // $v0
  int *v8; // $s0

  v6 = AllocEntry(&dword_4E7CF0, &dword_4E3654, 16);
  result = -1;
  if ( v6 >= 0 )
  {
    v8 = *(int **)(4 * v6 + dword_4E7CF0);
    v8[2] = a2;
    v8[3] = a3;
    *v8 = v6;
    v8[1] = time(0) + a1;
    return v6;
  }
  return result;
}
// 4E3654: using guessed type int dword_4E3654;
// 4E7CF0: using guessed type int dword_4E7CF0;
// 4E9F90: using guessed type int   time(_DWORD);

//----- (0040F2B0) --------------------------------------------------------
int   websTimeoutResched(int a1, int a2)
{
  int result; // $v0
  int *v4; // $a1
  int v5; // $s0

  result = 5111808;
  if ( dword_4E7CF0 )
  {
    if ( a1 != -1 )
    {
      v4 = (int *)(4 * a1 + dword_4E7CF0);
      if ( dword_4E3654 >= a1 )
      {
        v5 = *v4;
        if ( *v4 )
        {
          result = time(0);
          *(_DWORD *)(v5 + 4) = result + a2;
        }
      }
    }
  }
  return result;
}
// 4E3654: using guessed type int dword_4E3654;
// 4E7CF0: using guessed type int dword_4E7CF0;
// 4E9F90: using guessed type int   time(_DWORD);

//----- (0040F348) --------------------------------------------------------
void   websTimeoutUnsched(int a1)
{
  int *v1; // $v1
  int v2; // $s0

  if ( dword_4E7CF0 )
  {
    if ( a1 != -1 )
    {
      v1 = (int *)(4 * a1 + dword_4E7CF0);
      if ( dword_4E3654 >= a1 )
      {
        v2 = *v1;
        if ( *v1 )
        {
          dword_4E3654 = FreeEntryId(&dword_4E7CF0, a1);
          free2(v2);
        }
      }
    }
  }
}
// 4E3654: using guessed type int dword_4E3654;
// 4E7CF0: using guessed type int dword_4E7CF0;
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (0040F3F0) --------------------------------------------------------
int websTimeoutProcess()
{
  int result; // $v0
  int v1; // $v1
  int v2; // $s1
  int v3; // $s0

  result = dword_4E3654;
  if ( dword_4E3654 >= 0 )
  {
    v1 = dword_4E3658;
    result = dword_4E3654 < dword_4E3658;
    if ( dword_4E3654 < dword_4E3658 )
    {
      v1 = 0;
      dword_4E3658 = 0;
    }
    v2 = v1;
    while ( 1 )
    {
      v3 = *(_DWORD *)(4 * v2 + dword_4E7CF0);
      if ( v3 )
      {
        result = time(0);
        if ( result >= *(_DWORD *)(v3 + 4) )
          break;
      }
      if ( dword_4E3654 < ++v2 )
        v2 = 0;
      if ( v2 == dword_4E3658 )
        return result;
    }
    result = (*(int (  **)(_DWORD, _DWORD))(*(_DWORD *)(4 * v2 + dword_4E7CF0) + 8))(
               *(_DWORD *)(*(_DWORD *)(4 * v2 + dword_4E7CF0) + 12),
               **(_DWORD **)(4 * v2 + dword_4E7CF0));
    dword_4E3658 = v2 + 1;
  }
  return result;
}
// 4E3654: using guessed type int dword_4E3654;
// 4E3658: using guessed type int dword_4E3658;
// 4E7CF0: using guessed type int dword_4E7CF0;
// 4E9F90: using guessed type int   time(_DWORD);

//----- (0040F540) --------------------------------------------------------
int   allocDecodePasswordByName(int a1, int a2)
{
  unsigned __int8 *v3; // $v0
  int Var; // $s2

  Var = websGetVar(a1, a2, (int)byte_4A2DDC);
  v3 = (unsigned __int8 *)websGetVar(a1, (int)"SessionKey", (int)byte_4A2DDC);
  return allocDecryptbyKey(Var, v3);
}

//----- (0040F5C0) --------------------------------------------------------
int   allocEncodePasswordByName(int a1, int a2)
{
  int v3; // $s1
  int v4; // $s0
  unsigned __int8 *v6; // [sp+18h] [-8h] BYREF

  v3 = nvram_bufget(0, a2);
  allocFmtString((int *)&v6, 254, (int)"%s", *(char **)(a1 + 156));
  v4 = 0;
  if ( v6 )
  {
    v4 = allocEncryptbyKey(v3, v6);
    if ( v6 )
    {
      free2(v6);
      v6 = 0;
    }
  }
  return v4;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0040F67C) --------------------------------------------------------
int   websWritePasswordByString(int a1, char *a2)
{
  return websWriteFmt(a1, (int)"%s", a2);
}

//----- (0040F6A0) --------------------------------------------------------
int   websWritePasswordByName(int a1, int a2)
{
  char *v3; // $v0

  v3 = (char *)nvram_bufget(0, a2);
  return websWriteFmt(a1, (int)"%s", v3);
}
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0040F6FC) --------------------------------------------------------
int   nipcaWritePasswordByString(int a1, char *a2)
{
  char v4[256]; // [sp+18h] [-100h] BYREF

  websEncode64(v4, a2, 255);
  return websWriteFmt(a1, (int)"%s", v4);
}

//----- (0040F75C) --------------------------------------------------------
int   getSysInfoBuffer(int a1, int a2, int a3)
{
  int v6; // $s2

  v6 = open("/dev/gpio", 0);
  memset(a2, 0, a3);
  if ( v6 >= 0 )
  {
    ioctl(v6, (32 * a1) | (a3 << 13) | 0x10, a2);
    close(v6);
  }
  return a2;
}
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (0040F828) --------------------------------------------------------
int   AllocateMACAddress(int a1, int a2)
{
  unsigned __int8 *v3; // $s0
  int v4; // $a2
  unsigned __int8 *v5; // $t4
  unsigned int v6; // $a1
  int v7; // $a0
  unsigned __int8 v8; // $v1
  unsigned __int8 *v9; // $a0
  int v11; // $s1
  int v12; // $a0
  int v13; // $a1
  _DWORD v14[2]; // [sp+18h] [-28h] BYREF
  _DWORD v15[8]; // [sp+20h] [-20h] BYREF

  v14[0] = 0;
  LOWORD(v14[1]) = 0;
  v3 = (unsigned __int8 *)v15;
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v11 = open("/dev/gpio", 0);
      memset(v14, 0, 6);
      v12 = v11;
      if ( v11 >= 0 )
      {
        v13 = 50352;
        goto LABEL_24;
      }
    }
  }
  else
  {
    v11 = open("/dev/gpio", 0);
    memset(v14, 0, 6);
    v12 = v11;
    if ( v11 >= 0 )
    {
      v13 = 49968;
LABEL_24:
      ioctl(v12, v13, v14);
      close(v11);
      v15[0] = 0;
      goto LABEL_4;
    }
  }
  v15[0] = 0;
LABEL_4:
  memset(&v15[1], 0, 28);
  v4 = 0;
  v5 = (unsigned __int8 *)v14;
  do
  {
    v6 = *v5;
    if ( v6 >= 0x10 )
    {
      v7 = *v3;
      do
      {
        v6 -= 16;
        v8 = ++v7;
      }
      while ( v6 >= 0x10 );
      *v3 = v8;
    }
    if ( (char)(*v3 + 48) < 58 )
      *v3 += 48;
    else
      *v3 += 55;
    v9 = v3 + 1;
    if ( (char)(v6 + 48) < 58 )
      v3[1] = v6 + 48;
    else
      v3[1] = v6 + 55;
    v3 += 2;
    if ( v4 < 5 )
    {
      if ( a2 == 1 )
      {
        v3 = v9 + 2;
        v9[1] = 32;
      }
      else if ( a2 == 2 )
      {
        v3 = v9 + 2;
        v9[1] = 58;
      }
    }
    ++v4;
    v5 = (unsigned __int8 *)v14 + v4;
  }
  while ( v4 < 6 );
  *v3 = 0;
  return strdupWithoutNull(v15);
}
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (0040FA6C) --------------------------------------------------------
int   get_pantilt_range(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int result; // $v0
  int v6; // $s0
  int v7; // $s0
  int v8; // [sp+18h] [-10h] BYREF
  int v9; // [sp+1Ch] [-Ch]
  int v10; // [sp+20h] [-8h]
  int v11; // [sp+24h] [-4h]

  result = minPan;
  if ( maxPan == minPan || maxTilt == minTilt )
  {
    v8 = 12;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v6 = open("/dev/i2cM0", 0);
    ioctl(v6, 1, &v8);
    close(v6);
    maxPan = v10;
    maxTilt = v11;
    v8 = 13;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v7 = open("/dev/i2cM0", 0);
    ioctl(v7, 1, &v8);
    result = close(v7);
    minPan = v10;
    minTilt = v11;
  }
  *a1 = maxPan;
  *a2 = minPan;
  *a3 = maxTilt;
  *a4 = minTilt;
  return result;
}
// 4E3410: using guessed type int minTilt;
// 4E3414: using guessed type int maxTilt;
// 4E3418: using guessed type int minPan;
// 4E341C: using guessed type int maxPan;
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (0040FC30) --------------------------------------------------------
int   pantilt_cmd(int *a1)
{
  int v2; // $s0
  int v3; // $v1
  int result; // $v0
  int v5; // $v0
  unsigned int v6; // $s0
  int v7; // $v0
  int v8; // $v0
  unsigned int v9; // $s0
  int v10; // $a2
  int v11; // $a3
  int v12; // [sp+18h] [-20h] BYREF
  int v13; // [sp+1Ch] [-1Ch] BYREF
  int v14; // [sp+20h] [-18h] BYREF
  int v15; // [sp+24h] [-14h] BYREF
  int v16; // [sp+28h] [-10h] BYREF
  int v17; // [sp+2Ch] [-Ch] BYREF
  int v18; // [sp+30h] [-8h] BYREF
  int v19; // [sp+34h] [-4h] BYREF

  if ( *a1 == 9 )
  {
    v8 = nvram_bufget(0, "Mirror");
    v9 = atoi(v8);
    trace(1, (int)"PT_FUNC_GO_POSITION1=(%d,%d)\n", a1[2], a1[3]);
    get_pantilt_range(&v12, &v13, &v14, &v15);
    if ( (v9 & 1) != 0 )
    {
      v10 = v12 - a1[2] + v13;
      a1[2] = v10;
    }
    else
    {
      v10 = a1[2];
    }
    if ( ((v9 >> 1) & 1) != 0 )
    {
      v11 = v14 - a1[3] + v15;
      a1[3] = v11;
    }
    else
    {
      v11 = a1[3];
    }
    trace(1, (int)"PT_FUNC_GO_POSITION2=(%d,%d)\n", v10, v11);
  }
  v2 = open("/dev/i2cM0", 0);
  ioctl(v2, 1, a1);
  close(v2);
  v3 = *a1;
  if ( *a1 == 9 || (result = 2, v3 == 4) || v3 == 2 )
  {
    v5 = nvram_bufget(0, "Mirror");
    v6 = atoi(v5);
    v7 = *a1;
    if ( *a1 == 4 )
    {
      trace(1, (int)"PT_FUNC_GET_POTISION1=(%d,%d)\n", a1[2], a1[3]);
      v7 = *a1;
    }
    if ( v7 == 2 )
      trace(1, (int)"PT_FUNC_GET_HOME1=(%d,%d)\n", a1[2], a1[3]);
    get_pantilt_range(&v16, &v17, &v18, &v19);
    if ( (v6 & 1) != 0 )
      a1[2] = v16 - a1[2] + v17;
    if ( ((v6 >> 1) & 1) != 0 )
      a1[3] = v18 - a1[3] + v19;
    result = *a1;
    if ( *a1 == 4 )
    {
      trace(1, (int)"PT_FUNC_GET_POTISION2=(%d,%d)\n", a1[2], a1[3]);
      result = *a1;
    }
    if ( result == 2 )
      return (int)trace(1, (int)"PT_FUNC_GET_HOME2=(%d,%d)\n", a1[2], a1[3]);
  }
  return result;
}
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (0040FF50) --------------------------------------------------------
int   websPatchRequest(_DWORD *a1, char *a2)
{
  int v4; // $v1
  int v5; // $s6
  int v6; // $s2
  _BYTE *v7; // $s4
  int v8; // $s1
  int v9; // $s0
  int v10; // $v0
  int v11; // $s3
  _BYTE *v12; // $s4
  int v13; // $fp
  int v14; // $v0
  _BYTE *v15; // $a2
  int j; // $a1
  _BYTE *v17; // $fp
  char v18; // $t2
  int v19; // $a0
  int v21; // $s2
  _BYTE *v22; // $a0
  int v23; // $s0
  int i; // $a2
  int v25; // $v0
  _BYTE *v26; // $s1
  int v27; // $a0
  int v28; // $a1
  int v29; // $v1
  int v30; // $t1
  int v31; // $v0
  int v32; // $v0
  int v33; // $s3
  int v34; // $v0
  int v35; // $v0
  int v36; // $s2
  int v37; // $v0
  int v38; // $s0
  int v39; // $s0
  _BYTE *v40; // $t3
  int v41; // $s2
  int v42; // $s0
  _BYTE *v43; // $a0
  char *v44; // $a1
  int v45; // $s0
  _BYTE *v46; // $t3
  _BYTE v47[56]; // [sp+18h] [-1C0h] BYREF
  int v48; // [sp+50h] [-188h]
  _BYTE v49[256]; // [sp+B0h] [-128h] BYREF
  char v50[16]; // [sp+1B0h] [-28h] BYREF
  _WORD v51[4]; // [sp+1C0h] [-18h] BYREF
  char v52[16]; // [sp+1C8h] [-10h] BYREF

  v4 = -1;
  if ( !a1[69] )
    return v4;
  if ( stat(a2, v47) < 0 )
  {
    websConnError((int)a1, 500, (int)"Can't stat %s", a2);
    return -1;
  }
  v5 = v48;
  v6 = 256;
  v7 = v49;
  v8 = 0;
  v9 = 0;
  if ( v48 <= 0 )
    goto LABEL_12;
  do
  {
    v10 = read(a1[64], v7, v6);
    if ( v10 <= 0 )
      break;
    v5 -= v10;
    v11 = v8 + v10;
    v12 = &v7[v10];
    v13 = v6 - v10;
    if ( a1[69] != 1 )
      goto LABEL_6;
    v21 = strlen(WebWiFiToken);
    v22 = v49;
    v23 = WebWiFiToken[0];
    for ( i = v11; ; i = v11 - (v26 + 1 - v49) )
    {
      v26 = (_BYTE *)memchr(v22, v23, i);
      if ( !v26 )
      {
        v9 = v12 - v49;
        if ( *(v12 - 2) == 35 )
        {
          v27 = (unsigned __int8)*(v12 - 1);
          if ( (char)v27 == 64 )
          {
            v28 = (unsigned __int8)*v12;
            v29 = v27 << 24;
            if ( (char)v28 == 36 )
            {
              v9 -= 3;
              goto LABEL_6;
            }
LABEL_22:
            if ( v29 >> 24 == 35 )
            {
              v30 = v28 << 24;
              if ( (char)v28 == 64 )
              {
                v9 -= 2;
                goto LABEL_6;
              }
            }
            else
            {
              v30 = v28 << 24;
            }
            if ( v30 >> 24 != 35 )
              goto LABEL_6;
            v31 = websWriteComplete((int)a1, (int)v49, v9 - 1);
            v15 = &v49[v31];
            v9 = v31;
            v6 = v13 + v31;
            if ( &v49[v31] != v12 )
              goto LABEL_7;
LABEL_26:
            v7 = v49;
            v6 = 256;
            v8 = 0;
            goto LABEL_10;
          }
        }
        else
        {
          v27 = (unsigned __int8)*(v12 - 1);
        }
        v28 = (unsigned __int8)*v12;
        v29 = v27 << 24;
        goto LABEL_22;
      }
      v25 = memcmp(v26, WebWiFiToken, v21);
      v22 = v26 + 1;
      if ( !v25 )
        break;
    }
    v9 = v26 - v49;
    if ( v49 != v26 )
      goto LABEL_6;
    v32 = strlen(WiFiPatchIPAddress);
    if ( !memcmp(v49, WiFiPatchIPAddress, v32) )
    {
      strcpy(v50, "2.66.78.60");
      v41 = strlen(v50);
      v42 = strlen(WiFiPatchIPAddress);
      v43 = &v49[v42];
      v44 = v50;
      goto LABEL_42;
    }
    v33 = strlen(WiFiPatchUserName);
    if ( !memcmp(v49, WiFiPatchUserName, v33) )
    {
      v36 = a1[43];
      v37 = strlen(v36);
      goto LABEL_40;
    }
    v33 = strlen(WiFiPatchUserPass);
    if ( !memcmp(v49, WiFiPatchUserPass, v33) )
    {
      v36 = a1[42];
      v37 = strlen(v36);
LABEL_40:
      v38 = v37;
      memcpy(&v49[v33], v36, v37);
      v39 = v33 + v38;
      v40 = &v47[v39];
      v9 = v39 + 1;
      v40[152] = 0;
      goto LABEL_6;
    }
    v34 = strlen(WiFiPatchWlanEnable);
    if ( !memcmp(v49, WiFiPatchWlanEnable, v34) )
    {
      v51[0] = 48;
      v41 = strlen(v51);
      v42 = strlen(WiFiPatchWlanEnable);
      v43 = &v49[v42];
      v44 = (char *)v51;
    }
    else
    {
      v35 = strlen(WiFiPatchMacAddress);
      if ( memcmp(v49, WiFiPatchMacAddress, v35) )
      {
        v9 = strlen(WebWiFiToken);
        goto LABEL_6;
      }
      strcpy(v52, "0080c8112233");
      v41 = strlen(v52);
      v42 = strlen(WiFiPatchMacAddress);
      v43 = &v49[v42];
      v44 = v52;
    }
LABEL_42:
    memcpy(v43, v44, v41);
    v45 = v42 + v41;
    v46 = &v47[v45];
    v9 = v45 + 1;
    v46[152] = 0;
LABEL_6:
    v14 = websWriteComplete((int)a1, (int)v49, v9);
    v15 = &v49[v14];
    v9 = v14;
    v6 = v13 + v14;
    if ( &v49[v14] == v12 )
      goto LABEL_26;
LABEL_7:
    v8 = v12 - v15;
    for ( j = 0; j < v8; v17[152] = v18 )
    {
      v17 = &v47[j];
      v18 = v15[j++];
    }
    v7 = &v49[v8];
LABEL_10:
    ;
  }
  while ( v5 > 0 && v6 > 0 );
LABEL_12:
  v19 = a1[64];
  v4 = 1;
  if ( v19 >= 0 )
  {
    close(v19);
    a1[64] = -1;
    return 1;
  }
  return v4;
}
// 4101C4: conditional instruction was optimized away because $s1.4!=0
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F58: using guessed type int   stat(_DWORD, _DWORD);
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);
// 4E9FE0: using guessed type int   read(_DWORD, _DWORD, _DWORD);
// 4E9FF4: using guessed type int   memchr(_DWORD, _DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00410518) --------------------------------------------------------
int *  websetReplayPage(int a1, int a2, char *a3, char *a4)
{
  char *Var; // $v0
  char *v9; // $a0
  int *result; // $v0
  int v11; // $a0
  int *v12; // [sp+20h] [-8h] BYREF

  if ( !a2 )
  {
    Var = (char *)websGetVar(a1, (int)a3, (int)byte_4A2DDC);
    v9 = (char *)Var;
    if ( *Var )
      goto LABEL_3;
    return trace(16, (int)"websetReplayPage(%d,%s,%s)\n", a2, a3, a4);
  }
  Var = (char *)websGetVar(a1, (int)a4, (int)byte_4A2DDC);
  v9 = (char *)Var;
  if ( !*Var )
    return trace(16, (int)"websetReplayPage(%d,%s,%s)\n", a2, a3, a4);
LABEL_3:
  v12 = 0;
  if ( *Var == 47 )
    v12 = (int *)strdupWithoutNull(v9);
  else
    allocFmtString((int *)&v12, 254, (int)"/%s", Var);
  result = v12;
  if ( v12 )
  {
    v11 = *(_DWORD *)(a1 + 136);
    if ( v11 )
    {
      free2(v11);
      result = v12;
    }
    *(_DWORD *)(a1 + 136) = v12;
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00410688) --------------------------------------------------------
int   websAddUser(int a1, int a2, int a3)
{
  int v5; // $s3
  int v6; // $s5
  int v7; // $v0
  int v8; // $s2
  int v9; // $v0
  int v10; // $s2
  __int16 *v11; // $a1
  int v12; // $s1
  _BYTE *v13; // $v0
  int v14; // $v0
  _BYTE *v15; // $s0
  _BYTE *v16; // $v0
  _BYTE *v17; // $v0
  int result; // $v0
  int v19; // $v0
  int v20; // $s2
  BOOL v21; // $v0
  _BYTE v22[64]; // [sp+18h] [-40h] BYREF

  v5 = 0;
  v6 = 0;
  if ( a3 && !strcmp(a3, "1") )
  {
    v20 = strlen(a1);
    v19 = strlen(a2);
    v9 = mmalloc(v20 + v19 + 9);
    v5 = 1;
    v10 = v9;
    if ( v9 )
      goto LABEL_4;
    return -1;
  }
  v8 = strlen(a1);
  v7 = strlen(a2);
  v9 = mmalloc(v8 + v7 + 9);
  v10 = v9;
  if ( !v9 )
    return -1;
LABEL_4:
  strcpy(v9, a1);
  strcat(v10, "/");
  strcat(v10, a2);
  strcat(v10, "/");
  if ( v5 )
    v11 = (__int16 *)"1";
  else
    v11 = &word_4A0308;
  strcat(v10, v11);
  v12 = 1;
  while ( 1 )
  {
    snprintf(v22, 64, "User%d", v12);
    v13 = (_BYTE *)nvram_bufget(0, v22);
    if ( !v13 || !*v13 )
    {
      nvram_bufset(0, v22, v10);
      v21 = v12 < 9;
      goto LABEL_28;
    }
    v14 = strdupWithoutNull(v13);
    v15 = (_BYTE *)v14;
    if ( !v14 )
    {
      v21 = v12 < 9;
      v6 = -1;
      goto LABEL_28;
    }
    v16 = (_BYTE *)strchr(v14, 47);
    if ( v16 )
    {
      *v16 = 0;
      v17 = (_BYTE *)strrchr(v16 + 1, 47);
      if ( v17 )
        *v17 = 0;
    }
    if ( v15 )
      break;
LABEL_17:
    if ( ++v12 >= 9 )
    {
      v6 = -2;
      goto LABEL_19;
    }
  }
  if ( !*v15 || strcmp(v15, a1) )
  {
    free2(v15);
    goto LABEL_17;
  }
  nvram_bufset(0, v22, v10);
  v6 = 1;
  free2(v15);
  v21 = v12 < 9;
LABEL_28:
  if ( !v21 )
    v6 = -2;
LABEL_19:
  if ( v10 )
    free2(v10);
  result = v6;
  if ( v6 >= 0 )
  {
    nvram_commit(0);
    return v6;
  }
  return result;
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4EA00C: using guessed type int   strcat(_DWORD, _DWORD);
// 4EA028: using guessed type int   strrchr(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);
// 4EA0C8: using guessed type int   strcpy(_DWORD, _DWORD);

//----- (00410A18) --------------------------------------------------------
int   websDeleteUser(int a1)
{
  int v2; // $s5
  int v3; // $s3
  int v4; // $s1
  _BYTE *v5; // $v0
  int v6; // $v0
  _BYTE *v7; // $s0
  _BYTE *v8; // $v0
  _BYTE *v9; // $v0
  int result; // $v0
  BOOL v11; // $v0
  int v12; // $s0
  int v13; // $v0
  _BYTE v14[16]; // [sp+18h] [-20h] BYREF
  _BYTE v15[16]; // [sp+28h] [-10h] BYREF

  v2 = 0;
  v3 = 0;
  v4 = 1;
  while ( 1 )
  {
    while ( 1 )
    {
      snprintf(v14, 16, "User%d", v4);
      v5 = (_BYTE *)nvram_bufget(0, v14);
      if ( v5 )
      {
        if ( *v5 )
        {
          v6 = strdupWithoutNull(v5);
          v7 = (_BYTE *)v6;
          if ( !v6 )
          {
            v11 = v4 < 9;
            v3 = -1;
            goto LABEL_16;
          }
          v8 = (_BYTE *)strchr(v6, 47);
          if ( v8 )
          {
            *v8 = 0;
            v9 = (_BYTE *)strrchr(v8 + 1, 47);
            if ( v9 )
              *v9 = 0;
          }
          if ( v7 )
            break;
        }
      }
      if ( ++v4 >= 9 )
        return -2;
    }
    if ( *v7 && !strcmp(v7, a1) )
      break;
    ++v4;
    free2(v7);
    if ( v4 >= 9 )
      return -2;
  }
  nvram_bufset(0, v14, byte_4A2DDC);
  v2 = v4;
  free2(v7);
  v11 = v4 < 9;
LABEL_16:
  if ( !v11 )
    return -2;
  result = v3;
  if ( !v3 )
  {
    v12 = v2;
    if ( v2 < 8 )
    {
      do
      {
        snprintf(v14, 16, "User%d", v12++);
        snprintf(v15, 16, "User%d", v12);
        v13 = nvram_bufget(0, v15);
        nvram_bufset(0, v14, v13);
      }
      while ( v12 < 8 );
      nvram_bufset(0, v15, byte_4A2DDC);
    }
    nvram_commit(0);
    return 0;
  }
  return result;
}
// 410B48: conditional instruction was optimized away because $s0.4!=0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4EA028: using guessed type int   strrchr(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (00410CB0) --------------------------------------------------------
int *  webAddReplyMessage(int a1, char *a2, int a3)
{
  int v7; // $a3
  char v8[64]; // [sp+20h] [-240h] BYREF
  char v9[512]; // [sp+60h] [-200h] BYREF

  if ( !a2 || !*a2 )
    return trace(1, (int)"webAddReplyMessage(empty!)\n");
  memset(v9, 0, sizeof(v9));
  snprintf(v8, 64, "Message%d", *(_DWORD *)(a1 + 280));
  if ( a3 )
  {
    v7 = *(_DWORD *)(a1 + 284);
    *(_DWORD *)(a1 + 284) = v7 + 1;
    snprintf(v9, 512, "%2d. %s", v7, a2);
  }
  else
  {
    snprintf(v9, 512, "%s", a2);
  }
  ++*(_DWORD *)(a1 + 280);
  websSetVar(a1, v8, v9);
  return trace(1, (int)"webAddReplyMessage(%s=%s)\n", v8, v9);
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (00410E1C) --------------------------------------------------------
int   AllocPassFromConfigByUser(int a1, int a2, int *a3)
{
  int v5; // $s6
  int v6; // $s2
  int v7; // $s4
  _BYTE *v8; // $v0
  int result; // $v0
  void *v10; // $s1
  _BYTE *v11; // $s0
  int v12; // $s3
  _BYTE *v13; // $v0
  _BYTE v14[64]; // [sp+18h] [-40h] BYREF

  v5 = 0;
  v6 = 1;
  v7 = 0;
  do
  {
    snprintf(v14, 64, "User%d", v6);
    v8 = (_BYTE *)nvram_bufget(0, v14);
    if ( v8 && *v8 && (v10 = v8, v11 = (_BYTE *)strchr(v8, 47), (v12 = strdupWithoutNull(v10)) != 0) )
    {
      if ( v11 )
      {
        *v11++ = 0;
        v13 = (_BYTE *)strrchr(v11, 47);
        if ( v13 )
          *v13 = 0;
      }
      if ( !strcmp(v10, a2) )
      {
        v5 = strdupWithoutNull(v11);
        ++v7;
        *a3 = v6;
      }
      free2(v12);
      ++v6;
    }
    else
    {
      ++v6;
    }
    result = v5;
  }
  while ( v6 < 9 && !v7 );
  return result;
}
// 410F84: conditional instruction was optimized away because $s3.4!=0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA028: using guessed type int   strrchr(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (00410FCC) --------------------------------------------------------
int   AllocPrintableString(_BYTE *a1)
{
  int v2; // $a2
  _BYTE *v3; // $a1
  int v4; // $v0
  bool v5; // dc
  int v6; // $t0
  char *v7; // $a3
  _BYTE *v8; // $a2
  int v9; // $t4
  char v10; // $t6
  int v11; // $v0
  int v13; // $a0
  char *v14; // $v1
  char v15; // $t2
  char v16; // $t3

  v2 = 0;
  v3 = a1;
  if ( *a1 )
  {
    v4 = (unsigned __int8)*a1;
    do
    {
      switch ( v4 )
      {
        case '"':
        case '\'':
          v4 = (unsigned __int8)*++v3;
          v2 += 6;
          break;
        case '&':
          v4 = (unsigned __int8)*++v3;
          v2 += 5;
          break;
        case '<':
        case '>':
          v4 = (unsigned __int8)*++v3;
          v2 += 4;
          break;
        default:
          v4 = (unsigned __int8)*++v3;
          ++v2;
          break;
      }
      v5 = v4 != 0;
      v4 = (unsigned __int8)v4;
    }
    while ( v5 );
  }
  v6 = mmalloc(v2 + 1);
  if ( v6 )
  {
    v7 = a1;
    v8 = (_BYTE *)v6;
    if ( *a1 )
    {
      v9 = (unsigned __int8)*a1;
      do
      {
        switch ( v9 )
        {
          case '"':
            v13 = *(_DWORD *)"&quot;";
            v14 = "&quot;";
            goto LABEL_20;
          case '&':
            ++v7;
            qmemcpy(v8, "&amp;", 5);
            v11 = (unsigned __int8)*v7;
            v8 += 5;
            break;
          case '\'':
            v13 = *(_DWORD *)"&apos;";
            v14 = "&apos;";
LABEL_20:
            v15 = v14[5];
            v16 = v14[4];
            *(_DWORD *)v8 = v13;
            ++v7;
            v8[4] = v16;
            v8[5] = v15;
            v11 = (unsigned __int8)*v7;
            v8 += 6;
            break;
          case '<':
            *(_DWORD *)v8 = *(_DWORD *)"&lt;";
            v8 += 4;
            goto LABEL_17;
          case '>':
            *(_DWORD *)v8 = *(_DWORD *)"&gt;";
            v8 += 4;
LABEL_17:
            v11 = (unsigned __int8)*++v7;
            break;
          default:
            v10 = *v7++;
            *v8 = v10;
            v11 = (unsigned __int8)*v7;
            ++v8;
            break;
        }
        v9 = (unsigned __int8)v11;
      }
      while ( v11 );
    }
  }
  return v6;
}

//----- (004111D0) --------------------------------------------------------
int   AllocXMLString(_BYTE *a1)
{
  int v2; // $a2
  _BYTE *v3; // $a1
  int v4; // $v0
  bool v5; // dc
  int v6; // $t0
  char *v7; // $a3
  _BYTE *v8; // $a2
  int v9; // $t4
  char v10; // $t6
  int v11; // $v0
  int v13; // $a0
  char *v14; // $v1
  char v15; // $t2
  char v16; // $t3

  v2 = 0;
  v3 = a1;
  if ( *a1 )
  {
    v4 = (unsigned __int8)*a1;
    do
    {
      switch ( v4 )
      {
        case '"':
        case '\'':
          v4 = (unsigned __int8)*++v3;
          v2 += 6;
          break;
        case '&':
          v4 = (unsigned __int8)*++v3;
          v2 += 5;
          break;
        case '<':
        case '>':
          v4 = (unsigned __int8)*++v3;
          v2 += 4;
          break;
        default:
          v4 = (unsigned __int8)*++v3;
          ++v2;
          break;
      }
      v5 = v4 != 0;
      v4 = (unsigned __int8)v4;
    }
    while ( v5 );
  }
  v6 = mmalloc(v2 + 1);
  if ( v6 )
  {
    v7 = a1;
    v8 = (_BYTE *)v6;
    if ( *a1 )
    {
      v9 = (unsigned __int8)*a1;
      do
      {
        switch ( v9 )
        {
          case '"':
            v13 = *(_DWORD *)"&quot;";
            v14 = "&quot;";
            goto LABEL_20;
          case '&':
            ++v7;
            qmemcpy(v8, "&amp;", 5);
            v11 = (unsigned __int8)*v7;
            v8 += 5;
            break;
          case '\'':
            v13 = *(_DWORD *)"&apos;";
            v14 = "&apos;";
LABEL_20:
            v15 = v14[5];
            v16 = v14[4];
            *(_DWORD *)v8 = v13;
            ++v7;
            v8[4] = v16;
            v8[5] = v15;
            v11 = (unsigned __int8)*v7;
            v8 += 6;
            break;
          case '<':
            *(_DWORD *)v8 = *(_DWORD *)"&lt;";
            v8 += 4;
            goto LABEL_17;
          case '>':
            *(_DWORD *)v8 = *(_DWORD *)"&gt;";
            v8 += 4;
LABEL_17:
            v11 = (unsigned __int8)*++v7;
            break;
          default:
            v10 = *v7++;
            *v8 = v10;
            v11 = (unsigned __int8)*v7;
            ++v8;
            break;
        }
        v9 = (unsigned __int8)v11;
      }
      while ( v11 );
    }
  }
  return v6;
}

//----- (004113D4) --------------------------------------------------------
int   WriteHexString(int a1, unsigned __int8 *a2)
{
  int v3; // $s5
  unsigned int v5; // $s3
  int v6; // $v0
  char *v7; // $s2
  unsigned __int8 v8; // $a3
  unsigned __int8 *i; // $s1
  int v10; // $s0
  int v11; // $s1
  _BYTE v12[16]; // [sp+18h] [-10h] BYREF

  v3 = a1;
  if ( !a2 || !*a2 )
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
  v5 = 2 * strlen(a2) + 2;
  v6 = mmalloc(v5);
  v7 = (char *)v6;
  if ( !v6 )
    goto LABEL_12;
  memset(v6, 0, v5);
  v8 = *a2;
  for ( i = a2; *i; v8 = *i )
  {
    while ( 1 )
    {
      snprintf(v12, 16, "%X", v8);
      ++i;
      v10 = strlen(v7);
      if ( v10 + strlen(v12) < v5 )
        break;
      v8 = *i;
      if ( !*i )
        goto LABEL_10;
    }
    strcat(v7, v12);
  }
LABEL_10:
  if ( !v7 )
  {
LABEL_12:
    a1 = v3;
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
  }
  v11 = websWriteFmt(v3, (int)"%s", v7);
  free2(v7);
  return v11;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA00C: using guessed type int   strcat(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (004115C4) --------------------------------------------------------
int   WritePrintableString(int a1, _BYTE *a2)
{
  int (*v2)(int, int, ...); // $a3
  int v3; // $s0
  char *v5; // $s1
  int v6; // $s0

  v2 = websWriteFmt;
  v3 = a1;
  if ( !a2 || !*a2 )
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC, v2);
  v5 = (char *)AllocPrintableString(a2);
  a1 = v3;
  if ( !v5 )
  {
    v2 = (int (*)(int, int, ...))"DNS";
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC, v2);
  }
  v6 = websWriteFmt(v3, (int)"%s", v5);
  free2(v5);
  return v6;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (004116A8) --------------------------------------------------------
int   WriteMacString(int a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // $t1
  int i; // $t2
  unsigned int v5; // $t0
  int v6; // $a3
  unsigned __int8 v7; // $v1
  signed __int8 v8; // $v1
  unsigned __int8 *v9; // $a3
  _DWORD v11[8]; // [sp+18h] [-20h] BYREF

  memset(v11, 0, sizeof(v11));
  v3 = (unsigned __int8 *)v11;
  for ( i = 0; i < 6; ++i )
  {
    v5 = *a2++;
    if ( v5 >= 0x10 )
    {
      v6 = *v3;
      do
      {
        v5 -= 16;
        v7 = ++v6;
      }
      while ( v5 >= 0x10 );
      *v3 = v7;
    }
    v8 = *v3 + 48;
    if ( v8 < 58 )
      *v3 = v8;
    else
      *v3 += 55;
    v9 = v3 + 1;
    if ( (char)(v5 + 48) < 58 )
      v3[1] = v5 + 48;
    else
      v3[1] = v5 + 55;
    v3 += 2;
    if ( i < 5 )
    {
      if ( a3 == 1 )
      {
        v3 = v9 + 2;
        v9[1] = 32;
      }
      else if ( a3 == 2 )
      {
        v3 = v9 + 2;
        v9[1] = 58;
      }
    }
  }
  *v3 = 0;
  return websWriteFmt(a1, (int)"%s", (char *)v11);
}

//----- (004117EC) --------------------------------------------------------
int   WriteTimerString(
        int a1,
        int a2,
        unsigned __int16 a3,
        unsigned __int16 a4,
        unsigned __int16 a5,
        unsigned __int16 a6,
        unsigned __int16 a7,
        unsigned __int16 a8)
{
  _DWORD v10[12]; // [sp+18h] [-50h] BYREF
  char v11[32]; // [sp+48h] [-20h] BYREF

  v10[5] = a3;
  v10[4] = a4;
  v10[2] = a6;
  v10[1] = a7;
  v10[0] = a8;
  v10[3] = a5;
  strftime(v11, 32, a2, v10);
  return websWriteFmt(a1, (int)"%s", v11);
}
// 4E9F5C: using guessed type int   strftime(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00411890) --------------------------------------------------------
int   getStringConfig(int a1, int a2, int a3, _DWORD *a4)
{
  char *Var; // $v0

  if ( a3 > 0 && !strcmp(*a4, "2") && websTestVar(a1, a2) )
    Var = (char *)websGetVar(a1, a2, (int)byte_4A2DDC);
  else
    Var = (char *)nvram_bufget(0, a2);
  if ( Var && *Var )
    return websWriteFmt(a1, (int)"%s", Var);
  else
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0041199C) --------------------------------------------------------
int   getHashMd5StringConfig(int a1, int a2, int a3, _DWORD *a4)
{
  int v8; // $v0
  int v9; // $s2
  int v10; // $v0
  unsigned int v11; // $s1
  _DWORD v13[16]; // [sp+20h] [-88h] BYREF
  char v14[64]; // [sp+60h] [-48h] BYREF
  _DWORD *v15; // [sp+A0h] [-8h] BYREF

  v15 = 0;
  memset(v13, 0, sizeof(v13));
  memset(v14, 0, sizeof(v14));
  allocFmtString((int *)&v15, 254, (int)"%s", *(char **)(a1 + 156));
  if ( !v15 )
    return websWriteFmt(a1, (int)"%s", v14);
  v8 = a3 > 0 && !strcmp(*a4, "2") && websTestVar(a1, a2) ? websGetVar(a1, a2, (int)byte_4A2DDC) : nvram_bufget(0, a2);
  v9 = v8;
  v11 = strlen(v8);
  v10 = strlen(v15);
  hmac_md5(v9, v11, v15, v10, v13);
  hexarraytohexstring((unsigned __int8 *)v13, v14, 0x10u);
  if ( !v15 )
    return websWriteFmt(a1, (int)"%s", v14);
  free2(v15);
  v15 = 0;
  return websWriteFmt(a1, (int)"%s", v14);
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00411BC8) --------------------------------------------------------
int   getHexStringConfig(int a1, int a2, int a3, _DWORD *a4)
{
  unsigned __int8 *Var; // $v0
  unsigned __int8 *v7; // $s0
  unsigned int v9; // $s3
  int v10; // $v0
  char *v11; // $s2
  unsigned __int8 v12; // $a3
  unsigned __int8 *i; // $s1
  int v14; // $s0
  int v15; // $s1
  _BYTE v16[16]; // [sp+18h] [-10h] BYREF

  if ( a3 > 0 && !strcmp(*a4, "2") && websTestVar(a1, a2) )
    Var = (unsigned __int8 *)websGetVar(a1, a2, (int)byte_4A2DDC);
  else
    Var = (unsigned __int8 *)nvram_bufget(0, a2);
  v7 = Var;
  if ( !Var )
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
  if ( !*Var )
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
  v9 = 2 * strlen(Var) + 2;
  v10 = mmalloc(v9);
  v11 = (char *)v10;
  if ( !v10 )
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
  memset(v10, 0, v9);
  v12 = *v7;
  for ( i = v7; *i; v12 = *i )
  {
    while ( 1 )
    {
      snprintf(v16, 16, "%X", v12);
      ++i;
      v14 = strlen(v11);
      if ( v14 + strlen(v16) < v9 )
        break;
      v12 = *i;
      if ( !*i )
        goto LABEL_13;
    }
    strcat(v11, v16);
  }
LABEL_13:
  if ( !v11 )
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
  v15 = websWriteFmt(a1, (int)"%s", v11);
  free2(v11);
  return v15;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA00C: using guessed type int   strcat(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (00411E20) --------------------------------------------------------
int   getPrintableStringConfig(int a1, int a2, int a3, _DWORD *a4)
{
  _BYTE *Var; // $v0
  char *v8; // $v0
  char *v9; // $s2
  int v10; // $s0

  if ( a3 > 0 && !strcmp(*a4, "2") && websTestVar(a1, a2) )
    Var = (_BYTE *)websGetVar(a1, a2, (int)byte_4A2DDC);
  else
    Var = (_BYTE *)nvram_bufget(0, a2);
  if ( !Var )
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
  if ( !*Var )
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
  v8 = (char *)AllocPrintableString(Var);
  v9 = v8;
  if ( !v8 )
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
  v10 = websWriteFmt(a1, (int)"%s", v8);
  free2(v9);
  return v10;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00411F70) --------------------------------------------------------
int   getIntConfig(int a1, int a2, int a3, _DWORD *a4)
{
  char *Var; // $v0

  if ( a3 > 0 && !strcmp(*a4, "2") && websTestVar(a1, a2) )
    Var = (char *)websGetVar(a1, a2, (int)&word_4A0308);
  else
    Var = (char *)nvram_bufget(0, a2);
  if ( Var && *Var )
    return websWriteFmt(a1, (int)"%s", Var);
  else
    return websWriteFmt(a1, (int)"%s", &word_4A0308);
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0041207C) --------------------------------------------------------
int   getBitRateValue(int a1)
{
  return atoi(a1);
}
// 4E9F38: using guessed type int   atoi(_DWORD);

//----- (00412098) --------------------------------------------------------
int   getRadioConfig(int a1, int a2, int a3, _DWORD *a4)
{
  int v7; // $s1
  _BYTE *Var; // $v0
  _BYTE *v9; // $a0
  int v10; // $v0
  int v11; // $a0
  char *v12; // $a2

  v7 = *a4;
  if ( a3 < 2
    || strcmp(*a4, "2")
    || (v7 = a4[1], !websTestVar(a1, a2))
    || (Var = (_BYTE *)websGetVar(a1, a2, (int)&word_4A0308), (v9 = Var) == 0) )
  {
    Var = (_BYTE *)nvram_bufget(0, a2);
    v9 = Var;
    if ( !Var )
      goto LABEL_6;
  }
  if ( !*Var || (v10 = strcmp(v9, v7), v11 = a1, v12 = "checked", v10) )
  {
LABEL_6:
    v11 = a1;
    v12 = byte_4A2DDC;
  }
  return websWriteFmt(v11, (int)"%s", v12);
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (004121CC) --------------------------------------------------------
int   getCheckConfig(int a1, int a2, int a3, _DWORD *a4)
{
  int v7; // $s2
  _BYTE *Var; // $s0
  char v9; // $v0
  _BYTE *v10; // $a0
  int v11; // $v0
  int v12; // $s0
  int v13; // $a0
  char *v14; // $a2

  v7 = *a4;
  if ( a3 < 2
    || strcmp(*a4, "2")
    || (v7 = a4[1], !websTestVar(a1, a2))
    || (Var = (_BYTE *)websGetVar(a1, a2, (int)&word_4A0308)) == 0 )
  {
    Var = (_BYTE *)nvram_bufget(0, a2);
    if ( !Var )
      goto LABEL_6;
  }
  if ( !*Var
    || (v9 = atoi(v7), v10 = Var, v12 = 1 << v9, v11 = atoi(v10), v13 = a1, v14 = "checked", (v12 & v11) != v12) )
  {
LABEL_6:
    v13 = a1;
    v14 = byte_4A2DDC;
  }
  return websWriteFmt(v13, (int)"%s", v14);
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00412324) --------------------------------------------------------
int   getSelectString(int a1, int a2, _BYTE **a3, int a4, _DWORD *a5)
{
  int v8; // $s4
  int v9; // $s0
  int Var; // $s6
  int v11; // $s1
  _DWORD *v12; // $a0
  int v13; // $v0
  int v14; // $a0
  char *v15; // $a2
  int v16; // $v0
  int v17; // $s0
  int v18; // $v0
  int v19; // $s0

  v8 = 0;
  v9 = 0;
  if ( a4 > 0 && !strcmp(*a5, "2") && websTestVar(a1, a2) )
    Var = websGetVar(a1, a2, (int)byte_4A2DDC);
  else
    Var = nvram_bufget(0, a2);
  if ( *a3 )
  {
    v11 = 0;
    if ( **a3 )
    {
      v12 = a3;
      do
      {
        v13 = strcmp(*v12, Var);
        v14 = a1;
        v15 = WebOptionCheck;
        if ( v13 )
        {
          v15 = WebOptionStart;
          v14 = a1;
        }
        ++v8;
        v17 = v9 + websWriteFmt(v14, (int)"%s", v15);
        v16 = websWriteFmt(a1, (int)"%s", a3[v11]);
        v11 = v8;
        v19 = v17 + v16;
        v18 = websWriteFmt(a1, (int)"%s", WebOptionEnd);
        v12 = &a3[v8];
        v9 = v19 + v18;
      }
      while ( *v12 && *(_BYTE *)*v12 );
    }
  }
  return v9;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (004124D8) --------------------------------------------------------
int   getSelectStringOfMatchValue(int a1, int a2, int a3, _BYTE **a4, int a5, _DWORD *a6)
{
  int v10; // $s4
  int v11; // $s0
  int Var; // $s5
  int v13; // $s1
  _DWORD *v14; // $a0
  int v15; // $v0
  int v16; // $a0
  char *v17; // $a2
  int v18; // $v0
  int v19; // $s0
  int v20; // $v0
  int v21; // $s0

  v10 = 0;
  v11 = 0;
  if ( a5 > 0 && !strcmp(*a6, "2") && websTestVar(a1, a2) )
    Var = websGetVar(a1, a2, (int)byte_4A2DDC);
  else
    Var = nvram_bufget(0, a2);
  if ( *a4 )
  {
    v13 = 0;
    if ( **a4 )
    {
      v14 = a4;
      do
      {
        v15 = strcmp(*v14, Var);
        v16 = a1;
        v17 = WebOptionCheck;
        if ( v15 )
        {
          v17 = WebOptionStart;
          v16 = a1;
        }
        ++v10;
        v19 = v11 + websWriteFmt(v16, (int)"%s", v17);
        v18 = websWriteFmt(a1, (int)"%s", *(char **)(v13 + a3));
        v13 = 4 * v10;
        v21 = v19 + v18;
        v20 = websWriteFmt(a1, (int)"%s", WebOptionEnd);
        v14 = &a4[v10];
        v11 = v21 + v20;
      }
      while ( *v14 && *(_BYTE *)*v14 );
    }
  }
  return v11;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0041269C) --------------------------------------------------------
int   getStringOfValueSelect(int a1, int a2, _BYTE **a3, int a4, _DWORD *a5)
{
  int v8; // $s0
  int Var; // $v0
  int v10; // $a1
  int v11; // $a0
  _DWORD *v12; // $v1

  v8 = 0;
  if ( a4 > 0 && !strcmp(*a5, "2") && websTestVar(a1, a2) )
    Var = websGetVar(a1, a2, (int)byte_4A2DDC);
  else
    Var = nvram_bufget(0, a2);
  v10 = atoi(Var);
  v11 = 0;
  if ( *a3 )
  {
    v12 = a3;
    if ( **a3 )
    {
      while ( 1 )
      {
        ++v12;
        if ( v8 == v10 )
          break;
        v11 = ++v8;
        if ( !*v12 || !*(_BYTE *)*v12 )
          return websWriteFmt(a1, (int)"%s", a3[v11]);
      }
      v11 = v8;
    }
  }
  return websWriteFmt(a1, (int)"%s", a3[v11]);
}
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (004127E4) --------------------------------------------------------
int   getSysInfoShort(int a1)
{
  int v2; // $s1
  _WORD v4[4]; // [sp+18h] [-8h] BYREF

  v2 = open("/dev/gpio", 0);
  v4[0] = 0;
  if ( v2 >= 0 )
  {
    ioctl(v2, (32 * a1) | 0x4010, v4);
    close(v2);
  }
  return v4[0];
}
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (0041287C) --------------------------------------------------------
int   getChannelSelectString(int a1, int a2, char **a3, int a4, _DWORD *a5)
{
  int v7; // $v0
  int v9; // $s0
  int v10; // $s3
  int v11; // $fp
  int v12; // $s7
  int Var; // $s5
  int v14; // $a0
  char **v15; // $s1
  int v16; // $s2
  char *v17; // $v0
  int v18; // $t4
  int result; // $v0
  _DWORD *v20; // $a0
  int v21; // $v0
  int v22; // $a0
  char *v23; // $a2
  int v24; // $s0
  int v25; // $s0
  _WORD v26[4]; // [sp+18h] [-8h] BYREF

  v7 = open("/dev/gpio", 0);
  v9 = v7;
  v26[0] = 0;
  v10 = 0;
  v11 = 0;
  if ( v7 >= 0 )
  {
    ioctl(v7, 18576, v26);
    close(v9);
  }
  v12 = v26[0];
  if ( a4 > 0 && !strcmp(*a5, "2") && websTestVar(a1, a2) )
    Var = websGetVar(a1, a2, (int)byte_4A2DDC);
  else
    Var = nvram_bufget(0, a2);
  v14 = 0;
  if ( *a3 )
  {
    v15 = a3;
    if ( **a3 )
    {
      v16 = 0;
      while ( 1 )
      {
        v20 = (char **)((char *)a3 + v14);
        if ( (v12 & (__int16)(1 << v10)) == (__int16)(1 << v10) )
        {
          v21 = strcmp(*v20, Var);
          v22 = a1;
          v23 = WebOptionCheck;
          if ( v21 )
          {
            v23 = WebOptionStart;
            v22 = a1;
          }
          v16 += 4;
          v24 = v11 + websWriteFmt(v22, (int)"%s", v23);
          v25 = v24 + websWriteFmt(a1, (int)"%s", *v15++);
          v11 = v25 + websWriteFmt(a1, (int)"%s", WebOptionEnd);
          v17 = *v15;
          ++v10;
          v14 = v16;
          if ( !*v15 )
            return v11;
        }
        else
        {
          v17 = *++v15;
          v16 += 4;
          ++v10;
          v14 = v16;
          if ( !*v15 )
            return v11;
        }
        v18 = *v17;
        result = v11;
        if ( !v18 )
          return result;
      }
    }
  }
  return v11;
}
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (00412ADC) --------------------------------------------------------
int   getLogoSelectString(int a1, int a2, char **a3, int a4, _DWORD *a5)
{
  int v8; // $s0
  char **v9; // $s1
  int Var; // $v0
  char *v11; // $a0
  int i; // $s4
  int v13; // $v0
  int v14; // $s5
  int v15; // $v0
  int v16; // $s0
  int v17; // $v0
  int v18; // $s5
  int v19; // $v0
  int v20; // $s0

  v8 = 0;
  v9 = a3;
  if ( a4 > 0 && !strcmp(*a5, "2") && websTestVar(a1, a2) )
    Var = websGetVar(a1, a2, (int)byte_4A2DDC);
  else
    Var = nvram_bufget(0, a2);
  v11 = a3[1];
  for ( i = Var; v11; v8 = v20 + v19 )
  {
    while ( !strcmp(v11, i) )
    {
      v14 = v8 + websWriteFmt(a1, (int)"<OPTION value=\"%s\" selected>", *v9);
      v13 = websWriteFmt(a1, (int)"%s", v9[1]);
      v9 += 2;
      v16 = v14 + v13;
      v15 = websWriteFmt(a1, (int)"%s", WebOptionEnd);
      v11 = v9[1];
      v8 = v16 + v15;
      if ( !v11 )
        return v8;
    }
    v18 = v8 + websWriteFmt(a1, (int)"<OPTION value=\"%s\">", *v9);
    v17 = websWriteFmt(a1, (int)"%s", v9[1]);
    v9 += 2;
    v20 = v18 + v17;
    v19 = websWriteFmt(a1, (int)"%s", WebOptionEnd);
    v11 = v9[1];
  }
  return v8;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00412CB0) --------------------------------------------------------
int   getStringOfMatchValue(int a1, int a2, int a3, _BYTE **a4, int a5, _DWORD *a6)
{
  int v10; // $s1
  int Var; // $s2
  int v12; // $v1
  _DWORD *v13; // $a3
  _DWORD *v14; // $s0

  v10 = 0;
  if ( a5 > 0 && !strcmp(*a6, "2") && websTestVar(a1, a2) )
    Var = websGetVar(a1, a2, (int)byte_4A2DDC);
  else
    Var = nvram_bufget(0, a2);
  v12 = 0;
  if ( *a4 )
  {
    v13 = a4;
    if ( **a4 )
    {
      v14 = a4;
      while ( 1 )
      {
        ++v14;
        if ( !strcmp(*v13, Var) )
          break;
        ++v10;
        v12 = 4 * v10;
        v13 = v14;
        if ( !*v14 || !*(_BYTE *)*v14 )
          return websWriteFmt(a1, (int)"%s", *(char **)(v12 + a3));
      }
      v12 = 4 * v10;
    }
  }
  return websWriteFmt(a1, (int)"%s", *(char **)(v12 + a3));
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00412E14) --------------------------------------------------------
int   getCurrentTimeString(int a1, int a2)
{
  int v4; // $v0
  char v6[64]; // [sp+18h] [-48h] BYREF
  char v7; // [sp+58h] [-8h] BYREF

  memset(v6, 0, sizeof(v6));
  time(&v7);
  v4 = localtime(&v7);
  if ( v4 )
    strftime(v6, 64, a2, v4);
  return websWriteFmt(a1, (int)"%s", v6);
}
// 4E9F5C: using guessed type int   strftime(_DWORD, _DWORD, _DWORD, _DWORD);
// 4E9F90: using guessed type int   time(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FA4: using guessed type int   localtime(_DWORD);

//----- (00412EE8) --------------------------------------------------------
int   getStringVar(int a1, int a2, int a3)
{
  char *Var; // $v0

  Var = (char *)websGetVar(a1, a2, a3);
  if ( Var && *Var )
    return websWriteFmt(a1, (int)"%s", Var);
  else
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
}

//----- (00412F7C) --------------------------------------------------------
int   getHexStringVar(int a1, int a2, int a3)
{
  unsigned __int8 *Var; // $v0
  unsigned __int8 *v5; // $s0
  unsigned int v7; // $s3
  int v8; // $v0
  char *v9; // $s2
  unsigned __int8 v10; // $a3
  unsigned __int8 *i; // $s1
  int v12; // $s0
  int v13; // $s1
  _BYTE v14[16]; // [sp+18h] [-10h] BYREF

  Var = (unsigned __int8 *)websGetVar(a1, a2, a3);
  v5 = Var;
  if ( !Var )
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
  if ( !*Var )
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
  v7 = 2 * strlen(Var) + 2;
  v8 = mmalloc(v7);
  v9 = (char *)v8;
  if ( !v8 )
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
  memset(v8, 0, v7);
  v10 = *v5;
  for ( i = v5; *i; v10 = *i )
  {
    while ( 1 )
    {
      snprintf(v14, 16, "%X", v10);
      ++i;
      v12 = strlen(v9);
      if ( v12 + strlen(v14) < v7 )
        break;
      v10 = *i;
      if ( !*i )
        goto LABEL_10;
    }
    strcat(v9, v14);
  }
LABEL_10:
  if ( !v9 )
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
  v13 = websWriteFmt(a1, (int)"%s", v9);
  free2(v9);
  return v13;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA00C: using guessed type int   strcat(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (00413170) --------------------------------------------------------
int   getPrintableStringVar(int a1, int a2, int a3)
{
  _BYTE *Var; // $v0
  int v5; // $a0
  char *v7; // $s1
  int v8; // $s0

  Var = (_BYTE *)websGetVar(a1, a2, a3);
  v5 = a1;
  if ( !Var )
    return websWriteFmt(v5, (int)"%s", byte_4A2DDC);
  if ( !*Var )
    return websWriteFmt(v5, (int)"%s", byte_4A2DDC);
  v7 = (char *)AllocPrintableString(Var);
  v5 = a1;
  if ( !v7 )
    return websWriteFmt(v5, (int)"%s", byte_4A2DDC);
  v8 = websWriteFmt(a1, (int)"%s", v7);
  free2(v7);
  return v8;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00413268) --------------------------------------------------------
int *  copyStringHexVar(int a1, char *a2, int a3, int a4)
{
  _BYTE *Var; // $s0
  int v8; // $v0
  int v9; // $s3
  char *v10; // $s4
  int v11; // $a0
  char *v12; // $a3
  int v13; // $t0
  char v14; // $t1
  unsigned int v15; // $a1
  char v16; // $a2
  bool v17; // dc
  char v18; // $a1

  Var = (_BYTE *)websGetVar(a1, a3, a4);
  websDeleteVar(a1, a2);
  if ( !Var )
    return websSetVar(a1, a2, byte_4A2DDC);
  if ( !*Var )
    return websSetVar(a1, a2, byte_4A2DDC);
  v9 = strlen(Var);
  v8 = mmalloc(v9);
  v10 = (char *)v8;
  if ( !v8 )
    return websSetVar(a1, a2, byte_4A2DDC);
  memset(v8, 0, v9);
  v11 = (char)*Var;
  v12 = v10;
  v13 = 0;
  v14 = 0;
  if ( *Var )
  {
    v15 = v11 - 65;
    do
    {
      v16 = 16 * v14;
      v14 = 0;
      v17 = v15 < 6;
      v18 = v11 - 55;
      if ( !v17 )
      {
        v18 = v11 - 87;
        if ( (unsigned int)(v11 - 97) >= 6 )
        {
          v18 = v11 - 48;
          if ( (unsigned __int8)(v11 - 48) >= 0xAu )
            break;
        }
      }
      if ( v13 )
      {
        *v12 = v16 | v18;
        v11 = (char)*++Var;
        v13 = 0;
        ++v12;
      }
      else
      {
        v11 = (char)*++Var;
        v14 = v18;
        v13 = 1;
      }
      v15 = v11 - 65;
    }
    while ( v11 );
  }
  if ( !v10 )
    return websSetVar(a1, a2, byte_4A2DDC);
  websSetVar(a1, a2, v10);
  return (int *)free2(v10);
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (0041343C) --------------------------------------------------------
int   websConfigGetFromVar(int a1, int a2, char *a3, char **a4)
{
  char *Var; // $v1

  Var = (char *)websGetVar(a1, a2, (int)WebNotFound);
  if ( Var == WebNotFound )
  {
    *a4 = a3;
    return 0;
  }
  else
  {
    *a4 = Var;
    return 1;
  }
}

//----- (004134C4) --------------------------------------------------------
int   websGetSelectString(_DWORD *a1, int a2)
{
  int v2; // $a3
  int v3; // $v1
  _DWORD *v4; // $a2

  v2 = 0;
  v3 = 0;
  if ( !*a1 || !*(_BYTE *)*a1 )
    return a1[v3];
  v4 = a1;
  while ( 1 )
  {
    ++v4;
    if ( v2 == a2 )
      break;
    v3 = ++v2;
    if ( !*v4 || !*(_BYTE *)*v4 )
      return a1[v3];
  }
  return a1[v2];
}

//----- (00413534) --------------------------------------------------------
int   getSysInfoLong(int a1)
{
  int v2; // $s1
  int v4; // [sp+18h] [-8h] BYREF

  v2 = open("/dev/gpio", 0);
  v4 = 0;
  if ( v2 >= 0 )
  {
    ioctl(v2, (32 * a1) | 0x8010, &v4);
    close(v2);
  }
  return v4;
}
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (004135CC) --------------------------------------------------------
int   setSysInfoNone(int a1)
{
  int result; // $v0
  int v3; // $s1

  result = open("/dev/gpio", 0);
  v3 = result;
  if ( result >= 0 )
  {
    ioctl(result, (32 * a1) | 0x11, 0);
    return close(v3);
  }
  return result;
}
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (00413660) --------------------------------------------------------
int   setSysInfoBuffer(int a1, int a2, int a3)
{
  int v6; // $s3
  int result; // $v0

  v6 = open("/dev/gpio", 0);
  result = 32 * a1;
  if ( v6 >= 0 )
  {
    ioctl(v6, (32 * a1) | (a3 << 13) | 0x11, a2);
    return close(v6);
  }
  return result;
}
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (0041371C) --------------------------------------------------------
int   setSysInfoShort(int a1, __int16 a2)
{
  int result; // $v0
  int v5; // $s2
  _WORD v6[4]; // [sp+18h] [-8h] BYREF

  result = open("/dev/gpio", 0);
  v5 = result;
  v6[0] = a2;
  if ( result >= 0 )
  {
    ioctl(result, (32 * a1) | 0x4011, v6);
    return close(v5);
  }
  return result;
}
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (004137C0) --------------------------------------------------------
int   setSysInfoLong(int a1, int a2)
{
  int result; // $v0
  int v5; // $s2
  int v6; // [sp+18h] [-8h] BYREF

  result = open("/dev/gpio", 0);
  v5 = result;
  v6 = a2;
  if ( result >= 0 )
  {
    ioctl(result, (32 * a1) | 0x8011, &v6);
    return close(v5);
  }
  return result;
}
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (00413860) --------------------------------------------------------
int   websgetSysInfoString(int a1, int a2)
{
  int v4; // $s1
  char v6[256]; // [sp+18h] [-100h] BYREF

  v4 = open("/dev/gpio", 0);
  memset(v6, 0, sizeof(v6));
  if ( v4 >= 0 )
  {
    ioctl(v4, (32 * a2) | 0x200010, v6);
    close(v4);
  }
  return websWriteFmt(a1, (int)"%s", v6);
}
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (00413948) --------------------------------------------------------
int   websgetSysInfoPrintableString(int a1, int a2)
{
  int v4; // $s1
  char *v5; // $s1
  int v6; // $s2
  char v8[256]; // [sp+18h] [-100h] BYREF

  v4 = open("/dev/gpio", 0);
  memset(v8, 0, sizeof(v8));
  if ( v4 >= 0 )
  {
    ioctl(v4, (32 * a2) | 0x200010, v8);
    close(v4);
  }
  v5 = (char *)AllocPrintableString(v8);
  if ( !v5 )
    return websWriteFmt(a1, (int)"%s", v8);
  v6 = websWriteFmt(a1, (int)"%s", v5);
  free2(v5);
  return v6;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (00413AA0) --------------------------------------------------------
int   websgetSysInfoLong(int a1, int a2)
{
  int v4; // $s1
  int v6; // [sp+18h] [-8h] BYREF

  v4 = open("/dev/gpio", 0);
  v6 = 0;
  if ( v4 >= 0 )
  {
    ioctl(v4, (32 * a2) | 0x8010, &v6);
    close(v4);
  }
  return websWriteFmt(a1, (int)"%d", v6);
}
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (00413B60) --------------------------------------------------------
int   websgetSysInfoShort(int a1, int a2)
{
  int v4; // $s1
  _WORD v6[4]; // [sp+18h] [-8h] BYREF

  v4 = open("/dev/gpio", 0);
  v6[0] = 0;
  if ( v4 >= 0 )
  {
    ioctl(v4, (32 * a2) | 0x4010, v6);
    close(v4);
  }
  return websWriteFmt(a1, (int)"%d", v6[0]);
}
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (00413C20) --------------------------------------------------------
int   websgetSysInfoNetAddress(int a1, int a2)
{
  int v4; // $s1
  char *v5; // $v0
  int v7; // [sp+18h] [-8h] BYREF

  v4 = open("/dev/gpio", 0);
  v7 = 0;
  if ( v4 >= 0 )
  {
    ioctl(v4, (32 * a2) | 0x8010, &v7);
    close(v4);
  }
  v5 = (char *)inet_ntoa(v7);
  return websWriteFmt(a1, (int)"%s", v5);
}
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9F94: using guessed type int   inet_ntoa(_DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (00413CF4) --------------------------------------------------------
int   set_reboot_time(int a1, int a2)
{
  int result; // $v0
  int v4; // $s0
  _DWORD v5[2]; // [sp+18h] [-10h] BYREF
  _DWORD v6[2]; // [sp+20h] [-8h] BYREF

  v5[1] = 0;
  v6[0] = 0;
  v6[1] = 0;
  if ( a2 )
  {
    v5[0] = -16;
    gettimeofday(v5, v6);
    v5[0] += a1;
  }
  else
  {
    v5[0] = 0;
  }
  result = open("/dev/gpio", 0);
  v4 = result;
  if ( result >= 0 )
  {
    ioctl(result, 67665, v5);
    return close(v4);
  }
  return result;
}
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9FAC: using guessed type int   gettimeofday(_DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (00413DBC) --------------------------------------------------------
int   switch_language(int a1, int a2)
{
  int v4; // $s0
  int v5; // $s0
  char *v6; // $a0
  int v8; // $v0
  int v9; // $s0
  char *v10; // $v0
  _DWORD v11[4]; // [sp+20h] [-18h] BYREF
  char *v12[2]; // [sp+30h] [-8h] BYREF

  v12[0] = 0;
  memset(v11, 0, sizeof(v11));
  v4 = open("/dev/gpio", 0);
  memset(v11, 0, 1);
  if ( v4 >= 0 )
  {
    ioctl(v4, 10736, v11);
    close(v4);
  }
  v5 = SLOBYTE(v11[0]);
  if ( !a1 )
    a2 = SLOBYTE(v11[0]);
  switch ( a2 )
  {
    case 0:
      v10 = "eng";
      goto LABEL_22;
    case 1:
      v10 = "cht";
      goto LABEL_22;
    case 2:
      v10 = "twn";
      goto LABEL_22;
    case 3:
      v10 = "grm";
      goto LABEL_22;
    case 4:
      v10 = "frh";
      goto LABEL_22;
    case 5:
      v10 = "itn";
      goto LABEL_22;
    case 6:
      v10 = "sph";
      goto LABEL_22;
    case 7:
      v10 = "kor";
      goto LABEL_22;
    case 8:
      v10 = "rus";
      goto LABEL_22;
    case 9:
      v10 = "jpn";
LABEL_22:
      allocFmtString((int *)v12, 254, (int)"%s/pack/%s.lzma", "/etc_ro/web", v10);
      break;
    default:
      allocFmtString((int *)v12, 254, (int)"%s/pack/%s.lzma", "/etc_ro/web", "eng");
      a2 = 0;
      break;
  }
  v6 = v12[0];
  if ( !v12[0] )
    goto LABEL_10;
  if ( access(v12[0], 4) )
  {
    v6 = v12[0];
LABEL_10:
    trace(1, (int)"switch_language: %s was not found!\n", v6);
    if ( v12[0] )
    {
      free2(v12[0]);
      v12[0] = 0;
    }
    return -1;
  }
  trace(1, (int)"switch_language: %s\n", v12[0]);
  doSystem((int)"htmlunpack %s %s", v12[0], "/etc_ro/web");
  if ( v12[0] )
  {
    free2(v12[0]);
    v12[0] = 0;
  }
  if ( a2 != v5 )
  {
    LOBYTE(v11[0]) = a2;
    v8 = open("/dev/gpio", 0);
    v9 = v8;
    if ( v8 >= 0 )
    {
      ioctl(v8, 10737, v11);
      close(v9);
    }
  }
  if ( a1 )
  {
    websDisableErrorMessage();
    websEndAuthentication();
    websStartAuthentication();
    websEnableErrorMessage();
  }
  WebCurrentLanguage = a2;
  return 0;
}
// 4E4E14: using guessed type int WebCurrentLanguage;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9F50: using guessed type int   access(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA0C0: using guessed type int   ioctl(_DWORD, _DWORD, _DWORD);

//----- (004141D4) --------------------------------------------------------
_BYTE *  ParseSetPoition(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _BYTE *a5)
{
  _BYTE *result; // $v0

  result = a5;
  *a4 = a5;
  *a3 = a5;
  if ( a1 )
  {
    *a2 = a1;
    result = (_BYTE *)((int (*)(void))strrchr)();
    if ( result )
    {
      *result = 0;
      *a4 = result + 1;
      result = (_BYTE *)strrchr(a1, 47);
      if ( result )
        *result++ = 0;
      *a3 = result;
    }
  }
  else
  {
    *a2 = a5;
  }
  return result;
}
// 4EA028: using guessed type int   strrchr(_DWORD, _DWORD);

//----- (00414298) --------------------------------------------------------
_BYTE *  skipSpace(_BYTE *a1)
{
  _BYTE *result; // $v0

  result = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      result = a1;
      if ( (isspace(2 * (char)*a1)) == 0 )
        return result;
      do
        ++a1;
      while ( *a1 && (isspace(2 * (char)*a1)) != 0 );
    }
    return a1;
  }
  return result;
}
// 4EA098: using guessed type int _ctype_b;

//----- (00414324) --------------------------------------------------------
int *  websSetVar(int a1, char *a2, char *a3)
{
  int *result; // $v0
  int v7; // $v0
  _DWORD *v8; // $s0
  void *v9; // $s3
  int *v10; // $s0
  _DWORD *i; // $s0
  int *v12; // $s0
  int v13; // $a0
  int v14; // $a0

  trace(2, (int)"websSetVar=(%s,%s)\n", a2, a3);
  if ( !a2 )
    return trace(16, (int)"websSetVar with null var\n");
  if ( a3 )
  {
    if ( (unsigned int)strlen(a3) < 0x801 )
    {
      v7 = strdupWithoutNull(a3);
      v8 = *(_DWORD **)(a1 + 132);
      v9 = (void *)v7;
      while ( 1 )
      {
        if ( !v8 )
        {
          result = (int *)mmalloc(12);
          v10 = result;
          if ( result )
          {
            result[1] = strdupWithoutNull(a2);
            result = (int *)strdupWithoutNull(v9);
            v10[2] = (int)result;
            *v10 = *(_DWORD *)(a1 + 132);
            *(_DWORD *)(a1 + 132) = v10;
          }
          goto LABEL_21;
        }
        if ( !strcasecmp(a2, v8[1]) )
          break;
        v8 = (_DWORD *)*v8;
      }
      v13 = v8[2];
      if ( v13 )
      {
        free2(v13);
        v8[2] = 0;
      }
      result = (int *)strdupWithoutNull(v9);
      v8[2] = result;
LABEL_21:
      if ( v9 )
        return (int *)free2(v9);
    }
    else
    {
      return trace(16, (int)"websSetVar out of length(%s)\n", a3);
    }
  }
  else
  {
    for ( i = *(_DWORD **)(a1 + 132); ; i = (_DWORD *)*i )
    {
      if ( !i )
      {
        result = (int *)mmalloc(12);
        v12 = result;
        if ( result )
        {
          result[1] = strdupWithoutNull(a2);
          result = (int *)strdupWithoutNull(&unk_4A2DDC);
          v12[2] = (int)result;
          *v12 = *(_DWORD *)(a1 + 132);
          *(_DWORD *)(a1 + 132) = v12;
        }
        return result;
      }
      if ( !strcasecmp(a2, i[1]) )
        break;
    }
    v14 = i[2];
    if ( v14 )
    {
      free2(v14);
      i[2] = 0;
    }
    result = (int *)strdupWithoutNull(&unk_4A2DDC);
    i[2] = result;
  }
  return result;
}
// 41453C: conditional instruction was optimized away because $s0.4!=0
// 4145C0: conditional instruction was optimized away because $s0.4!=0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);

//----- (0041462C) --------------------------------------------------------
int   websTestVar(int a1, int a2)
{
  _DWORD *i; // $s0

  for ( i = *(_DWORD **)(a1 + 132); ; i = (_DWORD *)*i )
  {
    if ( !i )
      return 0;
    if ( !strcasecmp(a2, i[1]) )
      break;
  }
  return 1;
}
// 41469C: conditional instruction was optimized away because $s0.4!=0
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);

//----- (004146B8) --------------------------------------------------------
int   websGetVar(int a1, int a2, int a3)
{
  _DWORD *i; // $s0
  int result; // $v0

  for ( i = *(_DWORD **)(a1 + 132); ; i = (_DWORD *)*i )
  {
    result = a3;
    if ( !i )
      break;
    if ( !strcasecmp(a2, i[1]) )
      return i[2];
  }
  return result;
}
// 414730: conditional instruction was optimized away because $s0.4!=0
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);

//----- (00414754) --------------------------------------------------------
BOOL   websTestVarValue(int a1, int a2, int a3)
{
  _DWORD *v3; // $s1
  _DWORD *v6; // $s0
  bool v8; // dc
  _DWORD *v9; // $s0
  void *v10; // $a1

  v3 = *(_DWORD **)(a1 + 132);
  v6 = v3;
  if ( v3 )
  {
    while ( strcasecmp(a2, v6[1]) )
    {
      v6 = (_DWORD *)*v6;
      if ( !v6 )
        return 0;
    }
  }
  v8 = v6 == 0;
  v9 = v3;
  if ( v8 )
    return 0;
  if ( !v3 )
    goto LABEL_9;
  while ( strcasecmp(a2, v9[1]) )
  {
    v9 = (_DWORD *)*v9;
    if ( !v9 )
      goto LABEL_9;
  }
  if ( v9 )
    v10 = (void *)v9[2];
  else
LABEL_9:
    v10 = &unk_4A2DDC;
  return strcasecmp(a3, v10) == 0;
}
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);

//----- (0041486C) --------------------------------------------------------
void   websDeleteVar(int a1, char *a2)
{
  int *v4; // $s0
  int *v5; // $s3
  _DWORD *v6; // $s1
  int v7; // $a0
  int v8; // $a0

  if ( a2 )
  {
    v4 = *(int **)(a1 + 132);
    v5 = v4;
    v6 = v4;
    while ( v4 )
    {
      if ( !strcasecmp(a2, v4[1]) )
      {
        if ( v5 == v4 )
          *(_DWORD *)(a1 + 132) = *v4;
        else
          *v6 = *v4;
        trace(2, (int)"websDeleteVar=(%s,%s)\n", a2, (char *)v4[2]);
        v7 = v4[1];
        if ( v7 )
        {
          free2(v7);
          v4[1] = 0;
        }
        v8 = v4[2];
        if ( v8 )
        {
          free2(v8);
          v4[2] = 0;
        }
        free2(v4);
        return;
      }
      v6 = v4;
      v4 = (int *)*v4;
    }
  }
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);

//----- (004149D0) --------------------------------------------------------
int   websCloseVar(int a1)
{
  _DWORD *v1; // $s0
  int v3; // $a0
  int result; // $v0
  _DWORD *v5; // $s1
  int v6; // $v1

  v1 = *(_DWORD **)(a1 + 132);
  if ( !v1 )
  {
    *(_DWORD *)(a1 + 132) = 0;
    return result;
  }
  do
  {
    while ( 1 )
    {
      v5 = (_DWORD *)*v1;
      if ( v1[1] )
        break;
      v3 = v1[2];
      if ( v3 )
        goto LABEL_7;
LABEL_4:
      result = free2(v1);
      v1 = v5;
      if ( !v5 )
        goto LABEL_8;
    }
    free2(v1[1]);
    v6 = v1[2];
    v1[1] = 0;
    v3 = v6;
    if ( !v6 )
      goto LABEL_4;
LABEL_7:
    free2(v3);
    v1[2] = 0;
    result = free2(v1);
    v1 = v5;
  }
  while ( v5 );
LABEL_8:
  *(_DWORD *)(a1 + 132) = 0;
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00414AB4) --------------------------------------------------------
int   websParaDefine(void *a1, int a2)
{
  _DWORD *i; // $s0
  _DWORD *v5; // $s0

  for ( i = (_DWORD *)websParaFuncList; i; i = (_DWORD *)*i )
  {
    if ( !strcasecmp(a1, i[1]) )
    {
      i[2] = a2;
      return 0;
    }
  }
  v5 = (_DWORD *)mmalloc(12);
  if ( v5 )
  {
    v5[1] = strdupWithoutNull(a1);
    v5[2] = a2;
    *v5 = websParaFuncList;
    websParaFuncList = (int)v5;
  }
  return 0;
}
// 414B64: conditional instruction was optimized away because $s0.4!=0
// 4E41DC: using guessed type int websParaFuncList;
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);

//----- (00414B90) --------------------------------------------------------
int websParaOpen()
{
  formDefineInternet();
  formDefineWireless();
  formDefineDevice();
  formDefineMedia();
  return formDefineNetworkAPI();
}

//----- (00414C18) --------------------------------------------------------
int websParaClose()
{
  _DWORD *v0; // $s0
  int result; // $v0
  _DWORD *v2; // $s1

  v0 = (_DWORD *)websParaFuncList;
  if ( websParaFuncList )
  {
    do
    {
      while ( 1 )
      {
        v2 = (_DWORD *)*v0;
        if ( v0[1] )
          break;
        result = free2(v0);
        v0 = v2;
        if ( !v2 )
          goto LABEL_6;
      }
      free2(v0[1]);
      v0[1] = 0;
      result = free2(v0);
      v0 = v2;
    }
    while ( v2 );
LABEL_6:
    websParaFuncList = 0;
  }
  else
  {
    websParaFuncList = 0;
  }
  return result;
}
// 4E41DC: using guessed type int websParaFuncList;
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00414CCC) --------------------------------------------------------
int   websParaRequest(int a1, char *a2)
{
  int v3; // $s1
  int v4; // $s0
  int v5; // $a0
  _BYTE *v6; // $s5
  int v7; // $fp
  int v8; // $v0
  int v9; // $s0
  char *v10; // $a0
  char *v11; // $s1
  _BYTE *v12; // $v0
  char *v13; // $a0
  char *v14; // $s4
  int v15; // $v0
  char *v16; // $a0
  int v17; // $t2
  int v18; // $v1
  int v19; // $s0
  int v20; // $t7
  _BYTE *v21; // $v0
  _DWORD *v22; // $s2
  int v23; // $s3
  _BYTE *v24; // $s0
  _BYTE *v25; // $v0
  _DWORD *v26; // $v0
  int v27; // $s1
  int i; // $v1
  int v29; // $v0
  int j; // $a2
  _DWORD *k; // $s0
  int v32; // $v0
  int v33; // $s0
  int v34; // $a2
  int v35; // $a0
  int result; // $v0
  int v37; // $v0
  void (  *v38)(int, int, _DWORD *); // $t9
  char v39[56]; // [sp+18h] [-A0h] BYREF
  int v40; // [sp+50h] [-68h]
  int v41; // [sp+B0h] [-8h]
  int v42; // [sp+B4h] [-4h]

  v41 = 0;
  v42 = 0;
  v3 = -1;
  if ( stat(a2, v39) < 0 )
  {
    websConnError(a1, 500, (int)"Can't stat %s", a2);
    goto LABEL_64;
  }
  v4 = v40;
  v41 = mmalloc(v40 + 1);
  if ( !v41 )
  {
    websConnError(a1, 503, (int)"Can't allocate buffer");
    goto LABEL_64;
  }
  *(_BYTE *)(v41 + v4) = 0;
  if ( read(*(_DWORD *)(a1 + 256), v41, v4) == v4 )
  {
    v5 = *(_DWORD *)(a1 + 256);
    if ( v5 >= 0 )
    {
      close(v5);
      *(_DWORD *)(a1 + 256) = -1;
    }
    v42 = strndupWithoutNull(v41, v4);
    if ( !v42 )
    {
      websConnError(a1, 503, (int)"Can't allocate memory");
      goto LABEL_64;
    }
    v6 = (_BYTE *)v42;
    v7 = 0;
    while ( *v6 )
    {
      v8 = strstr(v6, "%%");
      v9 = v8;
      if ( !v8 )
        break;
      websWriteComplete(a1, (int)v6, v8 - (_DWORD)v6);
      v10 = (char *)(v9 + 2);
      v11 = 0;
      if ( v9 != -2 )
      {
        if ( *(_BYTE *)(v9 + 2) )
        {
          v11 = (char *)(v9 + 2);
          if ( (isspace(2 * *(char *)(v9 + 2))) == 0 )
            goto LABEL_16;
          do
            ++v10;
          while ( *v10 && (isspace(2 * *v10)) != 0 );
        }
        v11 = v10;
      }
LABEL_16:
      v12 = (_BYTE *)strstr(v11, "%%");
      v6 = v12 + 2;
      if ( !v12 )
      {
        websConnError(a1, 500, (int)"Unterminated script in %s: \n", a2);
        v3 = -1;
        goto LABEL_64;
      }
      v13 = v11;
      *v12 = 0;
      v14 = 0;
      if ( v11 )
      {
        if ( *v11 )
        {
          v14 = v11;
          if ( (isspace(2 * *v11)) == 0 )
            goto LABEL_23;
          do
            ++v13;
          while ( *v13 && (isspace(2 * *v13)) != 0 );
        }
        v14 = v13;
      }
LABEL_23:
      v15 = *(unsigned __int8 *)v14;
      v16 = (char *)v14;
      if ( *v14 )
      {
        v17 = v15 << 24;
        while ( 1 )
        {
          if ( v17 >> 24 == 92 && ((v32 = v16[1], v32 == 13) || v32 == 10) )
          {
            *v16++ = 32;
            v18 = (unsigned __int8)*v16;
            if ( (char)v18 == 13 || (v19 = v18 << 24, (char)v18 == 10) )
            {
              do
              {
                do
                {
                  *v16++ = 32;
                  v18 = (unsigned __int8)*v16;
                }
                while ( (char)v18 == 13 );
              }
              while ( (char)v18 == 10 );
              v20 = (char)v18;
              goto LABEL_28;
            }
          }
          else
          {
            v18 = (unsigned __int8)*++v16;
            v19 = v18 << 24;
          }
          v20 = v19 >> 24;
LABEL_28:
          v17 = v18 << 24;
          if ( !v20 )
          {
            LOBYTE(v15) = *v14;
            break;
          }
        }
      }
      if ( !(_BYTE)v15 )
        continue;
      v21 = (_BYTE *)strrchr(v14, 40);
      v22 = 0;
      v23 = 0;
      if ( v21 )
      {
        v24 = v21 + 1;
        *v21 = 0;
        v25 = (_BYTE *)strrchr(v21 + 1, 41);
        if ( v25 )
          *v25 = 0;
        v26 = (_DWORD *)mmalloc(12);
        v22 = v26;
        v27 = 3;
        if ( v26 )
        {
          for ( i = 2; i >= 0; --i )
            *v26++ = 0;
          v29 = strtok(v24, ",");
          for ( j = 0; v29; j = v23 )
          {
            ++v23;
            v22[j] = v29;
            if ( v23 >= v27 )
            {
              v33 = mmalloc(8 * v27);
              v34 = 4 * v27;
              if ( v33 )
              {
                v27 *= 2;
                memcpy(v33, v22, v34);
                if ( v22 )
                  free2(v22);
                v22 = (_DWORD *)v33;
              }
            }
            v29 = strtok(0, ",");
          }
        }
      }
      for ( k = (_DWORD *)websParaFuncList; ; k = (_DWORD *)*k )
      {
        if ( !k )
        {
          v7 = -1;
          goto LABEL_45;
        }
        if ( !strcasecmp(v14, k[1]) )
          break;
      }
      v38 = (void (  *)(int, int, _DWORD *))k[2];
      if ( v38 )
        v38(a1, v23, v22);
LABEL_45:
      if ( v22 )
        free2(v22);
      if ( v7 >= 0 )
        continue;
      websWriteFmt(a1, (int)"%s:NotSupport", v14);
      v7 = 0;
    }
    v3 = 0;
    if ( v6 && *v6 )
    {
      v37 = strlen(v6);
      websWriteComplete(a1, (int)v6, v37);
      v3 = 0;
    }
  }
  else
  {
    websConnError(a1, 500, (int)"Can't read %s", a2);
  }
LABEL_64:
  if ( websConnValid(a1) )
  {
    v35 = *(_DWORD *)(a1 + 256);
    if ( v35 >= 0 )
    {
      close(v35);
      *(_DWORD *)(a1 + 256) = -1;
    }
  }
  if ( v42 )
    free2(v42);
  result = v3;
  if ( v41 )
  {
    free2(v41);
    return v3;
  }
  return result;
}
// 414DCC: conditional instruction was optimized away because $fp.4==0
// 41510C: conditional instruction was optimized away because $fp.4==0
// 415368: conditional instruction was optimized away because $s0.4!=0
// 4E41DC: using guessed type int websParaFuncList;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F58: using guessed type int   stat(_DWORD, _DWORD);
// 4E9FCC: using guessed type int   strtok(_DWORD, _DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);
// 4E9FE0: using guessed type int   read(_DWORD, _DWORD, _DWORD);
// 4E9FEC: using guessed type int   strstr(_DWORD, _DWORD);
// 4EA028: using guessed type int   strrchr(_DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);
// 4EA098: using guessed type int _ctype_b;

//----- (004153B8) --------------------------------------------------------
int   websSetFormDefine(void *a1, int a2)
{
  _DWORD *i; // $s0
  _DWORD *v5; // $s0

  for ( i = (_DWORD *)websSetFormFuncList; i; i = (_DWORD *)*i )
  {
    if ( !strcasecmp(a1, i[1]) )
    {
      i[2] = a2;
      return 0;
    }
  }
  v5 = (_DWORD *)mmalloc(12);
  if ( v5 )
  {
    v5[1] = strdupWithoutNull(a1);
    v5[2] = a2;
    *v5 = websSetFormFuncList;
    websSetFormFuncList = (int)v5;
  }
  return 0;
}
// 415468: conditional instruction was optimized away because $s0.4!=0
// 4E41D8: using guessed type int websSetFormFuncList;
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);

//----- (00415494) --------------------------------------------------------
int websSetFormOpen()
{
  return formDefineManagement();
}

//----- (004154B0) --------------------------------------------------------
int websSetFormClose()
{
  _DWORD *v0; // $s0
  int result; // $v0
  _DWORD *v2; // $s1

  v0 = (_DWORD *)websSetFormFuncList;
  if ( websSetFormFuncList )
  {
    do
    {
      while ( 1 )
      {
        v2 = (_DWORD *)*v0;
        if ( v0[1] )
          break;
        result = free2(v0);
        v0 = v2;
        if ( !v2 )
          goto LABEL_6;
      }
      free2(v0[1]);
      v0[1] = 0;
      result = free2(v0);
      v0 = v2;
    }
    while ( v2 );
LABEL_6:
    websSetFormFuncList = 0;
  }
  else
  {
    websSetFormFuncList = 0;
  }
  return result;
}
// 4E41D8: using guessed type int websSetFormFuncList;
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00415564) --------------------------------------------------------
int   websSetFormProcessor(int a1, int a2, int a3, int a4, int a5)
{
  int v7; // $v0
  char *v8; // $s1
  _BYTE *v9; // $v0
  _DWORD *i; // $s0
  int result; // $v0
  void (  *v12)(int, char *, int); // $t9
  int v13; // $a1
  char v14; // [sp+18h] [-100h] BYREF
  _BYTE v15[255]; // [sp+19h] [-FFh] BYREF

  trace(1, (int)"websSetFormProcessor=%s\n", *(char **)(a1 + 136));
  strncpy(&v14, a4, 254);
  v7 = strchr(v15, 47);
  v8 = (char *)(v7 + 1);
  if ( !v7 )
  {
    websConnError(a1, 500, (int)"Missing form name");
    return 1;
  }
  v9 = (_BYTE *)strchr(v7 + 1, 47);
  if ( v9 )
    *v9 = 0;
  for ( i = (_DWORD *)websSetFormFuncList; ; i = (_DWORD *)*i )
  {
    if ( !i )
    {
      websConnError(a1, 500, (int)"Form %s is not defined", v8);
      return 1;
    }
    if ( !strcasecmp(v8, i[1]) )
      break;
  }
  v12 = (void (  *)(int, char *, int))i[2];
  if ( v12 )
    v12(a1, v8, a5);
  v13 = *(_DWORD *)(a1 + 292);
  result = 0;
  if ( v13 )
  {
    websConnError(a1, v13, (int)"Form %s is return error", v8);
    return 1;
  }
  return result;
}
// 415680: conditional instruction was optimized away because $s0.4!=0
// 4E41D8: using guessed type int websSetFormFuncList;
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);
// 4E9FD8: using guessed type int   strncpy(_DWORD, _DWORD, _DWORD);

//----- (004156F8) --------------------------------------------------------
int   websDecode64(int a1, char *a2, unsigned int a3)
{
  int v6; // $s3
  int result; // $v0
  int v8; // $v0
  int v9; // $s1
  char *v10; // $a0
  _BYTE *v11; // $a1
  int v12; // $v1
  char *v13; // $a0
  int v14; // $v0
  int v15; // $v1
  int v16; // $a2
  int v17; // $v1
  char *v18; // $a0
  int v19; // $v0
  int v20; // $v1
  int v21; // $a3
  int v22; // $t0
  int v23; // $a2
  int v24; // $t1
  char *v25; // $a0
  int v26; // $v0
  int v27; // $a2
  int v28; // $t0
  char v29; // $ra
  int v30; // $a2
  int v31; // $v0
  int v32; // $a2
  int v33; // $a3
  char v34; // $t6

  v6 = -1;
  if ( strlen(a2) >= a3 )
    return -1;
  v8 = mmalloc(a3);
  v9 = v8;
  if ( !v8 )
    return -1;
  v10 = a2;
  v11 = (_BYTE *)v8;
  while ( 1 )
  {
    v12 = *v10;
    v13 = v10 + 1;
    if ( !v12 )
      break;
    if ( v12 < 65 )
    {
      if ( v12 >= 58 )
      {
        v16 = (v12 != 0x3D) << 6;
        goto LABEL_12;
      }
      v14 = v12 + 4;
      if ( v12 >= 48 )
        goto LABEL_10;
      v16 = 62;
      if ( v12 != 43 )
        v16 = (v12 != 0x2F) + 63;
    }
    else
    {
      if ( v12 < 91 )
      {
        v14 = v12 - 65;
LABEL_10:
        v15 = v14 << 24;
LABEL_11:
        v16 = v15 >> 24;
        goto LABEL_12;
      }
      v16 = 64;
      if ( v12 >= 97 && v12 < 123 )
      {
        v15 = (v12 - 71) << 24;
        goto LABEL_11;
      }
    }
LABEL_12:
    if ( v16 == 64 )
      goto LABEL_38;
    v17 = *v13;
    v18 = v13 + 1;
    if ( !v17 )
      goto LABEL_38;
    if ( v17 < 65 )
    {
      if ( v17 >= 58 )
      {
        v21 = (v17 != 0x3D) << 6;
        goto LABEL_19;
      }
      v19 = v17 + 4;
      if ( v17 >= 48 )
        goto LABEL_17;
      v21 = 62;
      if ( v17 != 43 )
        v21 = (v17 != 0x2F) + 63;
    }
    else
    {
      if ( v17 < 91 )
      {
        v19 = v17 - 65;
LABEL_17:
        v20 = v19 << 24;
LABEL_18:
        v21 = v20 >> 24;
        goto LABEL_19;
      }
      v21 = 64;
      if ( v17 >= 97 && v17 < 123 )
      {
        v20 = (v17 - 71) << 24;
        goto LABEL_18;
      }
    }
LABEL_19:
    if ( v21 == 64 )
      goto LABEL_38;
    v22 = (4 * v16) | (v21 >> 4);
    v23 = *v18;
    v24 = (char)v22;
    v25 = v18 + 1;
    if ( !v23 )
      goto LABEL_38;
    if ( v23 < 65 )
    {
      if ( v23 >= 58 )
      {
        v28 = (v23 != 0x3D) << 6;
        goto LABEL_26;
      }
      if ( v23 >= 48 )
      {
        v26 = v23 + 4;
LABEL_24:
        v27 = v26 << 24;
LABEL_25:
        v28 = v27 >> 24;
        goto LABEL_26;
      }
      v28 = 62;
      if ( v23 != 43 )
        v28 = (v23 != 0x2F) + 63;
    }
    else
    {
      if ( v23 < 91 )
      {
        v26 = v23 - 65;
        goto LABEL_24;
      }
      v28 = 64;
      if ( v23 >= 97 && v23 < 123 )
      {
        v27 = (v23 - 71) << 24;
        goto LABEL_25;
      }
    }
LABEL_26:
    v29 = v21 & 0xF;
    if ( v28 == 64 )
      goto LABEL_38;
    v30 = *v25;
    v10 = v25 + 1;
    if ( !v30 )
      goto LABEL_38;
    if ( v30 < 65 )
    {
      if ( v30 >= 58 )
      {
        v33 = (v30 != 0x3D) << 6;
        goto LABEL_33;
      }
      v31 = v30 + 4;
      if ( v30 < 48 )
      {
        v33 = 62;
        if ( v30 != 43 )
          v33 = (v30 != 0x2F) + 63;
        goto LABEL_33;
      }
    }
    else
    {
      if ( v30 >= 91 )
      {
        v33 = 64;
        if ( v30 < 97 || v30 >= 123 )
          goto LABEL_33;
        v32 = (v30 - 71) << 24;
        goto LABEL_32;
      }
      v31 = v30 - 65;
    }
    v32 = v31 << 24;
LABEL_32:
    v33 = v32 >> 24;
LABEL_33:
    if ( v33 == 64 )
      goto LABEL_38;
    v34 = v33 | ((v28 & 3) << 6);
    *v11 = v24;
    if ( v24 )
    {
      v11[1] = (16 * v29) | (v28 >> 2);
      if ( (unsigned __int8)(16 * v29) | (unsigned __int8)(v28 >> 2) )
      {
        v11[2] = v34;
        v11 += 3;
        if ( v34 )
          continue;
      }
    }
    goto LABEL_37;
  }
  *v11 = 0;
LABEL_37:
  strncpy(a1, v9, a3 - 1);
  v6 = 0;
LABEL_38:
  result = v6;
  if ( v9 )
  {
    free2(v9);
    return v6;
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FD8: using guessed type int   strncpy(_DWORD, _DWORD, _DWORD);

//----- (00415A98) --------------------------------------------------------
int   websEncode64(_BYTE *a1, char *a2, int a3)
{
  char v3; // $t0
  int result; // $v0
  unsigned int v5; // $t2
  int v6; // $v1
  _BYTE *v7; // $a2
  int v8; // $a3
  char v9; // $t3
  int v10; // $t1
  char v11; // $t0
  int v12; // $a3
  unsigned int i; // $v1
  int v14; // $v1
  int v15; // $t2

  *a1 = 0;
  v3 = *a2;
  result = *a2;
  v5 = 0;
  if ( *a2 )
  {
    v6 = v3;
    v7 = &a1[a3];
    do
    {
      v8 = 2;
      if ( v6 )
      {
        result = v3;
        v9 = 16;
        do
        {
          --v8;
          v5 |= (unsigned __int8)result << v9;
          ++a2;
          if ( v8 < 0 )
            break;
          result = *a2;
          v9 = 8 * v8;
        }
        while ( *a2 );
      }
      v10 = v8 + 1;
      v11 = 18;
      v12 = v8 + 1;
      if ( v12 < 4 )
      {
        for ( i = v5 >> 18; a1 < v7; i = v5 >> v11 )
        {
          result = i & 0x3F;
          ++v12;
          *a1++ = byte_4E4E88[result];
          v11 -= 6;
          if ( v12 >= 4 )
            break;
        }
      }
      v14 = v10 - 1;
      if ( v10 > 0 )
      {
        do
        {
          v15 = v14;
          *a1 = 61;
          --v14;
          ++a1;
        }
        while ( v15 > 0 );
      }
      *a1 = 0;
      v3 = *a2;
      v6 = *a2;
      v5 = 0;
    }
    while ( *a2 );
  }
  return result;
}
// 4E4E88: using guessed type _BYTE byte_4E4E88[64];

//----- (00415BA4) --------------------------------------------------------
int   websReplacePathIntrenal(int a1)
{
  _DWORD *v2; // $s1
  int v3; // $s4
  void *v4; // $s0
  int v5; // $a0
  void *v6; // $s2
  int result; // $v0
  int v8; // $v0
  int v9; // $s0
  int v10; // $a0
  bool v11; // dc
  int v12; // [sp+20h] [-8h] BYREF

  v2 = &websReplacePathList;
  v3 = 403;
  strlower(*(_BYTE **)(a1 + 136));
  *(_DWORD *)(a1 + 144) = strdupWithoutNull(*(void **)(a1 + 136));
  v4 = off_4E4620;
  if ( off_4E4620 )
  {
    while ( 1 )
    {
      v5 = *(_DWORD *)(a1 + 136);
      v6 = (void *)v2[2];
      if ( v5 )
      {
        if ( v4 && !webncasestrcmp(v5, (int)v4) )
        {
          if ( !webncasestrcmp((int)"/NULLVDO.HTM", (int)v4) )
          {
            websSetVar(a1, "ReplySuccessPage", "setvdo.htm");
            websSetVar(a1, "ReplyErrorPage", "errrvdo.htm");
          }
          v8 = strdupWithoutNull(v6);
          v9 = v8;
          if ( v8 )
            break;
        }
      }
      v2 += 3;
      v4 = (void *)v2[1];
      if ( !v4 )
        goto LABEL_5;
    }
    v10 = *(_DWORD *)(a1 + 136);
    if ( v10 )
    {
      free2(v10);
      *(_DWORD *)(a1 + 136) = v9;
    }
    else
    {
      *(_DWORD *)(a1 + 136) = v8;
    }
    v3 = 0;
    v11 = *v2 != 0;
    *(_DWORD *)(a1 + 196) = *v2;
    if ( v11 )
      return v3;
  }
  else
  {
LABEL_5:
    if ( *(_DWORD *)(a1 + 196) )
      return v3;
  }
  if ( !webncasestrcmp(a1 + 68, (int)"text/html")
    || !webncasestrcmp(a1 + 68, (int)"image/gif")
    || !webncasestrcmp(a1 + 68, (int)"image/jpeg")
    || !webncasestrcmp(a1 + 68, (int)"image/png")
    || !webncasestrcmp(a1 + 68, (int)"text/css")
    || !webncasestrcmp(a1 + 68, (int)"application/x-javascript")
    || (v11 = webncasestrcmp(a1 + 68, (int)"image/vnd.microsoft.icon") != 0, result = v3, !v11) )
  {
    allocFmtString(&v12, 256, (int)"%s%s", "/etc_ro/web", *(char **)(a1 + 144));
    result = v3;
    if ( v12 )
    {
      if ( !access(v12, 4) )
      {
        v3 = 0;
        *(_DWORD *)(a1 + 196) = 1;
      }
      result = v3;
      if ( v12 )
      {
        free2(v12);
        v12 = 0;
        return v3;
      }
    }
  }
  return result;
}
// 4E4620: using guessed type _UNKNOWN *off_4E4620;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F50: using guessed type int   access(_DWORD, _DWORD);

//----- (00415F10) --------------------------------------------------------
int   websInternalForwardURL(int *a1)
{
  int v2; // $v0
  char *v3; // $s2
  int v4; // $s0
  int v5; // $s3
  int result; // $v0
  int v7; // $v1
  int v8; // $s0
  int v9; // $a0
  int v10; // $v1

  v2 = nvram_bufget(0, "ViewMode");
  v3 = 0;
  v4 = atoi(v2);
  v5 = 0;
  if ( !webncasestrcmp(a1[34], (int)ForwardHome) )
  {
    switch ( v4 )
    {
      case 1:
        goto LABEL_7;
      case 2:
        v3 = "/jview.htm";
        break;
      case 3:
      case 5:
      case 6:
        v5 = 1;
        if ( !websTestVar((int)a1, (int)"Profile") )
        {
          if ( v4 == 6 )
          {
            websSetVar((int)a1, "Profile", "3");
          }
          else if ( v4 == 5 )
          {
            websSetVar((int)a1, "Profile", "2");
          }
          else
          {
            websSetVar((int)a1, "Profile", "1");
          }
        }
        break;
      default:
LABEL_7:
        v3 = "/top.htm";
        break;
    }
  }
  if ( v5 != 1 )
  {
    result = webncasestrcmp(a1[34], (int)ForwardH264);
    if ( result )
    {
      if ( !v3 )
        return result;
      goto LABEL_13;
    }
  }
  v7 = a1[60];
  if ( v7 != 1 )
  {
    if ( v7 == 2 )
    {
      v10 = a1[61];
      if ( v10 == 9 || v10 == 7 || v10 == 5 )
        v3 = "/hfview.htm";
      else
        v3 = "/hmview.htm";
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if ( (unsigned int)(a1[61] - 2) >= 2 )
  {
LABEL_12:
    v3 = "/hjview.htm";
    goto LABEL_13;
  }
  v3 = "/aview.htm";
LABEL_13:
  result = strdupWithoutNull(v3);
  v8 = result;
  if ( result )
  {
    v9 = a1[34];
    if ( v9 )
    {
      result = free2(v9);
      a1[34] = v8;
    }
    else
    {
      a1[34] = result;
    }
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00416194) --------------------------------------------------------
void   websKernalParameter(int a1)
{
  int *v1; // $s0
  char *v2; // $a1
  int v4; // $a0
  int v5; // $s1
  void *v6; // $s2
  int v7; // $v1
  int v8; // $v0
  int v9; // $v0
  int v10; // $s1
  int v11; // $a0

  v1 = (int *)websPostCgiList;
  v2 = off_4E4244[0];
  if ( off_4E4244[0] )
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)(a1 + 136);
      v5 = *v1;
      v6 = (void *)v1[2];
      v7 = 0;
      if ( v4 )
      {
        if ( v2 )
        {
          v8 = webncasestrcmp(v4, (int)v2);
          v7 = 0;
          if ( v8 )
            goto LABEL_5;
          if ( v5 )
          {
            v9 = websTestVar(a1, v5);
            v7 = 0;
            if ( !v9 )
              goto LABEL_5;
          }
          v10 = strdupWithoutNull(v6);
          if ( v10 )
          {
            websSetVar(a1, "ReplySuccessPage", *(char **)(a1 + 136));
            websSetVar(a1, "ReplyErrorPage", *(char **)(a1 + 136));
            v11 = *(_DWORD *)(a1 + 136);
            if ( v11 )
              free2(v11);
            v7 = 1;
            *(_DWORD *)(a1 + 136) = v10;
            goto LABEL_5;
          }
        }
        v7 = 0;
      }
LABEL_5:
      v1 += 3;
      if ( v7 != 1 )
      {
        v2 = (char *)v1[1];
        if ( v2 )
          continue;
      }
      return;
    }
  }
}
// 4E4240: using guessed type char *websPostCgiList[51];
// 4E4244: using guessed type char *off_4E4244[50];
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00416310) --------------------------------------------------------
BOOL   checkASPFile(int a1)
{
  return !strcmp(a1, ".asp")
      || !strcmp(a1, ".htm")
      || !strcmp(a1, ".html")
      || !strcmp(a1, ".cgi")
      || strcmp(a1, ".m3u8") == 0;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (004163F0) --------------------------------------------------------
int   checkPatchFile(int a1)
{
  _DWORD *v1; // $s0
  char *v2; // $a1

  v1 = &websPathFileList;
  v2 = off_4E4234;
  if ( !off_4E4234 )
    return 0;
  while ( webncasestrcmp(*(_DWORD *)(a1 + 136), (int)v2) )
  {
    v1 += 2;
    v2 = (char *)v1[1];
    if ( !v2 )
      return 0;
  }
  *(_DWORD *)(a1 + 276) = *v1;
  return 1;
}
// 4E4234: using guessed type char *off_4E4234;

//----- (00416498) --------------------------------------------------------
int   checkCgiPostRequest(int a1)
{
  int *v1; // $s0
  int v3; // $a1
  int result; // $v0
  bool v5; // dc

  v1 = (int *)&websCgiPostRequestList;
  do
  {
    v3 = *v1;
    result = 0;
    if ( !*v1 )
      break;
    ++v1;
    v5 = webncasestrcmp(*(_DWORD *)(a1 + 136), v3) != 0;
    result = 1;
  }
  while ( v5 );
  return result;
}
// 4E4228: using guessed type char *websCgiPostRequestList;

//----- (00416514) --------------------------------------------------------
int   checkSessionKeyRequest(int a1)
{
  int *v1; // $s0
  int v3; // $a1
  int result; // $v0
  bool v5; // dc

  v1 = (int *)&websForceCheckSessionKeyList;
  do
  {
    v3 = *v1;
    result = 0;
    if ( !*v1 )
      break;
    ++v1;
    v5 = webncasestrcmp(*(_DWORD *)(a1 + 144), v3) != 0;
    result = 1;
  }
  while ( v5 );
  return result;
}
// 4E41E0: using guessed type _UNKNOWN *websForceCheckSessionKeyList;

//----- (00416590) --------------------------------------------------------
int websEnableErrorMessage()
{
  int v0; // $s3
  int v1; // $s0
  int result; // $v0
  int v3; // $s1
  int v4; // $v0
  int v5; // $a1
  int *v6; // $s0
  _BYTE v7[512]; // [sp+20h] [-208h] BYREF
  int v8; // [sp+220h] [-8h] BYREF

  v8 = 0;
  allocFmtString(&v8, 254, (int)"%s%s", "/etc_ro/web", WebErrMsgFile);
  v0 = 1;
  v1 = 0;
  if ( !v8 )
    return v0;
  v3 = fopen(v8, "r");
  if ( v3 )
  {
    while ( fgets(v7, 512, v3) )
    {
      while ( v7[0] != 59 )
      {
        ++v1;
        if ( !fgets(v7, 512, v3) )
          goto LABEL_8;
      }
    }
LABEL_8:
    fseek(v3, 0, 0);
    v4 = mmalloc(4 * v1);
    if ( v4 )
    {
      WebErrMsgList = v4;
      WebErrMsgCount = v1;
      v6 = (int *)v4;
      while ( fgets(v7, 512, v3) )
      {
        while ( v7[0] != 59 )
        {
          *v6++ = strdupWithoutNull(v7);
          if ( !fgets(v7, 512, v3) )
            goto LABEL_13;
        }
      }
    }
LABEL_13:
    fclose(v3);
    v0 = 0;
  }
  result = v0;
  if ( v8 )
  {
    free2(v8);
    v8 = 0;
    return v0;
  }
  return result;
}
// 41674C: variable 'v5' is possibly undefined
// 4E4E18: using guessed type int WebErrMsgCount;
// 4E4E1C: using guessed type int WebErrMsgList;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F98: using guessed type int   fclose(_DWORD);
// 4E9FA8: using guessed type int   fopen(_DWORD, _DWORD);
// 4E9FF8: using guessed type int   fseek(_DWORD, _DWORD, _DWORD);
// 4EA084: using guessed type int   fgets(_DWORD, _DWORD, _DWORD);

//----- (00416788) --------------------------------------------------------
int websDisableErrorMessage()
{
  int v0; // $s3
  int result; // $v0
  int v2; // $s1
  _DWORD *v3; // $s0

  v0 = WebErrMsgList;
  if ( WebErrMsgList )
  {
    result = WebErrMsgCount;
    v2 = 0;
    if ( WebErrMsgCount > 0 )
    {
      v3 = (_DWORD *)WebErrMsgList;
      do
      {
        while ( 1 )
        {
          ++v2;
          if ( *v3 )
            break;
          ++v3;
          if ( v2 >= WebErrMsgCount )
            goto LABEL_7;
        }
        result = free2(*v3);
        *v3++ = 0;
      }
      while ( v2 < WebErrMsgCount );
    }
LABEL_7:
    if ( v0 )
      result = free2(v0);
    WebErrMsgList = 0;
    WebErrMsgCount = 0;
  }
  return result;
}
// 4E4E18: using guessed type int WebErrMsgCount;
// 4E4E1C: using guessed type int WebErrMsgList;
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00416878) --------------------------------------------------------
void *  websGetErrorMessage(int a1)
{
  void *v2; // $a3
  int v3; // $a0

  v2 = &unk_4A2DDC;
  if ( a1 >= 0 )
  {
    v3 = 4 * a1 + WebErrMsgList;
    if ( a1 < WebErrMsgCount )
      return *(void **)v3;
  }
  return v2;
}
// 4E4E18: using guessed type int WebErrMsgCount;
// 4E4E1C: using guessed type int WebErrMsgList;

//----- (004168C4) --------------------------------------------------------
_DWORD *  umGetUser(int a1)
{
  _DWORD *i; // $s0
  bool v3; // dc
  _DWORD *result; // $v0

  for ( i = (_DWORD *)WebAuthUserList; ; i = (_DWORD *)*i )
  {
    result = i;
    if ( !i )
      break;
    v3 = strcmp(a1, i[2]) == 0;
    result = i;
    if ( v3 )
      break;
  }
  return result;
}
// 4E4E24: using guessed type int WebAuthUserList;
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (00416938) --------------------------------------------------------
int   umAddUser(void *a1, void *a2, int a3)
{
  _DWORD *i; // $s0
  _DWORD *v7; // $s0
  int result; // $v0
  int v9; // $a0

  for ( i = (_DWORD *)WebAuthUserList; i; i = (_DWORD *)*i )
  {
    if ( !strcmp(a1, i[2]) )
    {
      v9 = i[3];
      i[1] = a3 + 1;
      if ( v9 )
      {
        free2(v9);
        i[3] = 0;
      }
      i[3] = strdupWithoutNull(a2);
      return 0;
    }
  }
  v7 = (_DWORD *)mmalloc(16);
  result = -1;
  if ( !v7 )
    return result;
  v7[1] = a3 + 1;
  v7[2] = strdupWithoutNull(a1);
  v7[3] = strdupWithoutNull(a2);
  *v7 = WebAuthUserList;
  WebAuthUserList = (int)v7;
  return 0;
}
// 416A2C: conditional instruction was optimized away because $s0.4!=0
// 4E4E24: using guessed type int WebAuthUserList;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (00416A7C) --------------------------------------------------------
void   umDelUser(int a1)
{
  int *v2; // $s0
  int *v3; // $s2
  int v4; // $s1
  int v5; // $a0

  v2 = (int *)WebAuthUserList;
  v3 = (int *)WebAuthUserList;
  while ( v2 )
  {
    v4 = v2[2];
    if ( !strcmp(a1, v4) )
    {
      if ( v3 == (int *)WebAuthUserList )
      {
        WebAuthUserList = *v2;
        v4 = v2[2];
      }
      else
      {
        *v3 = *v2;
      }
      if ( v4 )
      {
        free2(v4);
        v2[2] = 0;
      }
      v5 = v2[3];
      if ( v5 )
      {
        free2(v5);
        v2[3] = 0;
      }
      free2(v2);
      return;
    }
    v3 = v2;
    v2 = (int *)*v2;
  }
}
// 4E4E24: using guessed type int WebAuthUserList;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (00416BC8) --------------------------------------------------------
int websEnableAllUser()
{
  int i; // $s3
  int result; // $v0
  void *v2; // $a0
  void *v3; // $s1
  _BYTE *v4; // $s2
  int v5; // $s5
  int v6; // $s4
  _BYTE *v7; // $v0
  _DWORD *j; // $s0
  _DWORD *v9; // $s0
  int v10; // $a0
  _BYTE v11[64]; // [sp+18h] [-40h] BYREF

  for ( i = 1; i < 9; ++i )
  {
    while ( 1 )
    {
      snprintf(v11, 64, "User%d", i);
      result = nvram_bufget(0, v11);
      v2 = (void *)result;
      if ( result )
      {
        result = *(unsigned __int8 *)result;
        if ( result )
        {
          v3 = v2;
          v4 = (_BYTE *)strchr();
          result = strdupWithoutNull(v3);
          v5 = result;
          if ( result )
          {
            v6 = 0;
            if ( v4 )
            {
              *v4++ = 0;
              v7 = (_BYTE *)strrchr(v4, 47);
              if ( !v7 || (*v7 = 0, v7 == (_BYTE *)-1) )
                v6 = 0;
              else
                v6 = (char)v7[1] - 48;
            }
            for ( j = (_DWORD *)WebAuthUserList; ; j = (_DWORD *)*j )
            {
              if ( !j )
              {
                result = mmalloc(16);
                v9 = (_DWORD *)result;
                if ( result )
                {
                  *(_DWORD *)(result + 4) = v6 + 1;
                  *(_DWORD *)(result + 8) = strdupWithoutNull(v3);
                  result = strdupWithoutNull(v4);
                  v9[3] = result;
                  *v9 = WebAuthUserList;
                  WebAuthUserList = (int)v9;
                }
                goto LABEL_16;
              }
              if ( !strcmp(v3, j[2]) )
                break;
            }
            v10 = j[3];
            j[1] = v6 + 1;
            if ( v10 )
            {
              free2(v10);
              j[3] = 0;
            }
            result = strdupWithoutNull(v4);
            j[3] = result;
LABEL_16:
            if ( v5 )
              break;
          }
        }
      }
      if ( ++i >= 9 )
        return result;
    }
    result = free2(v5);
  }
  return result;
}
// 416DD4: conditional instruction was optimized away because $s0.4!=0
// 4E4E24: using guessed type int WebAuthUserList;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int strchr(void);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA028: using guessed type int   strrchr(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (00416E24) --------------------------------------------------------
int websDisableAllUser()
{
  _DWORD *v0; // $s0
  int v1; // $a0
  int result; // $v0
  _DWORD *v3; // $s1
  int v4; // $v1

  v0 = (_DWORD *)WebAuthUserList;
  if ( !WebAuthUserList )
  {
    WebAuthUserList = 0;
    return result;
  }
  do
  {
    while ( 1 )
    {
      v3 = (_DWORD *)*v0;
      if ( v0[2] )
        break;
      v1 = v0[3];
      if ( v1 )
        goto LABEL_7;
LABEL_4:
      result = free2(v0);
      v0 = v3;
      if ( !v3 )
        goto LABEL_8;
    }
    free2(v0[2]);
    v4 = v0[3];
    v0[2] = 0;
    v1 = v4;
    if ( !v4 )
      goto LABEL_4;
LABEL_7:
    free2(v1);
    v0[3] = 0;
    result = free2(v0);
    v0 = v3;
  }
  while ( v3 );
LABEL_8:
  WebAuthUserList = 0;
  return result;
}
// 4E4E24: using guessed type int WebAuthUserList;
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00416F10) --------------------------------------------------------
int websEnableHtmlFile()
{
  int v0; // $s0
  int result; // $v0
  int v2; // $s1
  int v3; // $a1
  _DWORD *v4; // $s0
  int v5; // $s3
  int v6; // $v0
  _DWORD *v7; // $s0
  _BYTE v8[2]; // [sp+20h] [-108h] BYREF
  char v9; // [sp+22h] [-106h]
  _BYTE v10[253]; // [sp+23h] [-105h] BYREF
  int v11; // [sp+120h] [-8h] BYREF

  v11 = 0;
  allocFmtString(&v11, 254, (int)"%s%s", "/etc_ro/web", WebAuthFile);
  v0 = 1;
  if ( !v11 )
    return v0;
  v2 = fopen(v11, "r");
  if ( v2 )
  {
LABEL_5:
    while ( fgets(v8, 256, v2) )
    {
      if ( (isspace(2 * v8[1])) != 0
        && (isdigit(2 * v9)) != 0
        && (isspace(2 * v10[0])) != 0 )
      {
        v10[0] = 47;
        strtok(v10, " \r\t\n");
        v4 = (_DWORD *)WebAuthFileList;
        v5 = v9 - 48;
        while ( v4 )
        {
          if ( !webncasestrcmp((int)v10, v4[2]) )
          {
            v4[1] = v5;
            goto LABEL_5;
          }
          v4 = (_DWORD *)*v4;
        }
        v6 = mmalloc(12);
        v7 = (_DWORD *)v6;
        if ( v6 )
        {
          *(_DWORD *)(v6 + 4) = v5;
          *(_DWORD *)(v6 + 8) = strdupWithoutNull(v10);
          *v7 = WebAuthFileList;
          WebAuthFileList = (int)v7;
        }
      }
    }
    fclose(v2);
    v0 = 0;
  }
  result = v0;
  if ( v11 )
  {
    free2(v11);
    v11 = 0;
    return v0;
  }
  return result;
}
// 417140: conditional instruction was optimized away because $s0.4!=0
// 417104: variable 'v3' is possibly undefined
// 4E4E20: using guessed type int WebAuthFileList;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F98: using guessed type int   fclose(_DWORD);
// 4E9FA8: using guessed type int   fopen(_DWORD, _DWORD);
// 4E9FCC: using guessed type int   strtok(_DWORD, _DWORD);
// 4EA084: using guessed type int   fgets(_DWORD, _DWORD, _DWORD);
// 4EA098: using guessed type int _ctype_b;

//----- (00417150) --------------------------------------------------------
int websStartAuthentication()
{
  int v0; // $v0

  v0 = nvram_bufget(0, "AccessControlEnable");
  if ( !strcmp(v0, &word_4A0308) )
    websEnableAllUser();
  return websEnableHtmlFile();
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (004171DC) --------------------------------------------------------
int websEndAuthentication()
{
  int v0; // $v0
  int result; // $v0
  _DWORD *v2; // $s0
  _DWORD *v3; // $s0
  _DWORD *v4; // $s1
  int v5; // $a2
  int v6; // $a0
  _DWORD *v7; // $s1

  v0 = nvram_bufget(0, "AccessControlEnable");
  result = strcmp(v0, &word_4A0308);
  if ( !result )
  {
    v2 = (_DWORD *)WebAuthUserList;
    if ( !WebAuthUserList )
    {
LABEL_3:
      WebAuthUserList = 0;
      goto LABEL_4;
    }
    while ( 1 )
    {
      v7 = (_DWORD *)*v2;
      if ( v2[2] )
      {
        free2(v2[2]);
        v5 = v2[3];
        v2[2] = 0;
        v6 = v5;
        if ( v5 )
          goto LABEL_14;
      }
      else
      {
        v6 = v2[3];
        if ( v6 )
        {
LABEL_14:
          free2(v6);
          v2[3] = 0;
        }
      }
      result = free2(v2);
      v2 = v7;
      if ( !v7 )
        goto LABEL_3;
    }
  }
LABEL_4:
  v3 = (_DWORD *)WebAuthFileList;
  if ( WebAuthFileList )
  {
    do
    {
      while ( 1 )
      {
        v4 = (_DWORD *)*v3;
        if ( v3[2] )
          break;
        result = free2(v3);
        v3 = v4;
        if ( !v4 )
          goto LABEL_9;
      }
      free2(v3[2]);
      v3[2] = 0;
      result = free2(v3);
      v3 = v4;
    }
    while ( v4 );
LABEL_9:
    WebAuthFileList = 0;
  }
  else
  {
    WebAuthFileList = 0;
  }
  return result;
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E4E20: using guessed type int WebAuthFileList;
// 4E4E24: using guessed type int WebAuthUserList;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0041735C) --------------------------------------------------------
int   websGetAuthenticateRealm(int a1)
{
  int v2; // $v0
  int v3; // $v1
  int result; // $v0
  _DWORD *v5; // $s0
  char *v6; // $a1
  BOOL v7; // $s1

  v2 = nvram_bufget(0, "HTTPAuthentication");
  v7 = atoi(v2) == 1;
  v3 = *(_DWORD *)(a1 + 196);
  if ( v3 == 4 || v3 == 1 )
    return 1;
  result = v7;
  if ( !v7 )
  {
    v5 = &websForceAuthenticPathList;
    v6 = off_4E45C8;
    if ( off_4E45C8 )
    {
      while ( webncasestrcmp(*(_DWORD *)(a1 + 136), (int)v6) )
      {
        v5 += 2;
        v6 = (char *)v5[1];
        result = 0;
        if ( !v6 )
          return result;
      }
      return *v5;
    }
  }
  return result;
}
// 4E45C8: using guessed type char *off_4E45C8;
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00417474) --------------------------------------------------------
int   websCheckRealm(int a1)
{
  int v2; // $s1
  int v3; // $v0
  void *v4; // $s7
  void *v5; // $a0
  int v6; // $s6
  char *v7; // $s3
  char *v8; // $s4
  int v9; // $fp
  char *v10; // $s5
  int v11; // $s0
  int result; // $v0
  _DWORD *i; // $s0
  int *v14; // $s0
  char *v15; // $a1
  int v16; // $v0
  int v17; // $v1
  int *v18; // $s0
  char *v19; // $a1
  int v20; // $s1
  int j; // $s1
  int v22; // $v0
  BOOL v23; // $a3
  int v24; // $s1
  _BYTE *v25; // $a0
  int v26; // $v1
  _DWORD *v27; // $s0
  int v28; // $t8
  char *v29; // $s0
  int v30; // $t8
  unsigned int v31; // $v1
  int v32; // $t3
  int v33; // $s0
  int v34; // $a0
  bool v35; // dc
  _BYTE *v36; // $v0
  unsigned int v37; // $v1
  int v38; // $a0
  int v39; // $s7
  int v40; // $s0
  int v41; // $v0
  int v42; // $a0
  _BYTE v43[24]; // [sp+28h] [-A0h] BYREF
  int v44; // [sp+40h] [-88h]
  int v45; // [sp+C0h] [-8h]
  int v46; // [sp+C4h] [-4h]

  v2 = nvram_bufget(0, "AdminID");
  v4 = (void *)nvram_bufget(0, "AdminPassword");
  v3 = nvram_bufget(0, "AccessControlEnable");
  v5 = *(void **)(a1 + 136);
  v45 = 0;
  v6 = v3;
  v7 = (char *)strdupWithoutNull(v5);
  v8 = (char *)strdupWithoutNull(*(void **)(a1 + 172));
  v9 = 3;
  v10 = (char *)strdupWithoutNull(*(void **)(a1 + 168));
  if ( !v2 && !v4 )
  {
    v11 = 0;
    goto LABEL_4;
  }
  if ( ((*(_DWORD *)(a1 + 228) >> 2) & 1) != 0 )
  {
    v11 = 0;
LABEL_4:
    *(_DWORD *)(a1 + 192) = 3;
    goto LABEL_5;
  }
  for ( i = (_DWORD *)WebAuthFileList; i; i = (_DWORD *)*i )
  {
    if ( !webncasestrcmp((int)v7, i[2]) )
    {
      v9 = i[1];
      v45 = 1;
      goto LABEL_21;
    }
  }
  v14 = (int *)&websAuthenticationPathList;
  v15 = off_4E4328;
  if ( off_4E4328 )
  {
    if ( v7 )
    {
      if ( !off_4E4328 )
        goto LABEL_20;
      while ( webncasestrcmp((int)v7, (int)v15) )
      {
LABEL_20:
        v14 += 2;
        v15 = (char *)v14[1];
        if ( !v15 )
          goto LABEL_21;
      }
      v9 = *v14;
      v35 = *v14 != 4;
      v45 = 1;
      if ( !v35 )
      {
        v36 = (_BYTE *)nvram_bufget(0, "SnapshotURLAuthentication");
        v9 = 1;
        if ( v36 )
        {
          if ( *v36 )
            v9 = strcmp(v36, "1") != 0;
        }
      }
    }
    else
    {
      v27 = &unk_4E432C;
      do
      {
        v28 = v27[1];
        v29 = (char *)(v27 + 2);
        if ( !v28 )
          break;
        v30 = *((_DWORD *)v29 + 1);
        v27 = v29 + 8;
      }
      while ( v30 );
    }
  }
LABEL_21:
  v16 = nvram_bufget(0, "HTTPAuthentication");
  v46 = atoi(v16) == 1;
  v17 = *(_DWORD *)(a1 + 196);
  if ( v17 == 4 || v17 == 1 )
  {
    v46 = 1;
  }
  else if ( !v46 )
  {
    v18 = (int *)&websForceAuthenticPathList;
    v19 = off_4E45C8;
    if ( off_4E45C8 )
    {
      while ( webncasestrcmp(*(_DWORD *)(a1 + 136), (int)v19) )
      {
        v18 += 2;
        v19 = (char *)v18[1];
        if ( !v19 )
          goto LABEL_27;
      }
      v46 = *v18;
    }
  }
LABEL_27:
  if ( v2 )
  {
    if ( v8 )
    {
      if ( !strcmp(v2, v8) )
      {
        v20 = strlen(v2);
        if ( v20 == strlen(v8) )
        {
          if ( v46 == 1 )
          {
            v32 = *(_DWORD *)(a1 + 228) >> 13;
          }
          else
          {
            v31 = *(_DWORD *)(a1 + 228);
            v32 = v31 >> 13;
            if ( ((v31 >> 12) & 1) != 0 )
            {
              if ( !v4 )
              {
                if ( !v10 )
                  *(_DWORD *)(a1 + 192) = 3;
                goto LABEL_31;
              }
              if ( !v10 )
                goto LABEL_31;
              v33 = strlen(v4);
              if ( v33 != strlen(v10) || strcmp(v4, v10) )
                goto LABEL_31;
              goto LABEL_69;
            }
          }
          if ( (v32 & 1) == 0 )
            goto LABEL_31;
          *(_DWORD *)(a1 + 168) = strdupWithoutNull(v4);
          if ( websCheckDigestRealm(a1) )
          {
            v34 = *(_DWORD *)(a1 + 168);
            if ( v34 )
            {
              free2(v34);
              *(_DWORD *)(a1 + 168) = 0;
            }
            goto LABEL_31;
          }
LABEL_69:
          *(_DWORD *)(a1 + 192) = 3;
        }
      }
    }
  }
LABEL_31:
  if ( !v6 )
  {
    v23 = v9 < 2;
    goto LABEL_49;
  }
  if ( !strcmp(v6, &word_4A0308) && !*(_DWORD *)(a1 + 192) && v8 )
  {
    for ( j = WebAuthUserList; ; j = *(_DWORD *)j )
    {
      if ( !j )
        goto LABEL_39;
      if ( !strcmp(v8, *(_DWORD *)(j + 8)) )
        break;
    }
    if ( v46 == 1 )
    {
      v38 = *(_DWORD *)(a1 + 228) >> 13;
    }
    else
    {
      v37 = *(_DWORD *)(a1 + 228);
      v38 = v37 >> 13;
      if ( ((v37 >> 12) & 1) != 0 )
      {
        if ( !v10 )
        {
          v41 = *(_DWORD *)(j + 12);
LABEL_85:
          if ( v41 )
            goto LABEL_39;
          goto LABEL_86;
        }
        v39 = *(_DWORD *)(j + 12);
        if ( v39 )
        {
          v40 = strlen(v10);
          if ( v40 == strlen(v39) )
          {
            v41 = strcmp(v10, v39);
            goto LABEL_85;
          }
        }
        goto LABEL_39;
      }
    }
    if ( (v38 & 1) != 0 )
    {
      *(_DWORD *)(a1 + 168) = strdupWithoutNull(*(void **)(j + 12));
      if ( !websCheckDigestRealm(a1) )
      {
LABEL_86:
        *(_DWORD *)(a1 + 192) = *(_DWORD *)(j + 4);
        goto LABEL_39;
      }
      v42 = *(_DWORD *)(a1 + 168);
      if ( v42 )
      {
        free2(v42);
        *(_DWORD *)(a1 + 168) = 0;
      }
    }
  }
LABEL_39:
  v22 = strcmp(v6, &word_4A0308);
  v23 = v9 < 2;
  if ( !v22 )
  {
    v11 = 0;
    if ( *(_DWORD *)(a1 + 192) >= v9 )
      goto LABEL_5;
    v11 = 401;
    goto LABEL_42;
  }
LABEL_49:
  v11 = 0;
  if ( v23 )
    goto LABEL_5;
  v11 = 401;
  if ( *(_DWORD *)(a1 + 192) >= v9 )
  {
    v11 = 0;
    goto LABEL_5;
  }
LABEL_42:
  trace(1, (int)"websCheckRealm=Login(%s,%s,%d,%d,%s)\n", v8, v10, *(_DWORD *)(a1 + 192), v9, v7);
  if ( !v45 )
  {
    if ( websConnValidateUrl(a1, v7) < 0 )
    {
      v11 = 500;
    }
    else
    {
      v24 = *(_DWORD *)(a1 + 148);
      v25 = (_BYTE *)(v24 + strlen(v24) - 1);
      v26 = (char)*v25;
      if ( v26 == 47 || v26 == 92 )
        *v25 = 0;
      if ( access(v24, 4) )
      {
        v11 = 404;
      }
      else if ( stat(v24, v43) < 0 )
      {
        v11 = 400;
      }
      else if ( (v44 & 0xF000) != 0x8000 )
      {
        v11 = 404;
      }
    }
  }
LABEL_5:
  if ( v7 )
    free2(v7);
  if ( v8 )
    free2(v8);
  result = v11;
  if ( v10 )
  {
    free2(v10);
    return v11;
  }
  return result;
}
// 417824: conditional instruction was optimized away because $s6.4!=0
// 417964: conditional instruction was optimized away because $s0.4!=0
// 417B54: conditional instruction was optimized away because $s1.4!=0
// 4A0308: using guessed type __int16 word_4A0308;
// 4E4328: using guessed type char *off_4E4328;
// 4E45C8: using guessed type char *off_4E45C8;
// 4E4E20: using guessed type int WebAuthFileList;
// 4E4E24: using guessed type int WebAuthUserList;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F50: using guessed type int   access(_DWORD, _DWORD);
// 4E9F58: using guessed type int   stat(_DWORD, _DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00417CB4) --------------------------------------------------------
void websRefreshCookieDigest()
{
  ;
}

//----- (00417CBC) --------------------------------------------------------
int websSocketOpen()
{
  int v0; // $s0
  int v1; // $a1
  int v2; // $v0
  int v3; // $v1

  v0 = 10;
  v1 = 0;
  if ( ++dword_4E4ED4 < 2 )
  {
    socketHighestFd = -1;
    socketList = 0;
    socketLast = -1;
    while ( 1 )
    {
      v2 = websSSLOpen();
      v3 = v0;
      if ( v2 >= 0 )
        break;
      --v0;
      if ( v3 <= 0 )
        break;
      usleep(100000);
    }
    return v2;
  }
  return v1;
}
// 4E4ECC: using guessed type int socketHighestFd;
// 4E4ED0: using guessed type int socketLast;
// 4E4ED4: using guessed type int dword_4E4ED4;
// 4E7CF4: using guessed type int socketList;
// 4EA090: using guessed type int   usleep(_DWORD);

//----- (00417D78) --------------------------------------------------------
int   websSocketGetPtr(int a1)
{
  if ( a1 >= 0 && socketLast >= a1 && *(_DWORD *)(4 * a1 + socketList) )
    return *(_DWORD *)(4 * a1 + socketList);
  *(_DWORD *)_errno_location() = 9;
  return 0;
}
// 4E4ED0: using guessed type int socketLast;
// 4E7CF4: using guessed type int socketList;
// 4E9F40: using guessed type int _errno_location(void);

//----- (00417E14) --------------------------------------------------------
int   websSocketSetBlock(int a1, int a2)
{
  int v2; // $t0
  int v4; // $v0
  int v5; // $s0
  int v6; // $s1
  unsigned int v7; // $v0

  if ( a1 >= 0 && (v2 = 4 * a1, socketLast >= a1) && (v4 = *(_DWORD *)(v2 + socketList)) != 0 )
  {
    v5 = *(_DWORD *)(v2 + socketList);
    v6 = *(_DWORD *)(v4 + 108) & 0x10;
    v7 = *(_DWORD *)(v4 + 108) & 0xFFFFFFEF;
    if ( a2 )
      v7 |= 0x10u;
    *(_DWORD *)(v5 + 108) = v7;
    fcntl(*(_DWORD *)(v5 + 112), 3);
    fcntl(*(_DWORD *)(v5 + 112), 4);
    return v6;
  }
  else
  {
    *(_DWORD *)_errno_location() = 9;
    return 0;
  }
}
// 4E4ED0: using guessed type int socketLast;
// 4E7CF4: using guessed type int socketList;
// 4E9F08: using guessed type int   fcntl(_DWORD, _DWORD);
// 4E9F40: using guessed type int _errno_location(void);

//----- (00417F4C) --------------------------------------------------------
int   websSocketRead(int a1, int a2, int a3)
{
  int v5; // $s1
  _DWORD *v6; // $v0
  int v7; // $a0
  _DWORD *v9; // $a0
  _DWORD *v10; // $s2
  int v11; // $t2
  int v12; // $s4
  signed int v13; // $s0
  int v14; // $a2
  int v15; // $s0
  int v16; // $v0
  int v17; // [sp+18h] [-8h]

  v5 = a3;
  if ( a1 < 0 || socketLast < a1 || (v9 = *(_DWORD **)(4 * a1 + socketList), (v10 = v9) == 0) )
  {
    v6 = (_DWORD *)_errno_location();
    v7 = -1;
    *v6 = 9;
    return v7;
  }
  v11 = v9[27] & 1;
  v7 = 0;
  if ( v11 )
    return v7;
  v12 = 0;
  if ( a3 <= 0 )
    return v12;
  while ( 1 )
  {
    v13 = v5;
    if ( (int)memPoolLen(v10) < v5 )
      v13 = memPoolLen(v10);
    if ( v13 > 0 )
      goto LABEL_11;
    if ( ((v10[27] >> 4) & 1) != 0 )
    {
      v7 = v12;
      if ( v12 > 0 )
        return v7;
    }
    memPoolFlush(v10);
    v14 = memPoolPutMaxBlockSize(v10);
    if ( v5 < v14 )
      v14 = v5;
    v17 = 0;
    if ( a1 < 0 || socketLast < a1 || (v15 = *(_DWORD *)(4 * a1 + socketList)) == 0 )
    {
      *(_DWORD *)_errno_location() = 9;
      goto LABEL_22;
    }
    if ( (*(_DWORD *)(v15 + 108) & 1) != 0 )
      goto LABEL_34;
    v16 = recv(*(_DWORD *)(v15 + 112), v10[5], v14, 0);
    if ( v16 >= 0 )
    {
      v13 = v16;
      if ( !v16 )
        goto LABEL_34;
      memPoolPutBlockPtrAdj(v10, v16);
      if ( v5 < v13 )
        v13 = v5;
LABEL_11:
      memcpy(a2 + v12, v10[4], v13);
      memPoolGetBlockPtrAdj(v10, v13);
      v12 += v13;
      v5 -= v13;
      goto LABEL_12;
    }
    v17 = *(_DWORD *)_errno_location();
    if ( v17 == 131 )
      break;
LABEL_22:
    v7 = -1;
    if ( v17 != 11 )
      return v7;
    if ( ((v10[27] >> 4) & 1) == 0 || v12 )
    {
      v7 = v12;
      if ( v12 < 0 )
        return -1;
      return v7;
    }
LABEL_12:
    if ( v5 <= 0 )
      return v12;
  }
  *(_DWORD *)(v15 + 108) |= 0x40u;
LABEL_34:
  if ( v12 )
    return v12;
  v7 = 0;
  v10[27] |= 1u;
  return v7;
}
// 4E4ED0: using guessed type int socketLast;
// 4E7CF4: using guessed type int socketList;
// 4E9F40: using guessed type int _errno_location(void);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);
// 4EA0B4: using guessed type int   recv(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041827C) --------------------------------------------------------
int   websSocketGets(int a1, int *a2)
{
  _DWORD *v4; // $v0
  int v5; // $a1
  int v7; // $v0
  int v8; // $s3
  int *v9; // $s1
  int v10; // $v0
  char v11; // $s0
  signed int v12; // $v0
  signed int v13; // $v0
  signed int v14; // $s0
  _BYTE v15[8]; // [sp+18h] [-8h] BYREF

  *a2 = 0;
  if ( a1 >= 0 && socketLast >= a1 && (v7 = *(_DWORD *)(4 * a1 + socketList), (v8 = v7) != 0) )
  {
    v9 = (int *)(v7 + 56);
LABEL_7:
    v10 = websSocketRead(a1, (int)v15, 1);
    v5 = v10;
    if ( v10 >= 0 )
    {
      while ( 1 )
      {
        if ( v10 )
        {
          v11 = v15[0];
        }
        else
        {
          v12 = memPoolLen(v9);
          v5 = -1;
          if ( v12 <= 0 )
            return v5;
          v11 = 10;
          if ( (*(_DWORD *)(v8 + 108) & 1) == 0 )
            return v5;
          v15[0] = 10;
        }
        if ( v11 == 10 )
          break;
        if ( v11 == 13 )
          goto LABEL_7;
        if ( !v11 && !strcmp(v9[4], "<policy-file-request/>") )
          break;
        memPoolPutChar(v9, v11);
        v10 = websSocketRead(a1, (int)v15, 1);
        v5 = v10;
        if ( v10 < 0 )
          return v5;
      }
      v13 = memPoolLen(v9);
      v14 = v13;
      if ( v13 <= 0 )
        *a2 = 0;
      else
        *a2 = strndupWithoutNull(v9[4], v13);
      memPoolFlush(v9);
      return v14;
    }
  }
  else
  {
    v4 = (_DWORD *)_errno_location();
    v5 = -1;
    *v4 = 9;
  }
  return v5;
}
// 4E4ED0: using guessed type int socketLast;
// 4E7CF4: using guessed type int socketList;
// 4E9F40: using guessed type int _errno_location(void);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (00418490) --------------------------------------------------------
int   websSocketFlush(int a1)
{
  _DWORD *v2; // $v0
  _DWORD *v3; // $s2
  unsigned int v4; // $v1
  _DWORD *v5; // $s1
  int v6; // $v0
  unsigned int MaxBlockSize; // $s0
  int v8; // $v1
  int v9; // $t7
  int v10; // $v0

  if ( a1 < 0 || socketLast < a1 || (v2 = *(_DWORD **)(4 * a1 + socketList), (v3 = v2) == 0) )
  {
    *(_DWORD *)_errno_location() = 9;
    return -1;
  }
  v4 = v2[27];
  v5 = v2 + 7;
  if ( ((v4 >> 4) & 1) == 0 )
    v2[27] = v4 | 8;
  do
  {
    while ( 1 )
    {
      if ( (int)memPoolLen(v5) <= 0 )
      {
        if ( !memPoolLen(v5) )
          memPoolFlush(v5);
        v10 = v3[30];
        if ( v10 >= 0 )
        {
          v3[24] = v10;
          v3[30] = -1;
        }
        v3[27] &= ~8u;
        return 0;
      }
      MaxBlockSize = memPoolGetMaxBlockSize(v5);
      v6 = send(v3[28], v5[4], MaxBlockSize, 0);
      if ( v6 < 0 )
        break;
      if ( !v6 && MaxBlockSize )
      {
        v8 = 11;
        goto LABEL_13;
      }
      memPoolGetBlockPtrAdj(v5, v6);
    }
    v8 = *(_DWORD *)_errno_location();
LABEL_13:
    ;
  }
  while ( v8 == 4 );
  if ( v8 != 11 )
    return -1;
  if ( (int)v3[30] < 0 )
  {
    v9 = v3[24];
    v3[24] = v9 | 4;
    v3[30] = v9;
  }
  return 0;
}
// 418620: conditional instruction was optimized away because $v0.4>=0
// 4E4ED0: using guessed type int socketLast;
// 4E7CF4: using guessed type int socketList;
// 4E9F40: using guessed type int _errno_location(void);
// 4EA03C: using guessed type int   send(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004186D4) --------------------------------------------------------
int   websSocketWrite(int a1, int a2, int a3)
{
  int v7; // $v0
  int v8; // $s6
  int *v9; // $s3
  int v10; // $s5
  int v11; // $a0
  int v12; // $v0
  int v13; // $s0

  if ( a1 >= 0 && socketLast >= a1 && (v7 = *(_DWORD *)(4 * a1 + socketList), (v8 = v7) != 0) )
  {
    v9 = (int *)(v7 + 28);
    v10 = 0;
    while ( 1 )
    {
      v11 = v10;
      if ( a3 <= 0 )
        break;
      while ( 1 )
      {
        v12 = memPoolPutMaxBlockSize(v9);
        if ( !v12 )
          break;
        v13 = a3;
        if ( v12 < a3 )
          v13 = v12;
        memPoolPutBlock(v9, a2, v13);
        a2 += v13;
        a3 -= v13;
        v10 += v13;
        if ( a3 <= 0 )
          return v10;
      }
      if ( websSocketFlush(a1) < 0 )
        return -1;
      if ( !memPoolPutMaxBlockSize(v9) )
      {
        v11 = v10;
        if ( ((*(_DWORD *)(v8 + 108) >> 4) & 1) == 0 )
          break;
      }
    }
    return v11;
  }
  else
  {
    *(_DWORD *)_errno_location() = 9;
    return -1;
  }
}
// 4E4ED0: using guessed type int socketLast;
// 4E7CF4: using guessed type int socketList;
// 4E9F40: using guessed type int _errno_location(void);

//----- (004188A4) --------------------------------------------------------
int   websSocketEof(int a1)
{
  int v2; // $v0

  if ( a1 >= 0 && socketLast >= a1 )
  {
    v2 = *(_DWORD *)(4 * a1 + socketList);
    if ( v2 )
      return *(_DWORD *)(v2 + 108) & 1;
  }
  *(_DWORD *)_errno_location() = 9;
  return -1;
}
// 4E4ED0: using guessed type int socketLast;
// 4E7CF4: using guessed type int socketList;
// 4E9F40: using guessed type int _errno_location(void);

//----- (00418948) --------------------------------------------------------
int   websSocketSelect(int a1, int a2)
{
  int v3; // $s0
  int v5; // $v0
  int v6; // $s7
  int v7; // $s5
  int v8; // $s6
  int v9; // $s1
  unsigned int v10; // $a2
  unsigned int v11; // $a1
  int v12; // $s5
  unsigned int v13; // $s4
  _DWORD *v14; // $s3
  unsigned int v15; // $s0
  int v16; // $t0
  _DWORD *v17; // $s1
  unsigned int v18; // $a1
  int v19; // $s4
  int v20; // $s3
  _DWORD *v21; // $ra
  int v22; // $v0
  int result; // $v0
  unsigned int v24; // $v0
  unsigned int v25; // $s0
  int v26; // [sp+20h] [-10h] BYREF
  int v27; // [sp+24h] [-Ch]
  int v28; // [sp+28h] [-8h]

  v3 = 4 * ((unsigned int)(socketHighestFd + 32) >> 5);
  v6 = mmalloc(v3);
  v5 = mmalloc(v3);
  v7 = 0;
  v8 = v5;
  if ( v6 )
  {
    if ( v5 )
    {
      v28 = 0;
      v27 = 1000 * (a2 % 1000);
      v26 = a2 / 1000;
      if ( a1 < 0 )
      {
        a1 = 0;
        v28 = 1;
      }
      if ( socketLast >= a1 )
      {
        while ( 1 )
        {
          v9 = *(_DWORD *)(4 * a1 + socketList);
          if ( v9 )
            break;
LABEL_18:
          if ( v28 )
          {
            if ( socketLast >= ++a1 )
              continue;
          }
          goto LABEL_20;
        }
        v10 = *(_DWORD *)(v9 + 96);
        v11 = *(_DWORD *)(v9 + 112);
        v12 = 1 << (v11 & 0x1F);
        v13 = v11 >> 5;
        if ( ((v10 >> 1) & 1) != 0 )
        {
          *(_DWORD *)(4 * v13 + v6) |= v12;
          if ( a1 < 0 || socketLast < a1 || (v14 = *(_DWORD **)(4 * a1 + socketList)) == 0 )
          {
            *(_DWORD *)_errno_location() = 9;
            v16 = *(_DWORD *)(v9 + 96) >> 2;
LABEL_16:
            if ( (v16 & 1) != 0 )
              *(_DWORD *)(4 * v13 + v8) |= v12;
            goto LABEL_18;
          }
          if ( (v14[27] & 1) == 0 )
          {
            v15 = memPoolLen(v14 + 14);
            if ( (int)(v15 + memPoolLen(v14)) > 0 )
            {
              v26 = 0;
              v27 = 0;
            }
          }
          v10 = *(_DWORD *)(v9 + 96);
        }
        v16 = v10 >> 2;
        goto LABEL_16;
      }
LABEL_20:
      v7 = select(socketHighestFd + 1, v6, v8, 0, &v26);
      if ( v7 > 0 )
      {
        if ( v28 )
          a1 = 0;
        if ( socketLast >= a1 )
        {
          while ( 1 )
          {
            v17 = *(_DWORD **)(4 * a1 + socketList);
            if ( !v17 )
            {
              if ( !v28 )
                goto LABEL_35;
              v22 = socketLast;
              ++a1;
              goto LABEL_34;
            }
            v18 = v17[28];
            v19 = 4 * (v18 >> 5);
            v20 = 1 << (v18 & 0x1F);
            if ( (*(_DWORD *)(v19 + v6) & v20) != 0 )
              goto LABEL_42;
            if ( a1 >= 0 && socketLast >= a1 )
              break;
            *(_DWORD *)_errno_location() = 9;
LABEL_29:
            v21 = (_DWORD *)(v19 + v8);
LABEL_30:
            if ( (*v21 & v20) != 0 )
              v17[29] |= 4u;
            if ( !v28 )
              goto LABEL_35;
            v22 = socketLast;
            ++a1;
LABEL_34:
            if ( v22 < a1 )
              goto LABEL_35;
          }
          v21 = (_DWORD *)(v19 + v8);
          if ( (v17[27] & 1) != 0 )
            goto LABEL_30;
          v25 = memPoolLen(v17 + 14);
          v24 = memPoolLen(v17);
          v21 = (_DWORD *)(v19 + v8);
          if ( (int)(v25 + v24) <= 0 )
            goto LABEL_30;
LABEL_42:
          v17[29] |= 2u;
          goto LABEL_29;
        }
      }
    }
LABEL_35:
    free2(v6);
  }
  result = v7;
  if ( v8 )
  {
    free2(v8);
    return v7;
  }
  return result;
}
// 418CB8: conditional instruction was optimized away because $s7.4!=0
// 4E4ECC: using guessed type int socketHighestFd;
// 4E4ED0: using guessed type int socketLast;
// 4E7CF4: using guessed type int socketList;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F40: using guessed type int _errno_location(void);
// 4EA054: using guessed type int   select(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00418DD8) --------------------------------------------------------
_DWORD *  websSocketCreateEvent(int a1, int a2, int a3, int a4)
{
  _DWORD *result; // $v0

  if ( a1 >= 0 && socketLast >= a1 && (result = *(_DWORD **)(4 * a1 + socketList)) != 0 )
  {
    result[24] = a2;
    result[22] = a3;
    result[23] = a4;
  }
  else
  {
    result = (_DWORD *)_errno_location();
    *result = 9;
  }
  return result;
}
// 4E4ED0: using guessed type int socketLast;
// 4E7CF4: using guessed type int socketList;
// 4E9F40: using guessed type int _errno_location(void);

//----- (00418E74) --------------------------------------------------------
_DWORD *  websSocketDeleteEvent(int a1)
{
  _DWORD *result; // $v0

  if ( a1 >= 0 && socketLast >= a1 && (result = *(_DWORD **)(4 * a1 + socketList)) != 0 )
  {
    result[24] = 0;
    result[22] = 0;
  }
  else
  {
    result = (_DWORD *)_errno_location();
    *result = 9;
  }
  return result;
}
// 4E4ED0: using guessed type int socketLast;
// 4E7CF4: using guessed type int socketList;
// 4E9F40: using guessed type int _errno_location(void);

//----- (00418F0C) --------------------------------------------------------
_DWORD *  websSocketFree(int a1)
{
  _DWORD *result; // $v0
  _DWORD *v3; // $v0
  _DWORD *v4; // $s0
  int v5; // $t2
  int v6; // $a1
  _DWORD **v7; // $a0
  int v9; // $v1
  _BYTE v10[256]; // [sp+18h] [-100h] BYREF

  if ( a1 >= 0 && socketLast >= a1 && (v3 = *(_DWORD **)(4 * a1 + socketList), (v4 = v3) != 0) )
  {
    v5 = v3[28];
    v3[24] = 0;
    if ( v5 >= 0 )
    {
      websSocketSetBlock(a1, 0);
      if ( shutdown(v4[28], 1) >= 0 )
        recv(v4[28], v10, 256, 0);
      close(v4[28]);
    }
    socketLast = FreeEntryId(&socketList, a1);
    memPoolClose(v4);
    memPoolClose(v4 + 7);
    result = (_DWORD *)memPoolClose(v4 + 14);
    if ( v4 )
      result = (_DWORD *)free2(v4);
    socketHighestFd = -1;
    if ( socketLast >= 0 )
    {
      v6 = socketLast + 1;
      v7 = (_DWORD **)socketList;
      do
      {
        result = *v7;
        --v6;
        if ( *v7++ != 0 )
        {
          v9 = result[28];
          if ( v9 < socketHighestFd )
            v9 = socketHighestFd;
          socketHighestFd = v9;
        }
      }
      while ( v6 );
    }
  }
  else
  {
    result = (_DWORD *)_errno_location();
    *result = 9;
  }
  return result;
}
// 4E4ECC: using guessed type int socketHighestFd;
// 4E4ED0: using guessed type int socketLast;
// 4E7CF4: using guessed type int socketList;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F40: using guessed type int _errno_location(void);
// 4E9F80: using guessed type int   shutdown(_DWORD, _DWORD);
// 4EA0B4: using guessed type int   recv(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00419114) --------------------------------------------------------
int   sub_419114(_DWORD *a1)
{
  unsigned int v1; // $v1
  int v3; // $s1
  unsigned int v4; // $s7
  void (  *v5)(int, int, _DWORD); // $t9
  int v6; // $a1
  _DWORD *v8; // $s2
  unsigned int v9; // $s4
  int v10; // $a0
  int v11; // $s4
  int v12; // $s7
  int v13; // $s6
  int v14; // $s5
  int v15; // $v0
  int v16; // $fp
  int v17; // $s1
  int *v18; // $s0
  int v19; // $s1
  int v20; // $t2
  int v21; // $a0
  int v22; // $v0
  _BYTE v23[2]; // [sp+18h] [-18h] BYREF
  unsigned __int16 v24; // [sp+1Ah] [-16h]
  int v25; // [sp+1Ch] [-14h]
  int v26; // [sp+28h] [-8h] BYREF

  v1 = a1[29];
  v3 = a1[25];
  if ( ((v1 >> 1) & 1) == 0 )
  {
    v4 = v1 >> 2;
    if ( ((a1[24] >> 1) & 1) != 0 )
    {
      if ( v3 >= 0 && socketLast >= v3 && (v8 = *(_DWORD **)(4 * v3 + socketList)) != 0 )
      {
        if ( (v8[27] & 1) == 0 )
        {
          v9 = memPoolLen(v8 + 14);
          if ( (int)(v9 + memPoolLen(v8)) > 0 )
          {
            v1 = a1[29] | 2;
            a1[29] = v1;
            goto LABEL_3;
          }
        }
      }
      else
      {
        *(_DWORD *)_errno_location() = 9;
      }
      v4 = a1[29] >> 2;
    }
LABEL_4:
    if ( (v4 & 1) != 0 && ((a1[27] >> 3) & 1) != 0 )
    {
      if ( (int)memPoolLen(a1 + 7) <= 0 )
        a1[27] &= ~8u;
      else
        websSocketFlush(a1[25]);
    }
    v5 = (void (  *)(int, int, _DWORD))a1[22];
    if ( !v5 )
      return 1;
    v6 = a1[24] & a1[29];
    if ( !v6 )
      return 1;
    v5(v3, v6, a1[23]);
    if ( !socketList || socketLast < v3 || *(_DWORD **)(4 * v3 + socketList) != a1 )
      return 1;
    a1[29] = 0;
    return 1;
  }
  if ( ((a1[27] >> 5) & 1) == 0 )
  {
LABEL_3:
    v4 = v1 >> 2;
    goto LABEL_4;
  }
  v10 = a1[28];
  v26 = 16;
  v11 = accept(v10, v23, &v26);
  if ( v11 >= 0 )
  {
    v12 = a1[26];
    v13 = a1[21];
    v14 = a1[27];
    v15 = AllocEntry(&socketList, &socketLast, 128);
    v16 = v15;
    if ( v15 < 0 )
    {
      shutdown(v11, 2);
      close(v11);
      a1[29] = 0;
      return 1;
    }
    v17 = 4 * v15;
    v18 = *(int **)(4 * v15 + socketList);
    v18[30] = -1;
    v18[27] = v14 & 0x30;
    v18[21] = v13;
    v18[26] = v12;
    v18[25] = v15;
    memPoolOpen(v18, 2048, 2048);
    memPoolOpen(v18 + 7, 2048, 2048);
    memPoolOpen(v18 + 14, 512, 0);
    v19 = *(_DWORD *)(v17 + socketList);
    v20 = *(_DWORD *)(v19 + 108);
    *(_DWORD *)(v19 + 112) = v11;
    *(_DWORD *)(v19 + 108) = v20 & 0xFFFFFFDF;
    fcntl(v11, 2);
    v21 = v11;
    if ( v11 < socketHighestFd )
      v21 = socketHighestFd;
    socketHighestFd = v21;
    socketLastAcceptFd = v11;
    websSocketSetBlock(v16, (*(_DWORD *)(v19 + 108) >> 4) & 1);
    if ( a1[21] )
    {
      v22 = inet_ntoa(v25);
      if ( ((int (  *)(int, int, int, _DWORD))a1[21])(
             v16,
             v22,
             HIBYTE(v24) | ((unsigned __int8)v24 << 8),
             a1[25]) < 0 )
        websSocketFree(v16);
    }
  }
  a1[29] = 0;
  return 1;
}
// 4E4EC8: using guessed type int socketLastAcceptFd;
// 4E4ECC: using guessed type int socketHighestFd;
// 4E4ED0: using guessed type int socketLast;
// 4E7CF4: using guessed type int socketList;
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F08: using guessed type int   fcntl(_DWORD, _DWORD);
// 4E9F40: using guessed type int _errno_location(void);
// 4E9F80: using guessed type int   shutdown(_DWORD, _DWORD);
// 4E9F94: using guessed type int   inet_ntoa(_DWORD);
// 4EA02C: using guessed type int   accept(_DWORD, _DWORD, _DWORD);

//----- (004195C0) --------------------------------------------------------
_DWORD *  websSocketCloseConnection(int a1)
{
  _DWORD *result; // $v0

  if ( a1 >= 0 && socketLast >= a1 && *(_DWORD *)(4 * a1 + socketList) )
    return websSocketFree(a1);
  result = (_DWORD *)_errno_location();
  *result = 9;
  return result;
}
// 4E4ED0: using guessed type int socketLast;
// 4E7CF4: using guessed type int socketList;
// 4E9F40: using guessed type int _errno_location(void);

//----- (00419654) --------------------------------------------------------
_DWORD **websSocketEventPoll()
{
  int v0; // $a0
  int v1; // $s2
  _DWORD **result; // $v0
  _DWORD *v3; // $s1
  unsigned int v4; // $a1
  unsigned int v5; // $t3
  int v6; // $s4
  _DWORD *v7; // $s6
  int v8; // $s2
  int v9; // $s5
  _DWORD *v10; // $s1
  unsigned int v11; // $a0
  unsigned int v12; // $v1
  unsigned int v13; // $s0
  unsigned int v14; // $s6

  v0 = socketLast;
  v1 = 0;
  if ( socketLast < 0 )
    goto LABEL_10;
  while ( 1 )
  {
    result = (_DWORD **)(4 * v1 + socketList);
    v3 = *result;
    if ( !*result )
      goto LABEL_9;
    v4 = v3[27];
    if ( ((v4 >> 6) & 1) != 0 )
      break;
    v5 = v3[24];
    if ( (v3[29] & v5) != 0 )
      goto LABEL_11;
    if ( ((v5 >> 1) & 1) != 0 )
    {
      if ( v1 >= 0 && socketLast >= v1 )
      {
        if ( (v4 & 1) == 0 )
        {
          v14 = memPoolLen(v3 + 14);
          if ( (int)(v14 + memPoolLen(v3)) > 0 )
          {
            result = (_DWORD **)websSocketSelect(v1, 0);
            goto LABEL_11;
          }
        }
      }
      else
      {
        *(_DWORD *)_errno_location() = 9;
      }
    }
LABEL_9:
    v0 = socketLast;
    if ( socketLast < ++v1 )
      goto LABEL_10;
  }
  if ( v1 >= 0 && v0 >= v1 )
    websSocketFree(v1);
  else
    *(_DWORD *)_errno_location() = 9;
LABEL_10:
  result = (_DWORD **)websSocketSelect(-1, 1000);
  if ( !result )
    return result;
LABEL_11:
  v6 = 0;
  if ( socketLast < 0 )
    return result;
  while ( 2 )
  {
    while ( 1 )
    {
      v7 = *(_DWORD **)(4 * v6 + socketList);
      v8 = v6;
      if ( v7 )
      {
        v9 = 0;
        if ( v6 < 0 )
        {
          v8 = 0;
          v9 = 1;
        }
        if ( socketLast >= v8 )
          break;
      }
LABEL_25:
      if ( socketLast < ++v6 )
        return result;
    }
    while ( 2 )
    {
      result = (_DWORD **)(4 * v8);
      v10 = *(_DWORD **)(4 * v8 + socketList);
      if ( !v10 )
      {
LABEL_23:
        ++v8;
        if ( !v9 || socketLast < v8 )
          goto LABEL_25;
        continue;
      }
      break;
    }
    v11 = v10[27];
    if ( ((v11 >> 6) & 1) == 0 )
    {
      v12 = v10[24];
      if ( (v10[29] & v12) != 0 )
        goto LABEL_30;
      if ( ((v12 >> 1) & 1) != 0 )
      {
        if ( v8 >= 0 && socketLast >= v8 )
        {
          if ( (v11 & 1) == 0 )
          {
            v13 = memPoolLen(v10 + 14);
            result = (_DWORD **)memPoolLen(v10);
            if ( (int)((int)result + v13) > 0 )
            {
              websSocketSelect(v8, 0);
LABEL_30:
              result = (_DWORD **)sub_419114(v7);
              goto LABEL_31;
            }
          }
        }
        else
        {
          result = (_DWORD **)_errno_location();
          *result = (_DWORD *)9;
        }
      }
      goto LABEL_23;
    }
    if ( v8 < 0 || socketLast < v8 )
    {
      result = (_DWORD **)_errno_location();
      *result = (_DWORD *)9;
      goto LABEL_25;
    }
    result = (_DWORD **)websSocketFree(v8);
LABEL_31:
    if ( socketLast >= ++v6 )
      continue;
    return result;
  }
}
// 4E4ED0: using guessed type int socketLast;
// 4E7CF4: using guessed type int socketList;
// 4E9F40: using guessed type int _errno_location(void);

//----- (00419A30) --------------------------------------------------------
_DWORD *websSocketClose()
{
  _DWORD *result; // $v0
  int v1; // $s0
  int v2; // $a0

  result = (_DWORD *)--dword_4E4ED4;
  if ( dword_4E4ED4 <= 0 )
  {
    result = (_DWORD *)websSSLClose();
    v1 = socketLast;
    while ( v1 >= 0 )
    {
      if ( socketList && *(_DWORD *)(4 * v1 + socketList) )
      {
        if ( v1 >= 0 )
        {
          v2 = v1;
          if ( socketLast >= v1 )
          {
            --v1;
            result = websSocketFree(v2);
            continue;
          }
        }
        result = (_DWORD *)_errno_location();
        *result = 9;
      }
      --v1;
    }
    dword_4E4ED4 = 0;
  }
  return result;
}
// 4E4ED0: using guessed type int socketLast;
// 4E4ED4: using guessed type int dword_4E4ED4;
// 4E7CF4: using guessed type int socketList;
// 4E9F40: using guessed type int _errno_location(void);

//----- (00419B5C) --------------------------------------------------------
int   websSocketOpenConnection(int a1, int a2, unsigned int a3)
{
  bool v6; // dc
  int v7; // $a0
  int v8; // $v0
  int v9; // $s3
  int v10; // $s1
  int *v11; // $s0
  _DWORD *v12; // $s1
  int v13; // $v0
  int v14; // $v1
  int v15; // $v0
  unsigned int v16; // $ra
  int v17; // $s6
  _WORD v19[2]; // [sp+20h] [-18h] BYREF
  int v20; // [sp+24h] [-14h]
  int v21; // [sp+28h] [-10h]
  int v22; // [sp+2Ch] [-Ch]
  int v23; // [sp+30h] [-8h] BYREF

  v6 = a1 > 0xFFFF;
  v7 = -1;
  if ( !v6 )
  {
    v8 = AllocEntry(&socketList, &socketLast, 128);
    v9 = v8;
    v7 = -1;
    if ( v8 >= 0 )
    {
      v10 = 4 * v8;
      v11 = *(int **)(4 * v8 + socketList);
      v11[30] = -1;
      v11[27] = a3 & 0x30;
      v11[21] = a2;
      v11[25] = v8;
      v11[26] = a1;
      memPoolOpen(v11, 2048, 2048);
      memPoolOpen(v11 + 7, 2048, 2048);
      memPoolOpen(v11 + 14, 512, 0);
      v12 = *(_DWORD **)(v10 + socketList);
      v21 = 0;
      v19[0] = 2;
      v19[1] = BYTE1(a1) | ((unsigned __int8)a1 << 8);
      v22 = 0;
      v20 = 0;
      v13 = socket(2, 2, 0);
      v12[28] = v13;
      if ( v13 < 0 )
        goto LABEL_10;
      fcntl(v13, 2);
      v14 = v12[28];
      if ( v14 < socketHighestFd )
        v14 = socketHighestFd;
      socketHighestFd = v14;
      v23 = 1;
      setsockopt(v12[28], 0xFFFF, 4, &v23, 4);
      if ( bind(v12[28], v19, 16) < 0 || (v15 = listen(v12[28], 128), v16 = a3 >> 4, v15 < 0) )
      {
LABEL_10:
        websSocketFree(v9);
        return -1;
      }
      else
      {
        v17 = v12[27] | 0x20;
        v12[24] |= 2u;
        v12[27] = v17;
        websSocketSetBlock(v9, (v16 & 1) != 0);
        return v9;
      }
    }
  }
  return v7;
}
// 4E4ECC: using guessed type int socketHighestFd;
// 4E4ED0: using guessed type int socketLast;
// 4E7CF4: using guessed type int socketList;
// 4E9F08: using guessed type int   fcntl(_DWORD, _DWORD);
// 4E9FC4: using guessed type int   listen(_DWORD, _DWORD);
// 4E9FFC: using guessed type int   setsockopt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4EA008: using guessed type int   bind(_DWORD, _DWORD, _DWORD);
// 4EA058: using guessed type int   socket(_DWORD, _DWORD, _DWORD);

//----- (00419DEC) --------------------------------------------------------
int   websSocketGetPort(int a1)
{
  int v2; // $v0

  if ( a1 >= 0 && socketLast >= a1 )
  {
    v2 = *(_DWORD *)(4 * a1 + socketList);
    if ( v2 )
      return *(_DWORD *)(v2 + 104);
  }
  *(_DWORD *)_errno_location() = 9;
  return -1;
}
// 4E4ED0: using guessed type int socketLast;
// 4E7CF4: using guessed type int socketList;
// 4E9F40: using guessed type int _errno_location(void);

//----- (00419E8C) --------------------------------------------------------
int   mmalloc(int a1)
{
  int v2; // $s1
  int v3; // $s0
  int v4; // $a3
  int result; // $v0

  v2 = 5;
  while ( 1 )
  {
    v3 = malloc(a1);
    v4 = v2;
    if ( v3 )
      break;
    --v2;
    trace(16, (int)"mmalloc:allocate error(%d,%d)!\n", a1, v4);
    result = 0;
    if ( v2 <= 0 )
      return result;
  }
  memset(v3, 0, a1);
  return v3;
}
// 419F28: conditional instruction was optimized away because $s0.4==0
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (00419F68) --------------------------------------------------------
int   AllocEntryId(_DWORD *a1)
{
  _DWORD *v2; // $a1
  int v3; // $s1
  _DWORD *v4; // $s0
  int v5; // $a3
  int v6; // $a2
  int v7; // $a0
  int v8; // $a2
  int v9; // $s0
  BOOL v10; // $t5
  int v11; // $s3
  int v12; // $s2
  int v13; // $v0
  int v14; // $s1
  int result; // $v0
  _DWORD *v16; // $v1

  v2 = (_DWORD *)(*a1 - 12);
  if ( !*a1 )
  {
    v3 = 5;
    while ( 1 )
    {
      v4 = (_DWORD *)malloc(76);
      v5 = v3;
      if ( v4 )
        break;
      --v3;
      trace(16, (int)"mmalloc:allocate error(%d,%d)!\n", 76, v5);
      v2 = 0;
      if ( v3 <= 0 )
        goto LABEL_6;
    }
    memset(v4, 0, 76);
    v2 = v4;
LABEL_6:
    v6 = -1;
    if ( !v4 )
      return v6;
    *v4 = 26232;
    v4[1] = 16;
    v4[2] = 0;
    *a1 = v4 + 3;
  }
  if ( *v2 != 26232 )
  {
    trace(16, (int)"Entry magic error(%s)!\n", "AllocEntry");
    return -1;
  }
  v7 = v2[1];
  v8 = v2[2];
  v9 = v7;
  if ( v8 >= v7 || (v9 = 0, v7 <= 0) )
  {
    v10 = v7 < 64;
LABEL_11:
    v6 = -1;
    if ( v10 )
    {
      v11 = v7 + 16;
      v12 = 4 * (v7 + 16);
      v13 = realloc(v2, v12 + 12);
      v14 = v13;
      v6 = -1;
      if ( v13 )
      {
        *(_DWORD *)(v13 + 4) = v11;
        *a1 = v13 + 12;
        memset(v12 + v13 + 12 - 64, 0, 64);
        v6 = v9;
        ++*(_DWORD *)(v14 + 8);
      }
    }
    return v6;
  }
  v16 = v2 + 4;
  if ( v2[3] )
  {
    do
    {
      ++v9;
      v10 = v7 < 64;
      if ( v9 >= v7 )
        goto LABEL_11;
    }
    while ( *v16++ != 0 );
  }
  result = v9;
  v2[2] = v8 + 1;
  return result;
}
// 41A13C: conditional instruction was optimized away because $s0.4==0
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (0041A18C) --------------------------------------------------------
int   FreeEntryId(int *a1, int a2)
{
  int v2; // $s1
  int result; // $v0
  int v5; // $a3
  int v6; // $a1
  int v7; // $a0
  _DWORD *v8; // $v1

  v2 = *a1;
  result = -1;
  if ( *a1 )
  {
    if ( *(_DWORD *)(v2 - 12) == 26232 )
    {
      *(_DWORD *)(4 * a2 + v2) = 0;
      v5 = *(_DWORD *)(v2 - 4);
      *(_DWORD *)(v2 - 4) = v5 - 1;
      if ( v5 == 1 )
      {
        free2(v2 - 12);
        *a1 = 0;
      }
      v6 = -1;
      if ( *a1 )
      {
        v7 = *(_DWORD *)(v2 - 8);
        v6 = v7;
        if ( *(_DWORD *)(v2 - 4) < v7 )
        {
          v6 = v7 - 1;
          if ( v7 - 1 >= 0 )
          {
            v8 = (_DWORD *)(4 * (v7 - 1) + v2);
            do
            {
              if ( *v8-- != 0 )
                break;
              --v6;
            }
            while ( v6 >= 0 );
          }
        }
      }
      return v6;
    }
    else
    {
      trace(16, (int)"Entry magic error(%s)!\n", "FreeEntry");
      return -1;
    }
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (0041A2A4) --------------------------------------------------------
int   AllocEntry(int *a1, int *a2, int a3)
{
  int result; // $v0
  int v7; // $s3
  int v8; // $s1
  int v9; // $s0
  int v10; // $a3
  int v11; // $s0
  int v12; // $a3
  int v13; // $a0
  bool v14; // dc
  int v15; // $a0
  _DWORD *v16; // $v1

  result = -1;
  if ( a3 > 0 )
  {
    v7 = AllocEntryId(a1);
    result = -1;
    if ( v7 >= 0 )
    {
      v8 = 5;
      while ( 1 )
      {
        v9 = malloc(a3);
        v10 = v8;
        if ( v9 )
          break;
        --v8;
        trace(16, (int)"mmalloc:allocate error(%d,%d)!\n", a3, v10);
        if ( v8 <= 0 )
          goto LABEL_7;
      }
      memset(v9, 0, a3);
LABEL_7:
      if ( v9 )
      {
        memset(v9, 0, a3);
        *(_DWORD *)(4 * v7 + *a1) = v9;
        result = v7;
        if ( *a2 < v7 )
          *a2 = v7;
        return result;
      }
      v11 = *a1;
      result = -1;
      if ( !*a1 )
        return result;
      if ( *(_DWORD *)(v11 - 12) != 26232 )
      {
        trace(16, (int)"Entry magic error(%s)!\n", "FreeEntry");
        return -1;
      }
      *(_DWORD *)(4 * v7 + v11) = 0;
      v12 = *(_DWORD *)(v11 - 4);
      *(_DWORD *)(v11 - 4) = v12 - 1;
      if ( v12 == 1 )
      {
        free2(v11 - 12);
        *a1 = 0;
      }
      result = -1;
      if ( *a1 )
      {
        v13 = *(_DWORD *)(v11 - 8);
        v14 = *(_DWORD *)(v11 - 4) >= v13;
        v15 = v13 - 1;
        if ( !v14 && v15 >= 0 )
        {
          v16 = (_DWORD *)(4 * v15 + v11);
          while ( 1 )
          {
            --v15;
            v14 = *v16-- != 0;
            if ( v14 )
              break;
            if ( v15 < 0 )
              return -1;
          }
          return -1;
        }
      }
    }
  }
  return result;
}
// 41A3C8: conditional instruction was optimized away because $s0.4==0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (0041A4C8) --------------------------------------------------------
unsigned int   memPoolLen(_DWORD *a1)
{
  unsigned int v1; // $a1
  unsigned int v2; // $v1
  unsigned int v4; // $a0

  v1 = a1[4];
  v2 = a1[5];
  v4 = v2 - v1;
  if ( v2 < v1 )
    return v2 + *a1 - v1;
  return v4;
}

//----- (0041A4F8) --------------------------------------------------------
int   memPoolOpen(int *a1, int a2, int a3)
{
  int v3; // $s1
  BOOL i; // $v0
  int v7; // $s2
  _BYTE *v8; // $s0
  int v9; // $a3
  int result; // $v0

  v3 = 256;
  for ( i = a2 > 256; ; i = v3 < a2 )
  {
    v7 = 5;
    if ( !i )
      break;
    v3 *= 2;
  }
  do
  {
    v8 = (_BYTE *)malloc(v3);
    v9 = v7;
    if ( v8 )
    {
      memset(v8, 0, v3);
      a1[3] = (int)v8;
      goto LABEL_8;
    }
    --v7;
    trace(16, (int)"mmalloc:allocate error(%d,%d)!\n", v3, v9);
  }
  while ( v7 > 0 );
  a1[3] = 0;
LABEL_8:
  result = -1;
  if ( v8 )
  {
    a1[6] = (int)&v8[v3];
    a1[1] = a3;
    result = 0;
    *v8 = 0;
    *a1 = v3;
    a1[2] = v3;
    a1[4] = (int)v8;
    a1[5] = (int)v8;
  }
  return result;
}
// 41A5F0: conditional instruction was optimized away because $s0.4==0
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (0041A618) --------------------------------------------------------
_BYTE *  memPoolFlush(_DWORD *a1)
{
  _BYTE *result; // $v0

  result = (_BYTE *)a1[3];
  a1[5] = result;
  a1[4] = result;
  if ( result )
    *result = 0;
  return result;
}

//----- (0041A638) --------------------------------------------------------
int   memPoolClose(_DWORD *a1)
{
  _BYTE *v2; // $a0
  int result; // $v0

  if ( a1 )
  {
    v2 = (_BYTE *)a1[3];
    a1[4] = v2;
    a1[5] = v2;
    if ( v2 )
    {
      *v2 = 0;
      v2 = (_BYTE *)a1[3];
    }
    result = free2(v2);
    a1[3] = 0;
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (0041A6A4) --------------------------------------------------------
int   memPoolPutMaxBlockSize(_DWORD *a1)
{
  unsigned int v2; // $a1
  unsigned int v3; // $a0
  unsigned int v4; // $a1
  int v5; // $t0
  int v6; // $a1

  v2 = a1[4];
  v3 = a1[5];
  if ( v3 >= v2 )
    v4 = v3 - v2;
  else
    v4 = v3 + *a1 - v2;
  v5 = a1[6];
  v6 = *a1 - v4 - 1;
  if ( (int)(v5 - v3) < v6 )
    return v5 - v3;
  return v6;
}

//----- (0041A704) --------------------------------------------------------
unsigned int   memPoolGetMaxBlockSize(_DWORD *a1)
{
  unsigned int v2; // $v1
  unsigned int v3; // $a0
  int v4; // $a1

  v2 = a1[5];
  v3 = a1[4];
  v4 = v2 - v3;
  if ( v2 < v3 )
    v4 = v2 + *a1 - v3;
  if ( (int)(a1[6] - v3) < v4 )
    return a1[6] - v3;
  return v4;
}

//----- (0041A754) --------------------------------------------------------
int   sub_41A754(int *a1)
{
  int v1; // $v0
  int v3; // $a0
  int v4; // $v1
  int v5; // $s1
  int v6; // $s0
  int v7; // $s4
  int v8; // $a3
  unsigned int v9; // $a1
  unsigned int v10; // $a0
  int v11; // $s5
  int v12; // $s2
  int v13; // $s1
  unsigned int v14; // $a3
  BOOL i; // $t1
  int v16; // $a2
  BOOL v17; // $t4
  int v18; // $s0
  int v19; // $t7

  v1 = a1[1];
  if ( v1 <= 0 )
  {
    v3 = *a1;
  }
  else
  {
    v3 = *a1;
    v4 = 0;
    if ( v3 >= v1 )
      return v4;
  }
  v5 = v3 + a1[2];
  v6 = 5;
  while ( 1 )
  {
    v7 = malloc(v5);
    v8 = v6;
    if ( v7 )
      break;
    --v6;
    trace(16, (int)"mmalloc:allocate error(%d,%d)!\n", v5, v8);
    if ( v6 <= 0 )
      goto LABEL_7;
  }
  memset(v7, 0, v5);
LABEL_7:
  v4 = 0;
  if ( v7 )
  {
    v9 = a1[4];
    v10 = a1[5];
    v11 = v10 - v9;
    if ( v10 < v9 )
      v11 = v10 + *a1 - v9;
    v12 = v7;
    v13 = v11;
    if ( v11 > 0 )
    {
      v14 = a1[6];
      for ( i = v10 < v9; ; i = v10 < v9 )
      {
        v16 = v10 - v9;
        if ( i )
          v16 = v10 + *a1 - v9;
        v17 = v13 < v16;
        if ( (int)(v14 - v9) < v16 )
        {
          v16 = v14 - v9;
          v17 = v13 < (int)(v14 - v9);
        }
        v18 = v16;
        if ( v17 )
          v18 = v13;
        if ( v18 <= 0 )
          break;
        memcpy(v12, v9, v18);
        v14 = a1[6];
        v9 = a1[4] + v18;
        v13 -= v18;
        v12 += v18;
        if ( v9 >= v14 )
          v9 = a1[3];
        a1[4] = v9;
        if ( v13 <= 0 )
          break;
        v10 = a1[5];
      }
    }
    free2(a1[3]);
    v19 = *a1 + a1[2];
    a1[6] = v7 + v19;
    a1[5] = v7 + v11;
    *a1 = v19;
    a1[3] = v7;
    a1[4] = v7;
    return 1;
  }
  return v4;
}
// 41A94C: conditional instruction was optimized away because $s4.4==0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0041A974) --------------------------------------------------------
int   memPoolPutBlock(int *a1, int a2, int a3)
{
  int v3; // $s1
  int v6; // $s4
  unsigned int v7; // $a0
  unsigned int v8; // $t1
  unsigned int v9; // $a3
  int v10; // $t0
  unsigned int v11; // $v0
  int v12; // $a1
  BOOL v13; // $t3
  int v14; // $a2
  unsigned int v15; // $v1
  int v16; // $s0
  unsigned int v17; // $v1
  int result; // $v0
  bool v19; // dc
  unsigned int v20; // $a3
  int v21; // $t0
  unsigned int v22; // $v0
  int v23; // $t1
  int v24; // $a1
  BOOL v25; // $t8
  int v26; // $a2
  unsigned int v27; // $v1
  int v28; // $v1

  v3 = a3;
  v6 = 0;
  if ( a3 > 0 )
  {
    v7 = a1[5];
    v8 = a1[6];
    do
    {
      v9 = a1[4];
      v10 = *a1;
      if ( v7 >= v9 )
        v11 = v7 - v9;
      else
        v11 = v7 + *a1 - v9;
      v12 = v10 - v11 - 1;
      v13 = v12 < v3;
      if ( (int)(v8 - v7) < v12 )
        v13 = (int)(v8 - v7) < v3;
      v14 = v3;
      if ( v13 )
      {
        v15 = v7 - v9;
        if ( v7 < v9 )
          v15 = v7 + v10 - v9;
        v14 = v10 - v15 - 1;
        if ( (int)(v8 - v7) < v14 )
          v14 = v8 - v7;
      }
      v16 = v14;
      if ( v14 <= 0 )
      {
        v19 = sub_41A754(a1) == 0;
        result = v6;
        if ( v19 )
          return result;
        v20 = a1[4];
        v7 = a1[5];
        v21 = *a1;
        if ( v7 >= v20 )
          v22 = v7 - v20;
        else
          v22 = v7 + *a1 - v20;
        v23 = a1[6];
        v24 = v21 - v22 - 1;
        v25 = v24 < v3;
        if ( (int)(v23 - v7) < v24 )
          v25 = (int)(v23 - v7) < v3;
        v26 = v3;
        if ( v25 )
        {
          v27 = v7 - v20;
          if ( v7 < v20 )
            v27 = v7 + v21 - v20;
          v28 = v21 - v27 - 1;
          if ( (int)(v23 - v7) < v28 )
            v28 = v23 - v7;
          v26 = v28;
        }
        v16 = v26;
      }
      memcpy(v7, a2, v16);
      v8 = a1[6];
      v17 = a1[5] + v16;
      v6 += v16;
      a2 += v16;
      v3 -= v16;
      v7 = v17;
      if ( v17 < v8 )
      {
        a1[5] = v17;
      }
      else
      {
        v7 = a1[3];
        a1[5] = v7;
      }
    }
    while ( v3 > 0 );
  }
  return v6;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0041AB90) --------------------------------------------------------
int   memPoolPutChar(int *a1, char a2)
{
  unsigned int v2; // $a2
  unsigned int v4; // $a0
  unsigned int v6; // $a1
  int v7; // $t0
  _BYTE *v8; // $a0
  int v9; // $v1
  int v10; // $v1
  int v12; // $v0

  v2 = a1[4];
  v4 = a1[5];
  if ( v4 >= v2 )
    v6 = v4 - v2;
  else
    v6 = v4 + *a1 - v2;
  v7 = a1[6];
  v8 = (_BYTE *)a1[5];
  v9 = *a1 - v6 - 1;
  if ( v7 - (int)v8 < v9 )
    v9 = v7 - (_DWORD)v8;
  if ( v9 <= 0 )
  {
    v12 = sub_41A754(a1);
    v10 = -1;
    if ( !v12 )
      return v10;
    v8 = (_BYTE *)a1[5];
    *v8 = a2;
  }
  else
  {
    *v8 = a2;
  }
  if ( (unsigned int)(v8 + 1) < a1[6] )
    a1[5] = (int)(v8 + 1);
  else
    a1[5] = a1[3];
  return 0;
}

//----- (0041AC88) --------------------------------------------------------
_BYTE *  memPoolPutBlockPtrAdj(_DWORD *a1, int a2)
{
  unsigned int v2; // $a2
  unsigned int v3; // $v1
  _BYTE *result; // $v0

  v2 = a1[6];
  v3 = a1[5] + a2;
  result = (_BYTE *)(v3 < v2);
  if ( v3 >= v2 )
    v3 -= *a1;
  a1[5] = v3;
  if ( v3 >= v2 )
  {
    trace(16, (int)"Bad endp pointer");
    result = (_BYTE *)a1[3];
    a1[5] = result;
    a1[4] = result;
    if ( result )
      *result = 0;
  }
  return result;
}

//----- (0041AD24) --------------------------------------------------------
_BYTE *  memPoolGetBlockPtrAdj(_DWORD *a1, int a2)
{
  unsigned int v2; // $a2
  unsigned int v3; // $v1
  _BYTE *result; // $v0

  v2 = a1[6];
  v3 = a1[4] + a2;
  result = (_BYTE *)(v3 < v2);
  if ( v3 >= v2 )
    v3 -= *a1;
  a1[4] = v3;
  if ( v3 >= v2 )
  {
    trace(16, (int)"Bad startp pointer");
    result = (_BYTE *)a1[3];
    a1[5] = result;
    a1[4] = result;
    if ( result )
      *result = 0;
  }
  return result;
}

//----- (0041ADC0) --------------------------------------------------------
int   memsearch(int a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4)
{
  int v6; // $s5
  int v8; // $s3
  int v9; // $a1
  int v10; // $s0
  int v11; // $v0

  v6 = a1;
  if ( a2 >= a4 )
  {
    v8 = *a3;
    v9 = 0;
    do
    {
      v10 = memchr(a1, v8, a2 - v9);
      if ( !v10 )
        break;
      v11 = memcmp(v10, a3, a4);
      a1 = v10 + 1;
      v9 = v10 + 1 - v6;
      if ( !v11 )
        return v10;
    }
    while ( a2 - v9 >= a4 );
  }
  return 0;
}
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);
// 4E9FF4: using guessed type int   memchr(_DWORD, _DWORD, _DWORD);

//----- (0041AEB4) --------------------------------------------------------
int   findStrInFile(int a1, int a2, unsigned __int8 *a3, int a4)
{
  int v7; // $s6
  int v8; // $v1
  int v9; // $v0
  int v10; // $s3
  int v11; // $a1
  unsigned int i; // $s1
  _BYTE *v13; // $a0
  int v14; // $s2
  int v15; // $s0
  int v16; // $v0
  _BYTE v18[1024]; // [sp+18h] [-400h] BYREF

  v7 = 0;
  v8 = -1;
  if ( a4 < 513 && a2 >= 0 )
  {
    v9 = fopen(a1, "rb");
    v10 = v9;
    v8 = -1;
    if ( v9 )
    {
      rewind(v9);
      fseek(v10, a2, 0);
      for ( i = fread(v18, 1, 1024, v10); i; i = fread(v18, 1, 1024, v10) )
      {
        v13 = v18;
        if ( i >= a4 )
        {
          v14 = *a3;
          v11 = 0;
          do
          {
            v15 = memchr(v13, v14, i - v11);
            v11 = (int)a3;
            if ( !v15 )
              break;
            v16 = memcmp(v15, a3, a4);
            v13 = (_BYTE *)(v15 + 1);
            v11 = v15 + 1 - (_DWORD)v18;
            if ( !v16 )
            {
              fclose(v10);
              return v15 - (_DWORD)v18 + v7 + a2;
            }
          }
          while ( i - v11 >= a4 );
        }
        if ( i != 1024 )
          break;
        rewind(v10);
        v7 += 512;
        fseek(v10, a2 + v7, 0);
      }
      fclose(v10);
      return -1;
    }
  }
  return v8;
}
// 41B05C: variable 'v11' is possibly undefined
// 4E9F48: using guessed type int   rewind(_DWORD);
// 4E9F98: using guessed type int   fclose(_DWORD);
// 4E9FA8: using guessed type int   fopen(_DWORD, _DWORD);
// 4E9FB4: using guessed type int   fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);
// 4E9FF4: using guessed type int   memchr(_DWORD, _DWORD, _DWORD);
// 4E9FF8: using guessed type int   fseek(_DWORD, _DWORD, _DWORD);

//----- (0041B0C4) --------------------------------------------------------
int   getMemInFile(int a1, int a2, int a3)
{
  int v4; // $v0
  int v6; // $s3
  int v7; // $s0
  int v8; // $s1
  int v9; // $a3
  int v10; // $a1

  v4 = fopen(a1, "r");
  v6 = v4;
  v7 = 0;
  if ( v4 )
  {
    fseek(v4, a2, 0);
    v8 = 5;
    while ( 1 )
    {
      v7 = malloc(a3 + 1);
      v9 = v8;
      if ( v7 )
        break;
      --v8;
      trace(16, (int)"mmalloc:allocate error(%d,%d)!\n", a3 + 1, v9);
      if ( v8 <= 0 )
        goto LABEL_6;
    }
    memset(v7, 0, a3 + 1);
LABEL_6:
    if ( v7 && fread(v7, 1, a3, v6) != a3 )
    {
      free2(v7);
      v7 = 0;
    }
    fclose(v6);
  }
  return v7;
}
// 41B208: conditional instruction was optimized away because $s0.4==0
// 41B1C8: variable 'v10' is possibly undefined
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F98: using guessed type int   fclose(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FA8: using guessed type int   fopen(_DWORD, _DWORD);
// 4E9FB4: using guessed type int   fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 4E9FF8: using guessed type int   fseek(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (0041B230) --------------------------------------------------------
int   sub_41B230(int *a1, int a2)
{
  unsigned int v3; // $ra
  unsigned int v4; // $t9
  unsigned int v5; // $t8
  unsigned int v6; // $a3
  int *v7; // $t0
  int v8; // $t2
  int v9; // $a2
  unsigned __int64 v10; // kr00_8
  unsigned int v11; // $t0
  unsigned __int64 v12; // kr08_8
  unsigned int v13; // $s5
  unsigned __int64 v14; // kr10_8
  unsigned int v15; // $t2
  unsigned __int64 v16; // kr18_8
  unsigned int v17; // $a2
  unsigned __int64 v18; // kr20_8
  unsigned int v19; // $a3
  unsigned __int64 v20; // kr28_8
  unsigned int v21; // $t1
  unsigned __int64 v22; // kr30_8
  unsigned int v23; // $t3
  unsigned __int64 v24; // kr38_8
  unsigned int v25; // $s3
  unsigned __int64 v26; // kr40_8
  unsigned int v27; // $t2
  unsigned __int64 v28; // kr48_8
  unsigned int v29; // $t1
  unsigned __int64 v30; // kr50_8
  unsigned int v31; // $v1
  unsigned __int64 v32; // kr58_8
  unsigned int v33; // $a0
  unsigned __int64 v34; // kr60_8
  unsigned int v35; // $a3
  unsigned __int64 v36; // kr68_8
  int v37; // $a1
  unsigned __int64 v38; // kr70_8
  unsigned int v39; // $a2
  unsigned __int64 v40; // kr78_8
  unsigned int v41; // $v1
  __int64 v42; // kr80_8
  unsigned int v43; // $a0
  unsigned __int64 v44; // kr88_8
  unsigned int v45; // $a3
  unsigned __int64 v46; // kr90_8
  unsigned int v47; // $t0
  unsigned __int64 v48; // kr98_8
  unsigned int v49; // $a2
  __int64 v50; // krA0_8
  unsigned int v51; // $v1
  unsigned __int64 v52; // krA8_8
  unsigned int v53; // $a0
  unsigned __int64 v54; // krB0_8
  unsigned int v55; // $a3
  unsigned __int64 v56; // krB8_8
  unsigned int v57; // $a1
  __int64 v58; // krC0_8
  unsigned int v59; // $t1
  unsigned __int64 v60; // krC8_8
  unsigned int v61; // $v1
  unsigned __int64 v62; // krD0_8
  unsigned int v63; // $a0
  unsigned __int64 v64; // krD8_8
  unsigned int v65; // $t0
  __int64 v66; // krE0_8
  unsigned int v67; // $a1
  unsigned __int64 v68; // krE8_8
  unsigned int v69; // $a2
  unsigned __int64 v70; // krF0_8
  unsigned int v71; // $a3
  unsigned __int64 v72; // krF8_8
  unsigned int v73; // $v1
  __int64 v74; // kr100_8
  unsigned int v75; // $a0
  unsigned __int64 v76; // kr108_8
  unsigned int v77; // $a1
  unsigned __int64 v78; // kr110_8
  unsigned int v79; // $a2
  unsigned __int64 v80; // kr118_8
  unsigned int v81; // $a3
  __int64 v82; // kr120_8
  unsigned int v83; // $v1
  unsigned __int64 v84; // $t0
  unsigned int v85; // $a0
  unsigned __int64 v86; // $t0
  int v87; // $a1
  unsigned __int64 v88; // $t0
  int v89; // $a2
  __int64 v90; // kr128_8
  unsigned __int64 v91; // kr130_8
  int v92; // $v1
  unsigned __int64 v93; // kr138_8
  unsigned int v94; // $a0
  unsigned __int64 v95; // kr140_8
  unsigned int v96; // $a1
  __int64 v97; // kr148_8
  int v98; // $a2
  unsigned __int64 v99; // kr150_8
  int v100; // $a3
  unsigned __int64 v101; // kr158_8
  unsigned __int64 v102; // kr160_8
  unsigned __int64 v103; // kr168_8
  unsigned int v104; // $v1
  unsigned __int64 v105; // kr170_8
  unsigned int v106; // $a0
  unsigned __int64 v107; // kr178_8
  unsigned int v108; // $a1
  unsigned __int64 v109; // kr180_8
  unsigned int v110; // $a2
  unsigned __int64 v111; // kr188_8
  unsigned __int64 v112; // kr190_8
  unsigned int v113; // $t5
  unsigned __int64 v114; // kr198_8
  unsigned int v115; // $s6
  unsigned __int64 v116; // kr1A0_8
  int v117; // $a1
  unsigned __int64 v118; // kr1A8_8
  unsigned __int64 v119; // kr1B0_8
  unsigned int v120; // $t2
  unsigned __int64 v121; // kr1B8_8
  int v122; // $t4
  unsigned __int64 v123; // kr1C0_8
  unsigned int v124; // $s0
  unsigned __int64 v125; // kr1C8_8
  unsigned int v126; // $s6
  unsigned __int64 v127; // kr1D0_8
  unsigned int v128; // $s3
  unsigned __int64 v129; // kr1D8_8
  int v130; // $s4
  unsigned __int64 v131; // kr1E0_8
  _DWORD v133[17]; // [sp+18h] [-48h] BYREF
  int v134; // [sp+5Ch] [-4h]

  v134 = *a1;
  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v6 = 0;
  v7 = v133;
  do
  {
    v8 = *(unsigned __int8 *)(a2 + v6)
       | (*(unsigned __int8 *)(a2 + v6 + 1) << 8)
       | (*(unsigned __int8 *)(a2 + v6 + 2) << 16);
    v9 = *(unsigned __int8 *)(a2 + v6 + 3) << 24;
    v6 += 4;
    *v7++ = v8 | v9;
  }
  while ( v6 < 0x40 );
  v10 = (unsigned __int64)((v3 & v4 | ~v3 & v5) + v133[0] + v134 - 680876936) << 7;
  v11 = (v10 | HIDWORD(v10)) + v3;
  v12 = (unsigned __int64)((v11 & v3 | ~v11 & v4) + v133[1] + v5 - 389564586) << 12;
  v13 = (v12 | HIDWORD(v12)) + v11;
  v14 = (unsigned __int64)((v13 & v11 | ~v13 & v3) + v133[2] + v4 + 606105819) << 17;
  v15 = (v14 | HIDWORD(v14)) + v13;
  v16 = (unsigned __int64)((v15 & v13 | ~v15 & v11) + v133[3] + v3 - 1044525330) << 22;
  v17 = (v16 | HIDWORD(v16)) + v15;
  v18 = (unsigned __int64)((v17 & v15 | ~v17 & v13) + v133[4] + v11 - 176418897) << 7;
  v19 = (v18 | HIDWORD(v18)) + v17;
  v20 = (unsigned __int64)((v19 & v17 | ~v19 & v15) + v133[5] + v13 + 1200080426) << 12;
  v21 = (v20 | HIDWORD(v20)) + v19;
  v22 = (unsigned __int64)((v21 & v19 | ~v21 & v17) + v133[6] + v15 - 1473231341) << 17;
  v23 = (v22 | HIDWORD(v22)) + v21;
  v24 = (unsigned __int64)((v23 & v21 | ~v23 & v19) + v133[7] + v17 - 45705983) << 22;
  v25 = (v24 | HIDWORD(v24)) + v23;
  v26 = (unsigned __int64)((v25 & v23 | ~v25 & v21) + v133[8] + v19 + 1770035416) << 7;
  v27 = (v26 | HIDWORD(v26)) + v25;
  v28 = (unsigned __int64)((v27 & v25 | ~v27 & v23) + v133[9] + v21 - 1958414417) << 12;
  v29 = (v28 | HIDWORD(v28)) + v27;
  v30 = (unsigned __int64)((v29 & v27 | ~v29 & v25) + v133[10] + v23 - 42063) << 17;
  v31 = (v30 | HIDWORD(v30)) + v29;
  v32 = (unsigned __int64)((v31 & v29 | ~v31 & v27) + v133[11] + v25 - 1990404162) << 22;
  v33 = (v32 | HIDWORD(v32)) + v31;
  v34 = (unsigned __int64)((v33 & v31 | ~v33 & v29) + v133[12] + v27 + 1804603682) << 7;
  v35 = (v34 | HIDWORD(v34)) + v33;
  v36 = (unsigned __int64)((v35 & v33 | ~v35 & v31) + v133[13] + v29 - 40341101) << 12;
  v37 = (v36 | HIDWORD(v36)) + v35;
  v38 = (unsigned __int64)((v37 & v35 | ~v37 & v33) + v133[14] + v31 - 1502002290) << 17;
  v39 = (v38 | HIDWORD(v38)) + v37;
  v40 = (unsigned __int64)((v39 & v37 | ~v39 & v35) + v133[15] + v33 + 1236535329) << 22;
  v41 = (v40 | HIDWORD(v40)) + v39;
  v42 = 32LL * ((v41 & v37 | ~v37 & v39) + v133[1] + v35 - 165796510);
  v43 = (v42 | HIDWORD(v42)) + v41;
  v44 = (unsigned __int64)((v43 & v39 | ~v39 & v41) + v133[6] + v37 - 1069501632) << 9;
  v45 = (v44 | HIDWORD(v44)) + v43;
  v46 = (unsigned __int64)((v45 & v41 | ~v41 & v43) + v133[11] + v39 + 643717713) << 14;
  v47 = (v46 | HIDWORD(v46)) + v45;
  v48 = (unsigned __int64)((v47 & v43 | ~v43 & v45) + v133[0] + v41 - 373897302) << 20;
  v49 = (v48 | HIDWORD(v48)) + v47;
  v50 = 32LL * ((v49 & v45 | ~v45 & v47) + v133[5] + v43 - 701558691);
  v51 = (v50 | HIDWORD(v50)) + v49;
  v52 = (unsigned __int64)((v51 & v47 | ~v47 & v49) + v133[10] + v45 + 38016083) << 9;
  v53 = (v52 | HIDWORD(v52)) + v51;
  v54 = (unsigned __int64)((v53 & v49 | ~v49 & v51) + v133[15] + v47 - 660478335) << 14;
  v55 = (v54 | HIDWORD(v54)) + v53;
  v56 = (unsigned __int64)((v55 & v51 | ~v51 & v53) + v133[4] + v49 - 405537848) << 20;
  v57 = (v56 | HIDWORD(v56)) + v55;
  v58 = 32LL * ((v57 & v53 | ~v53 & v55) + v133[9] + v51 + 568446438);
  v59 = (v58 | HIDWORD(v58)) + v57;
  v60 = (unsigned __int64)((v59 & v55 | ~v55 & v57) + v133[14] + v53 - 1019803690) << 9;
  v61 = (v60 | HIDWORD(v60)) + v59;
  v62 = (unsigned __int64)((v61 & v57 | ~v57 & v59) + v133[3] + v55 - 187363961) << 14;
  v63 = (v62 | HIDWORD(v62)) + v61;
  v64 = (unsigned __int64)((v63 & v59 | ~v59 & v61) + v133[8] + v57 + 1163531501) << 20;
  v65 = (v64 | HIDWORD(v64)) + v63;
  v66 = 32LL * ((v65 & v61 | ~v61 & v63) + v133[13] + v59 - 1444681467);
  v67 = (v66 | HIDWORD(v66)) + v65;
  v68 = (unsigned __int64)((v67 & v63 | ~v63 & v65) + v133[2] + v61 - 51403784) << 9;
  v69 = (v68 | HIDWORD(v68)) + v67;
  v70 = (unsigned __int64)((v69 & v65 | ~v65 & v67) + v133[7] + v63 + 1735328473) << 14;
  v71 = (v70 | HIDWORD(v70)) + v69;
  v72 = (unsigned __int64)((v71 & v67 | ~v67 & v69) + v133[12] + v65 - 1926607734) << 20;
  v73 = (v72 | HIDWORD(v72)) + v71;
  v74 = 16LL * ((v73 ^ v71 ^ v69) + v133[5] + v67 - 378558);
  v75 = (v74 | HIDWORD(v74)) + v73;
  v76 = (unsigned __int64)((v75 ^ v73 ^ v71) + v133[8] + v69 - 2022574463) << 11;
  v77 = (v76 | HIDWORD(v76)) + v75;
  v78 = (unsigned __int64)((v77 ^ v75 ^ v73) + v133[11] + v71 + 1839030562) << 16;
  v79 = (v78 | HIDWORD(v78)) + v77;
  v80 = (unsigned __int64)((v79 ^ v77 ^ v75) + v133[14] + v73 - 35309556) << 23;
  v81 = (v80 | HIDWORD(v80)) + v79;
  v82 = 16LL * ((v81 ^ v79 ^ v77) + v133[1] + v75 - 1530992060);
  v83 = (v82 | HIDWORD(v82)) + v81;
  v84 = (unsigned __int64)((v83 ^ v81 ^ v79) + v133[4] + v77 + 1272893353) << 11;
  v85 = (v84 | HIDWORD(v84)) + v83;
  v86 = (unsigned __int64)((v85 ^ v83 ^ v81) + v133[7] + v79 - 155497632) << 16;
  v87 = (v86 | HIDWORD(v86)) + v85;
  v88 = (unsigned __int64)((v87 ^ v85 ^ v83) + v133[10] + v81 - 1094730640) << 23;
  v89 = (v88 | HIDWORD(v88)) + v87;
  v90 = 16LL * ((v89 ^ v87 ^ v85) + v133[13] + v83 + 681279174);
  LODWORD(v88) = (v90 | HIDWORD(v90)) + v89;
  v91 = (unsigned __int64)(((unsigned int)v88 ^ v89 ^ v87) + v133[0] + v85 - 358537222) << 11;
  v92 = (v91 | HIDWORD(v91)) + v88;
  v93 = (unsigned __int64)((v92 ^ (unsigned int)v88 ^ v89) + v133[3] + v87 - 722521979) << 16;
  v94 = (v93 | HIDWORD(v93)) + v92;
  v95 = (unsigned __int64)((v94 ^ v92 ^ (unsigned int)v88) + v133[6] + v89 + 76029189) << 23;
  v96 = (v95 | HIDWORD(v95)) + v94;
  v97 = 16LL * ((v96 ^ v94 ^ v92) + v133[9] + (unsigned int)v88 - 640364487);
  v98 = (v97 | HIDWORD(v97)) + v96;
  v99 = (unsigned __int64)((v98 ^ v96 ^ v94) + v133[12] + v92 - 421815835) << 11;
  v100 = (v99 | HIDWORD(v99)) + v98;
  v101 = (unsigned __int64)((v100 ^ v98 ^ v96) + v133[15] + v94 + 530742520) << 16;
  LODWORD(v88) = (v101 | HIDWORD(v101)) + v100;
  v102 = (unsigned __int64)(((unsigned int)v88 ^ v100 ^ v98) + v133[2] + v96 - 995338651) << 23;
  HIDWORD(v88) = (v102 | HIDWORD(v102)) + v88;
  v103 = (unsigned __int64)(((~v100 | HIDWORD(v88)) ^ (unsigned int)v88) + v133[0] + v98 - 198630844) << 6;
  v104 = (v103 | HIDWORD(v103)) + HIDWORD(v88);
  v105 = (unsigned __int64)(((~(_DWORD)v88 | v104) ^ HIDWORD(v88)) + v133[7] + v100 + 1126891415) << 10;
  v106 = (v105 | HIDWORD(v105)) + v104;
  v107 = (unsigned __int64)(((~HIDWORD(v88) | v106) ^ v104) + v133[14] + (unsigned int)v88 - 1416354905) << 15;
  v108 = (v107 | HIDWORD(v107)) + v106;
  v109 = (unsigned __int64)(((~v104 | v108) ^ v106) + v133[5] + HIDWORD(v88) - 57434055) << 21;
  v110 = (v109 | HIDWORD(v109)) + v108;
  v111 = (unsigned __int64)(((~v106 | v110) ^ v108) + v133[12] + v104 + 1700485571) << 6;
  HIDWORD(v88) = (v111 | HIDWORD(v111)) + v110;
  v112 = (unsigned __int64)(((~v108 | HIDWORD(v88)) ^ v110) + v133[3] + v106 - 1894986606) << 10;
  v113 = (v112 | HIDWORD(v112)) + HIDWORD(v88);
  v114 = (unsigned __int64)(((~v110 | v113) ^ HIDWORD(v88)) + v133[10] + v108 - 1051523) << 15;
  v115 = (v114 | HIDWORD(v114)) + v113;
  v116 = (unsigned __int64)(((~HIDWORD(v88) | v115) ^ v113) + v133[1] + v110 - 2054922799) << 21;
  v117 = (v116 | HIDWORD(v116)) + v115;
  v118 = (unsigned __int64)(((~v113 | v117) ^ v115) + v133[8] + HIDWORD(v88) + 1873313359) << 6;
  LODWORD(v88) = (v118 | HIDWORD(v118)) + v117;
  v119 = (unsigned __int64)(((~v115 | (unsigned int)v88) ^ v117) + v133[15] + v113 - 30611744) << 10;
  v120 = (v119 | HIDWORD(v119)) + v88;
  v121 = (unsigned __int64)(((~v117 | v120) ^ (unsigned int)v88) + v133[6] + v115 - 1560198380) << 15;
  v122 = (v121 | HIDWORD(v121)) + v120;
  v123 = (unsigned __int64)(((~(_DWORD)v88 | v122) ^ v120) + v133[13] + v117 + 1309151649) << 21;
  v124 = (v123 | HIDWORD(v123)) + v122;
  v125 = (unsigned __int64)(((~v120 | v124) ^ v122) + v133[4] + (unsigned int)v88 - 145523070) << 6;
  v126 = (v125 | HIDWORD(v125)) + v124;
  v127 = (unsigned __int64)(((~v122 | v126) ^ v124) + v133[11] + v120 - 1120210379) << 10;
  v128 = (v127 | HIDWORD(v127)) + v126;
  v129 = (unsigned __int64)(((~v124 | v128) ^ v126) + v133[2] + v122 + 718787259) << 15;
  v130 = (v129 | HIDWORD(v129)) + v128;
  v131 = (unsigned __int64)(((~v126 | v130) ^ v128) + v133[9] + v124 - 343485551) << 21;
  HIDWORD(v88) = v134 + v126;
  a1[3] = v5 + v128;
  *a1 = HIDWORD(v88);
  a1[1] = v3 + (v131 | HIDWORD(v131)) + v130;
  a1[2] = v4 + v130;
  return memset(v133, 0, 64);
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (0041BFD0) --------------------------------------------------------
int   MD5Init(_DWORD *a1)
{
  int result; // $v0

  result = -1732640768;
  a1[3] = 271733878;
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[5] = 0;
  a1[4] = 0;
  return result;
}

//----- (0041C00C) --------------------------------------------------------
int   MD5Update(int *a1, int a2, unsigned int a3)
{
  unsigned int v4; // $a2
  int v6; // $a0
  BOOL v7; // $v1
  int v8; // $a2
  int v10; // $s2
  int v12; // $s0
  int *v13; // $a0
  int v14; // $a1

  v4 = a1[4];
  v6 = v4 + 8 * a3;
  v7 = __CFADD__(v4, 8 * a3);
  v8 = (v4 >> 3) & 0x3F;
  a1[4] = v6;
  if ( v7 )
  {
    v10 = 64 - v8;
    a1[5] += 1 + (a3 >> 29);
    if ( a3 < 64 - v8 )
      return memcpy((char *)a1 + v8 + 24, a2, a3);
  }
  else
  {
    v10 = 64 - v8;
    a1[5] += a3 >> 29;
    if ( a3 < 64 - v8 )
      return memcpy((char *)a1 + v8 + 24, a2, a3);
  }
  memcpy((char *)a1 + v8 + 24, a2, v10);
  v12 = v10;
  v13 = a1;
  v14 = (int)(a1 + 6);
  while ( 1 )
  {
    sub_41B230(v13, v14);
    v14 = a2 + v12;
    if ( v12 + 63 >= a3 )
      break;
    v13 = a1;
    v12 += 64;
  }
  return memcpy(a1 + 6, v14, a3 - v12);
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0041C170) --------------------------------------------------------
int   MD5Final(_DWORD *a1, int a2)
{
  unsigned int v4; // $t1
  int *v5; // $t0
  int v6; // $v1
  _BYTE *v7; // $v0
  unsigned int v8; // $a1
  unsigned int v9; // $a2
  unsigned int v10; // $a0
  unsigned int v11; // $a2
  int v12; // $v0
  unsigned int v13; // $s1
  int v14; // $t6
  unsigned int v15; // $t3
  BOOL v16; // $t2
  int v17; // $a0
  int v18; // $s2
  unsigned int v19; // $a1
  unsigned int v20; // $s5
  BOOL v21; // $s1
  int v22; // $a1
  int v23; // $s1
  int v24; // $s0
  unsigned int v25; // $t1
  int *v26; // $t0
  int v27; // $s0
  _BYTE *v28; // $t8
  unsigned int v29; // $a3
  unsigned int v30; // $ra
  int result; // $v0
  int v32; // $a2
  int v33; // $v1
  int v34; // $s3
  int v35; // $s0
  int *v36; // $a0
  char *v37; // $a1
  unsigned int v38; // $a1
  unsigned int v39; // $s5
  BOOL v40; // $s1
  int *v41; // $a0
  _BYTE *v42; // $a1
  _BYTE v43[8]; // [sp+18h] [-18h] BYREF
  _DWORD v44[4]; // [sp+20h] [-10h] BYREF

  v4 = 0;
  v5 = (int *)(a2 + 16);
  do
  {
    v6 = *v5;
    v7 = &v43[v4];
    v4 += 4;
    v8 = (unsigned int)*v5 >> 8;
    v9 = HIWORD(*v5);
    v7[3] = HIBYTE(*v5);
    v7[1] = v8;
    v7[2] = v9;
    *v7 = v6;
    ++v5;
  }
  while ( v4 < 8 );
  v10 = *(_DWORD *)(a2 + 16);
  v11 = (v10 >> 3) & 0x3F;
  v12 = 56;
  if ( v11 >= 0x38 )
    v12 = 120;
  v13 = v12 - v11;
  v14 = 8 * (v12 - v11);
  v15 = v10 + v14;
  v16 = __CFADD__(v10, v14);
  v17 = (v10 >> 3) & 0x3F;
  *(_DWORD *)(a2 + 16) = v15;
  if ( v16 )
  {
    v18 = 64 - v17;
    *(_DWORD *)(a2 + 20) += 1 + (v13 >> 29);
    if ( v13 < 64 - v17 )
      goto LABEL_7;
  }
  else
  {
    v18 = 64 - v17;
    *(_DWORD *)(a2 + 20) += v13 >> 29;
    if ( v13 < 64 - v17 )
    {
LABEL_7:
      memcpy(a2 + v17 + 24, &unk_4E4ED8, v12 - v11);
      v19 = *(_DWORD *)(a2 + 16);
      v20 = v19 + 64;
      v21 = v19 >= 0xFFFFFFC0;
      v22 = (v19 >> 3) & 0x3F;
      *(_DWORD *)(a2 + 16) = v20;
      if ( v21 )
        goto LABEL_8;
      goto LABEL_17;
    }
  }
  memcpy(a2 + v17 + 24, &unk_4E4ED8, v18);
  v35 = v18;
  v36 = (int *)a2;
  v37 = (char *)(a2 + 24);
  while ( 1 )
  {
    sub_41B230(v36, (int)v37);
    v37 = (char *)&unk_4E4ED8 + v35;
    if ( v35 + 63 >= v13 )
      break;
    v36 = (int *)a2;
    v35 += 64;
  }
  memcpy(a2 + 24, v37, v13 - v35);
  v38 = *(_DWORD *)(a2 + 16);
  v39 = v38 + 64;
  v40 = v38 >= 0xFFFFFFC0;
  v22 = (v38 >> 3) & 0x3F;
  *(_DWORD *)(a2 + 16) = v39;
  if ( v40 )
  {
LABEL_8:
    v23 = 64 - v22;
    ++*(_DWORD *)(a2 + 20);
    v24 = 0;
    if ( (unsigned int)(64 - v22) > 8 )
      goto LABEL_9;
    goto LABEL_18;
  }
LABEL_17:
  v23 = 64 - v22;
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a2 + 20);
  v24 = 0;
  if ( (unsigned int)(64 - v22) > 8 )
    goto LABEL_9;
LABEL_18:
  memcpy(a2 + v22 + 24, v43, v23);
  v24 = v23;
  v41 = (int *)a2;
  v42 = (_BYTE *)(a2 + 24);
  while ( 1 )
  {
    sub_41B230(v41, (int)v42);
    v41 = (int *)a2;
    if ( (unsigned int)(v24 + 63) >= 8 )
      break;
    v42 = &v43[v24];
    v24 += 64;
  }
  v22 = 0;
LABEL_9:
  memcpy(a2 + v22 + 24, &v43[v24], 8 - v24);
  v25 = 0;
  v26 = (int *)a2;
  do
  {
    v27 = *v26;
    v28 = &v44[v25++];
    v29 = (unsigned int)*v26 >> 8;
    v30 = HIWORD(*v26);
    v28[3] = HIBYTE(*v26);
    v28[1] = v29;
    v28[2] = v30;
    *v28 = v27;
    ++v26;
  }
  while ( v25 < 4 );
  result = memset(a2, 0, 88);
  v32 = v44[1];
  *a1 = v44[0];
  a1[1] = v32;
  v33 = v44[2];
  a1[1] = v32;
  a1[2] = v33;
  v34 = v44[3];
  a1[2] = v33;
  a1[3] = v34;
  return result;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0041C4C0) --------------------------------------------------------
int   hmac_md5(int a1, unsigned int a2, _DWORD *a3, int a4, _DWORD *a5)
{
  unsigned int v5; // $s1
  _DWORD *v8; // $s2
  int i; // $a2
  char *v10; // $s3
  char v11; // $a1
  char v12; // $v0
  BOOL v13; // $a2
  int v14; // $a1
  int v15; // $s1
  int j; // $s0
  BOOL v17; // $s7
  unsigned int v18; // $s6
  int v19; // $a1
  int v20; // $s1
  int k; // $s0
  int v23; // $a1
  int v24; // $a1
  BOOL v25; // $v0
  int v26; // $s0
  int v27; // $a1
  int v28; // [sp+18h] [-150h] BYREF
  int v29; // [sp+1Ch] [-14Ch]
  int v30; // [sp+20h] [-148h]
  int v31; // [sp+24h] [-144h]
  unsigned int v32; // [sp+28h] [-140h]
  int v33; // [sp+2Ch] [-13Ch]
  _BYTE v34[64]; // [sp+30h] [-138h] BYREF
  _BYTE v35[72]; // [sp+70h] [-F8h] BYREF
  _BYTE v36[72]; // [sp+B8h] [-B0h] BYREF
  _DWORD v37[4]; // [sp+100h] [-68h] BYREF
  int v38[6]; // [sp+110h] [-58h] BYREF
  _BYTE v39[64]; // [sp+128h] [-40h] BYREF

  v5 = a4;
  v8 = a3;
  if ( a4 >= 65 )
  {
    v38[0] = 1732584193;
    v38[1] = -271733879;
    v38[2] = -1732584194;
    v38[3] = 271733878;
    v38[4] = 8 * a4;
    v38[5] = (unsigned int)a4 >> 29;
    memcpy(v39, a3, sizeof(v39));
    sub_41B230(v38, (int)v39);
    v25 = v5 > 0x7F;
    v26 = 16;
    while ( v25 )
    {
      v27 = (int)&v8[v26];
      v26 += 16;
      sub_41B230(v38, v27);
      v25 = v26 * 4 + 63 < v5;
    }
    memcpy(v39, &v8[v26], v5 - v26 * 4);
    MD5Final(v37, (int)v38);
    v8 = v37;
    v5 = 16;
  }
  memset(v35, 0, 65);
  memset(v36, 0, 65);
  memcpy(v35, v8, v5);
  memcpy(v36, v8, v5);
  for ( i = 0; i < 64; ++i )
  {
    v10 = (char *)&v28 + i;
    v11 = v35[i];
    v12 = v36[i];
    v10[160] = v12 ^ 0x5C;
    v10[88] = v11 ^ 0x36;
  }
  v29 = -271733879;
  v30 = -1732584194;
  v31 = 271733878;
  v32 = 512;
  v28 = 1732584193;
  v33 = 0;
  memcpy(v34, v35, sizeof(v34));
  sub_41B230(&v28, (int)v34);
  v13 = __CFADD__(v32, 8 * a2);
  v14 = (v32 >> 3) & 0x3F;
  v32 += 8 * a2;
  if ( v13 )
    ++v33;
  v15 = 64 - v14;
  v33 += a2 >> 29;
  j = 0;
  if ( a2 >= 64 - v14 )
  {
    memcpy(&v34[v14], a1, v15);
    sub_41B230(&v28, (int)v34);
    for ( j = v15; j + 63 < a2; j += 64 )
    {
      v23 = a1 + j;
      sub_41B230(&v28, v23);
    }
    v14 = 0;
  }
  memcpy(&v34[v14], a1 + j, a2 - j);
  MD5Final(a5, (int)&v28);
  v28 = 1732584193;
  v31 = 271733878;
  v32 = 512;
  v29 = -271733879;
  v30 = -1732584194;
  v33 = 0;
  memcpy(v34, v36, sizeof(v34));
  sub_41B230(&v28, (int)v34);
  v17 = v32 >= 0xFFFFFF80;
  v18 = v32 >> 3;
  v32 += 128;
  v19 = v18 & 0x3F;
  if ( v17 )
    ++v33;
  v20 = 64 - v19;
  k = 0;
  if ( (unsigned int)(64 - v19) <= 0x10 )
  {
    memcpy(&v34[v19], a5, v20);
    sub_41B230(&v28, (int)v34);
    for ( k = v20; (unsigned int)(k + 63) < 0x10; k += 64 )
    {
      v24 = (int)a5 + k;
      sub_41B230(&v28, v24);
    }
    v19 = 0;
  }
  memcpy(&v34[v19], (char *)a5 + k, 16 - k);
  return MD5Final(a5, (int)&v28);
}
// 41C560: conditional instruction was optimized away because $a3.4>=41
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0041CA14) --------------------------------------------------------
int   Sleep(int a1)
{
  int v1; // $v0
  int v3; // [sp+18h] [-10h] BYREF
  int v4; // [sp+1Ch] [-Ch]
  _DWORD v5[2]; // [sp+20h] [-8h] BYREF

  v3 = a1;
  v4 = 0;
  do
  {
    v1 = nanosleep(&v3, v5);
    v3 = v5[0];
    v4 = v5[1];
  }
  while ( v1 == -1 && *(_DWORD *)_errno_location() == 4 );
  return 0;
}
// 4E9F40: using guessed type int _errno_location(void);
// 4EA024: using guessed type int   nanosleep(_DWORD, _DWORD);

//----- (0041CAAC) --------------------------------------------------------
int   strdupWithoutNull(void *a1)
{
  void *v1; // $s1
  int v2; // $v0
  int v3; // $s0

  v1 = a1;
  if ( !a1 )
    v1 = &unk_4A2DDC;
  v2 = strlen(v1);
  v3 = mmalloc(v2 + 1);
  if ( v3 )
    strcpy(v3, v1);
  return v3;
}
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4EA0C8: using guessed type int   strcpy(_DWORD, _DWORD);

//----- (0041CB40) --------------------------------------------------------
int   vallocFmtString(int *a1, int a2, int a3, int a4)
{
  int v8; // $s3
  int v9; // $v0
  int v10; // $s1
  int v11; // $s0
  int v12; // $v1

  *a1 = 0;
  v8 = mmalloc(a2);
  if ( !v8 )
    return -1;
  v10 = vsnprintf(v8, a2, a3, a4);
  v9 = strlen(v8);
  v11 = mmalloc(v9 + 1);
  if ( v11 )
    strcpy(v11, v8);
  *a1 = v11;
  free2(v8);
  v12 = v10;
  if ( !*a1 )
    return -1;
  return v12;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4EA05C: using guessed type int   vsnprintf(_DWORD, _DWORD, _DWORD, _DWORD);
// 4EA0C8: using guessed type int   strcpy(_DWORD, _DWORD);

//----- (0041CC54) --------------------------------------------------------
int doSystem(int a1, ...)
{
  int v2; // $v0
  int v3; // $a2
  int v4; // $s1
  char *v5; // $s0
  __int16 v6; // $s2
  int v7; // $v0
  int v8; // $s3
  va_list va; // [sp+34h] [+1Ch] BYREF

  va_start(va, a1);
  v2 = mmalloc(1024);
  v3 = a1;
  v4 = v2;
  v5 = 0;
  v6 = 0;
  if ( !v2 )
  {
LABEL_7:
    if ( v5 )
    {
      trace(1, (int)"%s\n", v5);
      v6 = system(v5);
      free2(v5);
    }
    return ((unsigned __int8)v6 << 8) | ((v6 & 0xFF00) >> 8);
  }
  v8 = vsnprintf(v2, 1024, v3, (int *)va);
  v7 = strlen(v4);
  v5 = (char *)mmalloc(v7 + 1);
  if ( v5 )
    strcpy(v5, v4);
  free2(v4);
  if ( v5 )
  {
    if ( v8 >= 1024 )
      trace(1, (int)"doSystem: lost data, buffer overflow\n");
    goto LABEL_7;
  }
  return ((unsigned __int8)v6 << 8) | ((v6 & 0xFF00) >> 8);
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4EA05C: using guessed type int   vsnprintf(_DWORD, _DWORD, _DWORD, _DWORD);
// 4EA070: using guessed type int   system(_DWORD);
// 4EA0C8: using guessed type int   strcpy(_DWORD, _DWORD);

//----- (0041CDE8) --------------------------------------------------------
int allocFmtString(int *a1, int a2, int a3, ...)
{
  int v6; // $s2
  int v7; // $v0
  int v8; // $s1
  int v9; // $s0
  int v10; // $v1
  va_list va; // [sp+3Ch] [+24h] BYREF

  va_start(va, a3);
  *a1 = 0;
  v6 = mmalloc(a2);
  if ( !v6 )
    return -1;
  v8 = vsnprintf(v6, a2, a3, (int *)va);
  v7 = strlen(v6);
  v9 = mmalloc(v7 + 1);
  if ( v9 )
    strcpy(v9, v6);
  *a1 = v9;
  free2(v6);
  v10 = v8;
  if ( !*a1 )
    return -1;
  return v10;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4EA05C: using guessed type int   vsnprintf(_DWORD, _DWORD, _DWORD, _DWORD);
// 4EA0C8: using guessed type int   strcpy(_DWORD, _DWORD);

//----- (0041CEF4) --------------------------------------------------------
int   strndupWithoutNull(int a1, int a2)
{
  int v4; // $s1

  v4 = mmalloc(a2 + 1);
  if ( v4 )
  {
    memcpy(v4, a1, a2);
    *(_BYTE *)(v4 + a2) = 0;
  }
  return v4;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0041CF78) --------------------------------------------------------
int   webncasestrcmp(int a1, int a2)
{
  unsigned int v4; // $s0
  unsigned int v5; // $v1
  unsigned int v6; // $a2

  if ( !a1 || !a2 )
    return 1;
  v4 = ((int (*)(void))strlen)();
  v5 = strlen(a2);
  v6 = v4;
  if ( v5 >= v4 )
    v6 = v5;
  return strncasecmp(a1, a2, v6);
}
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4EA040: using guessed type int   strncasecmp(_DWORD, _DWORD, _DWORD);

//----- (0041D02C) --------------------------------------------------------
_BYTE *  strlower(_BYTE *a1)
{
  _BYTE *result; // $v0
  _BYTE *v2; // $a1
  int v3; // $a2
  int v4; // $a2

  result = 0;
  if ( a1 )
  {
    v2 = a1;
    if ( *a1 )
    {
      v3 = (unsigned __int8)*a1 << 24;
      do
      {
        v4 = 2 * (v3 >> 24);
        if ( islower(v4) != 0 )
          *v2 = tolower(v4);
        v3 = (unsigned __int8)*++v2 << 24;
      }
      while ( *v2 );
    }
    *v2 = 0;
    return a1;
  }
  return result;
}
// 4E9F00: using guessed type int _ctype_tolower;
// 4EA098: using guessed type int _ctype_b;

//----- (0041D0BC) --------------------------------------------------------
_BYTE *  strupper(_BYTE *a1)
{
  _BYTE *result; // $v0
  _BYTE *v2; // $a1
  int v3; // $a2
  int v4; // $a2

  result = 0;
  if ( a1 )
  {
    v2 = a1;
    if ( *a1 )
    {
      v3 = (unsigned __int8)*a1 << 24;
      do
      {
        v4 = 2 * (v3 >> 24);
        if ( (islower(v4)) != 0 )
          *v2 = toupper(v4);
        v3 = (unsigned __int8)*++v2 << 24;
      }
      while ( *v2 );
    }
    *v2 = 0;
    return a1;
  }
  return result;
}
// 4EA050: using guessed type int _ctype_toupper;
// 4EA098: using guessed type int _ctype_b;

//----- (0041D150) --------------------------------------------------------
_BYTE *  stritoa(int a1, _BYTE *a2, int a3)
{
  bool v4; // dc
  int v5; // $a1
  int v6; // $t3
  _BYTE *v7; // $a2
  _BYTE *v8; // $a3
  __int64 v9; // kr00_8
  char v10; // $t8
  _BYTE *v11; // $a0
  _BYTE *result; // $v0
  BOOL v13; // $v0
  _BYTE v14[16]; // [sp+18h] [-10h] BYREF

  v4 = a2 == 0;
  v5 = a1;
  if ( v4 )
  {
    trace(16, (int)"stritoa: output buffer is NULL!\n");
    return 0;
  }
  v6 = 0;
  if ( a1 < 0 )
  {
    v5 = -a1;
    --a3;
    v6 = 1;
  }
  v7 = &v14[a3 - 1];
  v8 = v14;
  if ( v5 < 10 )
  {
    v13 = v14 < v7;
LABEL_15:
    if ( v13 )
      *v8++ = v5 + 48;
    goto LABEL_9;
  }
  if ( v14 < v7 )
  {
    v9 = 1717986919LL * v5;
    while ( 1 )
    {
      v10 = v5;
      v5 = (SHIDWORD(v9) >> 2) - (v5 >> 31);
      *v8++ = v10 - 10 * v5 + 48;
      if ( v5 < 10 )
        break;
      v9 = 1717986919LL * v5;
      if ( v8 >= v7 )
        goto LABEL_9;
    }
    v13 = v8 < v7;
    goto LABEL_15;
  }
LABEL_9:
  v11 = a2;
  if ( v6 )
  {
    *a2 = 45;
    v11 = a2 + 1;
  }
  for ( ; v14 < v8; ++v11 )
    *v11 = *--v8;
  result = a2;
  *v11 = 0;
  return result;
}

//----- (0041D294) --------------------------------------------------------
char *  websRemoveDuplicateChars(char *a1, char a2)
{
  char v2; // $t0
  char *v3; // $v1
  int v4; // $a2
  char *v5; // $a3

  if ( a1 )
  {
    v2 = *a1;
    v3 = a1;
    v4 = *a1;
    v5 = a1;
    if ( *a1 )
    {
      do
      {
        if ( v4 == a2 && v3[1] == v4 )
        {
          do
            v2 = *++v3;
          while ( *v3 == a2 && v3[1] == a2 );
        }
        if ( v5 != v3 )
          *v5 = v2;
        v2 = *++v3;
        v4 = *v3;
        ++v5;
      }
      while ( *v3 && *v5 );
    }
    if ( v5 != v3 )
      *v5 = 0;
  }
  return a1;
}

//----- (0041D358) --------------------------------------------------------
int websGetTempFileName()
{
  return tempnam("/var", "tmp");
}
// 4E9F2C: using guessed type int   tempnam(_DWORD, _DWORD);

//----- (0041D37C) --------------------------------------------------------
__int64   hexarraytohexstring(unsigned __int8 *a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v6; // $s0
  unsigned __int8 *v7; // $t3
  unsigned int v8; // $t2
  char v9; // $a1
  __int64 result; // $v0
  _BYTE v11[8]; // [sp+18h] [-8h] BYREF

  *a2 = 0;
  v6 = 0;
  if ( a3 )
  {
    v7 = a1;
    do
    {
      v8 = *v7;
      v9 = byte_4E4F18[v8 & 0xF];
      v11[0] = byte_4E4F18[v8 >> 4];
      v11[1] = v9;
      v11[2] = 0;
      ++v6;
      LODWORD(result) = strcat(a2, v11);
      HIDWORD(result) = v6 < a3;
      v7 = &a1[v6];
    }
    while ( v6 < a3 );
  }
  return result;
}
// 4E4F18: using guessed type _BYTE byte_4E4F18[16];
// 4EA00C: using guessed type int   strcat(_DWORD, _DWORD);

//----- (0041D43C) --------------------------------------------------------
unsigned int   hexstringtohexarray(char *a1, int a2)
{
  unsigned int v4; // $s2
  unsigned int v5; // $a2
  char *v6; // $a3
  int v7; // $t1
  unsigned int v8; // $s1
  char v10; // $t4
  unsigned int v11; // $t3
  unsigned int v12; // $s1
  char v13; // $t4
  unsigned int v14; // $t3
  char v15; // [sp+18h] [-8h] BYREF
  char v16; // [sp+19h] [-7h]
  char v17; // [sp+1Ah] [-6h]

  v4 = strlen(a1);
  v5 = 0;
  if ( (v4 & 1) != 0 )
  {
    trace(1, (int)"[ERROR] input length error:%u\n", v4);
    return 0;
  }
  v6 = a1;
  if ( v4 )
  {
    while ( 1 )
    {
      v7 = *v6;
      ++v5;
      if ( v7 < 48 || (unsigned int)(v7 - 58) < 7 || (unsigned int)(v7 - 71) < 0x1A || v7 >= 103 )
        break;
      v6 = &a1[v5];
      if ( v5 >= v4 )
        goto LABEL_8;
    }
    trace(1, (int)"[ERROR] input string error: %s\n", a1);
    return 0;
  }
LABEL_8:
  v8 = 0;
  if ( v4 )
  {
    while ( 1 )
    {
      v10 = a1[v8 + 1];
      v11 = v8 >> 1;
      v15 = a1[v8];
      v16 = v10;
      v17 = 0;
      v12 = v8 + 2;
      *(_BYTE *)(v11 + a2) = strtol(&v15, 0, 16);
      if ( v12 >= v4 )
        break;
      v13 = a1[v12 + 1];
      v14 = v12 >> 1;
      v15 = a1[v12];
      v16 = v13;
      v17 = 0;
      v8 = v12 + 2;
      *(_BYTE *)(v14 + a2) = strtol(&v15, 0, 16);
      if ( v8 >= v4 )
        return v4 >> 1;
    }
  }
  return v4 >> 1;
}
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4EA030: using guessed type int   strtol(_DWORD, _DWORD, _DWORD);

//----- (0041D5F8) --------------------------------------------------------
int   websProcessUrlAndCheckRealm(int a1)
{
  int v1; // $s1
  int AntiTblCount; // $v0
  int v4; // $a0
  int v5; // $v1
  int v6; // $v1
  void *v7; // $a0
  int v8; // $s2
  int v9; // $v0
  int v10; // $s3
  _BYTE *v11; // $v0
  int v12; // $v0
  int result; // $v0
  int v14; // $v1
  int v15; // $v0
  int v16; // $t2

  v1 = a1 + 4;
  AntiTblCount = websGetAntiTblCount(a1 + 4);
  v4 = a1;
  if ( AntiTblCount >= 20 )
    goto LABEL_27;
  websRemoveDuplicateChars(*(char **)(a1 + 136), 47);
  websRemoveDuplicateChars(*(char **)(a1 + 140), 47);
  v5 = *(_DWORD *)(a1 + 244);
  if ( v5 == 1 || v5 == 9 || v5 == 7 || v5 == 5 )
  {
    v14 = *(_DWORD *)(a1 + 196);
    if ( (unsigned int)(v14 - 2) >= 2
      && v14 != 5
      && v14 != 6
      && webncasestrcmp(*(_DWORD *)(a1 + 136), (int)WebInteralSnapImgCGI) )
    {
      websReplyUnSupportMsg(a1);
      return 1;
    }
  }
  websInternalForwardURL((int *)a1);
  if ( ((*(_DWORD *)(a1 + 228) >> 2) & 1) == 0 )
  {
    v6 = *(_DWORD *)(a1 + 196);
    if ( v6 != 4 && v6 != 2 && v6 != 3 && v6 != 5 && v6 != 6 )
    {
      v7 = *(void **)(a1 + 332);
      if ( v7 && *(_DWORD *)(a1 + 336) )
      {
        v8 = strdupWithoutNull(v7);
        if ( v8 )
        {
          v9 = strstr(v8, "//");
          if ( v9 )
          {
            v10 = v9 + 2;
            v11 = (_BYTE *)strchr(v9 + 2, 47);
            if ( v11 )
              *v11 = 0;
            if ( webncasestrcmp(v10, *(_DWORD *)(a1 + 336)) )
            {
              free2(v8);
              websConnError(a1, 403, (int)"Forbidden");
              return 1;
            }
          }
          free2(v8);
        }
        goto LABEL_20;
      }
      v4 = a1;
LABEL_27:
      websConnError(v4, 403, (int)"Forbidden");
      return 1;
    }
  }
LABEL_20:
  v12 = websCheckRealm(a1);
  switch ( v12 )
  {
    case 0:
      websAntiTblUnsched(v1);
      return 0;
    case 404:
      websConnError(a1, 404, (int)"File Not Found");
      return 1;
    case 500:
      websConnError(a1, 500, (int)"Invalid URL");
      return 1;
  }
  if ( !*(_DWORD *)(a1 + 164) )
  {
    websConnError(a1, 401, (int)"Authentication was requested");
    return 1;
  }
  v15 = strdupWithoutNull("/antibruteforce");
  if ( !v15 )
    return 0;
  v16 = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a1 + 136) = v15;
  result = 0;
  *(_DWORD *)(a1 + 328) = v16;
  return result;
}
// 41D794: conditional instruction was optimized away because $s2.4!=0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9FEC: using guessed type int   strstr(_DWORD, _DWORD);

//----- (0041D980) --------------------------------------------------------
int   websUrlProcessRequest(int a1)
{
  unsigned __int8 *MACAddress; // $s0
  int v3; // $v1
  int (**v4)(); // $s2
  int (*v5)(); // $s1
  int v6; // $v0
  int v7; // $s6
  int v8; // $v0
  int v9; // $a3
  unsigned __int8 *v11; // $s4
  int v12; // $s6
  int Var; // $v0
  int v14; // $v0
  int v15; // $s5
  int v16; // $v0
  int v17; // $s1
  int v18; // $v0
  int v19; // $s2
  int v20; // $v0
  int v21; // $s0
  _BYTE *v22; // $v0
  _BYTE *v23; // $v0
  int v24; // $v0
  int v25; // $a0
  bool v26; // dc
  int v27; // [sp+20h] [-8h] BYREF

  websSocketDeleteEvent(*(_DWORD *)(a1 + 212));
  websSetEnv(a1);
  websSetQuery(a1);
  websKernalParameter(a1);
  v27 = 0;
  MACAddress = (unsigned __int8 *)AllocateMACAddress(0, 0);
  if ( MACAddress )
  {
    allocFmtString(&v27, 254, (int)"%d:%s", *(_DWORD *)a1, *(char **)(a1 + 144));
    if ( v27 )
    {
      v24 = allocEncryptbyKey(v27, MACAddress);
      v25 = v27;
      v26 = v27 == 0;
      *(_DWORD *)(a1 + 156) = v24;
      if ( !v26 )
      {
        free2(v25);
        v27 = 0;
      }
    }
    free2(MACAddress);
  }
  v3 = *(_DWORD *)(a1 + 196);
  if ( v3 == 1 && (*(_DWORD *)(a1 + 228) & 1) != 0 )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v11 = (unsigned __int8 *)AllocateMACAddress(0, 0);
      v12 = 0;
      if ( v11 )
      {
        Var = websGetVar(a1, (int)"SessionKey", (int)byte_4A2DDC);
        v14 = allocDecryptbyKey(Var, v11);
        v15 = v14;
        if ( v14 )
        {
          v16 = strstr(v14, ":/");
          v17 = v16;
          if ( v16 )
            v17 = v16 + 2;
          v18 = strdupWithoutNull(*(void **)(a1 + 332));
          v19 = v18;
          if ( v18 )
          {
            v20 = strstr(v18, "//");
            if ( v20 )
            {
              v21 = v20 + 2;
              v22 = (_BYTE *)strchr(v20 + 2, 47);
              if ( v22 )
              {
                *v22 = 0;
                v21 = (int)(v22 + 1);
              }
              v23 = (_BYTE *)strchr(v21, 63);
              if ( v23 )
                *v23 = 0;
              if ( !webncasestrcmp(v17, v21) )
                v12 = 1;
            }
            if ( v19 )
              free2(v19);
          }
          if ( v15 )
            free2(v15);
        }
        free2(v11);
      }
      if ( v12 != 1 )
        goto LABEL_39;
    }
    else if ( checkSessionKeyRequest(a1) )
    {
LABEL_39:
      websConnError(a1, 403, (int)"Forbidden");
      return 1;
    }
    v3 = *(_DWORD *)(a1 + 196);
  }
  if ( v3 == 2 || v3 == 5 || v3 == 3 || v3 == 6 )
    trace(16, (int)"websUrlProcessRequest=%s\n", *(_DWORD *)(a1 + 144));
  else
    trace(1, (int)"websUrlProcessRequest=%s\n", *(_DWORD *)(a1 + 144));
  v4 = &off_4E4FF4;
  if ( off_4E4FF4 )
  {
    while ( 1 )
    {
      v5 = v4[1];
      v6 = strlen(v5);
      v7 = *(_DWORD *)(a1 + 136);
      v8 = strncasecmp(v5, v7, v6);
      v9 = v7;
      if ( !v8 || !*(_BYTE *)v5 )
      {
        if ( ((int (  *)(int, int (*)(), _DWORD, int, _DWORD))*v4)(
               a1,
               v5,
               *(_DWORD *)(a1 + 140),
               v7,
               *(_DWORD *)(a1 + 160)) )
        {
          return 1;
        }
        if ( !websConnValid(a1) )
          break;
      }
      v4 += 2;
      if ( !*v4 )
      {
        websConnError(a1, 500, (int)"This URL was not support!", v9);
        return 0;
      }
    }
    trace(16, (int)"handler %s return error value(1) after it called websConnClose!\n", (char *)v4[1]);
    return 1;
  }
  websConnError(a1, 500, (int)"This URL was not support!");
  return 0;
}
// 41DA68: conditional instruction was optimized away because $s0.4!=0
// 41DDA0: conditional instruction was optimized away because $s4.4!=0
// 41DBA8: variable 'v9' is possibly undefined
// 4E4FF4: using guessed type int (*off_4E4FF4)();
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FEC: using guessed type int   strstr(_DWORD, _DWORD);
// 4EA040: using guessed type int   strncasecmp(_DWORD, _DWORD, _DWORD);

//----- (0041DEB0) --------------------------------------------------------
int   websSafeUrl(char *a1)
{
  char *v1; // $s1
  int v2; // $s0
  int v3; // $s3
  char *v4; // $a0
  int v5; // $v0
  int v6; // $s2
  int v7; // $t0
  int v8; // $v0
  int v9; // $v0
  int v10; // $v0
  char v11; // $a3
  char *v12; // $a0
  int v13; // $a1
  char *i; // $a2

  v1 = a1;
  v2 = 0;
  v3 = 0;
  if ( a1 )
  {
    while ( 1 )
    {
      v5 = strchr(a1, 60);
      a1 = (char *)(v5 + 1);
      if ( !v5 )
        break;
      ++v2;
    }
    v3 = v2;
    v2 = 0;
    v4 = v1;
  }
  else
  {
    v4 = 0;
  }
  v6 = 0;
  if ( v1 )
  {
    while ( 1 )
    {
      v8 = strchr(v4, 62);
      v4 = (char *)(v8 + 1);
      if ( !v8 )
        break;
      ++v2;
    }
    v6 = v2;
    v7 = 0;
  }
  else
  {
    v7 = 0;
  }
  if ( !v1 )
    return v7;
  v9 = strlen(v1);
  if ( v3 || v6 )
  {
    v10 = mmalloc(v9 + 4 * v3 + 4 * v6);
    v7 = v10;
    if ( v10 )
    {
      v11 = *v1;
      v12 = v1;
      v13 = *v1;
      for ( i = (char *)v10; *v12; ++i )
      {
        while ( v13 == 60 )
        {
          strcpy(i, "&lt;");
          i += 4;
LABEL_21:
          v11 = *++v12;
          v13 = *v12;
          if ( !*v12 )
            goto LABEL_22;
        }
        if ( v13 == 62 )
        {
          strcpy(i, "&gt;");
          i += 4;
          goto LABEL_21;
        }
        *i = v11;
        v11 = *++v12;
        v13 = *v12;
      }
LABEL_22:
      *i = 0;
    }
    return v7;
  }
  return strdupWithoutNull(v1);
}
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);

//----- (0041E0B0) --------------------------------------------------------
int   websDecodeUrl(char *a1, char *a2, int a3)
{
  char v3; // $a3
  int result; // $v0
  int v6; // $t1
  char *v7; // $a3
  int v8; // $a0
  int v9; // $t8
  int v10; // $a1

  v3 = *a2;
  for ( result = *a2; *a2 && a3 > 0; ++a1 )
  {
    if ( result == 43 )
    {
      *a1 = 32;
    }
    else if ( result == 37
           && (isxdigit(2 * a2[1])) != 0
           && (v6 = 1, (isxdigit(2 * a2[2])) != 0) )
    {
      v7 = a2 + 1;
      v8 = 0;
      do
      {
        v9 = tolower(*v7);
        v10 = 16 * v8 + v9;
        v8 = v10 - 48;
        if ( (unsigned int)(v9 - 97) < 6 )
          v8 = v10 - 87;
        --v6;
        ++v7;
      }
      while ( v6 >= 0 );
      a2 = v7 - 1;
      *a1 = v8;
    }
    else
    {
      *a1 = v3;
    }
    v3 = *++a2;
    --a3;
    result = *a2;
  }
  *a1 = 0;
  return result;
}
// 4E9F00: using guessed type int _ctype_tolower;
// 4EA098: using guessed type int _ctype_b;

//----- (0041E1DC) --------------------------------------------------------
int   websParseUrlInfo(char *a1, int *a2, int *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, char **a7)
{
  int v8; // $s1
  int v9; // $s3
  int result; // $v0
  char *v11; // $a0
  _BYTE *v12; // $fp
  int v13; // $a3
  _BYTE *v14; // $a2
  int v15; // $a1
  int v16; // $v1
  _BYTE *v17; // $v0
  _BYTE *v18; // $s6
  int v19; // $s4
  _BYTE *v20; // $s0
  _BYTE *v21; // $v0
  int v22; // $v0
  char *v23; // $s2
  int v24; // $v0
  char *v25; // $s5
  int v26; // $s0
  char *v27; // $t0
  int v28; // $t1
  int i; // $t2
  int v30; // $a0
  int v31; // $t1
  int v32; // $a1
  bool v33; // dc
  char *v34; // [sp+18h] [-8h]

  v8 = strlen(a1);
  v9 = mmalloc(2 * v8 + 13);
  result = -1;
  if ( v9 )
  {
    v11 = a1;
    v12 = (_BYTE *)(v9 + 2 * v8 + 13 - 11);
    v13 = v8;
    v14 = (_BYTE *)v9;
    if ( *a1 )
    {
      LOBYTE(v15) = *a1;
      if ( v8 > 0 )
      {
        v16 = (unsigned __int8)*a1 << 24;
        do
        {
          if ( v16 >> 24 == 43 )
          {
            *v14 = 32;
          }
          else if ( v16 >> 24 == 37
                 && (isxdigit(2 * v11[1])) != 0
                 && (v27 = v11 + 1, (isxdigit(2 * v11[2])) != 0) )
          {
            v28 = 0;
            for ( i = 1; i >= 0; --i )
            {
              v30 = 16 * v28;
              v31 = tolower(*v27);
              v32 = v30 + v31;
              v33 = (unsigned int)(v31 - 97) < 6;
              v28 = v30 + v31 - 87;
              if ( !v33 )
                v28 = v32 - 48;
              ++v27;
            }
            v11 = v27 - 1;
            *v14 = v28;
          }
          else
          {
            *v14 = v15;
          }
          v15 = (unsigned __int8)*++v11;
          --v13;
          ++v14;
          if ( !*v11 )
            break;
          v16 = v15 << 24;
        }
        while ( v13 > 0 );
      }
    }
    *v14 = 0;
    stritoa(websSrvPort, v12, 10);
    v34 = ".htm";
    v18 = &unk_4A2DDC;
    v17 = (_BYTE *)strchr(v9, 63);
    v19 = v9;
    v20 = (_BYTE *)v9;
    if ( v17 )
    {
      v18 = v17 + 1;
      *v17 = 0;
      v20 = v17 + 1;
    }
    v21 = (_BYTE *)strchr(v20, 35);
    if ( v21 )
    {
      *v21 = 0;
      if ( !*v18 )
        v19 = (int)v20;
    }
    if ( a7 )
    {
      v22 = strrchr(v19, 46);
      v23 = (char *)v22;
      if ( v22 )
      {
        v24 = strcspn(v22, "/\\");
        v25 = &v23[v24];
        v26 = v24 + strspn(&v23[v24], "/\\");
        if ( v26 == strlen(v23) )
        {
          *v25 = 0;
          v34 = v23;
        }
      }
    }
    if ( a3 )
      *a3 = v19;
    if ( a4 )
      *a4 = v12;
    if ( a5 )
      *a5 = v18;
    if ( a6 )
      *a6 = &unk_4A2DDC;
    if ( a7 )
      *a7 = v34;
    result = 0;
    *a2 = v9;
  }
  return result;
}
// 4E7CA8: using guessed type int websSrvPort;
// 4E9F00: using guessed type int _ctype_tolower;
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F30: using guessed type int   strspn(_DWORD, _DWORD);
// 4E9F74: using guessed type int   strcspn(_DWORD, _DWORD);
// 4EA028: using guessed type int   strrchr(_DWORD, _DWORD);
// 4EA098: using guessed type int _ctype_b;

//----- (0041E540) --------------------------------------------------------
char *  websGetUrlType(char *a1, char *a2)
{
  char *result; // $v0
  char *v4; // $v0
  char **v5; // $s2
  char *v6; // $s1
  char *v7; // $s3
  char *v8; // [sp+28h] [-8h] BYREF
  int v9; // [sp+2Ch] [-4h] BYREF

  if ( !a1 || !*a1 || websParseUrlInfo(a1, &v9, 0, 0, 0, 0, &v8) < 0 )
  {
    strcpy(a2, "text/plain");
    *(_DWORD *)a2 = *(_DWORD *)"text/plain";
    return a2;
  }
  v4 = (char *)strdupWithoutNull(v8);
  v8 = v4;
  if ( !v4 )
    goto LABEL_8;
  v5 = websMimeList;
  strlower(v4);
  v6 = websMimeList[0];
  if ( websMimeList[0] )
  {
    v7 = v8;
    while ( strcmp(v7, v5[1]) )
    {
      v5 += 2;
      v6 = *v5;
      if ( !*v5 )
        goto LABEL_15;
    }
    strcpy(a2, v6);
  }
  v7 = v8;
LABEL_15:
  if ( v7 )
  {
    free2(v7);
    v8 = 0;
  }
  if ( !v5 || !*v5 )
  {
LABEL_8:
    strcpy(a2, "text/plain");
    *(_DWORD *)a2 = *(_DWORD *)"text/plain";
  }
  result = a2;
  if ( v9 )
  {
    free2(v9);
    v9 = 0;
    return a2;
  }
  return result;
}
// 4E4F28: using guessed type char *websMimeList[3];
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA0C8: using guessed type int   strcpy(_DWORD, _DWORD);

//----- (0041E748) --------------------------------------------------------
int   websConnValidateUrl(int a1, void *a2)
{
  _BYTE *v3; // $s3
  int result; // $v0
  int v5; // $a3
  _BYTE *v6; // $a2
  char *v7; // $a1
  int v8; // $a0
  int v9; // $v0
  int v10; // $v0
  _BYTE *v11; // $v0
  int v12; // $s1
  int j; // $s6
  int v14; // $s0
  int v15; // $v0
  int v16; // $s5
  int v17; // $v0
  int v18; // $v0
  void *v19; // $s2
  int v20; // $s0
  _DWORD *v21; // $s1
  int v22; // $a0
  char *v23; // $v0
  char *v24; // $t0
  int i; // $t1
  int v26; // $v0
  int v27; // $a1
  _DWORD v28[64]; // [sp+18h] [-100h] BYREF

  v3 = (_BYTE *)strdupWithoutNull(a2);
  result = -1;
  if ( v3 )
  {
    v5 = strlen(v3);
    v6 = v3;
    v7 = v3;
    if ( *v3 )
    {
      LOBYTE(v8) = *v3;
      if ( v5 > 0 )
      {
        v9 = (unsigned __int8)*v3 << 24;
        do
        {
          v10 = v9 >> 24;
          if ( v10 == 43 )
          {
            *v6 = 32;
          }
          else
          {
            if ( v10 == 37 && (isxdigit(2 * v7[1])) != 0 )
            {
              v24 = v7 + 1;
              if ( (isxdigit(2 * v7[2])) != 0 )
              {
                v8 = 0;
                for ( i = 1; i >= 0; --i )
                {
                  v26 = tolower(*v24);
                  v27 = 16 * v8 + v26;
                  v8 = v27 - 48;
                  if ( (unsigned int)(v26 - 97) < 6 )
                    v8 = v27 - 87;
                  ++v24;
                }
                v7 = v24 - 1;
              }
            }
            *v6 = v8;
          }
          v8 = (unsigned __int8)*++v7;
          --v5;
          ++v6;
          if ( !*v7 )
            break;
          v9 = v8 << 24;
        }
        while ( v5 > 0 );
      }
    }
    *v6 = 0;
    v28[0] = 0;
    v11 = (_BYTE *)strchr(v3, 92);
    v12 = 0;
    for ( j = 0; v11; v11 = (_BYTE *)strchr(v11, 92) )
      *v11 = 47;
    v14 = strtok(v3, "/");
    if ( v14 )
    {
      while ( 1 )
      {
        if ( v12 >= 64 )
          goto LABEL_45;
        if ( !strcmp(v14, "..") )
          break;
        if ( !strcmp(v14, ".") )
        {
LABEL_16:
          v14 = strtok(0, "/");
          if ( !v14 )
            goto LABEL_21;
        }
        else
        {
          v28[v12] = v14;
          j += strlen(v14) + 1;
          ++v12;
          v14 = strtok(0, "/");
          if ( !v14 )
          {
LABEL_21:
            if ( v12 )
              goto LABEL_24;
            goto LABEL_22;
          }
        }
      }
      if ( v12 > 0 )
        --v12;
      goto LABEL_16;
    }
LABEL_22:
    if ( strcmp(v3, "/") && *v3 )
    {
LABEL_45:
      free2(v3);
      return -1;
    }
    else
    {
LABEL_24:
      v15 = strdupWithoutNull(off_4E4FF0);
      v16 = v15;
      if ( v15 )
      {
        v17 = strlen(v15);
        v18 = mmalloc(v17 + j + 2);
        v19 = (void *)v18;
        if ( v18 )
        {
          strcpy(v18, v16);
          if ( v12 > 0 )
          {
            v20 = v12;
            v21 = v28;
            do
            {
              strcat(v19, "/");
              --v20;
              strcat(v19, *v21++);
            }
            while ( v20 );
          }
          v22 = *(_DWORD *)(a1 + 148);
          if ( v22 )
          {
            free2(v22);
            *(_DWORD *)(a1 + 148) = 0;
          }
          v23 = (char *)strdupWithoutNull(v19);
          *(_DWORD *)(a1 + 148) = v23;
          websSetVar(a1, "PATH_TRANSLATED", v23);
          if ( v19 )
            free2(v19);
        }
        if ( v16 )
          free2(v16);
      }
      free2(v3);
      return 0;
    }
  }
  return result;
}
// 4E4FF0: using guessed type char *off_4E4FF0;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F00: using guessed type int _ctype_tolower;
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FCC: using guessed type int   strtok(_DWORD, _DWORD);
// 4EA00C: using guessed type int   strcat(_DWORD, _DWORD);
// 4EA098: using guessed type int _ctype_b;
// 4EA0C8: using guessed type int   strcpy(_DWORD, _DWORD);

//----- (0041EBFC) --------------------------------------------------------
int   websConnValidateUrlPath(int a1, void *a2)
{
  int result; // $v0
  _BYTE *v4; // $s5
  int v5; // $a3
  _BYTE *v6; // $a2
  char *v7; // $a1
  int v8; // $a0
  int v9; // $v0
  int v10; // $v0
  _BYTE *v11; // $v0
  int v12; // $s3
  int j; // $s6
  int v14; // $s0
  char *v15; // $v0
  char *v16; // $s2
  int v17; // $s0
  _DWORD *v18; // $s1
  int v19; // $a0
  char *v20; // $v0
  char *v21; // $t0
  int i; // $t1
  int v23; // $v0
  int v24; // $a1
  _DWORD v25[64]; // [sp+18h] [-100h] BYREF

  result = strdupWithoutNull(a2);
  v4 = (_BYTE *)result;
  if ( result )
  {
    v5 = strlen(result);
    v6 = v4;
    v7 = v4;
    if ( *v4 )
    {
      LOBYTE(v8) = *v4;
      if ( v5 > 0 )
      {
        v9 = (unsigned __int8)*v4 << 24;
        do
        {
          v10 = v9 >> 24;
          if ( v10 == 43 )
          {
            *v6 = 32;
          }
          else
          {
            if ( v10 == 37 && (isxdigit(2 * v7[1])) != 0 )
            {
              v21 = v7 + 1;
              if ( (isxdigit(2 * v7[2])) != 0 )
              {
                v8 = 0;
                for ( i = 1; i >= 0; --i )
                {
                  v23 = tolower(*v21);
                  v24 = 16 * v8 + v23;
                  v8 = v24 - 48;
                  if ( (unsigned int)(v23 - 97) < 6 )
                    v8 = v24 - 87;
                  ++v21;
                }
                v7 = v21 - 1;
              }
            }
            *v6 = v8;
          }
          v8 = (unsigned __int8)*++v7;
          --v5;
          ++v6;
          if ( !*v7 )
            break;
          v9 = v8 << 24;
        }
        while ( v5 > 0 );
      }
    }
    *v6 = 0;
    v25[0] = 0;
    v11 = (_BYTE *)strchr(v4, 92);
    v12 = 0;
    for ( j = 0; v11; v11 = (_BYTE *)strchr(v11, 92) )
      *v11 = 47;
    v14 = strtok(v4, "/");
    if ( v14 )
    {
      while ( 1 )
      {
        if ( v12 >= 64 )
          return free2(v4);
        if ( !strcmp(v14, "..") )
          break;
        if ( !strcmp(v14, ".") )
        {
LABEL_16:
          v14 = strtok(0, "/");
          if ( !v14 )
            goto LABEL_21;
        }
        else
        {
          v25[v12] = v14;
          j += strlen(v14) + 1;
          ++v12;
          v14 = strtok(0, "/");
          if ( !v14 )
          {
LABEL_21:
            if ( v12 )
              goto LABEL_24;
            goto LABEL_22;
          }
        }
      }
      if ( v12 > 0 )
        --v12;
      goto LABEL_16;
    }
LABEL_22:
    if ( strcmp(v4, "/") && *v4 )
    {
      return free2(v4);
    }
    else
    {
LABEL_24:
      v15 = (char *)mmalloc(j + 1);
      v16 = v15;
      if ( v15 )
      {
        strcpy(v15, "/");
        v17 = 0;
        if ( v12 > 0 )
        {
          v18 = v25;
          do
          {
            while ( !v17 )
            {
              v17 = 1;
              strcat(v16, *v18++);
              if ( v12 <= 1 )
                goto LABEL_30;
            }
            ++v17;
            strcat(v16, "/");
            strcat(v16, *v18++);
          }
          while ( v17 < v12 );
        }
LABEL_30:
        v19 = *(_DWORD *)(a1 + 136);
        if ( v19 )
        {
          free2(v19);
          *(_DWORD *)(a1 + 136) = 0;
        }
        v20 = (char *)strdupWithoutNull(v16);
        *(_DWORD *)(a1 + 136) = v20;
        websSetVar(a1, "PATH_INFO", v20);
      }
      result = free2(v4);
      if ( v16 )
        return free2(v16);
    }
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F00: using guessed type int _ctype_tolower;
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FCC: using guessed type int   strtok(_DWORD, _DWORD);
// 4EA00C: using guessed type int   strcat(_DWORD, _DWORD);
// 4EA098: using guessed type int _ctype_b;

//----- (0041F054) --------------------------------------------------------
BOOL   DigestCalcHA1(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  unsigned int v11; // $v0
  unsigned int v12; // $v0
  unsigned int v13; // $v0
  unsigned int v14; // $t0
  char v15; // $t4
  int v16; // $a2
  char v17; // $a0
  char v18; // $v1
  char *v19; // $a2
  int v20; // $v1
  unsigned int v21; // $a0
  BOOL result; // $v0
  char v23; // $a3
  char v24; // $a1
  bool v25; // dc
  _BYTE *v26; // $a0
  char v27; // $t4
  unsigned int v28; // $v0
  unsigned int v29; // $v0
  int v30[22]; // [sp+18h] [-68h] BYREF
  _DWORD v31[4]; // [sp+70h] [-10h] BYREF

  MD5Init(v30);
  v11 = strlen(a2);
  MD5Update(v30, a2, v11);
  MD5Update(v30, (int)":", 1u);
  v12 = strlen(a3);
  MD5Update(v30, a3, v12);
  MD5Update(v30, (int)":", 1u);
  v13 = strlen(a4);
  MD5Update(v30, a4, v13);
  MD5Final(v31, (int)v30);
  if ( !webncasestrcmp(a1, (int)"md5-sess") )
  {
    MD5Init(v30);
    MD5Update(v30, (int)v31, 0x10u);
    MD5Update(v30, (int)":", 1u);
    v28 = strlen(a5);
    MD5Update(v30, a5, v28);
    MD5Update(v30, (int)":", 1u);
    v29 = strlen(a6);
    MD5Update(v30, a6, v29);
    MD5Final(v31, (int)v30);
  }
  v14 = 0;
  while ( 2 )
  {
    v19 = (char *)v31 + v14;
    while ( 1 )
    {
      v20 = 2 * v14;
      v21 = (unsigned __int8)*v19 >> 4;
      result = v21 < 0xA;
      v23 = v21 + 48;
      v24 = v21 + 87;
      v25 = v21 < 0xA;
      v26 = (_BYTE *)(2 * v14 + a7);
      if ( !v25 )
        break;
      *v26 = v23;
      v15 = *v19;
      v16 = v20 + a7;
      v17 = (v15 & 0xF) + 48;
      v18 = (v15 & 0xF) + 87;
      if ( (v15 & 0xFu) < 0xA )
        goto LABEL_5;
LABEL_9:
      *(_BYTE *)(v16 + 1) = v18;
      v14 = (unsigned __int16)(v14 + 1);
      v19 = (char *)v31 + v14;
      if ( v14 >= 0x10 )
        goto LABEL_10;
    }
    *v26 = v24;
    v27 = *v19;
    v16 = v20 + a7;
    v17 = (v27 & 0xF) + 48;
    v18 = (v27 & 0xF) + 87;
    if ( (v27 & 0xFu) >= 0xA )
      goto LABEL_9;
LABEL_5:
    *(_BYTE *)(v16 + 1) = v17;
    v14 = (unsigned __int16)(v14 + 1);
    if ( v14 < 0x10 )
      continue;
    break;
  }
LABEL_10:
  *(_BYTE *)(a7 + 32) = 0;
  return result;
}
// 4E9F24: using guessed type int   strlen(_DWORD);

//----- (0041F360) --------------------------------------------------------
int   DigestCalcResponse(int a1, int a2, int a3, int a4, _BYTE *a5, int a6, int a7, int a8, int a9)
{
  unsigned int v13; // $v0
  unsigned int v14; // $v0
  unsigned int i; // $t0
  char v16; // $t4
  _BYTE *v17; // $a2
  char v18; // $a0
  char v19; // $v1
  char *v20; // $a2
  int v21; // $v1
  unsigned int v22; // $a0
  char v23; // $a3
  char v24; // $a1
  bool v25; // dc
  _BYTE *v26; // $a0
  char v27; // $t4
  unsigned int v28; // $v0
  int result; // $v0
  unsigned int v30; // $t0
  char v31; // $s6
  int v32; // $a2
  char v33; // $a0
  char v34; // $v1
  char *v35; // $a2
  int v36; // $v1
  unsigned int v37; // $t6
  _BYTE *v38; // $a0
  char v39; // $s6
  unsigned int v40; // $v0
  unsigned int v41; // $v0
  unsigned int v42; // $v0
  int v43[22]; // [sp+18h] [-A0h] BYREF
  _DWORD v44[4]; // [sp+70h] [-48h] BYREF
  _DWORD v45[4]; // [sp+80h] [-38h] BYREF
  _BYTE v46[40]; // [sp+90h] [-28h] BYREF

  MD5Init(v43);
  v13 = strlen(a6);
  MD5Update(v43, a6, v13);
  MD5Update(v43, (int)":", 1u);
  v14 = strlen(a7);
  MD5Update(v43, a7, v14);
  if ( !webncasestrcmp((int)a5, (int)"auth-int") )
  {
    MD5Update(v43, (int)":", 1u);
    MD5Update(v43, a8, 0x20u);
  }
  MD5Final(v44, (int)v43);
  for ( i = 0; i < 0x10; i = (unsigned __int16)(i + 1) )
  {
    while ( 1 )
    {
      v20 = (char *)v44 + i;
      v21 = 2 * i;
      v22 = *((unsigned __int8 *)v44 + i) >> 4;
      v23 = v22 + 48;
      v24 = v22 + 87;
      v25 = v22 < 0xA;
      v26 = &v46[2 * i];
      if ( !v25 )
        break;
      *v26 = v23;
      v16 = *v20;
      v17 = &v46[v21];
      v18 = (v16 & 0xF) + 48;
      v19 = (v16 & 0xF) + 87;
      if ( (v16 & 0xFu) >= 0xA )
        goto LABEL_8;
LABEL_5:
      v17[1] = v18;
      i = (unsigned __int16)(i + 1);
      if ( i >= 0x10 )
        goto LABEL_9;
    }
    *v26 = v24;
    v27 = *v20;
    v17 = &v46[v21];
    v18 = (v27 & 0xF) + 48;
    v19 = (v27 & 0xF) + 87;
    if ( (v27 & 0xFu) < 0xA )
      goto LABEL_5;
LABEL_8:
    v17[1] = v19;
  }
LABEL_9:
  v46[32] = 0;
  MD5Init(v43);
  MD5Update(v43, a1, 0x20u);
  MD5Update(v43, (int)":", 1u);
  v28 = strlen(a2);
  MD5Update(v43, a2, v28);
  MD5Update(v43, (int)":", 1u);
  if ( *a5 )
  {
    v40 = strlen(a3);
    MD5Update(v43, a3, v40);
    MD5Update(v43, (int)":", 1u);
    v41 = strlen(a4);
    MD5Update(v43, a4, v41);
    MD5Update(v43, (int)":", 1u);
    v42 = strlen(a5);
    MD5Update(v43, (int)a5, v42);
    MD5Update(v43, (int)":", 1u);
  }
  MD5Update(v43, (int)v46, 0x20u);
  result = MD5Final(v45, (int)v43);
  v30 = 0;
  while ( 2 )
  {
    while ( 1 )
    {
      v35 = (char *)v45 + v30;
      v36 = 2 * v30;
      v37 = *((unsigned __int8 *)v45 + v30) >> 4;
      v38 = (_BYTE *)(2 * v30 + a9);
      if ( v37 >= 0xA )
        break;
      *v38 = v37 + 48;
      v31 = *v35;
      v32 = v36 + a9;
      v33 = (v31 & 0xF) + 48;
      v34 = (v31 & 0xF) + 87;
      if ( (v31 & 0xFu) >= 0xA )
        goto LABEL_16;
LABEL_13:
      v30 = (unsigned __int16)(v30 + 1);
      *(_BYTE *)(v32 + 1) = v33;
      if ( v30 >= 0x10 )
        goto LABEL_17;
    }
    *v38 = v37 + 87;
    v39 = *v35;
    v32 = v36 + a9;
    v33 = (v39 & 0xF) + 48;
    v34 = (v39 & 0xF) + 87;
    if ( (v39 & 0xFu) < 0xA )
      goto LABEL_13;
LABEL_16:
    v30 = (unsigned __int16)(v30 + 1);
    *(_BYTE *)(v32 + 1) = v34;
    if ( v30 < 0x10 )
      continue;
    break;
  }
LABEL_17:
  *(_BYTE *)(a9 + 32) = 0;
  return result;
}
// 4E9F24: using guessed type int   strlen(_DWORD);

//----- (0041F7C4) --------------------------------------------------------
int   websGetDigestNonce(int a1)
{
  int v2; // $v0
  int v3; // $v0
  unsigned int v5; // $v0
  unsigned int v6; // $t0
  char v7; // $t4
  _BYTE *v8; // $a2
  char v9; // $a0
  char v10; // $v1
  char *v11; // $a2
  int v12; // $v1
  unsigned int v13; // $a0
  char v14; // $a3
  char v15; // $a1
  bool v16; // dc
  _BYTE *v17; // $a0
  char v18; // $t4
  int v19[22]; // [sp+20h] [-A8h] BYREF
  _DWORD v20[4]; // [sp+78h] [-50h] BYREF
  _BYTE v21[40]; // [sp+88h] [-40h] BYREF
  char v22[16]; // [sp+B0h] [-18h] BYREF
  int v23; // [sp+C0h] [-8h] BYREF

  v2 = time(0);
  srand(v2);
  v3 = rand();
  stritoa(v3, v22, 16);
  allocFmtString(&v23, 256, (int)"%s:%s", v22, *(char **)(a1 + 300));
  if ( !v23 )
    return strdupWithoutNull(v21);
  MD5Init(v19);
  v5 = strlen(v23);
  MD5Update(v19, v23, v5);
  MD5Final(v20, (int)v19);
  v6 = 0;
  do
  {
    while ( 1 )
    {
      v11 = (char *)v20 + v6;
      v12 = 2 * v6;
      v13 = *((unsigned __int8 *)v20 + v6) >> 4;
      v14 = v13 + 48;
      v15 = v13 + 87;
      v16 = v13 < 0xA;
      v17 = &v21[2 * v6];
      if ( !v16 )
        break;
      *v17 = v14;
      v7 = *v11;
      v8 = &v21[v12];
      v9 = (v7 & 0xF) + 48;
      v10 = (v7 & 0xF) + 87;
      if ( (v7 & 0xFu) >= 0xA )
        goto LABEL_8;
LABEL_5:
      v6 = (unsigned __int16)(v6 + 1);
      v8[1] = v9;
      if ( v6 >= 0x10 )
        goto LABEL_9;
    }
    *v17 = v15;
    v18 = *v11;
    v8 = &v21[v12];
    v9 = (v18 & 0xF) + 48;
    v10 = (v18 & 0xF) + 87;
    if ( (v18 & 0xFu) < 0xA )
      goto LABEL_5;
LABEL_8:
    v6 = (unsigned __int16)(v6 + 1);
    v8[1] = v10;
  }
  while ( v6 < 0x10 );
LABEL_9:
  v21[32] = 0;
  if ( v23 )
  {
    free2(v23);
    v23 = 0;
  }
  return strdupWithoutNull(v21);
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F90: using guessed type int   time(_DWORD);
// 4E9F9C: using guessed type int   srand(_DWORD);
// 4E9FE8: using guessed type int rand(void);

//----- (0041F9C8) --------------------------------------------------------
int   websCheckDigestRealm(int a1)
{
  int v2; // $s3
  int result; // $v0
  char *Realm; // $s0
  int v5; // $s6
  int v6; // $s7
  int v7; // $s4
  int v8; // $fp
  int v9; // $s1
  void *Var; // $v0
  int v11; // $s5
  int v12; // $v0
  int v13; // $s0
  _BYTE v14[40]; // [sp+30h] [-88h] BYREF
  _BYTE v15[40]; // [sp+58h] [-60h] BYREF
  _BYTE v16[40]; // [sp+80h] [-38h] BYREF
  int v17; // [sp+A8h] [-10h]
  int v18; // [sp+ACh] [-Ch]
  _BYTE *v19; // [sp+B0h] [-8h]

  v2 = -1;
  if ( !*(_DWORD *)(a1 + 300) || !*(_DWORD *)(a1 + 304) || !*(_DWORD *)(a1 + 308) || !*(_DWORD *)(a1 + 312) )
    return v2;
  result = -1;
  if ( *(_DWORD *)(a1 + 316) && *(_DWORD *)(a1 + 320) && *(_DWORD *)(a1 + 324) )
  {
    Realm = websGetRealm(a1);
    v5 = strdupWithoutNull(*(void **)(a1 + 172));
    v6 = strdupWithoutNull(*(void **)(a1 + 168));
    v7 = strdupWithoutNull(*(void **)(a1 + 300));
    v8 = strdupWithoutNull(*(void **)(a1 + 304));
    v9 = strdupWithoutNull(*(void **)(a1 + 312));
    v17 = strdupWithoutNull(*(void **)(a1 + 316));
    v18 = strdupWithoutNull(*(void **)(a1 + 320));
    v19 = (_BYTE *)strdupWithoutNull(*(void **)(a1 + 324));
    memset(v15, 0, 33);
    if ( v5 )
    {
      if ( v6 )
      {
        if ( v7 )
        {
          if ( v8 )
          {
            if ( v9 )
            {
              if ( v17 )
              {
                if ( v18 )
                {
                  if ( v19 )
                  {
                    if ( !strcmp(v7, Realm) )
                    {
                      Var = (void *)websGetVar(a1, (int)"HTTP_REQUEST", 0);
                      v11 = strdupWithoutNull(Var);
                      if ( v11 )
                      {
                        DigestCalcHA1((int)"md5", v5, v7, v6, v8, v18, (int)v14);
                        DigestCalcResponse((int)v14, v8, v17, v18, v19, v11, v9, (int)v15, (int)v16);
                        v12 = strdupWithoutNull(v16);
                        v13 = v12;
                        if ( v12 )
                        {
                          if ( !strcmp(*(_DWORD *)(a1 + 308), v12) )
                            v2 = 0;
                          free2(v13);
                        }
                        free2(v11);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      free2(v5);
    }
    if ( v6 )
      free2(v6);
    if ( v7 )
      free2(v7);
    if ( v8 )
      free2(v8);
    if ( v9 )
      free2(v9);
    if ( v17 )
      free2(v17);
    if ( v18 )
      free2(v18);
    if ( v19 )
      free2(v19);
    return v2;
  }
  return result;
}
// 41FBE4: conditional instruction was optimized away because $s6.4!=0
// 41FE10: conditional instruction was optimized away because $s5.4!=0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (0041FE34) --------------------------------------------------------
int websSSLOpen()
{
  int v0; // $v0
  int v1; // $a2
  int v2; // $v0
  int v3; // $v0
  int v4; // $s2
  char *v5; // $s3
  int RsaKeys; // $v0
  int v7; // $s1
  int v8; // $v0

  v0 = matrixSslOpenWithConfig((int)"YNYYNNNNNYYNY");
  v1 = -1;
  if ( v0 < 0 )
    return v1;
  v2 = matrixSslNewKeys(&dword_4E5034, 0);
  v1 = -1;
  if ( v2 < 0 )
    return v1;
  v4 = mmalloc(36);
  v3 = mmalloc(37);
  v5 = (char *)v3;
  if ( !v4 )
    goto LABEL_6;
  if ( !v3 )
  {
LABEL_8:
    if ( v4 )
      free2(v4);
    v8 = websSocketOpenConnection(WebSrv_HTTPS_Port, (int)websSSLAccept, 0x10u);
    v1 = 0;
    dword_4E5038 = v8;
    if ( v8 < 0 )
    {
      fprintf(stderr, "SSL: Unable to open SSL socket on port %d!\n", WebSrv_HTTPS_Port);
      matrixSslDeleteKeys(dword_4E5034);
      matrixSslClose();
      return -1;
    }
    return v1;
  }
  sprintf(v4, "%s/%s", "/etc_ro", "serverkey.pem");
  sprintf(v5, "%s/%s", "/etc_ro", "servercert.pem");
  RsaKeys = matrixSslLoadRsaKeys(dword_4E5034, v5, v4, 0, 0);
  v7 = RsaKeys;
  if ( RsaKeys >= 0 )
  {
LABEL_6:
    if ( v5 )
      free2(v5);
    goto LABEL_8;
  }
  fprintf(stderr, "failed to read certificates in websSSLOpen(%d)!\n", RsaKeys);
  if ( v7 == -37 )
  {
    nvram_bufset(0, "SSLCertificate1", byte_4A2DDC);
    nvram_bufset(0, "SSLCertificate2", byte_4A2DDC);
    nvram_commit(0);
    nvram_close(0);
    nvram_init(0);
    preparesslkey();
  }
  free2(v5);
  free2(v4);
  matrixSslDeleteKeys(dword_4E5034);
  matrixSslClose();
  return v7;
}
// 4E3424: using guessed type int WebSrv_HTTPS_Port;
// 4E5034: using guessed type int dword_4E5034;
// 4E5038: using guessed type int dword_4E5038;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F1C: using guessed type int   nvram_init(_DWORD);
// 4E9F64: using guessed type int   nvram_close(_DWORD);
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);
// 4E9F70: using guessed type int stderr;
// 4E9F78: using guessed type int sprintf(_DWORD, char *, ...);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4EA014: using guessed type int fprintf(_DWORD, char *, ...);

//----- (0042015C) --------------------------------------------------------
int   websSSLAccept(int a1, int a2, int a3, int a4)
{
  int v6; // $v0
  int v8; // $v1
  _DWORD *v9; // $s0
  unsigned int v10; // $v0
  int v11; // $v0

  v6 = websConnAlloc(a1);
  v8 = -1;
  if ( v6 >= 0 )
  {
    v9 = *(_DWORD **)(4 * v6 + websConnList);
    v9[54] = a4;
    v10 = strlen(a2) + 1;
    if ( v10 >= 0x21 )
      v10 = 32;
    memcpy(v9 + 1, a2, v10);
    if ( !strcmp(v9 + 1, "127.0.0.1") || !strcmp(v9 + 1, &websSrvIpAddr) || !strcmp(v9 + 1, &websSrvHostName) )
      v11 = v9[57] | 4;
    else
      v11 = v9[57];
    v9[57] = v11 | 0x80;
    websSocketCreateEvent(a1, 2, (int)sub_420570, (int)v9);
    v9[59] = websTimeoutSched(60, (int)websTimeout, (int)v9);
    trace(8, (int)"SSL accept request\n");
    return 0;
  }
  return v8;
}
// 4E7CA4: using guessed type int websConnList;
// 4E7CAC: using guessed type char websSrvHostName;
// 4E7CCC: using guessed type char websSrvIpAddr;
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00420308) --------------------------------------------------------
int   websSSLRead(int **a1, int a2, int a3)
{
  int v3; // $a0
  int v5; // [sp+18h] [-8h] BYREF

  v3 = sslRead(*a1, a2, a3, &v5);
  if ( !v3 && v5 == 1 )
    return -1;
  else
    return v3;
}

//----- (00420374) --------------------------------------------------------
int   websSSLGets(int a1, int *a2)
{
  int Ptr; // $s1
  int result; // $v0
  _DWORD *v6; // $s0
  int v7; // $v0
  signed int v8; // $v0
  signed int v9; // $s1
  char v10[4]; // [sp+18h] [-8h] BYREF
  int v11; // [sp+1Ch] [-4h] BYREF

  *a2 = 0;
  Ptr = websSocketGetPtr(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 212));
  result = -1;
  if ( Ptr )
  {
    v6 = (_DWORD *)(Ptr + 56);
    do
    {
LABEL_3:
      v7 = sslRead(*(int **)a1, (int)v10, 1, &v11);
      if ( v7 )
      {
        while ( v7 >= 0 )
        {
          if ( v10[0] == 10 )
            goto LABEL_12;
          if ( v10[0] == 13 )
            goto LABEL_3;
          memPoolPutChar((int *)(Ptr + 56), v10[0]);
          v7 = sslRead(*(int **)a1, (int)v10, 1, &v11);
          if ( !v7 )
            goto LABEL_4;
        }
        return -1;
      }
LABEL_4:
      if ( v11 == 1 )
        return -1;
    }
    while ( (int)memPoolLen((_DWORD *)(Ptr + 56)) <= 0 || (*(_DWORD *)(Ptr + 108) & 1) == 0 );
    v10[0] = 10;
LABEL_12:
    v8 = memPoolLen((_DWORD *)(Ptr + 56));
    v9 = v8;
    if ( v8 <= 0 )
      *a2 = 0;
    else
      *a2 = strndupWithoutNull(v6[4], v8);
    memPoolFlush(v6);
    return v9;
  }
  return result;
}
// 4204A8: conditional instruction was optimized away because $v0.4>=1

//----- (00420570) --------------------------------------------------------
int *  sub_420570(int a1, unsigned int a2, _DWORD *a3)
{
  int *result; // $v0
  unsigned int v6; // $t0
  int (  *v7)(_DWORD *); // $t9
  int **v8; // $v0
  int v9; // $a0
  int *v10[2]; // [sp+18h] [-8h] BYREF

  result = (int *)websConnValid((int)a3);
  if ( !result )
    return result;
  result = (int *)((a2 & 2) != 0);
  v6 = a2 >> 2;
  if ( (a2 & 2) != 0 )
  {
    result = (int *)websSocketGetPtr(a3[53]);
    v6 = a2 >> 2;
    if ( result )
    {
      if ( sslAccept(v10, result[28], dword_4E5034, 0) < 0 )
      {
        v9 = (int)a3;
        goto LABEL_11;
      }
      v8 = (int **)mmalloc(8);
      a3[68] = v8;
      if ( !v8 )
      {
        sslFreeConnection(v10);
        v9 = (int)a3;
LABEL_11:
        websTimeoutCancel(v9);
        websSocketCloseConnection(a3[53]);
        result = websConnFree((int)a3);
        v6 = a2 >> 2;
        goto LABEL_3;
      }
      *v8 = v10[0];
      *(_DWORD *)(a3[68] + 4) = a3;
      result = (int *)websReadEvent(a3);
      v6 = a2 >> 2;
    }
  }
LABEL_3:
  if ( (v6 & 1) != 0 )
  {
    v7 = (int (  *)(_DWORD *))a3[67];
    if ( v7 )
      return (int *)v7(a3);
  }
  return result;
}
// 4E5034: using guessed type int dword_4E5034;

//----- (004206F8) --------------------------------------------------------
int   websSSLWrite(int **a1, int a2, signed int a3)
{
  int result; // $v0
  int v7; // [sp+18h] [-8h] BYREF

  result = -1;
  if ( a1 )
  {
    do
      result = sslWrite(*a1, a2, a3, &v7);
    while ( !result );
    if ( result < 0 )
      return -1;
  }
  return result;
}

//----- (00420790) --------------------------------------------------------
int   websSSLEof(int a1)
{
  return websSocketEof(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 212));
}

//----- (004207B0) --------------------------------------------------------
int websSSLFlush()
{
  return 0;
}

//----- (004207B8) --------------------------------------------------------
int   webssslWriteClosureAlert(_DWORD ***a1)
{
  sslWriteClosureAlert(*a1);
  return 0;
}

//----- (004207F4) --------------------------------------------------------
int   websSSLFree(int **a1)
{
  if ( a1 )
  {
    sslFreeConnection(a1);
    free2(a1);
  }
  return 0;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00420854) --------------------------------------------------------
int websSSLClose()
{
  matrixSslDeleteKeys(dword_4E5034);
  return matrixSslClose();
}
// 4E5034: using guessed type int dword_4E5034;

//----- (00420898) --------------------------------------------------------
int   sslRead(int *a1, int a2, int a3, _DWORD *a4)
{
  _DWORD *v5; // $a0
  int v9; // $s5
  int v10; // $a1
  int v11; // $s2
  int v12; // $s3
  int Outdata; // $v0
  int v14; // $v0
  int v15; // $s0
  _DWORD *v16; // $a0
  int v17; // $v0
  int v18; // $v1
  unsigned int v19; // $a1
  unsigned int v20; // $a2
  int v21; // $s0
  _DWORD *v23; // $v0
  bool v24; // dc
  int v25; // $v0
  _DWORD *v26; // $v0
  int v27; // $a1
  char v28; // $t5
  char *v29; // $v1
  int v30; // $v0
  int v31; // $a2
  int v32; // $v0
  int v33; // $s0
  int v34; // $v0
  char *v35; // $a1
  int v36; // $a0
  int v37; // $v0
  int v38; // $a1
  int v39; // $s0
  int v40; // $v0
  _DWORD *v41; // $v0
  char *v42; // [sp+18h] [-8h] BYREF
  int i; // [sp+1Ch] [-4h] BYREF

  *a4 = 0;
  v5 = (_DWORD *)*a1;
  v9 = 1;
  if ( !v5 )
    return -1;
  v10 = -1;
  if ( a3 <= 0 )
    return v10;
  if ( a1[1] )
  {
    v19 = a1[2];
    v20 = a1[3];
    v21 = v20 - v19;
    if ( v19 < v20 )
    {
      if ( a3 < v21 )
        v21 = a3;
      memcpy(a2, v19, v21);
      a1[2] += v21;
      return v21;
    }
    free2(a1[1]);
    v5 = (_DWORD *)*a1;
    a1[1] = 0;
  }
  v11 = 0;
  v12 = 0;
LABEL_5:
  Outdata = matrixSslGetOutdata(v5, &v42);
  for ( i = Outdata; Outdata > 0; i = Outdata )
  {
    usleep(1000);
    v14 = send(a1[5], v42, i, 64);
    v15 = v14;
    if ( v14 )
    {
      if ( v14 < 0 )
      {
        v26 = (_DWORD *)_errno_location();
        v24 = *v26 != 11;
        *a4 = *v26;
        if ( v24 )
          return -1;
        if ( v11 != 255 )
          usleep(1000 * v11);
        v11 = (unsigned __int8)(v11 + 1);
        v10 = -1;
        if ( !v11 )
          return v10;
        v16 = (_DWORD *)*a1;
      }
      else
      {
        v25 = matrixSslSentData((_DWORD *)*a1, v14);
        if ( v25 < 0 )
          goto LABEL_74;
        if ( v25 == 3 )
        {
LABEL_75:
          v27 = 0;
          *a4 = 1;
          return v27;
        }
        if ( v25 == 5 )
          v9 = 1;
        if ( v25 != 1 && v15 >= i )
          goto LABEL_11;
        v11 = (unsigned __int8)(v11 + 1);
        if ( !v11 )
          goto LABEL_11;
        v16 = (_DWORD *)*a1;
      }
    }
    else
    {
      v11 = (unsigned __int8)(v11 + 1);
      if ( !v11 )
      {
        v41 = (_DWORD *)_errno_location();
        v10 = -1;
        *a4 = *v41;
        return v10;
      }
LABEL_8:
      v16 = (_DWORD *)*a1;
    }
LABEL_9:
    Outdata = matrixSslGetOutdata(v16, &v42);
  }
  if ( Outdata >= 0 )
  {
LABEL_11:
    v10 = 0;
    if ( !v9 )
      return v10;
LABEL_12:
    while ( 1 )
    {
      i = matrixSslGetReadbuf((_DWORD *)*a1, &v42);
      if ( i <= 0 )
        break;
      usleep(1000);
      v17 = recv(a1[5], v42, i, 64);
      if ( !v17 )
        goto LABEL_75;
      if ( v17 >= 0 )
      {
        v18 = matrixSslReceivedData(*a1, v17, &v42, &i);
        if ( v18 >= 0 )
        {
          while ( 1 )
          {
            switch ( v18 )
            {
              case 1:
                v11 = (unsigned __int8)(v11 + 1);
                v9 = 0;
                if ( !v11 )
                  return 0;
                v16 = (_DWORD *)*a1;
                goto LABEL_9;
              case 2:
                v28 = v12 + 1;
                v12 = (unsigned __int8)(v12 + 1);
                if ( v28 )
                  goto LABEL_12;
                return 0;
              case 4:
              case 7:
                v31 = i;
                if ( i <= 0 )
                  goto LABEL_61;
                v32 = a1[1];
                if ( v32 )
                {
                  v38 = a1[4];
                  v36 = a1[3];
                  v39 = v36 - a1[2];
                  if ( v32 + v38 - v36 < i )
                  {
                    v40 = realloc(a1[2], v38 + i);
                    v35 = v42;
                    v31 = i;
                    v36 = v40 + v39;
                    a1[1] = v40;
                    a1[2] = v40;
                    a1[3] = v40 + v39;
                  }
                  else
                  {
                    v35 = v42;
                  }
                }
                else
                {
                  v33 = i;
                  if ( i < 1500 )
                    v33 = 1500;
                  v34 = mmalloc(v33);
                  a1[1] = v34;
                  a1[3] = v34;
                  a1[2] = v34;
                  if ( !v34 )
                    goto LABEL_74;
                  v35 = v42;
                  v31 = i;
                  v36 = v34;
                  a1[4] = v33;
                }
                memcpy(v36, v35, v31);
                a1[3] += i;
LABEL_61:
                v37 = matrixSslProcessedData((_DWORD *)*a1, &v42, &i);
                v18 = v37;
                if ( !v37 )
                  return 0;
                if ( v37 <= 0 )
                  goto LABEL_41;
                switch ( v37 )
                {
                  case 4:
                    continue;
                  case 1:
                    goto LABEL_8;
                  case 2:
                    goto LABEL_12;
                }
                v10 = 0;
                if ( v37 != 6 )
                  return v10;
                v29 = v42;
                if ( !v42 )
                  goto LABEL_41;
                v30 = (unsigned __int8)*v42;
LABEL_49:
                if ( v30 == 2 )
                {
LABEL_41:
                  v27 = -1;
                  *a4 = 3;
                  return v27;
                }
                v10 = 0;
                if ( !v29[1] )
                {
                  *a4 = 2;
                  return v10;
                }
                v18 = matrixSslProcessedData((_DWORD *)*a1, &v42, &i);
                if ( !v18 )
                  goto LABEL_12;
                break;
              case 5:
                v5 = (_DWORD *)*a1;
                v9 = 1;
                goto LABEL_5;
              case 6:
                v29 = v42;
                if ( !v42 )
                  goto LABEL_41;
                v30 = (unsigned __int8)*v42;
                goto LABEL_49;
              default:
                goto LABEL_41;
            }
          }
        }
        break;
      }
      v23 = (_DWORD *)_errno_location();
      v24 = *v23 != 11;
      *a4 = *v23;
      if ( !v24 )
      {
        if ( v12 != 255 )
          usleep(1000 * v12);
        v12 = (unsigned __int8)(v12 + 1);
        if ( v12 )
          continue;
      }
      return -1;
    }
  }
LABEL_74:
  v27 = -1;
  *a4 = 4;
  return v27;
}
// 420C28: conditional instruction was optimized away because $v0.4<0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F40: using guessed type int _errno_location(void);
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);
// 4EA03C: using guessed type int   send(_DWORD, _DWORD, _DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);
// 4EA090: using guessed type int   usleep(_DWORD);
// 4EA0B4: using guessed type int   recv(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00420EB8) --------------------------------------------------------
int   sslWrite(int *a1, int a2, signed int a3, int *a4)
{
  int v8; // $s5
  int v9; // $s2
  int Outdata; // $v0
  int v11; // $s1
  int v12; // $v0
  int v13; // $s0
  int *v14; // $v0
  int v15; // $a1
  int v16; // $v0
  int Writebuf; // $v0
  int v18; // $v0
  int v19; // $v0
  int *v21; // $v0
  bool v22; // dc
  int v23[2]; // [sp+18h] [-8h] BYREF

  *a4 = 0;
  v8 = 1;
  v9 = 0;
LABEL_2:
  Outdata = matrixSslGetOutdata((_DWORD *)*a1, v23);
  v11 = Outdata;
  if ( Outdata <= 0 )
    goto LABEL_17;
  while ( 1 )
  {
    usleep(1000);
    v12 = send(a1[5], v23[0], v11, 0);
    v13 = v12;
    if ( !v12 )
    {
      v9 = (unsigned __int8)(v9 + 1);
      if ( !v9 )
      {
        v14 = (int *)_errno_location();
        v15 = -1;
        *a4 = *v14;
        return v15;
      }
      goto LABEL_2;
    }
    if ( v12 < 0 )
    {
      v21 = (int *)_errno_location();
      v22 = *v21 != 11;
      *a4 = *v21;
      if ( v22 )
        return -1;
      if ( v9 != 255 )
        usleep(1000 * v9);
      v9 = (unsigned __int8)(v9 + 1);
      if ( !v9 )
        return -1;
      goto LABEL_2;
    }
    v16 = matrixSslSentData((_DWORD *)*a1, v12);
    if ( v16 < 0 )
      break;
    if ( v16 == 3 )
    {
      v15 = 0;
      v19 = 1;
      goto LABEL_20;
    }
    if ( v16 == 1 || v13 < v11 )
    {
      v9 = (unsigned __int8)(v9 + 1);
      if ( v9 )
        goto LABEL_2;
    }
    while ( 1 )
    {
      if ( !v8 )
        return a3;
      Writebuf = matrixSslGetWritebuf(*a1, v23, a3);
      if ( Writebuf < 0 || Writebuf < a3 )
      {
LABEL_18:
        v15 = -1;
LABEL_19:
        v19 = 4;
        goto LABEL_20;
      }
      usleep(1000);
      memcpy(v23[0], a2, a3);
      v18 = matrixSslEncodeWritebuf(*a1, a3);
      v15 = -1;
      if ( v18 < 0 )
        goto LABEL_19;
      Outdata = matrixSslGetOutdata((_DWORD *)*a1, v23);
      v8 = 0;
      v11 = Outdata;
      if ( Outdata > 0 )
        break;
LABEL_17:
      if ( Outdata < 0 )
        goto LABEL_18;
    }
  }
  v15 = -1;
  v19 = 3;
LABEL_20:
  *a4 = v19;
  return v15;
}
// 4E9F40: using guessed type int _errno_location(void);
// 4EA03C: using guessed type int   send(_DWORD, _DWORD, _DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);
// 4EA090: using guessed type int   usleep(_DWORD);

//----- (00421170) --------------------------------------------------------
int   sslWriteClosureAlert(_DWORD **a1)
{
  int result; // $v0
  int v3; // [sp+18h] [-8h] BYREF

  result = matrixSslEncodeClosureAlert(*a1);
  if ( result >= 0 )
  {
    result = matrixSslGetOutdata(*a1, &v3);
    if ( result > 0 )
    {
      result = send(a1[5], v3, result, 64);
      if ( result > 0 )
        return matrixSslSentData(*a1, result);
    }
  }
  return result;
}
// 4EA03C: using guessed type int   send(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00421218) --------------------------------------------------------
int   sslFreeConnection(int **a1)
{
  int *v1; // $s0
  int v3; // $v0
  int result; // $v0

  v1 = *a1;
  matrixSslDeleteSession(**a1);
  v3 = v1[1];
  *v1 = 0;
  if ( v3 )
  {
    free2(v3);
    v1[1] = 0;
  }
  result = free2(v1);
  *a1 = 0;
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (004212D0) --------------------------------------------------------
int   sslAccept(int **a1, int a2, int a3, int a4)
{
  int *v8; // $s0
  int result; // $v0
  bool IsComplete; // dc
  int v11; // $v0
  int v12; // $a0
  _BYTE v13[1024]; // [sp+18h] [-450h] BYREF
  _DWORD v14[18]; // [sp+418h] [-50h] BYREF
  int v15; // [sp+460h] [-8h] BYREF

  memset(v14, 0, 68);
  v14[5] = a4;
  v14[7] = a3;
  v8 = (int *)mmalloc(24);
  result = -1;
  if ( v8 )
  {
    v8[5] = a2;
    if ( matrixSslNewServerSession(v8, a3, 0, (int)v14) >= 0 )
    {
      v8[4] = 0;
      v8[1] = 0;
      v8[3] = 0;
      v8[2] = 0;
      *a1 = v8;
      while ( 1 )
      {
        v11 = sslRead(v8, (int)v13, 1024, &v15);
        if ( v11 )
          break;
        if ( (unsigned int)(v15 - 1) < 2 )
          goto LABEL_8;
        IsComplete = matrixSslHandshakeIsComplete(*v8);
        result = 0;
        if ( IsComplete )
        {
          *a1 = v8;
          return result;
        }
      }
      if ( v11 > 0 )
      {
        printf("%s:%d sslAssert(%s)\n", "sslSocket.c", 66, (char *)&word_4A0308);
        abort();
      }
    }
LABEL_8:
    matrixSslDeleteSession(*v8);
    v12 = v8[1];
    *v8 = 0;
    if ( v12 )
    {
      free2(v12);
      v8[1] = 0;
    }
    free2(v8);
    return -1;
  }
  return result;
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA038: using guessed type void __noreturn abort(void);
// 4EA0BC: using guessed type int printf(char *, ...);

//----- (004214C4) --------------------------------------------------------
int   checkrangestring(int a1, int a2, int a3, int a4, int a5)
{
  int v7; // $s2
  int v8; // $s3
  int v9; // $v0
  _BYTE *v10; // $v0
  _BYTE *v11; // $s0
  _BYTE *v12; // $s1
  int v13; // $v0
  _BYTE *v14; // $v0
  _BYTE *v15; // $s0
  _BYTE *v16; // $s1
  int v17; // $s0
  char *ErrorMessage; // $v0
  int i; // $a1
  unsigned int v20; // $a0
  int v21; // $a2
  char *v22; // $v1
  unsigned int v23; // $fp
  unsigned __int8 *j; // $v1
  char v26[8]; // [sp+18h] [-18h] BYREF
  char v27[8]; // [sp+20h] [-10h] BYREF
  int v28; // [sp+28h] [-8h]

  strcpy(v26, "&nbsp;");
  v7 = strlen(v26);
  strcpy(v27, "&#160;");
  v8 = strlen(v27);
  v28 = 0;
  while ( 1 )
  {
    v10 = (_BYTE *)strstr(a2, v26);
    v11 = &v10[v7];
    v12 = v10 + 1;
    if ( !v10 )
      break;
    *v10 = 32;
    v9 = strlen(&v10[v7]);
    memcpy(v12, v11, v9);
    v12[strlen(v11)] = 0;
  }
  while ( 1 )
  {
    v14 = (_BYTE *)strstr(a2, v27);
    v15 = &v14[v8];
    v16 = v14 + 1;
    if ( !v14 )
      break;
    *v14 = 32;
    v13 = strlen(&v14[v8]);
    memcpy(v16, v15, v13);
    v16[strlen(v15)] = 0;
  }
  v17 = strlen(a2);
  trace(2, (int)"checkrangestring(length=%d)\n", v17);
  if ( v17 < a3 || a4 < v17 )
  {
    if ( a5 > 0 )
    {
      ErrorMessage = (char *)websGetErrorMessage(a5);
      webAddReplyMessage(a1, ErrorMessage, 1);
    }
    v28 = 1;
  }
  for ( i = 0; i < v17; ++i )
  {
    v20 = *(unsigned __int8 *)(a2 + i);
    v21 = 1;
    if ( (unsigned int)(WebCurrentLanguage - 1) >= 2 )
    {
      for ( j = (unsigned __int8 *)&DBCSVector; *j; j += 2 )
      {
        if ( v20 >= *j && j[1] >= v20 )
          goto LABEL_29;
      }
    }
    else
    {
      v22 = &DBCSVector12;
      v23 = (unsigned __int8)DBCSVector12;
      if ( DBCSVector12 )
      {
        while ( v20 < v23 || (unsigned __int8)v22[1] < v20 )
        {
          v22 += 2;
          v23 = (unsigned __int8)*v22;
          if ( !*v22 )
            goto LABEL_18;
        }
LABEL_29:
        v21 = 2;
      }
    }
LABEL_18:
    if ( v21 == 1 )
    {
      if ( v20 == 160 )
        *(_BYTE *)(a2 + i) = 32;
    }
    else
    {
      ++i;
    }
  }
  return v28;
}
// 4E4E14: using guessed type int WebCurrentLanguage;
// 4E503C: using guessed type char DBCSVector12;
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FEC: using guessed type int   strstr(_DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00421824) --------------------------------------------------------
int   checkcameraname(int a1, int a2, int a3, int a4, int a5)
{
  return checkrangestring(a1, a2, a3, a4, a5);
}

//----- (00421840) --------------------------------------------------------
int   checkusername(int a1, int a2, int a3, int a4, int a5)
{
  int v7; // $s0
  char *ErrorMessage; // $v0
  int v10; // $a3
  int v11; // $a2
  unsigned __int8 *v12; // $t8
  int v13; // $a1

  v7 = checkrangestring(a1, a2, a3, a4, a5);
  if ( v7 )
    return v7;
  if ( !strcmp(a2, "admin") )
    goto LABEL_3;
  v10 = strlen(a2);
  v11 = 0;
  if ( v10 > 0 )
  {
    v12 = (unsigned __int8 *)a2;
    while ( 1 )
    {
      v13 = *v12;
      ++v11;
      if ( (isalpha(2 * v13)) == 0 && v13 != 46 && v13 != 95 && v13 != 45 )
        break;
      v12 = (unsigned __int8 *)(a2 + v11);
      if ( v11 >= v10 )
        return 0;
    }
LABEL_3:
    v7 = 1;
    if ( a5 > 0 )
    {
      ErrorMessage = (char *)websGetErrorMessage(a5);
      webAddReplyMessage(a1, ErrorMessage, 1);
    }
  }
  return v7;
}
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA098: using guessed type int _ctype_b;

//----- (004219A0) --------------------------------------------------------
int   checkmaxstring(int a1, int a2, int a3, int a4)
{
  return checkrangestring(a1, a2, 0, a3, a4);
}

//----- (004219E0) --------------------------------------------------------
int   checkwepkey(int a1, int a2, int a3, int a4)
{
  int v8; // $a0
  int result; // $v0
  int v10; // $a0
  int v11; // $a1
  int v12; // $t6
  char *ErrorMessage; // $v0

  v8 = strlen(a2);
  if ( v8 )
  {
    if ( v8 == 10 || v8 == 26 )
    {
      v11 = 0;
      while ( 1 )
      {
        v12 = *(char *)(a2 + v11++);
        if ( (isxdigit(2 * v12)) == 0 )
          break;
        result = 0;
        if ( v11 >= v8 )
          return result;
      }
    }
    else if ( v8 == 5 || v8 == 13 )
    {
      return 0;
    }
    v10 = a3;
  }
  else
  {
    if ( !a4 )
      return 0;
    v10 = a4;
  }
  ErrorMessage = (char *)websGetErrorMessage(v10);
  webAddReplyMessage(a1, ErrorMessage, 1);
  return 1;
}
// 421A8C: conditional instruction was optimized away because $a0.4 is in (==A|==1A)
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4EA098: using guessed type int _ctype_b;

//----- (00421B40) --------------------------------------------------------
int   checkpresharedkey(int a1, int a2, int a3, int a4, int a5)
{
  int v8; // $v0
  int v10; // $s2
  int v11; // $a1
  int v12; // $v1
  int result; // $v0
  char *v14; // $s0
  int Var; // $v0
  bool v16; // dc
  char *v17; // $v0
  int v18; // $a0
  int v19; // $t5
  char *ErrorMessage; // $v0

  v8 = strlen(a3);
  v10 = 0;
  if ( !a5 || v8 )
  {
    if ( v8 == 64 )
    {
      v18 = 0;
      while ( 1 )
      {
        v19 = *(char *)(a3 + v18++);
        if ( (isxdigit(2 * v19)) == 0 )
          break;
        if ( v18 >= 64 )
          goto LABEL_11;
      }
      v10 = 1;
    }
    else
    {
      if ( (unsigned int)(v8 - 8) < 0x38 )
      {
        v11 = 0;
        if ( v8 <= 0 )
          goto LABEL_11;
        while ( 1 )
        {
          v12 = *(char *)(a3 + v11++);
          if ( v12 < 32 || v12 == 127 )
            break;
          if ( v11 >= v8 )
            goto LABEL_11;
        }
      }
      v10 = 1;
    }
LABEL_11:
    if ( v10 == 1 )
    {
      ErrorMessage = (char *)websGetErrorMessage(a4);
      webAddReplyMessage(a1, ErrorMessage, 1);
      return 1;
    }
    return v10;
  }
  v14 = "WEPEncryption";
  if ( !strcmp(a2, "APPreSharedKey") )
  {
    v14 = "APWEPEncryption";
    if ( websTestVar(a1, (int)"APWEPEncryption") )
      goto LABEL_16;
  }
  else if ( websTestVar(a1, (int)"WEPEncryption") )
  {
LABEL_16:
    Var = websGetVar(a1, (int)v14, (int)"4");
    goto LABEL_17;
  }
  Var = nvram_bufget(0, v14);
LABEL_17:
  v16 = strcmp(Var, "4") != 0;
  result = 0;
  if ( !v16 )
  {
    v17 = (char *)websGetErrorMessage(a5);
    webAddReplyMessage(a1, v17, 1);
    return 1;
  }
  return result;
}
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA098: using guessed type int _ctype_b;

//----- (00421DC8) --------------------------------------------------------
int   checkdatestring(int a1, char *a2, int a3)
{
  int v5; // $v0
  int v7; // $a2
  char *ErrorMessage; // $v0
  int v10; // $a1
  int v11; // $a3
  int v12; // $t1
  int v13; // $t2
  int v14; // $t3
  int v15; // $t5
  int v16; // $t4
  int v17; // $t6
  int v18; // $v0
  int v19; // $a0

  v5 = strlen(a2);
  v7 = 0;
  if ( v5 != 10 )
    goto LABEL_2;
  if ( a2[4] != 45 )
    goto LABEL_2;
  if ( a2[7] != 45 )
    goto LABEL_2;
  v10 = *a2;
  if ( (isdigit(2 * v10)) == 0 )
    goto LABEL_2;
  v11 = a2[1];
  if ( (isdigit(2 * v11)) == 0 )
    goto LABEL_2;
  v12 = a2[2];
  if ( (isdigit(2 * v12)) == 0
    || (v13 = a2[3], (isdigit(2 * v13)) == 0)
    || (v14 = a2[5], (isdigit(2 * v14)) == 0)
    || (v15 = a2[6], (isdigit(2 * v15)) == 0)
    || (v16 = a2[8], (isdigit(2 * v16)) == 0)
    || (v17 = a2[9], (isdigit(2 * v17)) == 0)
    || (v18 = 10 * v14 + v15 - 528,
        v19 = 10 * v16 + v17 - 528,
        (unsigned int)(1000 * v10 + 100 * v11 + 10 * v12 + v13 - 55334) >= 0xF)
    || v18 <= 0
    || v18 >= 13
    || v19 <= 0
    || v19 >= 32 )
  {
LABEL_2:
    ErrorMessage = (char *)websGetErrorMessage(a3);
    webAddReplyMessage(a1, ErrorMessage, 1);
    return 1;
  }
  return v7;
}
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4EA098: using guessed type int _ctype_b;

//----- (00422064) --------------------------------------------------------
int   checktimestring(int a1, char *a2, int a3)
{
  int v5; // $v0
  int v7; // $a2
  char *ErrorMessage; // $v0
  int v10; // $a3
  int v11; // $t1
  int v12; // $t0
  int v13; // $t3
  int v14; // $t2
  int v15; // $a1

  v5 = strlen(a2);
  v7 = 0;
  if ( v5 != 8
    || a2[2] != 58
    || a2[5] != 58
    || (v10 = *a2, (isdigit(2 * v10)) == 0)
    || (v11 = a2[1], (isdigit(2 * v11)) == 0)
    || (v12 = a2[3], (isdigit(2 * v12)) == 0)
    || (v13 = a2[4], (isdigit(2 * v13)) == 0)
    || (v14 = a2[6], (isdigit(2 * v14)) == 0)
    || (v15 = a2[7], (isdigit(2 * v15)) == 0)
    || (unsigned int)(10 * v10 + v11 - 528) >= 0x18
    || (unsigned int)(10 * v12 + v13 - 528) >= 0x3C
    || (unsigned int)(10 * v14 + v15 - 528) >= 0x3C )
  {
    ErrorMessage = (char *)websGetErrorMessage(a3);
    webAddReplyMessage(a1, ErrorMessage, 1);
    return 1;
  }
  return v7;
}
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4EA098: using guessed type int _ctype_b;

//----- (00422278) --------------------------------------------------------
int   checkhhmmstring(int a1, char *a2, int a3)
{
  char *ErrorMessage; // $v0
  int result; // $v0
  int v8; // $t0
  int v9; // $t2
  int v10; // $t1
  int v11; // $a0
  int v12; // $t7
  int v13; // $t1
  unsigned int v14; // $a0
  int v15; // $v1
  BOOL v16; // $a1

  if ( strlen(a2) != 5 )
    goto LABEL_2;
  if ( a2[2] != 58 )
    goto LABEL_2;
  v8 = *a2;
  if ( (isdigit(2 * v8)) == 0 )
    goto LABEL_2;
  v9 = a2[1];
  if ( (isdigit(2 * v9)) == 0 )
    goto LABEL_2;
  v10 = a2[3];
  if ( (isdigit(2 * v10)) == 0 )
    goto LABEL_2;
  v11 = a2[4];
  if ( (isdigit(2 * v11)) == 0 )
    goto LABEL_2;
  v12 = 10 * v8 + v9;
  v13 = 10 * v10 + v11;
  v14 = v12 - 528;
  v15 = v13 - 528;
  if ( v12 == 552 )
  {
    result = 0;
    if ( v13 == 528 )
      return result;
    v16 = v14 < 0x18;
  }
  else
  {
    v16 = v14 < 0x18;
  }
  if ( !v16 || v15 < 0 || (result = 0, v15 >= 60) )
  {
LABEL_2:
    if ( a3 > 0 )
    {
      ErrorMessage = (char *)websGetErrorMessage(a3);
      webAddReplyMessage(a1, ErrorMessage, 1);
    }
    return 1;
  }
  return result;
}
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4EA098: using guessed type int _ctype_b;

//----- (0042242C) --------------------------------------------------------
int   checkislong(int a1, char *a2, int a3)
{
  int v6; // $s5
  unsigned int v7; // $s0
  int v8; // $v0
  char *v9; // $v1
  int v10; // $v0
  unsigned int v11; // $v0
  int v12; // $v0
  int v13; // $s0
  int result; // $v0
  char *v15; // $v0
  char *ErrorMessage; // $v0
  int v17; // [sp+18h] [-8h] BYREF

  v6 = 0;
  v7 = 0;
  v8 = strlen(a2);
  v9 = a2;
  if ( v8 )
  {
    while ( 1 )
    {
      if ( v7 || (v10 = *a2, v10 != 45) && v10 != 43 )
      {
        if ( (isdigit(2 * *v9)) == 0 )
          break;
      }
      v11 = strlen(a2);
      v9 = &a2[++v7];
      if ( v7 >= v11 )
        goto LABEL_7;
    }
    if ( a3 > 0 )
    {
      ErrorMessage = (char *)websGetErrorMessage(a3);
      webAddReplyMessage(a1, ErrorMessage, 1);
    }
    return 1;
  }
  else
  {
LABEL_7:
    v12 = atol(a2);
    allocFmtString(&v17, 254, (int)"%d", v12);
    v13 = v17;
    result = 0;
    if ( v17 )
    {
      if ( strcmp(v17, a2) )
      {
        v6 = 1;
        if ( a3 > 0 )
        {
          v15 = (char *)websGetErrorMessage(a3);
          webAddReplyMessage(a1, v15, 1);
          v13 = v17;
          v6 = 1;
        }
      }
      result = v6;
      if ( v13 )
      {
        free2(v13);
        v17 = 0;
        return v6;
      }
    }
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA098: using guessed type int _ctype_b;
// 4EA09C: using guessed type int   atol(_DWORD);

//----- (00422660) --------------------------------------------------------
int   checklongrange(int a1, char *a2, int a3, int a4, int a5)
{
  int v9; // $s1
  int v10; // $v0
  BOOL v11; // $a3
  char *ErrorMessage; // $v0
  int result; // $v0

  v9 = checkislong(a1, a2, a5);
  if ( v9 )
    return v9;
  v10 = atol(a2);
  v11 = a4 < v10;
  if ( v10 < a3 || (result = 0, v11) )
  {
    if ( a5 > 0 )
    {
      ErrorMessage = (char *)websGetErrorMessage(a5);
      webAddReplyMessage(a1, ErrorMessage, 1);
    }
    return 1;
  }
  return result;
}
// 4EA09C: using guessed type int   atol(_DWORD);

//----- (00422768) --------------------------------------------------------
int   checktimezoneindex(int a1, char *a2, int a3, int a4, int a5)
{
  int v6; // $a1
  int v10; // $s4
  int v11; // $a0
  unsigned int v12; // $s0
  unsigned int v13; // $v0
  char *v14; // $v1
  int v17; // $v0
  int v18; // $a3
  char v19; // $a2
  int v20; // $v0
  int v21; // $a1
  int v22; // $a0
  int *v23; // $s0
  int v24; // $a2
  char *ErrorMessage; // $v0
  char v26[16]; // [sp+18h] [-10h] BYREF

  v6 = *a2;
  v10 = 1;
  if ( (isdigit(2 * v6)) == 0
    || (v11 = a2[1], (isdigit(2 * v11)) == 0) )
  {
    v12 = 0;
    goto LABEL_6;
  }
  v12 = 0;
  if ( a2[2] == 40 )
  {
    v17 = 10 * v6 + v11 - 528;
    if ( v17 >= a3 )
    {
      v18 = 0;
      if ( a4 >= v17 )
      {
        v19 = a2[6];
        v10 = 0;
        if ( v19 == 43 || v19 == 45 )
          v18 = 60 * (10 * a2[7] + a2[8] - 528) + 10 * a2[10] + a2[11] - 528;
        if ( v19 == 45 )
          snprintf(v26, 16, "-%d", v18);
        else
          snprintf(v26, 16, "%d", v18);
        websSetVar(a1, "TimeZone", v26);
      }
    }
  }
  else
  {
LABEL_6:
    while ( 1 )
    {
      v13 = strlen(a2);
      v14 = &a2[v12];
      if ( v12++ >= v13 )
        break;
      if ( (isdigit(2 * *v14)) == 0 )
        goto LABEL_8;
    }
    v20 = atoi(a2);
    if ( v20 >= a3 && a4 >= v20 )
    {
      v10 = 0;
      v21 = 0;
      if ( v20 )
      {
        if ( TimeZoneList[0] )
        {
          v22 = 0;
          while ( 1 )
          {
            v23 = &TimeZoneList[v22];
            ++v21;
            v24 = TimeZoneList[v22];
            v22 = 2 * v21;
            if ( v24 == v20 )
              break;
            if ( !TimeZoneList[2 * v21] )
              goto LABEL_8;
          }
          trace(2, (int)"(%d)=(%d)\n", v24, v23[1]);
          snprintf(v26, 16, "%d", v23[1]);
          websSetVar(a1, "TimeZone", v26);
        }
      }
    }
  }
LABEL_8:
  if ( v10 != 1 || !a5 )
    return v10;
  ErrorMessage = (char *)websGetErrorMessage(a5);
  webAddReplyMessage(a1, ErrorMessage, 1);
  return 1;
}
// 4E3AD0: using guessed type int TimeZoneList[186];
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4EA098: using guessed type int _ctype_b;
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (00422AE4) --------------------------------------------------------
int   checktimezone(int a1, char *a2, int a3, int a4, int a5)
{
  int v9; // $s0
  int v10; // $a1
  char *ErrorMessage; // $v0
  char v13[16]; // [sp+18h] [-10h] BYREF

  v9 = checkislong(a1, a2, a5);
  if ( v9 )
    return v9;
  v10 = atol(a2);
  if ( v10 < a3 || a4 < v10 )
  {
    v9 = 1;
    if ( v10 / 60 >= a3 )
      v9 = a4 < v10 / 60;
  }
  else
  {
    snprintf(v13, 16, "%d", 60 * v10);
    websSetVar(a1, "TimeZone", v13);
  }
  if ( v9 != 1 || !a5 )
    return v9;
  ErrorMessage = (char *)websGetErrorMessage(a5);
  webAddReplyMessage(a1, ErrorMessage, 1);
  return 1;
}
// 4EA09C: using guessed type int   atol(_DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (00422C64) --------------------------------------------------------
BOOL   checkenumrange(int a1, int a2, _BYTE **a3)
{
  int v5; // $s0
  int v6; // $s2

  v5 = 0;
  v6 = 0;
  if ( **a3 )
  {
    do
    {
      ++v5;
      if ( !strcmp(a2, a3[v6]) )
        break;
      v6 = v5;
    }
    while ( *a3[v5] );
  }
  return *a3[v6] == 0;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (00422D34) --------------------------------------------------------
BOOL   checkMatchValue(int a1, char *a2, int a3, _BYTE **a4, _BYTE **a5)
{
  int v9; // $s0
  int v10; // $s1
  int v11; // $s0
  int v12; // $s1
  _DWORD *v13; // $t7
  char *Var; // $v0

  v9 = 0;
  v10 = 0;
  if ( **a4 )
  {
    do
    {
      ++v9;
      if ( !strcmp(a3, a4[v10]) )
        break;
      v10 = v9;
    }
    while ( *a4[v9] );
  }
  if ( *a4[v10] )
  {
    websSetVar(a1, a2, a5[v10]);
    Var = (char *)websGetVar(a1, (int)a2, (int)byte_4A2DDC);
    trace(2, (int)"ChangeVar[%s]=(%s,%s)\n", a2, a4[v10], Var);
    return 0;
  }
  else
  {
    v11 = 0;
    v12 = 0;
    if ( **a5 )
    {
      v13 = a5;
      do
      {
        ++v11;
        if ( !strcmp(a3, *v13) )
          break;
        v12 = v11;
        v13 = &a5[v11];
      }
      while ( *(_BYTE *)*v13 );
    }
    return *a4[v12] == 0;
  }
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (00422F24) --------------------------------------------------------
int   CheckVarRange(int a1, char *a2, int *a3)
{
  int v6; // $v0
  int v7; // $a0
  int v8; // $v0
  int v9; // $v1
  int v10; // $a0
  int v11; // $a2
  int v12; // $s0
  int v13; // $s0
  int v14; // $s1
  int v15; // $v0
  int v16; // $a0
  unsigned __int8 *v17; // $t4
  int v20; // $s1
  int v21; // $s0
  int v22; // $v0
  char *ErrorMessage; // $v0
  int v24; // $s0
  int v25; // $s1
  int v26; // $v0
  int v27; // $a0
  unsigned __int8 *v28; // $ra
  int v30; // $s0
  int v31; // $s1
  int v32; // $a1
  int v33; // $a0
  unsigned __int8 *v34; // $v1
  int v36; // $s0
  int v37; // $s1
  int v38; // $v0
  int v39; // $a0
  unsigned __int8 *v40; // $a2
  char *v41; // $v0
  char *v42; // $v0
  char *v43; // $v0
  char *v44; // $v0
  char *v45; // $v0
  int v46; // $a0
  int v47; // $a3
  int v48; // $s0
  int v49; // $a0
  int v50; // $s0
  char *v51; // $v0
  char *v52; // $v0
  int v53; // $a0
  int v54; // $t1
  int v55; // $s0
  int v56; // $v0
  int v57; // $s0
  char *v58; // $v0
  char *v59; // $v0
  int v60; // $v0
  int v61; // $a0
  int v62; // $v0
  int v63; // $a0
  int v64; // $v0
  int v65; // $a0
  int v66; // $v0
  int v67; // $a0
  int v68; // $v0
  int v69; // $v0
  int v70; // $v0
  int v71; // $v0
  int v72; // $v0
  int v73; // $a0
  int v74; // $v0
  int v75; // $a0
  int v76; // $v0
  int v77; // $v0
  int v78; // $v0
  int v79; // $v0
  int v80; // $v0
  int v81; // $v0
  int v82; // $v0
  int v83; // $v0
  int v84; // $v0
  int v85; // $v0
  int v86; // $v0
  int v87; // $v0
  int v88; // $v0
  int v89; // $v0
  int v90; // $v0
  int v91; // $v0
  int v92; // $v0
  int v93; // $v0
  int v94; // $a0
  int v95; // $v0
  int v96; // $v0
  int v97; // $a0
  int v98; // $s4
  int v99; // $s0
  int v100; // $s3
  int v101; // $s2
  int v102; // $s4
  int v103; // $s0
  int v104; // $s2
  int v105; // $s3
  __int16 **v106; // $v0
  int v107; // $s4
  int v108; // $s0
  int v109; // $s2
  int v110; // $s3
  _DWORD *v111; // $t3
  int v112; // $s4
  int v113; // $s0
  int v114; // $s2
  int v115; // $s3
  _DWORD *v116; // $v0
  int v117; // $s0
  int v118; // $v0
  int v119; // $s3
  int v120; // $a0
  int v121; // $v0
  int v122; // $v0
  int v123; // $a0
  int v124; // $v0
  int v125; // $v0
  int v126; // $v0
  int v127; // $v0
  int v128; // $v0
  int v129; // $v0
  int v130; // $v0
  int v131; // $v0
  int v132; // $v0
  int v133; // $v0
  int v134; // $v0
  int v135; // $v0
  int v136; // $v0
  int v137; // $s0
  int v139; // $a0
  _BYTE *v140; // $t0
  int v141; // $v0
  int v142; // $v0
  int v143; // $v0
  int v144; // $v0
  int v145; // $a0
  int v146; // $v0
  int v147; // $v0
  int v148; // $v0
  int v149; // $a0
  int v150; // $v0
  int v151; // $s4
  int v152; // $s0
  int v153; // $s3
  int v154; // $s2
  __int16 **v155; // $a3
  int v156; // $v0
  int v157; // $v0
  int v158; // $v0
  int v159; // $a2
  int v160; // $v0
  int v161; // $a0
  int v162; // $v0
  int v163; // $v0
  int v164; // $v0
  int v165; // $v0
  int v166; // $s4
  int v167; // $s0
  int v168; // $s3
  int v169; // $s2
  __int16 **v170; // $t1
  int v171; // $v0
  int v172; // $v0
  int v173; // $v0
  int v174; // $v0
  int v175; // $v0
  int v176; // $v0
  int v177; // $v0
  char *Var; // $v0
  int v179; // $v0
  int v180; // $v0
  int v181; // $v0
  int v182; // $v0
  int v183; // $v0
  int v184; // $v0
  int v185; // $a0
  int v186; // $v0
  int v187; // $a0
  int v188; // $v0
  int v189; // $v0
  int v190; // $v0
  int v191; // $v0
  int v192; // $v0
  int v193; // $v0
  int v194; // $v0
  int v195; // $v0
  int v196; // $v0
  int v197; // $v0
  int v198; // $v0
  int v199; // $v0
  int v200; // $a0
  int v201; // $v0
  int v202; // $a0
  int v203; // $v0
  int v204; // $a0
  int v205; // $v0
  int v206; // $a0
  int v207; // $v0
  int v208; // $v0
  int v209; // $v0
  int v210; // $v0
  int v211; // $v0
  int v212; // $v0
  int v213; // $v0
  int v214; // $s4
  int v215; // $s0
  int v216; // $s3
  int v217; // $s2
  _DWORD *v218; // $t0
  int v219; // $v0
  char v220[16]; // [sp+20h] [-10h] BYREF

  trace(2, (int)"CheckVarRange(%s=%s)\n", a2, (char *)*a3);
  if ( !strcmp(a2, "AdminID") )
  {
    v20 = *a3;
    v21 = checkrangestring(a1, *a3, 1, 12, 25);
    if ( !v21 )
    {
      v22 = strcmp(v20, "admin");
      v9 = 0;
      if ( !v22 )
        return v9;
      ErrorMessage = (char *)websGetErrorMessage(25);
      webAddReplyMessage(a1, ErrorMessage, 1);
      return 1;
    }
    return v21;
  }
  if ( !strcmp(a2, "AdminPassword") )
  {
    v13 = *a3;
    v14 = checkrangestring(a1, v13, 0, 32, 26);
    if ( v14 )
      return v14;
    v15 = strlen(v13);
    v16 = 0;
    if ( v15 <= 0 )
      return v14;
    v17 = (unsigned __int8 *)v13;
    while ( 1 )
    {
      ++v16;
      if ( (unsigned int)*v17 - 33 >= 0x5E )
        break;
      v17 = (unsigned __int8 *)(v13 + v16);
      if ( v16 >= v15 )
        return v14;
    }
    v41 = (char *)websGetErrorMessage(26);
    webAddReplyMessage(a1, v41, 1);
    return 1;
  }
  else if ( !strcmp(a2, "ConfirmAdminPassword") )
  {
    v24 = *a3;
    v25 = checkrangestring(a1, v24, 6, 32, 26);
    if ( v25 )
      return v25;
    v26 = strlen(v24);
    v27 = 0;
    if ( v26 <= 0 )
      return v25;
    v28 = (unsigned __int8 *)v24;
    while ( 1 )
    {
      ++v27;
      if ( (unsigned int)*v28 - 33 >= 0x5E )
        break;
      v28 = (unsigned __int8 *)(v24 + v27);
      if ( v27 >= v26 )
        return v25;
    }
    v42 = (char *)websGetErrorMessage(26);
    webAddReplyMessage(a1, v42, 1);
    return 1;
  }
  else
  {
    if ( strcmp(a2, "VerifyAdminPassword") )
    {
      if ( !strcmp(a2, "CameraName") )
        return checkrangestring(a1, *a3, 0, 32, 23);
      if ( !strcmp(a2, "BonjourName") )
        return checkrangestring(a1, *a3, 0, 32, 104);
      if ( !strcmp(a2, "Location") )
        return checkrangestring(a1, *a3, 0, 64, 24);
      if ( !strcmp(a2, "UserName") )
        return checkusername(a1, *a3, 1, 12, 46);
      if ( !strcmp(a2, "UserPassword") )
      {
        v36 = *a3;
        v37 = checkrangestring(a1, v36, 0, 8, 47);
        if ( v37 )
          return v37;
        v38 = strlen(v36);
        v39 = 0;
        if ( v38 <= 0 )
          return v37;
        v40 = (unsigned __int8 *)v36;
        while ( 1 )
        {
          ++v39;
          if ( (unsigned int)*v40 - 33 >= 0x5E )
            break;
          v40 = (unsigned __int8 *)(v36 + v39);
          if ( v39 >= v38 )
            return v37;
        }
        v44 = (char *)websGetErrorMessage(47);
        webAddReplyMessage(a1, v44, 1);
        return 1;
      }
      if ( !strcmp(a2, "PPPoEUserID") )
        return checkrangestring(a1, *a3, 0, 64, 35);
      if ( !strcmp(a2, "PPPoEPassword") )
        return checkrangestring(a1, *a3, 0, 32, 36);
      if ( !strcmp(a2, "DDNSHostName") )
        return checkrangestring(a1, *a3, 0, 64, 68);
      if ( !strcmp(a2, "DDNSUserName") )
        return checkrangestring(a1, *a3, 0, 64, 69);
      if ( !strcmp(a2, "DDNSPassword") )
        return checkrangestring(a1, *a3, 0, 32, 70);
      if ( !strcmp(a2, "DDNSTimeout") )
        return checklongrange(a1, (char *)*a3, 240, 0xFFFF, 0);
      if ( !strcmp(a2, "FTPHostAddress") )
        return checkrangestring(a1, *a3, 0, 64, 56);
      if ( !strcmp(a2, "FTPUserName") )
        return checkrangestring(a1, *a3, 0, 32, 58);
      if ( !strcmp(a2, "FTPPassword") )
        return checkrangestring(a1, *a3, 0, 32, 59);
      if ( !strcmp(a2, "FTPDirectoryPath") )
        return checkrangestring(a1, *a3, 0, 64, 60);
      v6 = strcmp(a2, "FTPScheduleBaseFileName");
      v7 = a1;
      if ( !v6 )
        return checkrangestring(v7, *a3, 0, 32, 62);
      if ( !strcmp(a2, "EmailUserName") )
        return checkrangestring(a1, *a3, 0, 64, 71);
      if ( !strcmp(a2, "EmailPassword") )
        return checkrangestring(a1, *a3, 0, 32, 72);
      if ( !strcmp(a2, "EmailSMTPServerAddress") )
        return checkrangestring(a1, *a3, 0, 64, 49);
      if ( !strcmp(a2, "EmailSenderAddress") )
        return checkrangestring(a1, *a3, 0, 64, 50);
      if ( !strcmp(a2, "EmailReceiverAddress") )
        return checkrangestring(a1, *a3, 0, 256, 51);
      if ( !strcmp(a2, "TimeServerIPAddress") )
        return checkrangestring(a1, *a3, 0, 64, 81);
      v8 = strcmp(a2, "DDNSProvider");
      v9 = 0;
      if ( v8 )
      {
        if ( !strcmp(a2, "IPAddress") )
        {
          v56 = inet_addr(*a3);
          v57 = 0;
          if ( v56 == -1 )
          {
            v58 = (char *)websGetErrorMessage(28);
            webAddReplyMessage(a1, v58, 1);
            return 1;
          }
          return v57;
        }
        if ( !strcmp(a2, "SubnetMask") )
        {
          v49 = *a3;
          v50 = 0;
          if ( inet_addr(v49) == -1 )
          {
            v51 = (char *)websGetErrorMessage(29);
            webAddReplyMessage(a1, v51, 1);
            return 1;
          }
          return v50;
        }
        if ( !strcmp(a2, "DefaultGateway") )
        {
          v10 = *a3;
          v11 = *(char *)*a3;
          v12 = 0;
          if ( v11 )
          {
            if ( inet_addr(v10) == -1 )
            {
              v45 = (char *)websGetErrorMessage(30);
              webAddReplyMessage(a1, v45, 1);
              return 1;
            }
          }
          return v12;
        }
        if ( !strcmp(a2, "DNSIPAddress1") )
        {
          v46 = *a3;
          v47 = *(char *)*a3;
          v48 = 0;
          if ( v47 && inet_addr(v46) == -1 )
          {
            v52 = (char *)websGetErrorMessage(31);
            webAddReplyMessage(a1, v52, 1);
            return 1;
          }
          return v48;
        }
        if ( !strcmp(a2, "DNSIPAddress2") )
        {
          v53 = *a3;
          v54 = *(char *)*a3;
          v55 = 0;
          if ( v54 && inet_addr(v53) == -1 )
          {
            v59 = (char *)websGetErrorMessage(32);
            webAddReplyMessage(a1, v59, 1);
            return 1;
          }
          return v55;
        }
        if ( !strcmp(a2, "Date") )
          return checkdatestring(a1, (char *)*a3, 82);
        if ( !strcmp(a2, "Time") )
          return checktimestring(a1, (char *)*a3, 83);
        v60 = strcmp(a2, "FTPScheduleTimeStart");
        v61 = a1;
        if ( !v60 )
          return checktimestring(v61, (char *)*a3, 66);
        if ( !strcmp(a2, "FTPScheduleTimeStop") )
          return checktimestring(a1, (char *)*a3, 67);
        v62 = strcmp(a2, "EmailScheduleTimeStart");
        v63 = a1;
        if ( !v62 )
          return checktimestring(v63, (char *)*a3, 73);
        v64 = strcmp(a2, "EmailScheduleTimeStop");
        v65 = a1;
        if ( !v64 )
          return checktimestring(v65, (char *)*a3, 74);
        v66 = strcmp(a2, "HTTPAuthentication");
        v67 = a1;
        if ( !v66 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        v68 = strcmp(a2, "DateTimeMode");
        v67 = a1;
        if ( !v68 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        v69 = strcmp(a2, "TimeServerProtocol");
        v67 = a1;
        if ( !v69 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        v70 = strcmp(a2, "AccessControlEnable");
        v67 = a1;
        if ( !v70 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        v71 = strcmp(a2, "UserPrivilege");
        v67 = a1;
        if ( !v71 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        v72 = strcmp(a2, "ViewMode");
        v73 = a1;
        if ( !v72 )
          return checklongrange(v73, (char *)*a3, 0, 4, 0);
        v74 = strcmp(a2, "LightFrequency");
        v75 = a1;
        if ( !v74 )
          return checklongrange(v75, (char *)*a3, 0, 2, 0);
        v76 = strcmp(a2, "AntiFlickerEnable");
        v67 = a1;
        if ( !v76 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        v77 = strcmp(a2, "DDNSEnable");
        v67 = a1;
        if ( !v77 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        v78 = strcmp(a2, "UPnPEnable");
        v67 = a1;
        if ( !v78 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        if ( !strcmp(a2, "BonjourEnable") )
          return checklongrange(a1, (char *)*a3, 0, 1, 0);
        v79 = strcmp(a2, "UPnPPortForwarding");
        v67 = a1;
        if ( !v79 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        v80 = strcmp(a2, "EmailScheduleEnable");
        v67 = a1;
        if ( !v80 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        v81 = strcmp(a2, "FTPPassiveMode");
        v67 = a1;
        if ( !v81 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        v82 = strcmp(a2, "FTPScheduleEnable");
        v67 = a1;
        if ( !v82 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        v83 = strcmp(a2, "FTPScheduleVideoFrequencyMode");
        v67 = a1;
        if ( !v83 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        v84 = strcmp(a2, "AudioEnable");
        v67 = a1;
        if ( !v84 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        v85 = strcmp(a2, "SpeakerEnable");
        v67 = a1;
        if ( !v85 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        v86 = strcmp(a2, "EmailMotionMode");
        v67 = a1;
        if ( !v86 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        v87 = strcmp(a2, "LEDControl");
        v75 = a1;
        if ( !v87 )
          return checklongrange(v75, (char *)*a3, 0, 2, 0);
        v88 = strcmp(a2, "VideoResolution");
        v75 = a1;
        if ( !v88 )
          return checklongrange(v75, (char *)*a3, 0, 2, 0);
        v89 = strcmp(a2, "FTPScheduleFileMode");
        v75 = a1;
        if ( !v89 )
          return checklongrange(v75, (char *)*a3, 0, 2, 0);
        v90 = strcmp(a2, "EmailTLSAuthentication");
        v75 = a1;
        if ( !v90 )
          return checklongrange(v75, (char *)*a3, 0, 2, 0);
        v91 = strcmp(a2, "EmailScheduleMode");
        v75 = a1;
        if ( !v91 )
          return checklongrange(v75, (char *)*a3, 0, 2, 0);
        v92 = strcmp(a2, "FTPScheduleMode");
        v75 = a1;
        if ( !v92 )
          return checklongrange(v75, (char *)*a3, 0, 2, 0);
        v93 = strcmp(a2, "Mirror");
        v94 = a1;
        if ( !v93 )
          return checklongrange(v94, (char *)*a3, 0, 3, 0);
        v95 = strcmp(a2, "CompressionRate");
        v73 = a1;
        if ( !v95 )
          return checklongrange(v73, (char *)*a3, 0, 4, 0);
        v96 = strcmp(a2, "EmailScheduleDay");
        v97 = a1;
        if ( !v96 )
          return checklongrange(v97, (char *)*a3, 0, 127, 0);
        if ( !strcmp(a2, "FTPScheduleDay") )
          return checklongrange(a1, (char *)*a3, 0, 127, 0);
        if ( !strcmp(a2, "BrightnessControl") )
          return checklongrange(a1, (char *)*a3, 1, 128, 53);
        if ( !strcmp(a2, "ContrastControl") )
          return checklongrange(a1, (char *)*a3, 0, 128, 54);
        if ( !strcmp(a2, "SaturationControl") )
          return checklongrange(a1, (char *)*a3, 0, 128, 55);
        if ( !strcmp(a2, "SharpnessControl") )
          return checklongrange(a1, (char *)*a3, 0, 0xFFFF, 0);
        if ( !strcmp(a2, "SecondHTTPPort") )
          return checklongrange(a1, (char *)*a3, 1, 0xFFFF, 52);
        if ( !strcmp(a2, "FTPPortNumber") )
          return checklongrange(a1, (char *)*a3, 1, 0xFFFF, 57);
        if ( !strcmp(a2, "FTPScheduleSecondPerFrame") )
          return checklongrange(a1, (char *)*a3, 1, 0xFFFF, 61);
        if ( !strcmp(a2, "FTPScheduleMaxFileSequenceNumber") )
          return checklongrange(a1, (char *)*a3, 1, 0xFFFF, 63);
        if ( !strcmp(a2, "FTPCreateFolderInterval") )
          return checklongrange(a1, (char *)*a3, 0, 1440, 0);
        if ( !strcmp(a2, "EmailScheduleInterval") )
          return checklongrange(a1, (char *)*a3, 1, 0xFFFF, 75);
        if ( !strcmp(a2, "TimeZoneIndex") )
          return checktimezoneindex(a1, (char *)*a3, 0, 92, 0);
        if ( !strcmp(a2, "TimeZone") )
          return checktimezone(a1, (char *)*a3, -12, 13, 0);
        v98 = 0;
        if ( !strcmp(a2, "IPAddressMode") )
        {
          v99 = *a3;
          v100 = 0;
          v101 = 0;
          if ( *(_BYTE *)ipmode_select )
          {
            do
            {
              ++v101;
              if ( !strcmp(v99, *(_UNKNOWN **)((char *)&ipmode_select + v100)) )
                break;
              v100 = 4 * v101;
            }
            while ( *(_BYTE *)*(&ipmode_select + v101) );
          }
          if ( !**(_BYTE **)((char *)&ipmode_select + v100) )
            return 1;
          return v98;
        }
        v102 = 0;
        if ( !strcmp(a2, "SecondHTTPPortEnable") )
        {
          v103 = *a3;
          v104 = 0;
          v105 = 0;
          if ( *(_BYTE *)secondportenable_value )
          {
            v106 = &secondportenable_value;
            do
            {
              ++v104;
              if ( !strcmp(v103, *v106) )
                break;
              v105 = v104;
              v106 = &(&secondportenable_value)[v104];
            }
            while ( *(_BYTE *)*v106 );
          }
          if ( !*(_BYTE *)(&secondportenable_value)[v105] )
            return 1;
          return v102;
        }
        v107 = 0;
        if ( !strcmp(a2, "AudioVolume") )
        {
          v108 = *a3;
          v109 = 0;
          v110 = 0;
          if ( *audiovol_select )
          {
            v111 = &audiovol_select;
            do
            {
              ++v109;
              if ( !strcmp(v108, *v111) )
                break;
              v110 = 4 * v109;
              v111 = (_DWORD *)((char *)&audiovol_select + 4 * v109);
            }
            while ( *(_BYTE *)*v111 );
          }
          if ( !**(_BYTE **)((char *)&audiovol_select + v110) )
            return 1;
          return v107;
        }
        v112 = 0;
        if ( !strcmp(a2, "SpeakerVolume") )
        {
          v113 = *a3;
          v114 = 0;
          v115 = 0;
          if ( *audiovol_select )
          {
            v116 = &audiovol_select;
            do
            {
              ++v114;
              if ( !strcmp(v113, *v116) )
                break;
              v115 = 4 * v114;
              v116 = (_DWORD *)((char *)&audiovol_select + 4 * v114);
            }
            while ( *(_BYTE *)*v116 );
          }
          if ( !**(_BYTE **)((char *)&audiovol_select + v115) )
            return 1;
          return v112;
        }
        if ( !strcmp(a2, "FrameRate") )
        {
          v117 = *a3;
          v119 = atol(v117);
          v118 = strcmp(v117, "Auto");
          v120 = 0;
          if ( v118 )
          {
            if ( v119 < 36 )
            {
              v120 = 30;
              if ( v119 < 30 )
              {
                v120 = 20;
                if ( v119 < 20 )
                {
                  v120 = 15;
                  if ( v119 < 15 )
                  {
                    v120 = 7;
                    if ( v119 < 7 )
                    {
                      v120 = 5;
                      if ( v119 < 5 )
                        v120 = v119 > 0;
                    }
                  }
                }
              }
            }
          }
LABEL_356:
          stritoa(v120, v220, 16);
          websSetVar(a1, a2, v220);
          Var = (char *)websGetVar(a1, (int)a2, (int)byte_4A2DDC);
          trace(2, (int)"ChangeVar=(%s,%s)\n", a2, Var);
          return 0;
        }
        if ( !strcmp(a2, "FTPScheduleFramePerSecond") )
          return checkMatchValue(a1, a2, *a3, (_BYTE **)&frame_select, (_BYTE **)&frame_value);
        if ( !strcmp(a2, "EmailMotionFrameInterval") )
          return checkMatchValue(a1, a2, *a3, &motioninterval_select, (_BYTE **)&motioninterval_value);
        v121 = strcmp(a2, "DayNightMode");
        v73 = a1;
        if ( !v121 )
          return checklongrange(v73, (char *)*a3, 0, 4, 0);
        v122 = strcmp(a2, "IRLedScheduleSunStart");
        v123 = a1;
        if ( !v122 )
          return checkhhmmstring(v123, (char *)*a3, 0);
        v124 = strcmp(a2, "IRLedScheduleSunEnd");
        v123 = a1;
        if ( !v124 )
          return checkhhmmstring(v123, (char *)*a3, 0);
        v125 = strcmp(a2, "IRLedScheduleMonStart");
        v123 = a1;
        if ( !v125 )
          return checkhhmmstring(v123, (char *)*a3, 0);
        v126 = strcmp(a2, "IRLedScheduleMonEnd");
        v123 = a1;
        if ( !v126 )
          return checkhhmmstring(v123, (char *)*a3, 0);
        v127 = strcmp(a2, "IRLedScheduleTueStart");
        v123 = a1;
        if ( !v127 )
          return checkhhmmstring(v123, (char *)*a3, 0);
        v128 = strcmp(a2, "IRLedScheduleTueEnd");
        v123 = a1;
        if ( !v128 )
          return checkhhmmstring(v123, (char *)*a3, 0);
        v129 = strcmp(a2, "IRLedScheduleWedStart");
        v123 = a1;
        if ( !v129 )
          return checkhhmmstring(v123, (char *)*a3, 0);
        v130 = strcmp(a2, "IRLedScheduleWedEnd");
        v123 = a1;
        if ( !v130 )
          return checkhhmmstring(v123, (char *)*a3, 0);
        v131 = strcmp(a2, "IRLedScheduleThuStart");
        v123 = a1;
        if ( !v131 )
          return checkhhmmstring(v123, (char *)*a3, 0);
        v132 = strcmp(a2, "IRLedScheduleThuEnd");
        v123 = a1;
        if ( !v132 )
          return checkhhmmstring(v123, (char *)*a3, 0);
        v133 = strcmp(a2, "IRLedScheduleFriStart");
        v123 = a1;
        if ( !v133 )
          return checkhhmmstring(v123, (char *)*a3, 0);
        if ( !strcmp(a2, "IRLedScheduleFriEnd") )
          return checkhhmmstring(a1, (char *)*a3, 0);
        v134 = strcmp(a2, "IRLedScheduleSatStart");
        v123 = a1;
        if ( !v134 )
          return checkhhmmstring(v123, (char *)*a3, 0);
        v135 = strcmp(a2, "IRLedScheduleSatEnd");
        v123 = a1;
        if ( !v135 )
          return checkhhmmstring(v123, (char *)*a3, 0);
        v136 = strcmp(a2, "MotionDetectionEnable");
        v67 = a1;
        if ( !v136 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        if ( !strcmp(a2, "MotionDetectionBlockSet") )
        {
          v137 = *a3;
          if ( strlen(v137) != 25 )
            return 1;
          v139 = 0;
          v140 = (_BYTE *)v137;
          while ( 1 )
          {
            ++v139;
            if ( (unsigned __int8)(*v140 - 48) >= 2u )
              break;
            v140 = (_BYTE *)(v137 + v139);
            if ( v139 >= 25 )
              return 0;
          }
          return 2;
        }
        if ( !strcmp(a2, "MotionDetectionSensitivity") )
          return checklongrange(a1, (char *)*a3, 0, 100, 0);
        if ( !strcmp(a2, "MotionDetectionScheduleTimeStart") )
          return checktimestring(a1, (char *)*a3, 114);
        if ( !strcmp(a2, "MotionDetectionScheduleTimeStop") )
          return checktimestring(a1, (char *)*a3, 115);
        v141 = strcmp(a2, "MotionDetectionScheduleMode");
        v94 = a1;
        if ( !v141 )
          return checklongrange(v94, (char *)*a3, 0, 3, 0);
        v142 = strcmp(a2, "MotionDetectionScheduleDay");
        v97 = a1;
        if ( !v142 )
          return checklongrange(v97, (char *)*a3, 0, 127, 0);
        v143 = strcmp(a2, "OSDEnable");
        v67 = a1;
        if ( !v143 )
          return checklongrange(v67, (char *)*a3, 0, 1, 0);
        v144 = strcmp(a2, "OSDColorY");
        v145 = a1;
        if ( !v144 )
          return checklongrange(v145, (char *)*a3, 0, 255, 0);
        v146 = strcmp(a2, "OSDColorU");
        v145 = a1;
        if ( !v146 )
          return checklongrange(v145, (char *)*a3, 0, 255, 0);
        v147 = strcmp(a2, "OSDColorV");
        v145 = a1;
        if ( !v147 )
          return checklongrange(v145, (char *)*a3, 0, 255, 0);
        if ( !strcmp(a2, "WirelessDisable") )
          return checklongrange(a1, (char *)*a3, 0, 1, 0);
        if ( strcmp(a2, "SSID") )
        {
          v148 = strcmp(a2, "WirelessChannel");
          v149 = a1;
          if ( !v148 )
            return checklongrange(v149, (char *)*a3, 1, 14, 0);
          if ( !strcmp(a2, "TransmissionRate") )
            return checkMatchValue(a1, a2, *a3, txrate_select, (_BYTE **)&txrate_value);
          v150 = strcmp(a2, "ConnectionMode");
          v67 = a1;
          if ( !v150 )
            return checklongrange(v67, (char *)*a3, 0, 1, 0);
          v151 = 0;
          if ( !strcmp(a2, "WEPEncryption") )
          {
            v152 = *a3;
            v153 = 0;
            v154 = 0;
            if ( *(_BYTE *)wepencry_select )
            {
              v155 = &wepencry_select;
              do
              {
                ++v154;
                if ( !strcmp(v152, *v155) )
                  break;
                v153 = v154;
                v155 = &(&wepencry_select)[v154];
              }
              while ( *(_BYTE *)*v155 );
            }
            if ( !*(_BYTE *)(&wepencry_select)[v153] )
              return 1;
            return v151;
          }
          v156 = strcmp(a2, "WEPKeyFormat");
          v67 = a1;
          if ( !v156 )
            return checklongrange(v67, (char *)*a3, 0, 1, 0);
          v157 = strcmp(a2, "AuthenticationType");
          v75 = a1;
          if ( !v157 )
            return checklongrange(v75, (char *)*a3, 0, 2, 0);
          if ( !strcmp(a2, "TxKey") )
            return checklongrange(a1, (char *)*a3, 1, 4, 0);
          if ( !strcmp(a2, "Key1") )
            return checkwepkey(a1, *a3, 38, 0);
          if ( !strcmp(a2, "Key2") )
            return checkwepkey(a1, *a3, 39, 0);
          v158 = strcmp(a2, "Key3");
          v159 = 40;
          if ( !v158 )
            return checkwepkey(a1, *a3, v159, 0);
          if ( !strcmp(a2, "Key4") )
            return checkwepkey(a1, *a3, 41, 0);
          v160 = strcmp(a2, "PreSharedKey");
          v161 = a1;
          if ( !v160 )
            return checkpresharedkey(v161, (int)a2, *a3, 77, 78);
          if ( !strcmp(a2, "BeaconInterval") )
            return checklongrange(a1, (char *)*a3, 1, 0xFFFF, 80);
          v162 = strcmp(a2, "Preamble");
          v67 = a1;
          if ( !v162 )
            return checklongrange(v67, (char *)*a3, 0, 1, 0);
          v163 = strcmp(a2, "WirelessMode");
          v67 = a1;
          if ( !v163 )
            return checklongrange(v67, (char *)*a3, 0, 1, 0);
          v164 = strcmp(a2, "APExtendName");
          v67 = a1;
          if ( !v164 )
            return checklongrange(v67, (char *)*a3, 0, 1, 0);
          v165 = strcmp(a2, "APSSIDHidden");
          v67 = a1;
          if ( !v165 )
            return checklongrange(v67, (char *)*a3, 0, 1, 0);
          v166 = 0;
          if ( !strcmp(a2, "APWEPEncryption") )
          {
            v167 = *a3;
            v168 = 0;
            v169 = 0;
            if ( *(_BYTE *)wepencry_select )
            {
              v170 = &wepencry_select;
              do
              {
                ++v169;
                if ( !strcmp(v167, *v170) )
                  break;
                v168 = v169;
                v170 = &(&wepencry_select)[v169];
              }
              while ( *(_BYTE *)*v170 );
            }
            if ( !*(_BYTE *)(&wepencry_select)[v168] )
              return 1;
            return v166;
          }
          v171 = strcmp(a2, "APWEPKeyFormat");
          v67 = a1;
          if ( !v171 )
            return checklongrange(v67, (char *)*a3, 0, 1, 0);
          v172 = strcmp(a2, "APKey1");
          v159 = 38;
          if ( !v172 )
            return checkwepkey(a1, *a3, v159, 0);
          v173 = strcmp(a2, "APAuthenticationType");
          v75 = a1;
          if ( !v173 )
            return checklongrange(v75, (char *)*a3, 0, 2, 0);
          if ( !strcmp(a2, "APMaxClient") )
            return checklongrange(a1, (char *)*a3, 1, 5, 0);
          if ( strcmp(a2, "APSSID") )
          {
            v174 = strcmp(a2, "APPreSharedKey");
            v161 = a1;
            if ( v174 )
            {
              if ( !strcmp(a2, "APEnable") )
                return checklongrange(a1, (char *)*a3, 0, 1, 0);
              v175 = strcmp(a2, "WirelessChannel");
              v149 = a1;
              if ( v175 )
              {
                v176 = strcmp(a2, "VideoResolution264");
                v75 = a1;
                if ( !v176 )
                  return checklongrange(v75, (char *)*a3, 0, 2, 0);
                if ( !strcmp(a2, "BitRate264") )
                  return checklongrange(a1, (char *)*a3, 0, 10, 0);
                if ( !strcmp(a2, "FrameRate264") )
                {
                  v177 = atol(*a3);
                  v120 = 30;
                  if ( v177 < 30 )
                  {
                    v120 = 20;
                    if ( v177 < 20 )
                    {
                      v120 = 15;
                      if ( v177 < 15 )
                      {
                        v120 = 10;
                        if ( v177 < 10 )
                        {
                          v120 = 5;
                          if ( v177 < 5 )
                            v120 = 1;
                        }
                      }
                    }
                  }
                  goto LABEL_356;
                }
                v179 = strcmp(a2, "FTPScheduleBaseFileNameVideo");
                v7 = a1;
                if ( v179 )
                {
                  v180 = strcmp(a2, "FTPScheduleTimeStartVideo");
                  v61 = a1;
                  if ( v180 )
                  {
                    if ( strcmp(a2, "FTPScheduleTimeStopVideo") )
                    {
                      v181 = strcmp(a2, "FTPScheduleEnableVideo");
                      v67 = a1;
                      if ( !v181 )
                        return checklongrange(v67, (char *)*a3, 0, 1, 0);
                      v182 = strcmp(a2, "FTPScheduleModeVideo");
                      v75 = a1;
                      if ( !v182 )
                        return checklongrange(v75, (char *)*a3, 0, 2, 0);
                      v183 = strcmp(a2, "FTPScheduleDayVideo");
                      v97 = a1;
                      if ( !v183 )
                        return checklongrange(v97, (char *)*a3, 0, 127, 0);
                      v184 = strcmp(a2, "FTPScheduleVideoLimitSize");
                      v185 = a1;
                      if ( !v184 )
                        return checklongrange(v185, (char *)*a3, 1, 3072, 0);
                      v186 = strcmp(a2, "FTPScheduleVideoLimitTime");
                      v187 = a1;
                      if ( !v186 )
                        return checklongrange(v187, (char *)*a3, 1, 15, 0);
                      v188 = strcmp(a2, "EmailScheduleTimeStartVideo");
                      v63 = a1;
                      if ( v188 )
                      {
                        v189 = strcmp(a2, "EmailScheduleTimeStopVideo");
                        v65 = a1;
                        if ( v189 )
                        {
                          if ( strcmp(a2, "EmailScheduleIntervalVideo") )
                          {
                            if ( !strcmp(a2, "EmailSMTPPortNumber") )
                              return checklongrange(a1, (char *)*a3, 1, 0xFFFF, 79);
                            v190 = strcmp(a2, "EmailScheduleEnableVideo");
                            v67 = a1;
                            if ( !v190 )
                              return checklongrange(v67, (char *)*a3, 0, 1, 0);
                            v191 = strcmp(a2, "EmailScheduleModeVideo");
                            v75 = a1;
                            if ( v191 )
                            {
                              v192 = strcmp(a2, "EmailScheduleDayVideo");
                              v97 = a1;
                              if ( !v192 )
                                return checklongrange(v97, (char *)*a3, 0, 127, 0);
                              v193 = strcmp(a2, "EmailScheduleVideoLimitSize");
                              v185 = a1;
                              if ( v193 )
                              {
                                v194 = strcmp(a2, "EmailScheduleVideoLimitTime");
                                v187 = a1;
                                if ( v194 )
                                {
                                  v195 = strcmp(a2, "SoundDetectionEnable");
                                  v67 = a1;
                                  if ( !v195 )
                                    return checklongrange(v67, (char *)*a3, 0, 1, 0);
                                  if ( !strcmp(a2, "SoundDetectionDB") )
                                    return checklongrange(a1, (char *)*a3, 50, 90, 0);
                                  if ( !strcmp(a2, "SoundDetectionScheduleTimeStart") )
                                    return checktimestring(a1, (char *)*a3, 116);
                                  if ( !strcmp(a2, "SoundDetectionScheduleTimeStop") )
                                    return checktimestring(a1, (char *)*a3, 117);
                                  v196 = strcmp(a2, "SoundDetectionScheduleMode");
                                  v67 = a1;
                                  if ( !v196 )
                                    return checklongrange(v67, (char *)*a3, 0, 1, 0);
                                  v197 = strcmp(a2, "SoundDetectionScheduleDay");
                                  v97 = a1;
                                  if ( v197 )
                                  {
                                    v198 = strcmp(a2, "DSTEnable");
                                    v67 = a1;
                                    if ( v198 )
                                    {
                                      if ( !strcmp(a2, "DSTOffset") )
                                        return checklongrange(a1, (char *)*a3, 0, 7, 0);
                                      v199 = strcmp(a2, "DSTStartMonth");
                                      v200 = a1;
                                      if ( v199 )
                                      {
                                        v201 = strcmp(a2, "DSTStartWeek");
                                        v202 = a1;
                                        if ( !v201 )
                                          return checklongrange(v202, (char *)*a3, 0, 5, 0);
                                        v203 = strcmp(a2, "DSTStartDay");
                                        v204 = a1;
                                        if ( !v203 )
                                          return checklongrange(v204, (char *)*a3, 0, 6, 0);
                                        v205 = strcmp(a2, "DSTStartTime");
                                        v206 = a1;
                                        if ( !v205 )
                                          return checklongrange(v206, (char *)*a3, 0, 23, 0);
                                        v207 = strcmp(a2, "DSTEndMonth");
                                        v200 = a1;
                                        if ( v207 )
                                        {
                                          v208 = strcmp(a2, "DSTEndWeek");
                                          v202 = a1;
                                          if ( v208 )
                                          {
                                            v209 = strcmp(a2, "DSTEndDay");
                                            v204 = a1;
                                            if ( v209 )
                                            {
                                              v210 = strcmp(a2, "DSTEndTime");
                                              v206 = a1;
                                              if ( v210 )
                                              {
                                                if ( !strcmp(a2, "CifsServerFolder") )
                                                  return checkrangestring(a1, *a3, 0, 256, 111);
                                                if ( !strcmp(a2, "CifsUserName") )
                                                  return checkrangestring(a1, *a3, 0, 32, 112);
                                                if ( !strcmp(a2, "CifsPassword") )
                                                  return checkrangestring(a1, *a3, 0, 32, 113);
                                                if ( strcmp(a2, "CifsScheduleEnable") )
                                                {
                                                  v211 = strcmp(a2, "CifsFullAction");
                                                  v67 = a1;
                                                  if ( v211 )
                                                  {
                                                    if ( !strcmp(a2, "CifsScheduleTimeStart") )
                                                      return checktimestring(a1, (char *)*a3, 109);
                                                    if ( !strcmp(a2, "CifsScheduleTimeStop") )
                                                      return checktimestring(a1, (char *)*a3, 110);
                                                    v212 = strcmp(a2, "CifsScheduleMode");
                                                    v94 = a1;
                                                    if ( v212 )
                                                    {
                                                      v213 = strcmp(a2, "CifsScheduleDay");
                                                      v97 = a1;
                                                      if ( v213 )
                                                      {
                                                        v214 = 0;
                                                        if ( !strcmp(a2, "CifsMaxRecordTime") )
                                                        {
                                                          v215 = *a3;
                                                          v216 = 0;
                                                          v217 = 0;
                                                          if ( *(_BYTE *)recordtime_select )
                                                          {
                                                            v218 = &recordtime_select;
                                                            do
                                                            {
                                                              ++v217;
                                                              if ( !strcmp(v215, *v218) )
                                                                break;
                                                              v216 = 4 * v217;
                                                              v218 = &recordtime_select + v217;
                                                            }
                                                            while ( *(_BYTE *)*v218 );
                                                          }
                                                          if ( !**(_BYTE **)((char *)&recordtime_select + v216) )
                                                            return 1;
                                                          return v214;
                                                        }
                                                        else
                                                        {
                                                          v219 = strcmp(a2, "DwellingTime");
                                                          v9 = 0;
                                                          if ( !v219 )
                                                            return checklongrange(a1, (char *)*a3, 1, 0xFFFF, 0);
                                                        }
                                                        return v9;
                                                      }
                                                      return checklongrange(v97, (char *)*a3, 0, 127, 0);
                                                    }
                                                    return checklongrange(v94, (char *)*a3, 0, 3, 0);
                                                  }
                                                  return checklongrange(v67, (char *)*a3, 0, 1, 0);
                                                }
                                                return checklongrange(a1, (char *)*a3, 0, 1, 0);
                                              }
                                              return checklongrange(v206, (char *)*a3, 0, 23, 0);
                                            }
                                            return checklongrange(v204, (char *)*a3, 0, 6, 0);
                                          }
                                          return checklongrange(v202, (char *)*a3, 0, 5, 0);
                                        }
                                      }
                                      return checklongrange(v200, (char *)*a3, 0, 11, 0);
                                    }
                                    return checklongrange(v67, (char *)*a3, 0, 1, 0);
                                  }
                                  return checklongrange(v97, (char *)*a3, 0, 127, 0);
                                }
                                return checklongrange(v187, (char *)*a3, 1, 15, 0);
                              }
                              return checklongrange(v185, (char *)*a3, 1, 3072, 0);
                            }
                            return checklongrange(v75, (char *)*a3, 0, 2, 0);
                          }
                          return checklongrange(a1, (char *)*a3, 1, 0xFFFF, 75);
                        }
                        return checktimestring(v65, (char *)*a3, 74);
                      }
                      return checktimestring(v63, (char *)*a3, 73);
                    }
                    return checktimestring(a1, (char *)*a3, 67);
                  }
                  return checktimestring(v61, (char *)*a3, 66);
                }
                return checkrangestring(v7, *a3, 0, 32, 62);
              }
              return checklongrange(v149, (char *)*a3, 1, 14, 0);
            }
            return checkpresharedkey(v161, (int)a2, *a3, 77, 78);
          }
        }
        return checkrangestring(a1, *a3, 0, 32, 37);
      }
      return v9;
    }
    v30 = *a3;
    v31 = checkrangestring(a1, v30, 0, 32, 27);
    if ( v31 )
      return v31;
    v32 = strlen(v30);
    v33 = 0;
    if ( v32 <= 0 )
      return v31;
    v34 = (unsigned __int8 *)v30;
    while ( 1 )
    {
      ++v33;
      if ( (unsigned int)*v34 - 33 >= 0x5E )
        break;
      v34 = (unsigned __int8 *)(v30 + v33);
      if ( v33 >= v32 )
        return v31;
    }
    v43 = (char *)websGetErrorMessage(27);
    webAddReplyMessage(a1, v43, 1);
    return 1;
  }
}
// 4E368C: using guessed type _UNKNOWN *recordtime_select;
// 4E3700: using guessed type __int16 *wepencry_select;
// 4E3714: using guessed type _UNKNOWN *ipmode_select;
// 4E3734: using guessed type __int16 *secondportenable_value;
// 4E37F4: using guessed type _UNKNOWN *frame_select;
// 4E3808: using guessed type _UNKNOWN *frame_value;
// 4E381C: using guessed type char *motioninterval_select;
// 4E3828: using guessed type __int16 *motioninterval_value;
// 4E3874: using guessed type char *txrate_select[13];
// 4E38AC: using guessed type __int16 *txrate_value;
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA004: using guessed type int   inet_addr(_DWORD);
// 4EA09C: using guessed type int   atol(_DWORD);

//----- (004269B4) --------------------------------------------------------
int   websGetVarCheck(int a1, char *a2, int *a3)
{
  char *Var; // $v0
  int v7; // $s2
  int v9; // $v0
  int v10; // $a3
  char *v11; // $a1

  Var = (char *)websGetVar(a1, (int)a2, (int)WebNotFound);
  *a3 = (int)Var;
  v7 = 0;
  if ( Var == WebNotFound )
  {
    v9 = nvram_bufget(0, a2);
    v10 = v9;
    v11 = "NulAppendVar=(%s,%s)\n";
  }
  else
  {
    v7 = CheckVarRange(a1, a2, a3);
    if ( !v7 )
      return 0;
    v9 = nvram_bufget(0, a2);
    v10 = v9;
    v11 = "ErrAppendVar=(%s,%s)\n";
  }
  *a3 = v9;
  trace(2, (int)v11, a2, v10);
  websSetVar(a1, a2, (char *)*a3);
  *a3 = websGetVar(a1, (int)a2, (int)byte_4A2DDC);
  return v7;
}
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00426B10) --------------------------------------------------------
int   CheckAuthorizationModeVar(int a1)
{
  int v2; // [sp+18h] [-8h] BYREF

  return websGetVarCheck(a1, "HTTPAuthentication", &v2);
}

//----- (00426B50) --------------------------------------------------------
BOOL   AuthorizationModeChanged(int a1)
{
  int Var; // $v0
  int v3; // $s2

  v3 = nvram_bufget(0, "HTTPAuthentication");
  Var = websGetVar(a1, (int)"HTTPAuthentication", (int)byte_4A2DDC);
  return strcmp(v3, Var) != 0;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00426BF0) --------------------------------------------------------
int   WriteAuthorizationModeVar(int a1)
{
  int Var; // $v0

  Var = websGetVar(a1, (int)"HTTPAuthentication", (int)byte_4A2DDC);
  nvram_bufset(0, "HTTPAuthentication", Var);
  return 0;
}
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);

//----- (00426C54) --------------------------------------------------------
int   OSDTimeChanged(int a1)
{
  int v2; // $s7
  int Var; // $s6
  int v4; // $s5
  int v5; // $fp
  int v6; // $s0
  int v7; // $s3
  int v8; // $s2
  int result; // $v0
  bool v10; // dc
  int v11; // [sp+18h] [-8h]

  v2 = nvram_bufget(0, "OSDEnable");
  Var = websGetVar(a1, (int)"OSDEnable", (int)byte_4A2DDC);
  v4 = nvram_bufget(0, "OSDColorY");
  v5 = nvram_bufget(0, "OSDColorU");
  v11 = nvram_bufget(0, "OSDColorV");
  v6 = websGetVar(a1, (int)"OSDColorY", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"OSDColorU", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"OSDColorV", (int)byte_4A2DDC);
  if ( strcmp(v2, Var) )
    return 1;
  if ( strcmp(v4, v6) )
    return 1;
  if ( strcmp(v5, v7) )
    return 1;
  v10 = strcmp(v11, v8) == 0;
  result = 0;
  if ( !v10 )
    return 1;
  return result;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00426E2C) --------------------------------------------------------
int   CheckSystemVar(int a1)
{
  int v2; // $s0
  int v3; // $s0
  int v4; // $s0
  int v5; // $s2
  int v6; // $s0
  int v7; // $s2
  int v8; // $s0
  int v9; // $s2
  int v10; // $s0
  int v11; // $s2
  int v12; // $s0
  int v13; // $s0
  int result; // $v0
  char *Var; // $v0
  int v16; // $s0
  bool v17; // dc
  char *ErrorMessage; // $v0
  int v19; // [sp+18h] [-38h] BYREF
  int v20; // [sp+1Ch] [-34h] BYREF
  int v21; // [sp+20h] [-30h] BYREF
  int v22; // [sp+24h] [-2Ch] BYREF
  int v23; // [sp+28h] [-28h] BYREF
  int v24; // [sp+2Ch] [-24h] BYREF
  int v25; // [sp+30h] [-20h] BYREF
  int v26; // [sp+34h] [-1Ch] BYREF
  int v27; // [sp+38h] [-18h] BYREF
  int v28; // [sp+3Ch] [-14h] BYREF
  int v29; // [sp+40h] [-10h] BYREF
  int v30; // [sp+44h] [-Ch] BYREF
  int v31; // [sp+48h] [-8h] BYREF

  v2 = 0;
  if ( websTestVar(a1, (int)"AdminPassword") )
  {
    Var = (char *)websGetVar(a1, (int)"AdminPassword", (int)byte_4A2DDC);
    websSetVar(a1, "ConfirmAdminPassword", Var);
    v2 = websGetVarCheck(a1, "ConfirmAdminPassword", &v19);
  }
  v3 = v2 | websGetVarCheck(a1, "CameraName", &v20);
  v4 = v3 | websGetVarCheck(a1, "Location", &v21);
  v5 = v4 | websGetVarCheck(a1, "AdminID", &v22);
  v6 = v5 | websGetVarCheck(a1, "AdminPassword", &v23);
  v7 = v6 | websGetVarCheck(a1, "LEDControl", &v24);
  v8 = v7 | websGetVarCheck(a1, "SnapshotURLAuthentication", &v25);
  v9 = v8 | websGetVarCheck(a1, "AccessControlEnable", &v26);
  v10 = v9 | websGetVarCheck(a1, "OSDEnable", &v27);
  v11 = v10 | websGetVarCheck(a1, "OSDColorY", &v28);
  v12 = v11 | websGetVarCheck(a1, "OSDColorU", &v29);
  v13 = v12 | websGetVarCheck(a1, "OSDColorV", &v30);
  if ( !websTestVar(a1, (int)"VerifyAdminPassword") )
    return v13;
  v16 = v13 | websGetVarCheck(a1, "VerifyAdminPassword", &v31);
  v17 = strcmp(v23, v31) == 0;
  result = v16;
  if ( !v17 )
  {
    ErrorMessage = (char *)websGetErrorMessage(27);
    webAddReplyMessage(a1, ErrorMessage, 1);
    return v16 | 1;
  }
  return result;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (004270C8) --------------------------------------------------------
int   WriteSystemVar(int a1)
{
  int v2; // $s4
  int v3; // $s5
  int v4; // $fp
  int v5; // $s6
  int v6; // $s7
  int v7; // $v0
  int v8; // $s1
  bool v9; // dc
  int result; // $v0
  int Var; // [sp+18h] [-10h]
  int v12; // [sp+1Ch] [-Ch]
  int v13; // [sp+20h] [-8h]
  int v14; // [sp+24h] [-4h]

  Var = websGetVar(a1, (int)"CameraName", (int)byte_4A2DDC);
  v12 = websGetVar(a1, (int)"Location", (int)byte_4A2DDC);
  v2 = websGetVar(a1, (int)"AdminID", (int)byte_4A2DDC);
  v3 = websGetVar(a1, (int)"AdminPassword", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"LEDControl", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"SnapshotURLAuthentication", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"AccessControlEnable", (int)byte_4A2DDC);
  nvram_bufset(0, "CameraName", Var);
  nvram_bufset(0, "Location", v12);
  nvram_bufset(0, "AdminID", v2);
  nvram_bufset(0, "AdminPassword", v3);
  nvram_bufset(0, "LEDControl", v4);
  nvram_bufset(0, "SnapshotURLAuthentication", v5);
  nvram_bufset(0, "AccessControlEnable", v6);
  v7 = websGetVar(a1, (int)"OSDEnable", (int)byte_4A2DDC);
  nvram_bufset(0, "OSDEnable", v7);
  v13 = websGetVar(a1, (int)"OSDColorY", (int)byte_4A2DDC);
  v14 = websGetVar(a1, (int)"OSDColorU", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"OSDColorV", (int)byte_4A2DDC);
  nvram_bufset(0, "OSDColorY", v13);
  nvram_bufset(0, "OSDColorU", v14);
  nvram_bufset(0, "OSDColorV", v8);
  if ( !strcmp(v4, &word_4A0308) )
  {
    setSysInfoShort(53, 0);
    return 0;
  }
  if ( !strcmp(v4, "1") )
  {
    setSysInfoShort(53, 1);
    return 0;
  }
  v9 = strcmp(v4, "2") == 0;
  result = 0;
  if ( v9 )
  {
    setSysInfoShort(53, 2);
    return 0;
  }
  return result;
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (00427498) --------------------------------------------------------
int   CheckNetworkVar(int a1)
{
  int v2; // $s0
  int v3; // $s0
  int v4; // $s0
  int v5; // $s0
  int v6; // $s0
  int v7; // $s0
  int v8; // $s0
  int v9; // $s0
  int v10; // $s0
  int v11; // $s0
  int v12; // $s0
  int v13; // $s0
  int v14; // $s0
  int v15; // $s0
  int v17; // [sp+18h] [-40h] BYREF
  int v18; // [sp+1Ch] [-3Ch] BYREF
  int v19; // [sp+20h] [-38h] BYREF
  int v20; // [sp+24h] [-34h] BYREF
  int v21; // [sp+28h] [-30h] BYREF
  int v22; // [sp+2Ch] [-2Ch] BYREF
  int v23; // [sp+30h] [-28h] BYREF
  int v24; // [sp+34h] [-24h] BYREF
  int v25; // [sp+38h] [-20h] BYREF
  int v26; // [sp+3Ch] [-1Ch] BYREF
  int v27; // [sp+40h] [-18h] BYREF
  int v28; // [sp+44h] [-14h] BYREF
  int v29; // [sp+48h] [-10h] BYREF
  int v30; // [sp+4Ch] [-Ch] BYREF
  int v31; // [sp+50h] [-8h] BYREF

  v2 = websGetVarCheck(a1, "IPAddressMode", &v17);
  v3 = v2 | websGetVarCheck(a1, "IPAddress", &v18);
  v4 = v3 | websGetVarCheck(a1, "SubnetMask", &v19);
  v5 = v4 | websGetVarCheck(a1, "DefaultGateway", &v20);
  v6 = v5 | websGetVarCheck(a1, "PPPoEUserID", &v21);
  v7 = v6 | websGetVarCheck(a1, "PPPoEPassword", &v22);
  v8 = v7 | websGetVarCheck(a1, "DNSIPAddress1", &v23);
  v9 = v8 | websGetVarCheck(a1, "DNSIPAddress2", &v24);
  v10 = v9 | websGetVarCheck(a1, "SecondHTTPPortEnable", &v25);
  v11 = v10 | websGetVarCheck(a1, "SecondHTTPPort", &v26);
  v12 = v11 | websGetVarCheck(a1, "UPnPEnable", &v27);
  v13 = v12 | websGetVarCheck(a1, "UPnPPortForwarding", &v28);
  v14 = v13 | websGetVarCheck(a1, "BonjourEnable", &v29);
  v15 = v14 | websGetVarCheck(a1, "BonjourName", &v30);
  return v15 | websGetVarCheck(a1, "HTTPAuthentication", &v31);
}

//----- (004276AC) --------------------------------------------------------
int   SystemNetworkChanged(int a1)
{
  int v2; // $s2
  int v3; // $s3
  int v4; // $s4
  int v5; // $s5
  int v6; // $fp
  int v7; // $s7
  int v8; // $s6
  int v9; // $s1
  int result; // $v0
  bool v11; // dc
  int v12; // [sp+18h] [-58h]
  int v13; // [sp+1Ch] [-54h]
  int v14; // [sp+20h] [-50h]
  int v15; // [sp+24h] [-4Ch]
  int v16; // [sp+28h] [-48h]
  int v17; // [sp+2Ch] [-44h]
  int v18; // [sp+30h] [-40h]
  int v19; // [sp+34h] [-3Ch]
  int v20; // [sp+38h] [-38h]
  int v21; // [sp+3Ch] [-34h]
  int v22; // [sp+40h] [-30h]
  int v23; // [sp+44h] [-2Ch]
  int v24; // [sp+48h] [-28h]
  int v25; // [sp+4Ch] [-24h]
  int v26; // [sp+50h] [-20h]
  int v27; // [sp+54h] [-1Ch]
  int v28; // [sp+58h] [-18h]
  int v29; // [sp+5Ch] [-14h]
  int v30; // [sp+60h] [-10h]
  int v31; // [sp+64h] [-Ch]
  int v32; // [sp+68h] [-8h]
  int Var; // [sp+6Ch] [-4h]

  v12 = nvram_bufget(0, "IPAddressMode");
  v13 = nvram_bufget(0, "IPAddress");
  v14 = nvram_bufget(0, "SubnetMask");
  v15 = nvram_bufget(0, "DefaultGateway");
  v16 = nvram_bufget(0, "PPPoEUserID");
  v17 = nvram_bufget(0, "PPPoEPassword");
  v18 = nvram_bufget(0, "DNSIPAddress1");
  v19 = nvram_bufget(0, "DNSIPAddress2");
  v20 = nvram_bufget(0, "SecondHTTPPortEnable");
  v21 = nvram_bufget(0, "SecondHTTPPort");
  v22 = nvram_bufget(0, "UPnPEnable");
  v23 = nvram_bufget(0, "UPnPPortForwarding");
  v24 = nvram_bufget(0, "BonjourEnable");
  v25 = nvram_bufget(0, "BonjourName");
  v32 = nvram_bufget(0, "HTTPAuthentication");
  Var = websGetVar(a1, (int)"HTTPAuthentication", (int)byte_4A2DDC);
  v2 = websGetVar(a1, (int)"IPAddressMode", (int)byte_4A2DDC);
  v3 = websGetVar(a1, (int)"IPAddress", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"SubnetMask", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"DefaultGateway", (int)byte_4A2DDC);
  v26 = websGetVar(a1, (int)"PPPoEUserID", (int)byte_4A2DDC);
  v27 = websGetVar(a1, (int)"PPPoEPassword", (int)byte_4A2DDC);
  v28 = websGetVar(a1, (int)"DNSIPAddress1", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"DNSIPAddress2", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"SecondHTTPPortEnable", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"SecondHTTPPort", (int)byte_4A2DDC);
  v29 = websGetVar(a1, (int)"UPnPEnable", (int)byte_4A2DDC);
  v30 = websGetVar(a1, (int)"UPnPPortForwarding", (int)byte_4A2DDC);
  v31 = websGetVar(a1, (int)"BonjourEnable", (int)byte_4A2DDC);
  v9 = websGetVar(a1, (int)"BonjourName", (int)byte_4A2DDC);
  if ( strcmp(v12, v2) )
    return 1;
  if ( strcmp(v13, v3) )
    return 1;
  if ( strcmp(v14, v4) )
    return 1;
  if ( strcmp(v15, v5) )
    return 1;
  if ( strcmp(v16, v26) )
    return 1;
  if ( strcmp(v17, v27) )
    return 1;
  if ( strcmp(v18, v28) )
    return 1;
  if ( strcmp(v19, v6) )
    return 1;
  if ( strcmp(v20, v7) )
    return 1;
  if ( strcmp(v21, v8) )
    return 1;
  if ( strcmp(v32, Var) )
    return 1;
  if ( strcmp(v22, v29) )
    return 1;
  if ( strcmp(v23, v30) )
    return 1;
  if ( strcmp(v24, v31) )
    return 1;
  v11 = strcmp(v25, v9) == 0;
  result = 0;
  if ( !v11 )
    return 1;
  return result;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00427C58) --------------------------------------------------------
int   SystemDDNSChanged(int a1)
{
  int v2; // $fp
  int Var; // $s7
  int v4; // $s2
  int v5; // $s3
  int v6; // $s4
  int v7; // $s5
  int v8; // $s1
  int result; // $v0
  bool v10; // dc
  int v11; // [sp+18h] [-18h]
  int v12; // [sp+1Ch] [-14h]
  int v13; // [sp+20h] [-10h]
  int v14; // [sp+24h] [-Ch]
  int v15; // [sp+28h] [-8h]

  v2 = nvram_bufget(0, "DDNSEnable");
  v11 = nvram_bufget(0, "DDNSProvider");
  v12 = nvram_bufget(0, "DDNSHostName");
  v13 = nvram_bufget(0, "DDNSUserName");
  v14 = nvram_bufget(0, "DDNSPassword");
  v15 = nvram_bufget(0, "DDNSTimeout");
  Var = websGetVar(a1, (int)"DDNSEnable", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"DDNSProvider", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"DDNSHostName", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"DDNSUserName", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"DDNSPassword", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"DDNSTimeout", (int)byte_4A2DDC);
  if ( strcmp(v2, Var) )
    return 1;
  if ( strcmp(v11, v4) )
    return 1;
  if ( strcmp(v12, v5) )
    return 1;
  if ( strcmp(v13, v6) )
    return 1;
  if ( strcmp(v14, v7) )
    return 1;
  v10 = strcmp(v15, v8) == 0;
  result = 0;
  if ( !v10 )
    return 1;
  return result;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00427ED4) --------------------------------------------------------
int   WriteNetworkVar(int a1)
{
  int v2; // $s3
  int v3; // $s4
  int v4; // $s5
  int v5; // $s6
  int v6; // $s7
  int v7; // $v0
  int v8; // $fp
  int Var; // [sp+18h] [-38h]
  int v11; // [sp+1Ch] [-34h]
  int v12; // [sp+20h] [-30h]
  int v13; // [sp+24h] [-2Ch]
  int v14; // [sp+28h] [-28h]
  int v15; // [sp+2Ch] [-24h]
  int v16; // [sp+30h] [-20h]
  int v17; // [sp+34h] [-1Ch]
  int v18; // [sp+38h] [-18h]
  int v19; // [sp+3Ch] [-14h]
  int v20; // [sp+40h] [-10h]
  int v21; // [sp+44h] [-Ch]
  int v22; // [sp+48h] [-8h]
  int v23; // [sp+4Ch] [-4h]

  Var = websGetVar(a1, (int)"IPAddressMode", (int)byte_4A2DDC);
  v11 = websGetVar(a1, (int)"IPAddress", (int)byte_4A2DDC);
  v12 = websGetVar(a1, (int)"SubnetMask", (int)byte_4A2DDC);
  v13 = websGetVar(a1, (int)"DefaultGateway", (int)byte_4A2DDC);
  v14 = websGetVar(a1, (int)"PPPoEUserID", (int)byte_4A2DDC);
  v15 = websGetVar(a1, (int)"PPPoEPassword", (int)byte_4A2DDC);
  v16 = websGetVar(a1, (int)"DNSIPAddress1", (int)byte_4A2DDC);
  v17 = websGetVar(a1, (int)"DNSIPAddress2", (int)byte_4A2DDC);
  v18 = websGetVar(a1, (int)"SecondHTTPPortEnable", (int)byte_4A2DDC);
  v19 = websGetVar(a1, (int)"SecondHTTPPort", (int)byte_4A2DDC);
  v20 = websGetVar(a1, (int)"UPnPEnable", (int)byte_4A2DDC);
  v21 = websGetVar(a1, (int)"UPnPPortForwarding", (int)byte_4A2DDC);
  v22 = websGetVar(a1, (int)"BonjourEnable", (int)byte_4A2DDC);
  v23 = websGetVar(a1, (int)"BonjourName", (int)byte_4A2DDC);
  v2 = websGetVar(a1, (int)"DDNSEnable", (int)byte_4A2DDC);
  v3 = websGetVar(a1, (int)"DDNSProvider", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"DDNSHostName", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"DDNSUserName", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"DDNSPassword", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"DDNSTimeout", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"HTTPAuthentication", (int)byte_4A2DDC);
  nvram_bufset(0, "HTTPAuthentication", v7);
  nvram_bufset(0, "IPAddressMode", Var);
  nvram_bufset(0, "IPAddress", v11);
  nvram_bufset(0, "SubnetMask", v12);
  nvram_bufset(0, "DefaultGateway", v13);
  nvram_bufset(0, "PPPoEUserID", v14);
  nvram_bufset(0, "PPPoEPassword", v15);
  nvram_bufset(0, "DNSIPAddress1", v16);
  nvram_bufset(0, "DNSIPAddress2", v17);
  nvram_bufset(0, "SecondHTTPPortEnable", v18);
  nvram_bufset(0, "SecondHTTPPort", v19);
  nvram_bufset(0, "UPnPEnable", v20);
  nvram_bufset(0, "UPnPPortForwarding", v21);
  nvram_bufset(0, "BonjourEnable", v22);
  nvram_bufset(0, "BonjourName", v23);
  nvram_bufset(0, "DDNSEnable", v2);
  nvram_bufset(0, "DDNSProvider", v3);
  nvram_bufset(0, "DDNSHostName", v4);
  nvram_bufset(0, "DDNSUserName", v5);
  nvram_bufset(0, "DDNSPassword", v6);
  nvram_bufset(0, "DDNSTimeout", v8);
  return 0;
}
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);

//----- (0042842C) --------------------------------------------------------
int   SystemWirelessChanged(int a1)
{
  int v2; // $fp
  int v3; // $s6
  int v4; // $s7
  int v5; // $s5
  int v6; // $s4
  int v7; // $s3
  int v8; // $s1
  int result; // $v0
  bool v10; // dc
  int v11; // [sp+18h] [-C0h]
  int v12; // [sp+1Ch] [-BCh]
  int v13; // [sp+20h] [-B8h]
  int v14; // [sp+24h] [-B4h]
  int v15; // [sp+28h] [-B0h]
  int v16; // [sp+2Ch] [-ACh]
  int v17; // [sp+30h] [-A8h]
  int v18; // [sp+34h] [-A4h]
  int v19; // [sp+38h] [-A0h]
  int v20; // [sp+3Ch] [-9Ch]
  int v21; // [sp+40h] [-98h]
  int v22; // [sp+44h] [-94h]
  int v23; // [sp+48h] [-90h]
  int v24; // [sp+4Ch] [-8Ch]
  int v25; // [sp+50h] [-88h]
  int v26; // [sp+54h] [-84h]
  int Var; // [sp+58h] [-80h]
  int v28; // [sp+5Ch] [-7Ch]
  int v29; // [sp+60h] [-78h]
  int v30; // [sp+64h] [-74h]
  int v31; // [sp+68h] [-70h]
  int v32; // [sp+6Ch] [-6Ch]
  int v33; // [sp+70h] [-68h]
  int v34; // [sp+74h] [-64h]
  int v35; // [sp+78h] [-60h]
  int v36; // [sp+7Ch] [-5Ch]
  int v37; // [sp+80h] [-58h]
  int v38; // [sp+84h] [-54h]
  int v39; // [sp+88h] [-50h]
  int v40; // [sp+8Ch] [-4Ch]
  int v41; // [sp+90h] [-48h]
  int v42; // [sp+94h] [-44h]
  int v43; // [sp+98h] [-40h]
  int v44; // [sp+9Ch] [-3Ch]
  int v45; // [sp+A0h] [-38h]
  int v46; // [sp+A4h] [-34h]
  int v47; // [sp+A8h] [-30h]
  int v48; // [sp+ACh] [-2Ch]
  int v49; // [sp+B0h] [-28h]
  int v50; // [sp+B4h] [-24h]
  int v51; // [sp+B8h] [-20h]
  int v52; // [sp+BCh] [-1Ch]
  int v53; // [sp+C0h] [-18h]
  int v54; // [sp+C4h] [-14h]
  int v55; // [sp+C8h] [-10h]
  int v56; // [sp+CCh] [-Ch]
  int v57; // [sp+D0h] [-8h]

  v11 = nvram_bufget(0, "WirelessDisable");
  v12 = nvram_bufget(0, "SSID");
  v13 = nvram_bufget(0, "WirelessChannel");
  v14 = nvram_bufget(0, "TransmissionRate");
  v15 = nvram_bufget(0, "ConnectionMode");
  v16 = nvram_bufget(0, "WEPEncryption");
  v17 = nvram_bufget(0, "WEPKeyFormat");
  v18 = nvram_bufget(0, "BeaconInterval");
  v19 = nvram_bufget(0, "Preamble");
  v20 = nvram_bufget(0, "AuthenticationType");
  v21 = nvram_bufget(0, "TxKey");
  v22 = nvram_bufget(0, "Key1");
  v23 = nvram_bufget(0, "Key2");
  v24 = nvram_bufget(0, "Key3");
  v25 = nvram_bufget(0, "Key4");
  v26 = nvram_bufget(0, "PreSharedKey");
  Var = websGetVar(a1, (int)"WirelessDisable", (int)byte_4A2DDC);
  v28 = websGetVar(a1, (int)"SSID", (int)byte_4A2DDC);
  v29 = websGetVar(a1, (int)"WirelessChannel", (int)byte_4A2DDC);
  v30 = websGetVar(a1, (int)"TransmissionRate", (int)byte_4A2DDC);
  v31 = websGetVar(a1, (int)"ConnectionMode", (int)byte_4A2DDC);
  v32 = websGetVar(a1, (int)"WEPEncryption", (int)byte_4A2DDC);
  v33 = websGetVar(a1, (int)"WEPKeyFormat", (int)byte_4A2DDC);
  v34 = websGetVar(a1, (int)"BeaconInterval", (int)byte_4A2DDC);
  v35 = websGetVar(a1, (int)"Preamble", (int)byte_4A2DDC);
  v36 = websGetVar(a1, (int)"AuthenticationType", (int)byte_4A2DDC);
  v37 = websGetVar(a1, (int)"TxKey", (int)byte_4A2DDC);
  v38 = websGetVar(a1, (int)"Key1", (int)byte_4A2DDC);
  v39 = websGetVar(a1, (int)"Key2", (int)byte_4A2DDC);
  v40 = websGetVar(a1, (int)"Key3", (int)byte_4A2DDC);
  v41 = websGetVar(a1, (int)"Key4", (int)byte_4A2DDC);
  v42 = websGetVar(a1, (int)"PreSharedKey", (int)byte_4A2DDC);
  v43 = nvram_bufget(0, "WirelessMode");
  v44 = nvram_bufget(0, "APExtendName");
  v45 = nvram_bufget(0, "APSSIDHidden");
  v46 = nvram_bufget(0, "APWEPEncryption");
  v47 = nvram_bufget(0, "APWEPKeyFormat");
  v49 = nvram_bufget(0, "APKey1");
  v48 = nvram_bufget(0, "APAuthenticationType");
  v50 = nvram_bufget(0, "APMaxClient");
  v51 = websGetVar(a1, (int)"WirelessMode", (int)byte_4A2DDC);
  v52 = websGetVar(a1, (int)"APExtendName", (int)byte_4A2DDC);
  v53 = websGetVar(a1, (int)"APSSIDHidden", (int)byte_4A2DDC);
  v54 = websGetVar(a1, (int)"APWEPEncryption", (int)byte_4A2DDC);
  v55 = websGetVar(a1, (int)"APWEPKeyFormat", (int)byte_4A2DDC);
  v57 = websGetVar(a1, (int)"APKey1", (int)byte_4A2DDC);
  v56 = websGetVar(a1, (int)"APAuthenticationType", (int)byte_4A2DDC);
  v2 = websGetVar(a1, (int)"APMaxClient", (int)byte_4A2DDC);
  v3 = nvram_bufget(0, "APSSID");
  v4 = nvram_bufget(0, "APPreSharedKey");
  v5 = websGetVar(a1, (int)"APSSID", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"APPreSharedKey", (int)byte_4A2DDC);
  v7 = nvram_bufget(0, "APChannel");
  v8 = websGetVar(a1, (int)"APChannel", (int)byte_4A2DDC);
  if ( strcmp(v11, Var) )
    return 1;
  if ( strcmp(v12, v28) )
    return 1;
  if ( strcmp(v13, v29) )
    return 1;
  if ( strcmp(v14, v30) )
    return 1;
  if ( strcmp(v15, v31) )
    return 1;
  if ( strcmp(v16, v32) )
    return 1;
  if ( strcmp(v17, v33) )
    return 1;
  if ( strcmp(v18, v34) )
    return 1;
  if ( strcmp(v19, v35) )
    return 1;
  if ( strcmp(v20, v36) )
    return 1;
  if ( strcmp(v21, v37) )
    return 1;
  if ( strcmp(v22, v38) )
    return 1;
  if ( strcmp(v23, v39) )
    return 1;
  if ( strcmp(v24, v40) )
    return 1;
  if ( strcmp(v25, v41) )
    return 1;
  if ( strcmp(v43, v51) )
    return 1;
  if ( strcmp(v44, v52) )
    return 1;
  if ( strcmp(v45, v53) )
    return 1;
  if ( strcmp(v46, v54) )
    return 1;
  if ( strcmp(v47, v55) )
    return 1;
  if ( strcmp(v49, v57) )
    return 1;
  if ( strcmp(v48, v56) )
    return 1;
  if ( strcmp(v50, v2) )
    return 1;
  if ( strcmp(v3, v5) )
    return 1;
  if ( strcmp(v4, v6) )
    return 1;
  if ( strcmp(v7, v8) )
    return 1;
  v10 = strcmp(v26, v42) == 0;
  result = 0;
  if ( !v10 )
    return 1;
  return result;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00428E10) --------------------------------------------------------
int   CheckWirelessVar(int a1)
{
  int v2; // $s5
  int v3; // $s4
  int v4; // $s2
  int v5; // $s3
  int v6; // $s0
  int v7; // $s0
  int v8; // $a0
  char *v9; // $a1
  int v10; // $a0
  char *v11; // $a1
  int v12; // $s0
  int v13; // $s0
  int v14; // $s0
  int v15; // $s0
  int v16; // $s0
  int v17; // $s0
  int v18; // $fp
  int v19; // $s0
  int v20; // $fp
  int v21; // $s5
  int v22; // $s0
  int v23; // $fp
  int v24; // $s5
  int v25; // $s0
  int v26; // $s2
  int v27; // $fp
  int v28; // $s7
  int v29; // $s6
  int v30; // $s5
  int v31; // $v0
  int v32; // $s0
  int v34; // [sp+18h] [-70h] BYREF
  int v35; // [sp+1Ch] [-6Ch] BYREF
  int v36; // [sp+20h] [-68h] BYREF
  int v37; // [sp+24h] [-64h] BYREF
  int v38; // [sp+28h] [-60h] BYREF
  int v39; // [sp+2Ch] [-5Ch] BYREF
  int v40; // [sp+30h] [-58h] BYREF
  int v41; // [sp+34h] [-54h] BYREF
  int v42; // [sp+38h] [-50h] BYREF
  int v43; // [sp+3Ch] [-4Ch] BYREF
  int v44; // [sp+40h] [-48h] BYREF
  int v45; // [sp+44h] [-44h] BYREF
  int v46; // [sp+48h] [-40h] BYREF
  int v47; // [sp+4Ch] [-3Ch] BYREF
  int v48; // [sp+50h] [-38h] BYREF
  int v49; // [sp+54h] [-34h] BYREF
  int v50; // [sp+58h] [-30h] BYREF
  int v51; // [sp+5Ch] [-2Ch] BYREF
  int v52; // [sp+60h] [-28h] BYREF
  int v53; // [sp+64h] [-24h] BYREF
  int v54; // [sp+68h] [-20h] BYREF
  int v55; // [sp+6Ch] [-1Ch] BYREF
  int v56; // [sp+70h] [-18h] BYREF
  int v57; // [sp+74h] [-14h] BYREF
  int v58; // [sp+78h] [-10h] BYREF
  int v59; // [sp+7Ch] [-Ch] BYREF
  int v60; // [sp+80h] [-8h] BYREF
  int v61; // [sp+84h] [-4h] BYREF

  v2 = websGetVarCheck(a1, "WirelessDisable", &v34);
  v3 = v2 | websGetVarCheck(a1, "SSID", &v35);
  v4 = v3 | websGetVarCheck(a1, "WirelessChannel", &v36);
  v5 = v4 | websGetVarCheck(a1, "TransmissionRate", &v37);
  v6 = v5 | websGetVarCheck(a1, "ConnectionMode", &v38);
  v7 = v6 | websGetVarCheck(a1, "WEPEncryption", &v39);
  if ( websTestVarValue(a1, (int)"WEPEncryption", (int)&word_4A0308) )
  {
    websDeleteVar(a1, "WEPKeyFormat");
    websDeleteVar(a1, "AuthenticationType");
    websDeleteVar(a1, "TxKey");
    websDeleteVar(a1, "Key1");
    websDeleteVar(a1, "Key2");
    websDeleteVar(a1, "Key3");
    websDeleteVar(a1, "Key4");
    v8 = a1;
    v9 = "PreSharedKey";
LABEL_3:
    websDeleteVar(v8, v9);
    goto LABEL_4;
  }
  if ( websTestVarValue(a1, (int)"WEPEncryption", (int)"2") || websTestVarValue(a1, (int)"WEPEncryption", (int)"3") )
  {
    v8 = a1;
    v9 = "PreSharedKey";
    goto LABEL_3;
  }
  if ( websTestVarValue(a1, (int)"WEPEncryption", (int)"4") )
  {
    websDeleteVar(a1, "WEPKeyFormat");
    websDeleteVar(a1, "AuthenticationType");
    websDeleteVar(a1, "TxKey");
    websDeleteVar(a1, "Key1");
    websDeleteVar(a1, "Key2");
    websDeleteVar(a1, "Key3");
    v8 = a1;
    v9 = "Key4";
    goto LABEL_3;
  }
LABEL_4:
  if ( websTestVarValue(a1, (int)"APWEPEncryption", (int)&word_4A0308) )
  {
    websDeleteVar(a1, "APWEPKeyFormat");
    websDeleteVar(a1, "APAuthenticationType");
    websDeleteVar(a1, "APKey1");
    v10 = a1;
    v11 = "APPreSharedKey";
  }
  else if ( websTestVarValue(a1, (int)"APWEPEncryption", (int)"2")
         || websTestVarValue(a1, (int)"APWEPEncryption", (int)"3") )
  {
    v10 = a1;
    v11 = "APPreSharedKey";
  }
  else
  {
    if ( !websTestVarValue(a1, (int)"APWEPEncryption", (int)"4") )
      goto LABEL_7;
    websDeleteVar(a1, "APWEPKeyFormat");
    websDeleteVar(a1, "APAuthenticationType");
    v10 = a1;
    v11 = "APKey1";
  }
  websDeleteVar(v10, v11);
LABEL_7:
  v12 = v7 | websGetVarCheck(a1, "WEPKeyFormat", &v40);
  v13 = v12 | websGetVarCheck(a1, "BeaconInterval", &v41);
  v14 = v13 | websGetVarCheck(a1, "Preamble", &v42);
  v15 = v14 | websGetVarCheck(a1, "AuthenticationType", &v43);
  v16 = v15 | websGetVarCheck(a1, "TxKey", &v44);
  v17 = v16 | websGetVarCheck(a1, "Key1", &v45);
  v18 = v17 | websGetVarCheck(a1, "Key2", &v46);
  v19 = v18 | websGetVarCheck(a1, "Key3", &v47);
  v20 = v19 | websGetVarCheck(a1, "Key4", &v48);
  v21 = v20 | websGetVarCheck(a1, "PreSharedKey", &v49);
  v22 = v21 | websGetVarCheck(a1, "WirelessMode", &v50);
  v23 = v22 | websGetVarCheck(a1, "APExtendName", &v51);
  v24 = v23 | websGetVarCheck(a1, "APSSIDHidden", &v52);
  v25 = v24 | websGetVarCheck(a1, "APWEPEncryption", &v53);
  v26 = v25 | websGetVarCheck(a1, "APWEPKeyFormat", &v54);
  v27 = v26 | websGetVarCheck(a1, "APKey1", &v55);
  v28 = v27 | websGetVarCheck(a1, "APAuthenticationType", &v56);
  v29 = v28 | websGetVarCheck(a1, "APMaxClient", &v57);
  v30 = v29 | websGetVarCheck(a1, "APSSID", &v58);
  v32 = v30 | websGetVarCheck(a1, "APPreSharedKey", &v59);
  v31 = websGetVarCheck(a1, "APEnable", &v60);
  return v32 | v31 | websGetVarCheck(a1, "APChannel", &v61);
}
// 4A0308: using guessed type __int16 word_4A0308;

//----- (004295B0) --------------------------------------------------------
int   WriteWirelessVar(int a1)
{
  int v2; // $s2
  int v3; // $s3
  int v4; // $s4
  int v5; // $s5
  int v6; // $s6
  int v7; // $s7
  int v8; // $fp
  int v9; // $s0
  int Var; // [sp+18h] [-50h]
  int v12; // [sp+1Ch] [-4Ch]
  int v13; // [sp+20h] [-48h]
  int v14; // [sp+24h] [-44h]
  int v15; // [sp+28h] [-40h]
  int v16; // [sp+2Ch] [-3Ch]
  int v17; // [sp+30h] [-38h]
  int v18; // [sp+34h] [-34h]
  int v19; // [sp+38h] [-30h]
  int v20; // [sp+3Ch] [-2Ch]
  int v21; // [sp+40h] [-28h]
  int v22; // [sp+44h] [-24h]
  int v23; // [sp+48h] [-20h]
  int v24; // [sp+4Ch] [-1Ch]
  int v25; // [sp+50h] [-18h]
  int v26; // [sp+54h] [-14h]
  int v27; // [sp+58h] [-10h]
  int v28; // [sp+5Ch] [-Ch]
  int v29; // [sp+60h] [-8h]

  Var = websGetVar(a1, (int)"WirelessDisable", (int)byte_4A2DDC);
  v12 = websGetVar(a1, (int)"SSID", (int)byte_4A2DDC);
  v13 = websGetVar(a1, (int)"WirelessChannel", (int)byte_4A2DDC);
  v14 = websGetVar(a1, (int)"TransmissionRate", (int)byte_4A2DDC);
  v15 = websGetVar(a1, (int)"ConnectionMode", (int)byte_4A2DDC);
  v16 = websGetVar(a1, (int)"WEPEncryption", (int)byte_4A2DDC);
  v17 = websGetVar(a1, (int)"WEPKeyFormat", (int)byte_4A2DDC);
  v18 = websGetVar(a1, (int)"BeaconInterval", (int)byte_4A2DDC);
  v19 = websGetVar(a1, (int)"Preamble", (int)byte_4A2DDC);
  v20 = websGetVar(a1, (int)"AuthenticationType", (int)byte_4A2DDC);
  v21 = websGetVar(a1, (int)"TxKey", (int)byte_4A2DDC);
  v22 = websGetVar(a1, (int)"Key1", (int)byte_4A2DDC);
  v23 = websGetVar(a1, (int)"Key2", (int)byte_4A2DDC);
  v24 = websGetVar(a1, (int)"Key3", (int)byte_4A2DDC);
  v25 = websGetVar(a1, (int)"Key4", (int)byte_4A2DDC);
  v26 = websGetVar(a1, (int)"PreSharedKey", (int)byte_4A2DDC);
  v27 = websGetVar(a1, (int)"WirelessMode", (int)byte_4A2DDC);
  v28 = websGetVar(a1, (int)"APExtendName", (int)byte_4A2DDC);
  v29 = websGetVar(a1, (int)"APSSIDHidden", (int)byte_4A2DDC);
  v2 = websGetVar(a1, (int)"APWEPEncryption", (int)byte_4A2DDC);
  v3 = websGetVar(a1, (int)"APWEPKeyFormat", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"APKey1", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"APAuthenticationType", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"APMaxClient", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"APSSID", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"APPreSharedKey", (int)byte_4A2DDC);
  v9 = websGetVar(a1, (int)"APChannel", (int)byte_4A2DDC);
  nvram_bufset(0, "WirelessDisable", Var);
  nvram_bufset(0, "SSID", v12);
  nvram_bufset(0, "WirelessChannel", v13);
  nvram_bufset(0, "TransmissionRate", v14);
  nvram_bufset(0, "ConnectionMode", v15);
  nvram_bufset(0, "WEPEncryption", v16);
  nvram_bufset(0, "WEPKeyFormat", v17);
  nvram_bufset(0, "BeaconInterval", v18);
  nvram_bufset(0, "Preamble", v19);
  nvram_bufset(0, "AuthenticationType", v20);
  nvram_bufset(0, "TxKey", v21);
  nvram_bufset(0, "Key1", v22);
  nvram_bufset(0, "Key2", v23);
  nvram_bufset(0, "Key3", v24);
  nvram_bufset(0, "Key4", v25);
  nvram_bufset(0, "PreSharedKey", v26);
  nvram_bufset(0, "WirelessMode", v27);
  nvram_bufset(0, "APExtendName", v28);
  nvram_bufset(0, "APSSIDHidden", v29);
  nvram_bufset(0, "APWEPEncryption", v2);
  nvram_bufset(0, "APWEPKeyFormat", v3);
  nvram_bufset(0, "APKey1", v4);
  nvram_bufset(0, "APAuthenticationType", v5);
  nvram_bufset(0, "APMaxClient", v6);
  nvram_bufset(0, "APSSID", v7);
  nvram_bufset(0, "APPreSharedKey", v8);
  nvram_bufset(0, "APChannel", v9);
  return 0;
}
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);

//----- (00429C7C) --------------------------------------------------------
int   CheckStreamVar(int a1)
{
  int v2; // $s0
  int v3; // $s0
  int v4; // $s0
  int v5; // $s0
  int v6; // $s0
  int v7; // $s0
  int v8; // $s0
  int v9; // $s0
  int v10; // $s0
  int v11; // $s0
  int v12; // $s0
  int v13; // $s0
  int v14; // $s0
  int v15; // $s0
  int v16; // $s0
  int v18; // [sp+18h] [-40h] BYREF
  int v19; // [sp+1Ch] [-3Ch] BYREF
  int v20; // [sp+20h] [-38h] BYREF
  int v21; // [sp+24h] [-34h] BYREF
  int v22; // [sp+28h] [-30h] BYREF
  int v23; // [sp+2Ch] [-2Ch] BYREF
  int v24; // [sp+30h] [-28h] BYREF
  int v25; // [sp+34h] [-24h] BYREF
  int v26; // [sp+38h] [-20h] BYREF
  int v27; // [sp+3Ch] [-1Ch] BYREF
  int v28; // [sp+40h] [-18h] BYREF
  int v29; // [sp+44h] [-14h] BYREF
  int v30; // [sp+48h] [-10h] BYREF
  int v31; // [sp+4Ch] [-Ch] BYREF
  int v32; // [sp+50h] [-8h] BYREF
  int v33; // [sp+54h] [-4h] BYREF

  v2 = websGetVarCheck(a1, "BrightnessControl", &v18);
  v3 = v2 | websGetVarCheck(a1, "ContrastControl", &v19);
  v4 = v3 | websGetVarCheck(a1, "SaturationControl", &v20);
  v5 = v4 | websGetVarCheck(a1, "SharpnessControl", &v21);
  v6 = v5 | websGetVarCheck(a1, "AntiFlickerEnable", &v22);
  v7 = v6 | websGetVarCheck(a1, "Mirror", &v23);
  v8 = v7 | websGetVarCheck(a1, "VideoResolution", &v24);
  v9 = v8 | websGetVarCheck(a1, "CompressionRate", &v25);
  v10 = v9 | websGetVarCheck(a1, "FrameRate", &v26);
  v11 = v10 | websGetVarCheck(a1, "ViewMode", &v27);
  v12 = v11 | websGetVarCheck(a1, "LightFrequency", &v28);
  v13 = v12 | websGetVarCheck(a1, "AudioEnable", &v29);
  v14 = v13 | websGetVarCheck(a1, "AudioVolume", &v30);
  v15 = v14 | websGetVarCheck(a1, "VideoResolution264", &v31);
  v16 = v15 | websGetVarCheck(a1, "FrameRate264", &v32);
  return v16 | websGetVarCheck(a1, "BitRate264", &v33);
}

//----- (00429EB0) --------------------------------------------------------
int   StreamImageChanged(int a1)
{
  int v2; // $fp
  int Var; // $s7
  int v4; // $s2
  int v5; // $s3
  int v6; // $s4
  int v7; // $s5
  int v8; // $s1
  int result; // $v0
  bool v10; // dc
  int v11; // [sp+18h] [-18h]
  int v12; // [sp+1Ch] [-14h]
  int v13; // [sp+20h] [-10h]
  int v14; // [sp+24h] [-Ch]
  int v15; // [sp+28h] [-8h]

  v2 = nvram_bufget(0, "BrightnessControl");
  v11 = nvram_bufget(0, "ContrastControl");
  v12 = nvram_bufget(0, "SaturationControl");
  v13 = nvram_bufget(0, "SharpnessControl");
  v14 = nvram_bufget(0, "AntiFlickerEnable");
  v15 = nvram_bufget(0, "Mirror");
  Var = websGetVar(a1, (int)"BrightnessControl", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"ContrastControl", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"SaturationControl", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"SharpnessControl", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"AntiFlickerEnable", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"Mirror", (int)byte_4A2DDC);
  if ( strcmp(v2, Var) )
    return 1;
  if ( strcmp(v11, v4) )
    return 1;
  if ( strcmp(v12, v5) )
    return 1;
  if ( strcmp(v13, v6) )
    return 1;
  if ( strcmp(v14, v7) )
    return 1;
  v10 = strcmp(v15, v8) == 0;
  result = 0;
  if ( !v10 )
    return 1;
  return result;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0042A12C) --------------------------------------------------------
int   StreamVideoChanged(int a1)
{
  int v2; // $fp
  int Var; // $s7
  int v4; // $s4
  int v5; // $s1
  int v6; // $s3
  int v7; // $s2
  int result; // $v0
  bool v9; // dc
  int v10; // [sp+18h] [-20h]
  int v11; // [sp+1Ch] [-1Ch]
  int v12; // [sp+20h] [-18h]
  int v13; // [sp+24h] [-14h]
  int v14; // [sp+28h] [-10h]
  int v15; // [sp+2Ch] [-Ch]
  int v16; // [sp+30h] [-8h]
  int v17; // [sp+34h] [-4h]

  v2 = nvram_bufget(0, "VideoResolution");
  v10 = nvram_bufget(0, "CompressionRate");
  v11 = nvram_bufget(0, "FrameRate");
  v12 = nvram_bufget(0, "VideoResolution264");
  v13 = nvram_bufget(0, "BitRate264");
  v14 = nvram_bufget(0, "FrameRate264");
  Var = websGetVar(a1, (int)"VideoResolution264", (int)byte_4A2DDC);
  v15 = websGetVar(a1, (int)"BitRate264", (int)byte_4A2DDC);
  v16 = websGetVar(a1, (int)"FrameRate264", (int)byte_4A2DDC);
  v17 = nvram_bufget(0, "LightFrequency");
  v4 = websGetVar(a1, (int)"LightFrequency", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"VideoResolution", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"CompressionRate", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"FrameRate", (int)byte_4A2DDC);
  if ( strcmp(v2, v5) )
    return 1;
  if ( strcmp(v10, v6) )
    return 1;
  if ( strcmp(v12, Var) )
    return 1;
  if ( strcmp(v13, v15) )
    return 1;
  if ( strcmp(v14, v16) )
    return 1;
  if ( strcmp(v17, v4) )
    return 1;
  v9 = strcmp(v11, v7) == 0;
  result = 0;
  if ( !v9 )
    return 1;
  return result;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0042A408) --------------------------------------------------------
int   StreamAudioChanged(int a1)
{
  int v2; // $s5
  int v3; // $s4
  int Var; // $s1
  int v5; // $s0
  bool v6; // dc
  int result; // $v0

  v2 = nvram_bufget(0, "AudioEnable");
  v3 = nvram_bufget(0, "AudioVolume");
  Var = websGetVar(a1, (int)"AudioEnable", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"AudioVolume", (int)byte_4A2DDC);
  if ( strcmp(v2, Var) )
    return 1;
  v6 = strcmp(v3, v5) == 0;
  result = 0;
  if ( !v6 )
    return 1;
  return result;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0042A518) --------------------------------------------------------
int   WriteStreamVar(int a1)
{
  int v2; // $s2
  int v3; // $s3
  int v4; // $s4
  int v5; // $s5
  int v6; // $s6
  int v7; // $s7
  int v8; // $fp
  int v9; // $s0
  int Var; // [sp+18h] [-20h]
  int v12; // [sp+1Ch] [-1Ch]
  int v13; // [sp+20h] [-18h]
  int v14; // [sp+24h] [-14h]
  int v15; // [sp+28h] [-10h]
  int v16; // [sp+2Ch] [-Ch]
  int v17; // [sp+30h] [-8h]
  int v18; // [sp+34h] [-4h]

  Var = websGetVar(a1, (int)"BrightnessControl", (int)byte_4A2DDC);
  v12 = websGetVar(a1, (int)"ContrastControl", (int)byte_4A2DDC);
  v13 = websGetVar(a1, (int)"SaturationControl", (int)byte_4A2DDC);
  v14 = websGetVar(a1, (int)"SharpnessControl", (int)byte_4A2DDC);
  v15 = websGetVar(a1, (int)"AntiFlickerEnable", (int)byte_4A2DDC);
  v16 = websGetVar(a1, (int)"Mirror", (int)byte_4A2DDC);
  v17 = websGetVar(a1, (int)"VideoResolution", (int)byte_4A2DDC);
  v18 = websGetVar(a1, (int)"CompressionRate", (int)byte_4A2DDC);
  v2 = websGetVar(a1, (int)"FrameRate", (int)byte_4A2DDC);
  v3 = websGetVar(a1, (int)"ViewMode", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"LightFrequency", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"AudioEnable", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"AudioVolume", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"VideoResolution264", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"BitRate264", (int)byte_4A2DDC);
  v9 = websGetVar(a1, (int)"FrameRate264", (int)byte_4A2DDC);
  nvram_bufset(0, "BrightnessControl", Var);
  nvram_bufset(0, "ContrastControl", v12);
  nvram_bufset(0, "SaturationControl", v13);
  nvram_bufset(0, "SharpnessControl", v14);
  nvram_bufset(0, "AntiFlickerEnable", v15);
  nvram_bufset(0, "Mirror", v16);
  nvram_bufset(0, "VideoResolution", v17);
  nvram_bufset(0, "CompressionRate", v18);
  nvram_bufset(0, "FrameRate", v2);
  nvram_bufset(0, "ViewMode", v3);
  nvram_bufset(0, "LightFrequency", v4);
  nvram_bufset(0, "AudioEnable", v5);
  nvram_bufset(0, "AudioVolume", v6);
  nvram_bufset(0, "VideoResolution264", v7);
  nvram_bufset(0, "BitRate264", v8);
  nvram_bufset(0, "FrameRate264", v9);
  return 0;
}
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);

//----- (0042A94C) --------------------------------------------------------
int   CheckEmailVar(int a1)
{
  int v2; // $s0
  int v3; // $s0
  int v4; // $s0
  int v5; // $s0
  int v6; // $s0
  int v7; // $s0
  int v8; // $s0
  int v9; // $s0
  int v10; // $s0
  int v11; // $s0
  int v12; // $s0
  int v13; // $s0
  int v14; // $s0
  int v15; // $s0
  int v16; // $s0
  int v17; // $s0
  int v18; // $s0
  int v19; // $s0
  int v20; // $s0
  int v21; // $s0
  int v22; // $s0
  int v23; // $s0
  int v25; // [sp+18h] [-60h] BYREF
  int v26; // [sp+1Ch] [-5Ch] BYREF
  int v27; // [sp+20h] [-58h] BYREF
  int v28; // [sp+24h] [-54h] BYREF
  int v29; // [sp+28h] [-50h] BYREF
  int v30; // [sp+2Ch] [-4Ch] BYREF
  int v31; // [sp+30h] [-48h] BYREF
  int v32; // [sp+34h] [-44h] BYREF
  int v33; // [sp+38h] [-40h] BYREF
  int v34; // [sp+3Ch] [-3Ch] BYREF
  int v35; // [sp+40h] [-38h] BYREF
  int v36; // [sp+44h] [-34h] BYREF
  int v37; // [sp+48h] [-30h] BYREF
  int v38; // [sp+4Ch] [-2Ch] BYREF
  int v39; // [sp+50h] [-28h] BYREF
  int v40; // [sp+54h] [-24h] BYREF
  int v41; // [sp+58h] [-20h] BYREF
  int v42; // [sp+5Ch] [-1Ch] BYREF
  int v43; // [sp+60h] [-18h] BYREF
  int v44; // [sp+64h] [-14h] BYREF
  int v45; // [sp+68h] [-10h] BYREF
  int v46; // [sp+6Ch] [-Ch] BYREF
  int v47; // [sp+70h] [-8h] BYREF

  v2 = websGetVarCheck(a1, "EmailScheduleEnable", &v25);
  v3 = v2 | websGetVarCheck(a1, "EmailScheduleDay", &v26);
  v4 = v3 | websGetVarCheck(a1, "EmailSMTPServerAddress", &v27);
  v5 = v4 | websGetVarCheck(a1, "EmailSMTPPortNumber", &v28);
  v6 = v5 | websGetVarCheck(a1, "EmailSenderAddress", &v29);
  v7 = v6 | websGetVarCheck(a1, "EmailReceiverAddress", &v30);
  v8 = v7 | websGetVarCheck(a1, "EmailUserName", &v31);
  v9 = v8 | websGetVarCheck(a1, "EmailPassword", &v32);
  v10 = v9 | websGetVarCheck(a1, "EmailTLSAuthentication", &v33);
  v11 = v10 | websGetVarCheck(a1, "EmailScheduleMode", &v34);
  v12 = v11 | websGetVarCheck(a1, "EmailScheduleTimeStart", &v35);
  v13 = v12 | websGetVarCheck(a1, "EmailScheduleTimeStop", &v36);
  v14 = v13 | websGetVarCheck(a1, "EmailScheduleInterval", &v37);
  v15 = v14 | websGetVarCheck(a1, "EmailMotionMode", &v38);
  v16 = v15 | websGetVarCheck(a1, "EmailMotionFrameInterval", &v39);
  v17 = v16 | websGetVarCheck(a1, "EmailScheduleEnableVideo", &v40);
  v18 = v17 | websGetVarCheck(a1, "EmailScheduleDayVideo", &v41);
  v19 = v18 | websGetVarCheck(a1, "EmailScheduleModeVideo", &v42);
  v20 = v19 | websGetVarCheck(a1, "EmailScheduleTimeStartVideo", &v43);
  v21 = v20 | websGetVarCheck(a1, "EmailScheduleTimeStopVideo", &v44);
  v22 = v21 | websGetVarCheck(a1, "EmailScheduleIntervalVideo", &v45);
  v23 = v22 | websGetVarCheck(a1, "EmailScheduleVideoLimitSize", &v46);
  return v23 | websGetVarCheck(a1, "EmailScheduleVideoLimitTime", &v47);
}

//----- (0042AC60) --------------------------------------------------------
int   SystemEmailChanged(int a1)
{
  int v2; // $s5
  int v3; // $s4
  int v4; // $s3
  int v5; // $s2
  int v6; // $s1
  int result; // $v0
  bool v8; // dc
  int v9; // [sp+18h] [-A8h]
  int v10; // [sp+1Ch] [-A4h]
  int v11; // [sp+20h] [-A0h]
  int v12; // [sp+24h] [-9Ch]
  int v13; // [sp+28h] [-98h]
  int v14; // [sp+2Ch] [-94h]
  int v15; // [sp+30h] [-90h]
  int v16; // [sp+34h] [-8Ch]
  int v17; // [sp+38h] [-88h]
  int v18; // [sp+3Ch] [-84h]
  int v19; // [sp+40h] [-80h]
  int v20; // [sp+44h] [-7Ch]
  int v21; // [sp+48h] [-78h]
  int v22; // [sp+4Ch] [-74h]
  int v23; // [sp+50h] [-70h]
  int Var; // [sp+54h] [-6Ch]
  int v25; // [sp+58h] [-68h]
  int v26; // [sp+5Ch] [-64h]
  int v27; // [sp+60h] [-60h]
  int v28; // [sp+64h] [-5Ch]
  int v29; // [sp+68h] [-58h]
  int v30; // [sp+6Ch] [-54h]
  int v31; // [sp+70h] [-50h]
  int v32; // [sp+74h] [-4Ch]
  int v33; // [sp+78h] [-48h]
  int v34; // [sp+7Ch] [-44h]
  int v35; // [sp+80h] [-40h]
  int v36; // [sp+84h] [-3Ch]
  int v37; // [sp+88h] [-38h]
  int v38; // [sp+8Ch] [-34h]
  int v39; // [sp+90h] [-30h]
  int v40; // [sp+94h] [-2Ch]
  int v41; // [sp+98h] [-28h]
  int v42; // [sp+9Ch] [-24h]
  int v43; // [sp+A0h] [-20h]
  int v44; // [sp+A4h] [-1Ch]
  int v45; // [sp+A8h] [-18h]
  int v46; // [sp+ACh] [-14h]
  int v47; // [sp+B0h] [-10h]
  int v48; // [sp+B4h] [-Ch]
  int v49; // [sp+B8h] [-8h]

  v9 = nvram_bufget(0, "EmailScheduleEnable");
  v10 = nvram_bufget(0, "EmailScheduleDay");
  v11 = nvram_bufget(0, "EmailSMTPServerAddress");
  v12 = nvram_bufget(0, "EmailSMTPPortNumber");
  v13 = nvram_bufget(0, "EmailSenderAddress");
  v14 = nvram_bufget(0, "EmailReceiverAddress");
  v15 = nvram_bufget(0, "EmailUserName");
  v16 = nvram_bufget(0, "EmailPassword");
  v17 = nvram_bufget(0, "EmailTLSAuthentication");
  v18 = nvram_bufget(0, "EmailScheduleMode");
  v19 = nvram_bufget(0, "EmailScheduleTimeStart");
  v20 = nvram_bufget(0, "EmailScheduleTimeStop");
  v21 = nvram_bufget(0, "EmailScheduleInterval");
  v22 = nvram_bufget(0, "EmailMotionMode");
  v23 = nvram_bufget(0, "EmailMotionFrameInterval");
  Var = websGetVar(a1, (int)"EmailScheduleEnable", (int)byte_4A2DDC);
  v25 = websGetVar(a1, (int)"EmailScheduleDay", (int)byte_4A2DDC);
  v26 = websGetVar(a1, (int)"EmailSMTPServerAddress", (int)byte_4A2DDC);
  v27 = websGetVar(a1, (int)"EmailSMTPPortNumber", (int)byte_4A2DDC);
  v28 = websGetVar(a1, (int)"EmailSenderAddress", (int)byte_4A2DDC);
  v29 = websGetVar(a1, (int)"EmailReceiverAddress", (int)byte_4A2DDC);
  v30 = websGetVar(a1, (int)"EmailUserName", (int)byte_4A2DDC);
  v31 = websGetVar(a1, (int)"EmailPassword", (int)byte_4A2DDC);
  v32 = websGetVar(a1, (int)"EmailTLSAuthentication", (int)byte_4A2DDC);
  v33 = websGetVar(a1, (int)"EmailScheduleMode", (int)byte_4A2DDC);
  v34 = websGetVar(a1, (int)"EmailScheduleTimeStart", (int)byte_4A2DDC);
  v35 = websGetVar(a1, (int)"EmailScheduleTimeStop", (int)byte_4A2DDC);
  v36 = websGetVar(a1, (int)"EmailScheduleInterval", (int)byte_4A2DDC);
  v37 = websGetVar(a1, (int)"EmailMotionMode", (int)byte_4A2DDC);
  v38 = websGetVar(a1, (int)"EmailMotionFrameInterval", (int)byte_4A2DDC);
  v39 = nvram_bufget(0, "EmailScheduleEnableVideo");
  v40 = nvram_bufget(0, "EmailScheduleDayVideo");
  v41 = nvram_bufget(0, "EmailScheduleModeVideo");
  v42 = nvram_bufget(0, "EmailScheduleTimeStartVideo");
  v43 = nvram_bufget(0, "EmailScheduleTimeStopVideo");
  v44 = nvram_bufget(0, "EmailScheduleIntervalVideo");
  v45 = nvram_bufget(0, "EmailScheduleVideoLimitSize");
  v46 = nvram_bufget(0, "EmailScheduleVideoLimitTime");
  v47 = websGetVar(a1, (int)"EmailScheduleEnableVideo", (int)byte_4A2DDC);
  v48 = websGetVar(a1, (int)"EmailScheduleDayVideo", (int)byte_4A2DDC);
  v49 = websGetVar(a1, (int)"EmailScheduleModeVideo", (int)byte_4A2DDC);
  v2 = websGetVar(a1, (int)"EmailScheduleTimeStartVideo", (int)byte_4A2DDC);
  v3 = websGetVar(a1, (int)"EmailScheduleTimeStopVideo", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"EmailScheduleIntervalVideo", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"EmailScheduleVideoLimitSize", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"EmailScheduleVideoLimitTime", (int)byte_4A2DDC);
  if ( strcmp(v9, Var) )
    return 1;
  if ( strcmp(v10, v25) )
    return 1;
  if ( strcmp(v11, v26) )
    return 1;
  if ( strcmp(v12, v27) )
    return 1;
  if ( strcmp(v13, v28) )
    return 1;
  if ( strcmp(v14, v29) )
    return 1;
  if ( strcmp(v15, v30) )
    return 1;
  if ( strcmp(v16, v31) )
    return 1;
  if ( strcmp(v17, v32) )
    return 1;
  if ( strcmp(v18, v33) )
    return 1;
  if ( strcmp(v19, v34) )
    return 1;
  if ( strcmp(v20, v35) )
    return 1;
  if ( strcmp(v21, v36) )
    return 1;
  if ( strcmp(v39, v47) )
    return 1;
  if ( strcmp(v40, v48) )
    return 1;
  if ( strcmp(v41, v49) )
    return 1;
  if ( strcmp(v42, v2) )
    return 1;
  if ( strcmp(v43, v3) )
    return 1;
  if ( strcmp(v44, v4) )
    return 1;
  if ( strcmp(v45, v5) )
    return 1;
  if ( strcmp(v46, v6) )
    return 1;
  if ( strcmp(v22, v37) )
    return 1;
  v8 = strcmp(v23, v38) == 0;
  result = 0;
  if ( !v8 )
    return 1;
  return result;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0042B4DC) --------------------------------------------------------
int   WriteEmailVar(int a1)
{
  int v2; // $fp
  int v3; // $s2
  int v4; // $s3
  int v5; // $s4
  int v6; // $s5
  int v7; // $s6
  int v8; // $s7
  int v9; // $fp
  int v10; // $s0
  int Var; // [sp+18h] [-38h]
  int v13; // [sp+1Ch] [-34h]
  int v14; // [sp+20h] [-30h]
  int v15; // [sp+24h] [-2Ch]
  int v16; // [sp+28h] [-28h]
  int v17; // [sp+2Ch] [-24h]
  int v18; // [sp+30h] [-20h]
  int v19; // [sp+34h] [-1Ch]
  int v20; // [sp+38h] [-18h]
  int v21; // [sp+3Ch] [-14h]
  int v22; // [sp+40h] [-10h]
  int v23; // [sp+44h] [-Ch]
  int v24; // [sp+48h] [-8h]
  int v25; // [sp+4Ch] [-4h]

  Var = websGetVar(a1, (int)"EmailScheduleEnable", (int)byte_4A2DDC);
  v13 = websGetVar(a1, (int)"EmailScheduleDay", (int)byte_4A2DDC);
  v14 = websGetVar(a1, (int)"EmailSMTPServerAddress", (int)byte_4A2DDC);
  v15 = websGetVar(a1, (int)"EmailSMTPPortNumber", (int)byte_4A2DDC);
  v16 = websGetVar(a1, (int)"EmailSenderAddress", (int)byte_4A2DDC);
  v17 = websGetVar(a1, (int)"EmailReceiverAddress", (int)byte_4A2DDC);
  v18 = websGetVar(a1, (int)"EmailUserName", (int)byte_4A2DDC);
  v19 = websGetVar(a1, (int)"EmailPassword", (int)byte_4A2DDC);
  v20 = websGetVar(a1, (int)"EmailTLSAuthentication", (int)byte_4A2DDC);
  v21 = websGetVar(a1, (int)"EmailScheduleMode", (int)byte_4A2DDC);
  v22 = websGetVar(a1, (int)"EmailScheduleTimeStart", (int)byte_4A2DDC);
  v23 = websGetVar(a1, (int)"EmailScheduleTimeStop", (int)byte_4A2DDC);
  v24 = websGetVar(a1, (int)"EmailScheduleInterval", (int)byte_4A2DDC);
  v25 = websGetVar(a1, (int)"EmailMotionMode", (int)byte_4A2DDC);
  v2 = websGetVar(a1, (int)"EmailMotionFrameInterval", (int)byte_4A2DDC);
  nvram_bufset(0, "EmailScheduleEnable", Var);
  nvram_bufset(0, "EmailScheduleDay", v13);
  nvram_bufset(0, "EmailSMTPServerAddress", v14);
  nvram_bufset(0, "EmailSMTPPortNumber", v15);
  nvram_bufset(0, "EmailSenderAddress", v16);
  nvram_bufset(0, "EmailReceiverAddress", v17);
  nvram_bufset(0, "EmailUserName", v18);
  nvram_bufset(0, "EmailPassword", v19);
  nvram_bufset(0, "EmailTLSAuthentication", v20);
  nvram_bufset(0, "EmailScheduleMode", v21);
  nvram_bufset(0, "EmailScheduleTimeStart", v22);
  nvram_bufset(0, "EmailScheduleTimeStop", v23);
  nvram_bufset(0, "EmailScheduleInterval", v24);
  nvram_bufset(0, "EmailMotionMode", v25);
  nvram_bufset(0, "EmailMotionFrameInterval", v2);
  v3 = websGetVar(a1, (int)"EmailScheduleEnableVideo", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"EmailScheduleDayVideo", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"EmailScheduleModeVideo", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"EmailScheduleTimeStartVideo", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"EmailScheduleTimeStopVideo", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"EmailScheduleIntervalVideo", (int)byte_4A2DDC);
  v9 = websGetVar(a1, (int)"EmailScheduleVideoLimitSize", (int)byte_4A2DDC);
  v10 = websGetVar(a1, (int)"EmailScheduleVideoLimitTime", (int)byte_4A2DDC);
  nvram_bufset(0, "EmailScheduleEnableVideo", v3);
  nvram_bufset(0, "EmailScheduleDayVideo", v4);
  nvram_bufset(0, "EmailScheduleModeVideo", v5);
  nvram_bufset(0, "EmailScheduleTimeStartVideo", v6);
  nvram_bufset(0, "EmailScheduleTimeStopVideo", v7);
  nvram_bufset(0, "EmailScheduleIntervalVideo", v8);
  nvram_bufset(0, "EmailScheduleVideoLimitSize", v9);
  nvram_bufset(0, "EmailScheduleVideoLimitTime", v10);
  return 0;
}
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);

//----- (0042BAB4) --------------------------------------------------------
int   CheckFTPVar(int a1)
{
  int v2; // $s0
  int v3; // $s0
  int v4; // $s0
  int v5; // $s0
  int v6; // $s0
  int v7; // $s0
  int v8; // $s0
  int v9; // $s0
  int v10; // $s0
  int v11; // $s0
  int v12; // $s0
  int v13; // $s0
  int v14; // $s0
  int v15; // $s0
  int v16; // $s0
  int v17; // $s0
  int v18; // $s0
  int v19; // $s0
  int v20; // $s0
  int v21; // $s0
  int v22; // $s0
  int v23; // $s0
  int v24; // $s0
  int v25; // $s0
  int v26; // $s0
  int v28; // [sp+18h] [-68h] BYREF
  int v29; // [sp+1Ch] [-64h] BYREF
  int v30; // [sp+20h] [-60h] BYREF
  int v31; // [sp+24h] [-5Ch] BYREF
  int v32; // [sp+28h] [-58h] BYREF
  int v33; // [sp+2Ch] [-54h] BYREF
  int v34; // [sp+30h] [-50h] BYREF
  int v35; // [sp+34h] [-4Ch] BYREF
  int v36; // [sp+38h] [-48h] BYREF
  int v37; // [sp+3Ch] [-44h] BYREF
  int v38; // [sp+40h] [-40h] BYREF
  int v39; // [sp+44h] [-3Ch] BYREF
  int v40; // [sp+48h] [-38h] BYREF
  int v41; // [sp+4Ch] [-34h] BYREF
  int v42; // [sp+50h] [-30h] BYREF
  int v43; // [sp+54h] [-2Ch] BYREF
  int v44; // [sp+58h] [-28h] BYREF
  int v45; // [sp+5Ch] [-24h] BYREF
  int v46; // [sp+60h] [-20h] BYREF
  int v47; // [sp+64h] [-1Ch] BYREF
  int v48; // [sp+68h] [-18h] BYREF
  int v49; // [sp+6Ch] [-14h] BYREF
  int v50; // [sp+70h] [-10h] BYREF
  int v51; // [sp+74h] [-Ch] BYREF
  int v52; // [sp+78h] [-8h] BYREF
  int v53; // [sp+7Ch] [-4h] BYREF

  v2 = websGetVarCheck(a1, "FTPScheduleEnable", &v28);
  v3 = v2 | websGetVarCheck(a1, "FTPScheduleDay", &v29);
  v4 = v3 | websGetVarCheck(a1, "FTPHostAddress", &v30);
  v5 = v4 | websGetVarCheck(a1, "FTPPortNumber", &v31);
  v6 = v5 | websGetVarCheck(a1, "FTPUserName", &v32);
  v7 = v6 | websGetVarCheck(a1, "FTPPassword", &v33);
  v8 = v7 | websGetVarCheck(a1, "FTPDirectoryPath", &v34);
  v9 = v8 | websGetVarCheck(a1, "FTPPassiveMode", &v35);
  v10 = v9 | websGetVarCheck(a1, "FTPScheduleMode", &v36);
  v11 = v10 | websGetVarCheck(a1, "FTPScheduleTimeStart", &v37);
  v12 = v11 | websGetVarCheck(a1, "FTPScheduleTimeStop", &v38);
  v13 = v12 | websGetVarCheck(a1, "FTPScheduleVideoFrequencyMode", &v39);
  v14 = v13 | websGetVarCheck(a1, "FTPScheduleFramePerSecond", &v40);
  v15 = v14 | websGetVarCheck(a1, "FTPScheduleSecondPerFrame", &v41);
  v16 = v15 | websGetVarCheck(a1, "FTPScheduleBaseFileName", &v42);
  v17 = v16 | websGetVarCheck(a1, "FTPScheduleFileMode", &v43);
  v18 = v17 | websGetVarCheck(a1, "FTPScheduleMaxFileSequenceNumber", &v44);
  v19 = v18 | websGetVarCheck(a1, "FTPCreateFolderInterval", &v45);
  v20 = v19 | websGetVarCheck(a1, "FTPScheduleEnableVideo", &v46);
  v21 = v20 | websGetVarCheck(a1, "FTPScheduleDayVideo", &v47);
  v22 = v21 | websGetVarCheck(a1, "FTPScheduleModeVideo", &v48);
  v23 = v22 | websGetVarCheck(a1, "FTPScheduleTimeStartVideo", &v49);
  v24 = v23 | websGetVarCheck(a1, "FTPScheduleTimeStopVideo", &v50);
  v25 = v24 | websGetVarCheck(a1, "FTPScheduleBaseFileNameVideo", &v51);
  v26 = v25 | websGetVarCheck(a1, "FTPScheduleVideoLimitSize", &v52);
  return v26 | websGetVarCheck(a1, "FTPScheduleVideoLimitTime", &v53);
}

//----- (0042BE28) --------------------------------------------------------
int   SystemFTPChanged(int a1)
{
  int v2; // $s3
  int v3; // $s4
  int v4; // $s2
  int v5; // $s1
  int result; // $v0
  bool v7; // dc
  int v8; // [sp+18h] [-C0h]
  int v9; // [sp+1Ch] [-BCh]
  int v10; // [sp+20h] [-B8h]
  int v11; // [sp+24h] [-B4h]
  int v12; // [sp+28h] [-B0h]
  int v13; // [sp+2Ch] [-ACh]
  int v14; // [sp+30h] [-A8h]
  int v15; // [sp+34h] [-A4h]
  int v16; // [sp+38h] [-A0h]
  int v17; // [sp+3Ch] [-9Ch]
  int v18; // [sp+40h] [-98h]
  int v19; // [sp+44h] [-94h]
  int v20; // [sp+48h] [-90h]
  int v21; // [sp+4Ch] [-8Ch]
  int v22; // [sp+50h] [-88h]
  int v23; // [sp+54h] [-84h]
  int v24; // [sp+58h] [-80h]
  int v25; // [sp+5Ch] [-7Ch]
  int Var; // [sp+60h] [-78h]
  int v27; // [sp+64h] [-74h]
  int v28; // [sp+68h] [-70h]
  int v29; // [sp+6Ch] [-6Ch]
  int v30; // [sp+70h] [-68h]
  int v31; // [sp+74h] [-64h]
  int v32; // [sp+78h] [-60h]
  int v33; // [sp+7Ch] [-5Ch]
  int v34; // [sp+80h] [-58h]
  int v35; // [sp+84h] [-54h]
  int v36; // [sp+88h] [-50h]
  int v37; // [sp+8Ch] [-4Ch]
  int v38; // [sp+90h] [-48h]
  int v39; // [sp+94h] [-44h]
  int v40; // [sp+98h] [-40h]
  int v41; // [sp+9Ch] [-3Ch]
  int v42; // [sp+A0h] [-38h]
  int v43; // [sp+A4h] [-34h]
  int v44; // [sp+A8h] [-30h]
  int v45; // [sp+ACh] [-2Ch]
  int v46; // [sp+B0h] [-28h]
  int v47; // [sp+B4h] [-24h]
  int v48; // [sp+B8h] [-20h]
  int v49; // [sp+BCh] [-1Ch]
  int v50; // [sp+C0h] [-18h]
  int v51; // [sp+C4h] [-14h]
  int v52; // [sp+C8h] [-10h]
  int v53; // [sp+CCh] [-Ch]
  int v54; // [sp+D0h] [-8h]
  int v55; // [sp+D4h] [-4h]

  v8 = nvram_bufget(0, "FTPScheduleEnable");
  v9 = nvram_bufget(0, "FTPScheduleDay");
  v10 = nvram_bufget(0, "FTPHostAddress");
  v11 = nvram_bufget(0, "FTPPortNumber");
  v12 = nvram_bufget(0, "FTPUserName");
  v13 = nvram_bufget(0, "FTPPassword");
  v14 = nvram_bufget(0, "FTPDirectoryPath");
  v15 = nvram_bufget(0, "FTPPassiveMode");
  v16 = nvram_bufget(0, "FTPScheduleMode");
  v17 = nvram_bufget(0, "FTPScheduleTimeStart");
  v18 = nvram_bufget(0, "FTPScheduleTimeStop");
  v19 = nvram_bufget(0, "FTPScheduleVideoFrequencyMode");
  v21 = nvram_bufget(0, "FTPScheduleFramePerSecond");
  v20 = nvram_bufget(0, "FTPScheduleSecondPerFrame");
  v22 = nvram_bufget(0, "FTPScheduleBaseFileName");
  v23 = nvram_bufget(0, "FTPScheduleFileMode");
  v24 = nvram_bufget(0, "FTPScheduleMaxFileSequenceNumber");
  v25 = nvram_bufget(0, "FTPCreateFolderInterval");
  Var = websGetVar(a1, (int)"FTPScheduleEnable", (int)byte_4A2DDC);
  v27 = websGetVar(a1, (int)"FTPScheduleDay", (int)byte_4A2DDC);
  v28 = websGetVar(a1, (int)"FTPHostAddress", (int)byte_4A2DDC);
  v29 = websGetVar(a1, (int)"FTPPortNumber", (int)byte_4A2DDC);
  v30 = websGetVar(a1, (int)"FTPUserName", (int)byte_4A2DDC);
  v31 = websGetVar(a1, (int)"FTPPassword", (int)byte_4A2DDC);
  v32 = websGetVar(a1, (int)"FTPDirectoryPath", (int)byte_4A2DDC);
  v33 = websGetVar(a1, (int)"FTPPassiveMode", (int)byte_4A2DDC);
  v34 = websGetVar(a1, (int)"FTPScheduleMode", (int)byte_4A2DDC);
  v35 = websGetVar(a1, (int)"FTPScheduleTimeStart", (int)byte_4A2DDC);
  v36 = websGetVar(a1, (int)"FTPScheduleTimeStop", (int)byte_4A2DDC);
  v37 = websGetVar(a1, (int)"FTPScheduleVideoFrequencyMode", (int)byte_4A2DDC);
  v39 = websGetVar(a1, (int)"FTPScheduleFramePerSecond", (int)byte_4A2DDC);
  v38 = websGetVar(a1, (int)"FTPScheduleSecondPerFrame", (int)byte_4A2DDC);
  v40 = websGetVar(a1, (int)"FTPScheduleBaseFileName", (int)byte_4A2DDC);
  v41 = websGetVar(a1, (int)"FTPScheduleFileMode", (int)byte_4A2DDC);
  v42 = websGetVar(a1, (int)"FTPScheduleMaxFileSequenceNumber", (int)byte_4A2DDC);
  v43 = websGetVar(a1, (int)"FTPCreateFolderInterval", (int)byte_4A2DDC);
  v44 = nvram_bufget(0, "FTPScheduleEnableVideo");
  v45 = nvram_bufget(0, "FTPScheduleDayVideo");
  v46 = nvram_bufget(0, "FTPScheduleModeVideo");
  v47 = nvram_bufget(0, "FTPScheduleTimeStartVideo");
  v48 = nvram_bufget(0, "FTPScheduleTimeStopVideo");
  v49 = nvram_bufget(0, "FTPScheduleBaseFileNameVideo");
  v50 = nvram_bufget(0, "FTPScheduleVideoLimitSize");
  v51 = nvram_bufget(0, "FTPScheduleVideoLimitTime");
  v52 = websGetVar(a1, (int)"FTPScheduleEnableVideo", (int)byte_4A2DDC);
  v53 = websGetVar(a1, (int)"FTPScheduleDayVideo", (int)byte_4A2DDC);
  v54 = websGetVar(a1, (int)"FTPScheduleModeVideoVideo", (int)byte_4A2DDC);
  v55 = websGetVar(a1, (int)"FTPScheduleTimeStartVideo", (int)byte_4A2DDC);
  v2 = websGetVar(a1, (int)"FTPScheduleTimeStopVideo", (int)byte_4A2DDC);
  v3 = websGetVar(a1, (int)"FTPScheduleBaseFileNameVideo", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"FTPScheduleVideoLimitSize", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"FTPScheduleVideoLimitTime", (int)byte_4A2DDC);
  if ( strcmp(v8, Var) )
    return 1;
  if ( strcmp(v9, v27) )
    return 1;
  if ( strcmp(v10, v28) )
    return 1;
  if ( strcmp(v11, v29) )
    return 1;
  if ( strcmp(v12, v30) )
    return 1;
  if ( strcmp(v13, v31) )
    return 1;
  if ( strcmp(v14, v32) )
    return 1;
  if ( strcmp(v15, v33) )
    return 1;
  if ( strcmp(v16, v34) )
    return 1;
  if ( strcmp(v17, v35) )
    return 1;
  if ( strcmp(v18, v36) )
    return 1;
  if ( strcmp(v19, v37) )
    return 1;
  if ( strcmp(v21, v39) )
    return 1;
  if ( strcmp(v20, v38) )
    return 1;
  if ( strcmp(v22, v40) )
    return 1;
  if ( strcmp(v23, v41) )
    return 1;
  if ( strcmp(v24, v42) )
    return 1;
  if ( strcmp(v44, v52) )
    return 1;
  if ( strcmp(v45, v53) )
    return 1;
  if ( strcmp(v46, v54) )
    return 1;
  if ( strcmp(v47, v55) )
    return 1;
  if ( strcmp(v48, v2) )
    return 1;
  if ( strcmp(v49, v3) )
    return 1;
  if ( strcmp(v50, v4) )
    return 1;
  if ( strcmp(v51, v5) )
    return 1;
  v7 = strcmp(v25, v43) == 0;
  result = 0;
  if ( !v7 )
    return 1;
  return result;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0042C7B8) --------------------------------------------------------
int   WriteFTPVar(int a1)
{
  int v2; // $fp
  int v3; // $s2
  int v4; // $s3
  int v5; // $s4
  int v6; // $s5
  int v7; // $s6
  int v8; // $s7
  int v9; // $fp
  int v10; // $s0
  int Var; // [sp+18h] [-48h]
  int v13; // [sp+1Ch] [-44h]
  int v14; // [sp+20h] [-40h]
  int v15; // [sp+24h] [-3Ch]
  int v16; // [sp+28h] [-38h]
  int v17; // [sp+2Ch] [-34h]
  int v18; // [sp+30h] [-30h]
  int v19; // [sp+34h] [-2Ch]
  int v20; // [sp+38h] [-28h]
  int v21; // [sp+3Ch] [-24h]
  int v22; // [sp+40h] [-20h]
  int v23; // [sp+44h] [-1Ch]
  int v24; // [sp+48h] [-18h]
  int v25; // [sp+4Ch] [-14h]
  int v26; // [sp+50h] [-10h]
  int v27; // [sp+54h] [-Ch]
  int v28; // [sp+58h] [-8h]

  Var = websGetVar(a1, (int)"FTPScheduleEnable", (int)byte_4A2DDC);
  v13 = websGetVar(a1, (int)"FTPScheduleDay", (int)byte_4A2DDC);
  v14 = websGetVar(a1, (int)"FTPHostAddress", (int)byte_4A2DDC);
  v15 = websGetVar(a1, (int)"FTPPortNumber", (int)byte_4A2DDC);
  v16 = websGetVar(a1, (int)"FTPUserName", (int)byte_4A2DDC);
  v17 = websGetVar(a1, (int)"FTPPassword", (int)byte_4A2DDC);
  v18 = websGetVar(a1, (int)"FTPDirectoryPath", (int)byte_4A2DDC);
  v19 = websGetVar(a1, (int)"FTPPassiveMode", (int)byte_4A2DDC);
  v20 = websGetVar(a1, (int)"FTPScheduleMode", (int)byte_4A2DDC);
  v21 = websGetVar(a1, (int)"FTPScheduleTimeStart", (int)byte_4A2DDC);
  v22 = websGetVar(a1, (int)"FTPScheduleTimeStop", (int)byte_4A2DDC);
  v23 = websGetVar(a1, (int)"FTPScheduleVideoFrequencyMode", (int)byte_4A2DDC);
  v25 = websGetVar(a1, (int)"FTPScheduleFramePerSecond", (int)byte_4A2DDC);
  v24 = websGetVar(a1, (int)"FTPScheduleSecondPerFrame", (int)byte_4A2DDC);
  v26 = websGetVar(a1, (int)"FTPScheduleBaseFileName", (int)byte_4A2DDC);
  v27 = websGetVar(a1, (int)"FTPScheduleFileMode", (int)byte_4A2DDC);
  v28 = websGetVar(a1, (int)"FTPScheduleMaxFileSequenceNumber", (int)byte_4A2DDC);
  v2 = websGetVar(a1, (int)"FTPCreateFolderInterval", (int)byte_4A2DDC);
  nvram_bufset(0, "FTPScheduleEnable", Var);
  nvram_bufset(0, "FTPScheduleDay", v13);
  nvram_bufset(0, "FTPHostAddress", v14);
  nvram_bufset(0, "FTPPortNumber", v15);
  nvram_bufset(0, "FTPUserName", v16);
  nvram_bufset(0, "FTPPassword", v17);
  nvram_bufset(0, "FTPDirectoryPath", v18);
  nvram_bufset(0, "FTPPassiveMode", v19);
  nvram_bufset(0, "FTPScheduleMode", v20);
  nvram_bufset(0, "FTPScheduleTimeStart", v21);
  nvram_bufset(0, "FTPScheduleTimeStop", v22);
  nvram_bufset(0, "FTPScheduleVideoFrequencyMode", v23);
  nvram_bufset(0, "FTPScheduleFramePerSecond", v25);
  nvram_bufset(0, "FTPScheduleSecondPerFrame", v24);
  nvram_bufset(0, "FTPScheduleBaseFileName", v26);
  nvram_bufset(0, "FTPScheduleFileMode", v27);
  nvram_bufset(0, "FTPScheduleMaxFileSequenceNumber", v28);
  nvram_bufset(0, "FTPCreateFolderInterval", v2);
  v3 = websGetVar(a1, (int)"FTPScheduleEnableVideo", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"FTPScheduleDayVideo", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"FTPScheduleModeVideo", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"FTPScheduleTimeStartVideo", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"FTPScheduleTimeStopVideo", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"FTPScheduleBaseFileNameVideo", (int)byte_4A2DDC);
  v9 = websGetVar(a1, (int)"FTPScheduleVideoLimitSize", (int)byte_4A2DDC);
  v10 = websGetVar(a1, (int)"FTPScheduleVideoLimitTime", (int)byte_4A2DDC);
  nvram_bufset(0, "FTPScheduleEnableVideo", v3);
  nvram_bufset(0, "FTPScheduleDayVideo", v4);
  nvram_bufset(0, "FTPScheduleModeVideo", v5);
  nvram_bufset(0, "FTPScheduleTimeStartVideo", v6);
  nvram_bufset(0, "FTPScheduleTimeStopVideo", v7);
  nvram_bufset(0, "FTPScheduleBaseFileNameVideo", v8);
  nvram_bufset(0, "FTPScheduleVideoLimitSize", v9);
  nvram_bufset(0, "FTPScheduleVideoLimitTime", v10);
  return 0;
}
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);

//----- (0042CE44) --------------------------------------------------------
int   CheckDateVar(int a1)
{
  int v2; // $s0
  int v3; // $s0
  int v4; // $s0
  int v5; // $s0
  int v6; // $s0
  int v7; // $s0
  int v8; // $s0
  int v9; // $s0
  int v10; // $s0
  int v11; // $s0
  int v12; // $s0
  int v13; // $s0
  int v14; // $s0
  int v15; // $s0
  int v16; // $s0
  int v18; // [sp+18h] [-40h] BYREF
  int v19; // [sp+1Ch] [-3Ch] BYREF
  int v20; // [sp+20h] [-38h] BYREF
  int v21; // [sp+24h] [-34h] BYREF
  int v22; // [sp+28h] [-30h] BYREF
  int v23; // [sp+2Ch] [-2Ch] BYREF
  int v24; // [sp+30h] [-28h] BYREF
  int v25; // [sp+34h] [-24h] BYREF
  int v26; // [sp+38h] [-20h] BYREF
  int v27; // [sp+3Ch] [-1Ch] BYREF
  int v28; // [sp+40h] [-18h] BYREF
  int v29; // [sp+44h] [-14h] BYREF
  int v30; // [sp+48h] [-10h] BYREF
  int v31; // [sp+4Ch] [-Ch] BYREF
  int v32; // [sp+50h] [-8h] BYREF
  int v33; // [sp+54h] [-4h] BYREF

  v2 = websGetVarCheck(a1, "DateTimeMode", &v18);
  v3 = v2 | websGetVarCheck(a1, "TimeServerIPAddress", &v19);
  v4 = v3 | websGetVarCheck(a1, "Date", &v20);
  v5 = v4 | websGetVarCheck(a1, "Time", &v21);
  v6 = v5 | websGetVarCheck(a1, "TimeZoneIndex", &v22);
  v7 = v6 | websGetVarCheck(a1, "TimeZone", &v23);
  v8 = v7 | websGetVarCheck(a1, "DSTEnable", &v24);
  v9 = v8 | websGetVarCheck(a1, "DSTOffset", &v25);
  v10 = v9 | websGetVarCheck(a1, "DSTStartMonth", &v26);
  v11 = v10 | websGetVarCheck(a1, "DSTStartWeek", &v27);
  v12 = v11 | websGetVarCheck(a1, "DSTStartDay", &v28);
  v13 = v12 | websGetVarCheck(a1, "DSTStartTime", &v29);
  v14 = v13 | websGetVarCheck(a1, "DSTEndMonth", &v30);
  v15 = v14 | websGetVarCheck(a1, "DSTEndWeek", &v31);
  v16 = v15 | websGetVarCheck(a1, "DSTEndDay", &v32);
  return v16 | websGetVarCheck(a1, "DSTEndTime", &v33);
}

//----- (0042D078) --------------------------------------------------------
int   SystemDateChanged(int a1)
{
  int v2; // $s5
  int v3; // $s6
  int v4; // $s2
  int v5; // $s4
  int v6; // $s3
  int v7; // $s1
  int result; // $v0
  bool v9; // dc
  int v10; // [sp+18h] [-68h]
  int v11; // [sp+1Ch] [-64h]
  int v12; // [sp+20h] [-60h]
  int v13; // [sp+24h] [-5Ch]
  int v14; // [sp+28h] [-58h]
  int v15; // [sp+2Ch] [-54h]
  int Var; // [sp+30h] [-50h]
  int v17; // [sp+34h] [-4Ch]
  int v18; // [sp+38h] [-48h]
  int v19; // [sp+3Ch] [-44h]
  int v20; // [sp+40h] [-40h]
  int v21; // [sp+44h] [-3Ch]
  int v22; // [sp+48h] [-38h]
  int v23; // [sp+4Ch] [-34h]
  int v24; // [sp+50h] [-30h]
  int v25; // [sp+54h] [-2Ch]
  int v26; // [sp+58h] [-28h]
  int v27; // [sp+5Ch] [-24h]
  int v28; // [sp+60h] [-20h]
  int v29; // [sp+64h] [-1Ch]
  int v30; // [sp+68h] [-18h]
  int v31; // [sp+6Ch] [-14h]
  int v32; // [sp+70h] [-10h]
  int v33; // [sp+74h] [-Ch]
  int v34; // [sp+78h] [-8h]
  int v35; // [sp+7Ch] [-4h]

  v10 = nvram_bufget(0, "DateTimeMode");
  v11 = nvram_bufget(0, "TimeServerIPAddress");
  v12 = nvram_bufget(0, "TimeZoneIndex");
  v13 = nvram_bufget(0, "Date");
  v14 = nvram_bufget(0, "Time");
  v15 = nvram_bufget(0, "TimeZone");
  Var = websGetVar(a1, (int)"DateTimeMode", (int)byte_4A2DDC);
  v17 = websGetVar(a1, (int)"TimeServerIPAddress", (int)byte_4A2DDC);
  v18 = websGetVar(a1, (int)"TimeZoneIndex", (int)byte_4A2DDC);
  v19 = websGetVar(a1, (int)"Date", (int)byte_4A2DDC);
  v20 = websGetVar(a1, (int)"Time", (int)byte_4A2DDC);
  v21 = websGetVar(a1, (int)"TimeZone", (int)byte_4A2DDC);
  v22 = nvram_bufget(0, "DSTEnable");
  v23 = nvram_bufget(0, "DSTOffset");
  v24 = nvram_bufget(0, "DSTStartMonth");
  v25 = nvram_bufget(0, "DSTStartWeek");
  v26 = nvram_bufget(0, "DSTStartDay");
  v27 = nvram_bufget(0, "DSTStartTime");
  v28 = nvram_bufget(0, "DSTEndMonth");
  v29 = nvram_bufget(0, "DSTEndWeek");
  v30 = nvram_bufget(0, "DSTEndDay");
  v31 = nvram_bufget(0, "DSTEndTime");
  v32 = websGetVar(a1, (int)"DSTEnable", (int)byte_4A2DDC);
  v33 = websGetVar(a1, (int)"DSTOffset", (int)byte_4A2DDC);
  v34 = websGetVar(a1, (int)"DSTStartMonth", (int)byte_4A2DDC);
  v35 = websGetVar(a1, (int)"DSTStartWeek", (int)byte_4A2DDC);
  v2 = websGetVar(a1, (int)"DSTStartDay", (int)byte_4A2DDC);
  v3 = websGetVar(a1, (int)"DSTStartTime", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"DSTEndMonth", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"DSTEndWeek", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"DSTEndDay", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"DSTEndTime", (int)byte_4A2DDC);
  if ( strcmp(v10, Var) )
    return 1;
  if ( strcmp(v11, v17) )
    return 1;
  if ( strcmp(v12, v18) )
    return 1;
  if ( strcmp(v13, v19) )
    return 1;
  if ( strcmp(v14, v20) )
    return 1;
  if ( strcmp(v22, v32) )
    return 1;
  if ( strcmp(v23, v33) )
    return 1;
  if ( strcmp(v24, v34) )
    return 1;
  if ( strcmp(v25, v35) )
    return 1;
  if ( strcmp(v26, v2) )
    return 1;
  if ( strcmp(v28, v4) )
    return 1;
  if ( strcmp(v27, v3) )
    return 1;
  if ( strcmp(v29, v5) )
    return 1;
  if ( strcmp(v30, v6) )
    return 1;
  if ( strcmp(v31, v7) )
    return 1;
  v9 = strcmp(v15, v21) == 0;
  result = 0;
  if ( !v9 )
    return 1;
  return result;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0042D66C) --------------------------------------------------------
int   WriteDateVar(int a1)
{
  int Var; // $s4
  int v3; // $s5
  int v4; // $s6
  int v5; // $s7
  int v6; // $fp
  int v7; // $fp
  int v8; // $s0
  int v10; // [sp+18h] [-28h]
  int v11; // [sp+1Ch] [-24h]
  int v12; // [sp+20h] [-20h]
  int v13; // [sp+24h] [-1Ch]
  int v14; // [sp+28h] [-18h]
  int v15; // [sp+2Ch] [-14h]
  int v16; // [sp+30h] [-10h]
  int v17; // [sp+34h] [-Ch]
  int v18; // [sp+38h] [-8h]

  Var = websGetVar(a1, (int)"DateTimeMode", (int)byte_4A2DDC);
  v3 = websGetVar(a1, (int)"TimeServerIPAddress", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"Date", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"Time", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"TimeZoneIndex", (int)byte_4A2DDC);
  v10 = websGetVar(a1, (int)"TimeZone", (int)byte_4A2DDC);
  nvram_bufset(0, "DateTimeMode", Var);
  nvram_bufset(0, "TimeServerIPAddress", v3);
  nvram_bufset(0, "Date", v4);
  nvram_bufset(0, "Time", v5);
  nvram_bufset(0, "TimeZoneIndex", v6);
  nvram_bufset(0, "TimeZone", v10);
  v11 = websGetVar(a1, (int)"DSTEnable", (int)byte_4A2DDC);
  v12 = websGetVar(a1, (int)"DSTOffset", (int)byte_4A2DDC);
  v13 = websGetVar(a1, (int)"DSTStartMonth", (int)byte_4A2DDC);
  v14 = websGetVar(a1, (int)"DSTStartWeek", (int)byte_4A2DDC);
  v15 = websGetVar(a1, (int)"DSTStartDay", (int)byte_4A2DDC);
  v16 = websGetVar(a1, (int)"DSTStartTime", (int)byte_4A2DDC);
  v17 = websGetVar(a1, (int)"DSTEndMonth", (int)byte_4A2DDC);
  v18 = websGetVar(a1, (int)"DSTEndWeek", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"DSTEndDay", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"DSTEndTime", (int)byte_4A2DDC);
  nvram_bufset(0, "DSTEnable", v11);
  nvram_bufset(0, "DSTOffset", v12);
  nvram_bufset(0, "DSTStartMonth", v13);
  nvram_bufset(0, "DSTStartWeek", v14);
  nvram_bufset(0, "DSTStartDay", v15);
  nvram_bufset(0, "DSTStartTime", v16);
  nvram_bufset(0, "DSTEndMonth", v17);
  nvram_bufset(0, "DSTEndWeek", v18);
  nvram_bufset(0, "DSTEndDay", v7);
  nvram_bufset(0, "DSTEndTime", v8);
  return 0;
}
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);

//----- (0042DA98) --------------------------------------------------------
int   CheckMotionVar(int a1)
{
  int v2; // $v0
  int v3; // $a0
  int v4; // $s2
  int v5; // $s0
  int v6; // $s2
  int v7; // $s0
  int v8; // $s2
  int v9; // $s0
  _BYTE *v11; // $v0
  int v12; // $v0
  int v13; // [sp+18h] [-20h] BYREF
  int v14; // [sp+1Ch] [-1Ch] BYREF
  int v15; // [sp+20h] [-18h] BYREF
  int v16; // [sp+24h] [-14h] BYREF
  int v17; // [sp+28h] [-10h] BYREF
  int v18; // [sp+2Ch] [-Ch] BYREF
  int v19; // [sp+30h] [-8h] BYREF

  if ( !strcmp(aXxxxxxxxxxxxxx_0, "xxxxxxxxxxxxxxxxxxxxxxxxx") )
  {
    v11 = (_BYTE *)nvram_bufget(0, "MotionDetectionBlockSet");
    if ( !v11 || !*v11 )
    {
      strcpy(aXxxxxxxxxxxxxx_0, "0000000000000000000000000");
      v12 = websTestVar(a1, (int)"MotionDetectionBlockSet");
      v3 = a1;
      if ( v12 )
        goto LABEL_3;
LABEL_7:
      websSetVar(v3, "MotionDetectionBlockSet", aXxxxxxxxxxxxxx_0);
      goto LABEL_3;
    }
    strcpy(aXxxxxxxxxxxxxx_0, v11);
  }
  v2 = websTestVar(a1, (int)"MotionDetectionBlockSet");
  v3 = a1;
  if ( !v2 )
    goto LABEL_7;
LABEL_3:
  v4 = websGetVarCheck(a1, "MotionDetectionEnable", &v13);
  v5 = v4 | websGetVarCheck(a1, "MotionDetectionBlockSet", &v14);
  v6 = v5 | websGetVarCheck(a1, "MotionDetectionSensitivity", &v15);
  v7 = v6 | websGetVarCheck(a1, "MotionDetectionScheduleDay", &v16);
  v8 = v7 | websGetVarCheck(a1, "MotionDetectionScheduleMode", &v17);
  v9 = v8 | websGetVarCheck(a1, "MotionDetectionScheduleTimeStart", &v18);
  return v9 | websGetVarCheck(a1, "MotionDetectionScheduleTimeStop", &v19);
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0C8: using guessed type int   strcpy(_DWORD, _DWORD);

//----- (0042DCC8) --------------------------------------------------------
int   WriteMotionVar(int a1)
{
  int Var; // $s6
  int v3; // $s7
  int v4; // $s3
  int v5; // $fp
  int v6; // $s7
  int v7; // $s6
  int v8; // $s0

  Var = websGetVar(a1, (int)"MotionDetectionEnable", (int)byte_4A2DDC);
  v3 = websGetVar(a1, (int)"MotionDetectionBlockSet", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"MotionDetectionSensitivity", (int)byte_4A2DDC);
  nvram_bufset(0, "MotionDetectionEnable", Var);
  nvram_bufset(0, "MotionDetectionBlockSet", v3);
  nvram_bufset(0, "MotionDetectionSensitivity", v4);
  strcpy(aXxxxxxxxxxxxxx_0, v3);
  v5 = websGetVar(a1, (int)"MotionDetectionScheduleDay", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"MotionDetectionScheduleMode", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"MotionDetectionScheduleTimeStart", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"MotionDetectionScheduleTimeStop", (int)byte_4A2DDC);
  nvram_bufset(0, "MotionDetectionScheduleDay", v5);
  nvram_bufset(0, "MotionDetectionScheduleMode", v6);
  nvram_bufset(0, "MotionDetectionScheduleTimeStart", v7);
  nvram_bufset(0, "MotionDetectionScheduleTimeStop", v8);
  return 0;
}
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);
// 4EA0C8: using guessed type int   strcpy(_DWORD, _DWORD);

//----- (0042DEE0) --------------------------------------------------------
int   SystemMotionChanged(int a1)
{
  int v2; // $s7
  int Var; // $s6
  int v4; // $fp
  int v5; // $s2
  int v6; // $s3
  int v7; // $s4
  int v8; // $s1
  int result; // $v0
  bool v10; // dc
  int v11; // [sp+18h] [-20h]
  int v12; // [sp+1Ch] [-1Ch]
  int v13; // [sp+20h] [-18h]
  int v14; // [sp+24h] [-14h]
  int v15; // [sp+28h] [-10h]
  int v16; // [sp+2Ch] [-Ch]
  int v17; // [sp+30h] [-8h]

  v2 = nvram_bufget(0, "MotionDetectionEnable");
  v11 = nvram_bufget(0, "MotionDetectionBlockSet");
  v12 = nvram_bufget(0, "MotionDetectionSensitivity");
  Var = websGetVar(a1, (int)"MotionDetectionEnable", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"MotionDetectionBlockSet", (int)byte_4A2DDC);
  v13 = websGetVar(a1, (int)"MotionDetectionSensitivity", (int)byte_4A2DDC);
  v14 = nvram_bufget(0, "MotionDetectionScheduleDay");
  v15 = nvram_bufget(0, "MotionDetectionScheduleMode");
  v16 = nvram_bufget(0, "MotionDetectionScheduleTimeStart");
  v17 = nvram_bufget(0, "MotionDetectionScheduleTimeStop");
  v5 = websGetVar(a1, (int)"MotionDetectionScheduleDay", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"MotionDetectionScheduleMode", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"MotionDetectionScheduleTimeStart", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"MotionDetectionScheduleTimeStop", (int)byte_4A2DDC);
  if ( strcmp(v2, Var) )
    return 1;
  if ( strcmp(v11, v4) )
    return 1;
  if ( strcmp(v14, v5) )
    return 1;
  if ( strcmp(v15, v6) )
    return 1;
  if ( strcmp(v16, v7) )
    return 1;
  if ( strcmp(v17, v8) )
    return 1;
  v10 = strcmp(v12, v13) == 0;
  result = 0;
  if ( !v10 )
    return 1;
  return result;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0042E1B4) --------------------------------------------------------
int   CheckDayNightVar(int a1)
{
  int v2; // $s0
  int v3; // $s0
  int v4; // $s0
  int v5; // $s0
  int v6; // $s0
  int v7; // $s0
  int v8; // $s0
  int v9; // $s0
  int v10; // $s0
  int v11; // $s0
  int v12; // $s0
  int v13; // $s0
  int v14; // $s0
  int v15; // $s0
  int v17; // [sp+18h] [-40h] BYREF
  int v18; // [sp+1Ch] [-3Ch] BYREF
  int v19; // [sp+20h] [-38h] BYREF
  int v20; // [sp+24h] [-34h] BYREF
  int v21; // [sp+28h] [-30h] BYREF
  int v22; // [sp+2Ch] [-2Ch] BYREF
  int v23; // [sp+30h] [-28h] BYREF
  int v24; // [sp+34h] [-24h] BYREF
  int v25; // [sp+38h] [-20h] BYREF
  int v26; // [sp+3Ch] [-1Ch] BYREF
  int v27; // [sp+40h] [-18h] BYREF
  int v28; // [sp+44h] [-14h] BYREF
  int v29; // [sp+48h] [-10h] BYREF
  int v30; // [sp+4Ch] [-Ch] BYREF
  int v31; // [sp+50h] [-8h] BYREF

  v2 = websGetVarCheck(a1, "DayNightMode", &v17);
  v3 = v2 | websGetVarCheck(a1, "IRLedScheduleSunStart", &v18);
  v4 = v3 | websGetVarCheck(a1, "IRLedScheduleSunEnd", &v19);
  v5 = v4 | websGetVarCheck(a1, "IRLedScheduleMonStart", &v20);
  v6 = v5 | websGetVarCheck(a1, "IRLedScheduleMonEnd", &v21);
  v7 = v6 | websGetVarCheck(a1, "IRLedScheduleTueStart", &v22);
  v8 = v7 | websGetVarCheck(a1, "IRLedScheduleTueEnd", &v23);
  v9 = v8 | websGetVarCheck(a1, "IRLedScheduleWedStart", &v24);
  v10 = v9 | websGetVarCheck(a1, "IRLedScheduleWedEnd", &v25);
  v11 = v10 | websGetVarCheck(a1, "IRLedScheduleThuStart", &v26);
  v12 = v11 | websGetVarCheck(a1, "IRLedScheduleThuEnd", &v27);
  v13 = v12 | websGetVarCheck(a1, "IRLedScheduleFriStart", &v28);
  v14 = v13 | websGetVarCheck(a1, "IRLedScheduleFriEnd", &v29);
  v15 = v14 | websGetVarCheck(a1, "IRLedScheduleSatStart", &v30);
  return v15 | websGetVarCheck(a1, "IRLedScheduleSatEnd", &v31);
}

//----- (0042E3C8) --------------------------------------------------------
int   SystemDayNightChanged(int a1)
{
  int Var; // $fp
  int v3; // $s2
  int v4; // $s3
  int v5; // $s7
  int v6; // $s6
  int v7; // $s5
  int v8; // $s4
  int v9; // $s1
  int result; // $v0
  bool v11; // dc
  int v12; // [sp+18h] [-58h]
  int v13; // [sp+1Ch] [-54h]
  int v14; // [sp+20h] [-50h]
  int v15; // [sp+24h] [-4Ch]
  int v16; // [sp+28h] [-48h]
  int v17; // [sp+2Ch] [-44h]
  int v18; // [sp+30h] [-40h]
  int v19; // [sp+34h] [-3Ch]
  int v20; // [sp+38h] [-38h]
  int v21; // [sp+3Ch] [-34h]
  int v22; // [sp+40h] [-30h]
  int v23; // [sp+44h] [-2Ch]
  int v24; // [sp+48h] [-28h]
  int v25; // [sp+4Ch] [-24h]
  int v26; // [sp+50h] [-20h]
  int v27; // [sp+54h] [-1Ch]
  int v28; // [sp+58h] [-18h]
  int v29; // [sp+5Ch] [-14h]
  int v30; // [sp+60h] [-10h]
  int v31; // [sp+64h] [-Ch]
  int v32; // [sp+68h] [-8h]
  int v33; // [sp+6Ch] [-4h]

  v12 = nvram_bufget(0, "DayNightMode");
  v13 = nvram_bufget(0, "IRLedScheduleSunStart");
  v14 = nvram_bufget(0, "IRLedScheduleSunEnd");
  v15 = nvram_bufget(0, "IRLedScheduleMonStart");
  v16 = nvram_bufget(0, "IRLedScheduleMonEnd");
  v17 = nvram_bufget(0, "IRLedScheduleTueStart");
  v18 = nvram_bufget(0, "IRLedScheduleTueEnd");
  v19 = nvram_bufget(0, "IRLedScheduleWedStart");
  v20 = nvram_bufget(0, "IRLedScheduleWedEnd");
  v21 = nvram_bufget(0, "IRLedScheduleThuStart");
  v22 = nvram_bufget(0, "IRLedScheduleThuEnd");
  v23 = nvram_bufget(0, "IRLedScheduleFriStart");
  v24 = nvram_bufget(0, "IRLedScheduleFriEnd");
  v25 = nvram_bufget(0, "IRLedScheduleSatStart");
  v26 = nvram_bufget(0, "IRLedScheduleSatEnd");
  Var = websGetVar(a1, (int)"DayNightMode", (int)byte_4A2DDC);
  v3 = websGetVar(a1, (int)"IRLedScheduleSunStart", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"IRLedScheduleSunEnd", (int)byte_4A2DDC);
  v27 = websGetVar(a1, (int)"IRLedScheduleMonStart", (int)byte_4A2DDC);
  v28 = websGetVar(a1, (int)"IRLedScheduleMonEnd", (int)byte_4A2DDC);
  v29 = websGetVar(a1, (int)"IRLedScheduleTueStart", (int)byte_4A2DDC);
  v30 = websGetVar(a1, (int)"IRLedScheduleTueEnd", (int)byte_4A2DDC);
  v31 = websGetVar(a1, (int)"IRLedScheduleWedStart", (int)byte_4A2DDC);
  v32 = websGetVar(a1, (int)"IRLedScheduleWedEnd", (int)byte_4A2DDC);
  v33 = websGetVar(a1, (int)"IRLedScheduleThuStart", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"IRLedScheduleThuEnd", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"IRLedScheduleFriStart", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"IRLedScheduleFriEnd", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"IRLedScheduleSatStart", (int)byte_4A2DDC);
  v9 = websGetVar(a1, (int)"IRLedScheduleSatEnd", (int)byte_4A2DDC);
  if ( strcmp(v12, Var) )
    return 1;
  if ( strcmp(v13, v3) )
    return 1;
  if ( strcmp(v14, v4) )
    return 1;
  if ( strcmp(v15, v27) )
    return 1;
  if ( strcmp(v16, v28) )
    return 1;
  if ( strcmp(v17, v29) )
    return 1;
  if ( strcmp(v18, v30) )
    return 1;
  if ( strcmp(v19, v31) )
    return 1;
  if ( strcmp(v20, v32) )
    return 1;
  if ( strcmp(v21, v33) )
    return 1;
  if ( strcmp(v22, v5) )
    return 1;
  if ( strcmp(v23, v6) )
    return 1;
  if ( strcmp(v24, v7) )
    return 1;
  if ( strcmp(v25, v8) )
    return 1;
  v11 = strcmp(v26, v9) == 0;
  result = 0;
  if ( !v11 )
    return 1;
  return result;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0042E974) --------------------------------------------------------
int   WriteDayNightVar(int a1)
{
  int v2; // $s2
  int v3; // $s3
  int v4; // $s4
  int v5; // $s5
  int v6; // $s6
  int v7; // $s7
  int v8; // $fp
  int v9; // $s0
  int Var; // [sp+18h] [-20h]
  int v12; // [sp+1Ch] [-1Ch]
  int v13; // [sp+20h] [-18h]
  int v14; // [sp+24h] [-14h]
  int v15; // [sp+28h] [-10h]
  int v16; // [sp+2Ch] [-Ch]
  int v17; // [sp+30h] [-8h]

  Var = websGetVar(a1, (int)"DayNightMode", (int)byte_4A2DDC);
  v12 = websGetVar(a1, (int)"IRLedScheduleSunStart", (int)byte_4A2DDC);
  v13 = websGetVar(a1, (int)"IRLedScheduleSunEnd", (int)byte_4A2DDC);
  v14 = websGetVar(a1, (int)"IRLedScheduleMonStart", (int)byte_4A2DDC);
  v15 = websGetVar(a1, (int)"IRLedScheduleMonEnd", (int)byte_4A2DDC);
  v16 = websGetVar(a1, (int)"IRLedScheduleTueStart", (int)byte_4A2DDC);
  v17 = websGetVar(a1, (int)"IRLedScheduleTueEnd", (int)byte_4A2DDC);
  v2 = websGetVar(a1, (int)"IRLedScheduleWedStart", (int)byte_4A2DDC);
  v3 = websGetVar(a1, (int)"IRLedScheduleWedEnd", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"IRLedScheduleThuStart", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"IRLedScheduleThuEnd", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"IRLedScheduleFriStart", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"IRLedScheduleFriEnd", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"IRLedScheduleSatStart", (int)byte_4A2DDC);
  v9 = websGetVar(a1, (int)"IRLedScheduleSatEnd", (int)byte_4A2DDC);
  nvram_bufset(0, "DayNightMode", Var);
  nvram_bufset(0, "IRLedScheduleSunStart", v12);
  nvram_bufset(0, "IRLedScheduleSunEnd", v13);
  nvram_bufset(0, "IRLedScheduleMonStart", v14);
  nvram_bufset(0, "IRLedScheduleMonEnd", v15);
  nvram_bufset(0, "IRLedScheduleTueStart", v16);
  nvram_bufset(0, "IRLedScheduleTueEnd", v17);
  nvram_bufset(0, "IRLedScheduleWedStart", v2);
  nvram_bufset(0, "IRLedScheduleWedEnd", v3);
  nvram_bufset(0, "IRLedScheduleThuStart", v4);
  nvram_bufset(0, "IRLedScheduleThuEnd", v5);
  nvram_bufset(0, "IRLedScheduleFriStart", v6);
  nvram_bufset(0, "IRLedScheduleFriEnd", v7);
  nvram_bufset(0, "IRLedScheduleSatStart", v8);
  nvram_bufset(0, "IRLedScheduleSatEnd", v9);
  return 0;
}
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);

//----- (0042ED68) --------------------------------------------------------
int   CheckSoundDBVar(int a1)
{
  int v2; // $s0
  int v3; // $s0
  int v4; // $s0
  int v5; // $s0
  int v6; // $s0
  int v8; // [sp+18h] [-18h] BYREF
  int v9; // [sp+1Ch] [-14h] BYREF
  int v10; // [sp+20h] [-10h] BYREF
  int v11; // [sp+24h] [-Ch] BYREF
  int v12; // [sp+28h] [-8h] BYREF
  int v13; // [sp+2Ch] [-4h] BYREF

  v2 = websGetVarCheck(a1, "SoundDetectionEnable", &v8);
  v3 = v2 | websGetVarCheck(a1, "SoundDetectionDB", &v9);
  v4 = v3 | websGetVarCheck(a1, "SoundDetectionScheduleDay", &v10);
  v5 = v4 | websGetVarCheck(a1, "SoundDetectionScheduleMode", &v11);
  v6 = v5 | websGetVarCheck(a1, "SoundDetectionScheduleTimeStart", &v12);
  return v6 | websGetVarCheck(a1, "SoundDetectionScheduleTimeStop", &v13);
}

//----- (0042EE5C) --------------------------------------------------------
int   SystemSoundDBChanged(int a1)
{
  int v2; // $fp
  int Var; // $s7
  int v4; // $s2
  int v5; // $s3
  int v6; // $s4
  int v7; // $s5
  int v8; // $s1
  int result; // $v0
  bool v10; // dc
  int v11; // [sp+18h] [-18h]
  int v12; // [sp+1Ch] [-14h]
  int v13; // [sp+20h] [-10h]
  int v14; // [sp+24h] [-Ch]
  int v15; // [sp+28h] [-8h]

  v2 = nvram_bufget(0, "SoundDetectionEnable");
  v11 = nvram_bufget(0, "SoundDetectionDB");
  v12 = nvram_bufget(0, "SoundDetectionScheduleDay");
  v13 = nvram_bufget(0, "SoundDetectionScheduleMode");
  v14 = nvram_bufget(0, "SoundDetectionScheduleTimeStart");
  v15 = nvram_bufget(0, "SoundDetectionScheduleTimeStop");
  Var = websGetVar(a1, (int)"SoundDetectionEnable", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"SoundDetectionDB", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"SoundDetectionScheduleDay", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"SoundDetectionScheduleMode", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"SoundDetectionScheduleTimeStart", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"SoundDetectionScheduleTimeStop", (int)byte_4A2DDC);
  if ( strcmp(v2, Var) )
    return 1;
  if ( strcmp(v11, v4) )
    return 1;
  if ( strcmp(v12, v5) )
    return 1;
  if ( strcmp(v13, v6) )
    return 1;
  if ( strcmp(v14, v7) )
    return 1;
  v10 = strcmp(v15, v8) == 0;
  result = 0;
  if ( !v10 )
    return 1;
  return result;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0042F0D8) --------------------------------------------------------
int   WriteSoundDBVar(int a1)
{
  int Var; // $s4
  int v3; // $s5
  int v4; // $s6
  int v5; // $s7
  int v6; // $fp
  int v7; // $s0

  Var = websGetVar(a1, (int)"SoundDetectionEnable", (int)byte_4A2DDC);
  v3 = websGetVar(a1, (int)"SoundDetectionDB", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"SoundDetectionScheduleDay", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"SoundDetectionScheduleMode", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"SoundDetectionScheduleTimeStart", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"SoundDetectionScheduleTimeStop", (int)byte_4A2DDC);
  nvram_bufset(0, "SoundDetectionEnable", Var);
  nvram_bufset(0, "SoundDetectionDB", v3);
  nvram_bufset(0, "SoundDetectionScheduleDay", v4);
  nvram_bufset(0, "SoundDetectionScheduleMode", v5);
  nvram_bufset(0, "SoundDetectionScheduleTimeStart", v6);
  nvram_bufset(0, "SoundDetectionScheduleTimeStop", v7);
  return 0;
}
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);

//----- (0042F2AC) --------------------------------------------------------
int   CheckCIFSVar(int a1)
{
  int v2; // $s0
  int v3; // $s0
  int v4; // $s0
  int v5; // $s0
  int v6; // $s0
  int v7; // $s0
  int v8; // $s0
  int v9; // $s0
  int v10; // $s0
  int v12; // [sp+18h] [-28h] BYREF
  int v13; // [sp+1Ch] [-24h] BYREF
  int v14; // [sp+20h] [-20h] BYREF
  int v15; // [sp+24h] [-1Ch] BYREF
  int v16; // [sp+28h] [-18h] BYREF
  int v17; // [sp+2Ch] [-14h] BYREF
  int v18; // [sp+30h] [-10h] BYREF
  int v19; // [sp+34h] [-Ch] BYREF
  int v20; // [sp+38h] [-8h] BYREF
  int v21; // [sp+3Ch] [-4h] BYREF

  v2 = websGetVarCheck(a1, "CifsServerFolder", &v12);
  v3 = v2 | websGetVarCheck(a1, "CifsUserName", &v13);
  v4 = v3 | websGetVarCheck(a1, "CifsPassword", &v14);
  v5 = v4 | websGetVarCheck(a1, "CifsScheduleEnable", &v15);
  v6 = v5 | websGetVarCheck(a1, "CifsScheduleDay", &v16);
  v7 = v6 | websGetVarCheck(a1, "CifsScheduleMode", &v17);
  v8 = v7 | websGetVarCheck(a1, "CifsScheduleTimeStart", &v18);
  v9 = v8 | websGetVarCheck(a1, "CifsScheduleTimeStop", &v19);
  v10 = v9 | websGetVarCheck(a1, "CifsMaxRecordTime", &v20);
  return v10 | websGetVarCheck(a1, "CifsFullAction", &v21);
}

//----- (0042F420) --------------------------------------------------------
int   SystemCIFSChanged(int a1)
{
  int Var; // $fp
  int v3; // $s2
  int v4; // $s3
  int v5; // $s4
  int v6; // $s7
  int v7; // $s6
  int v8; // $s5
  int v9; // $s1
  int result; // $v0
  bool v11; // dc
  int v12; // [sp+18h] [-30h]
  int v13; // [sp+1Ch] [-2Ch]
  int v14; // [sp+20h] [-28h]
  int v15; // [sp+24h] [-24h]
  int v16; // [sp+28h] [-20h]
  int v17; // [sp+2Ch] [-1Ch]
  int v18; // [sp+30h] [-18h]
  int v19; // [sp+34h] [-14h]
  int v20; // [sp+38h] [-10h]
  int v21; // [sp+3Ch] [-Ch]
  int v22; // [sp+40h] [-8h]
  int v23; // [sp+44h] [-4h]

  v12 = nvram_bufget(0, "CifsServerFolder");
  v13 = nvram_bufget(0, "CifsUserName");
  v14 = nvram_bufget(0, "CifsPassword");
  v15 = nvram_bufget(0, "CifsScheduleEnable");
  v16 = nvram_bufget(0, "CifsScheduleDay");
  v17 = nvram_bufget(0, "CifsScheduleMode");
  v18 = nvram_bufget(0, "CifsScheduleTimeStart");
  v19 = nvram_bufget(0, "CifsScheduleTimeStop");
  v20 = nvram_bufget(0, "CifsMaxRecordTime");
  v21 = nvram_bufget(0, "CifsFullAction");
  Var = websGetVar(a1, (int)"CifsServerFolder", (int)byte_4A2DDC);
  v3 = websGetVar(a1, (int)"CifsUserName", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"CifsPassword", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"CifsScheduleEnable", (int)byte_4A2DDC);
  v22 = websGetVar(a1, (int)"CifsScheduleDay", (int)byte_4A2DDC);
  v23 = websGetVar(a1, (int)"CifsScheduleMode", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"CifsScheduleTimeStart", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"CifsScheduleTimeStop", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"CifsMaxRecordTime", (int)byte_4A2DDC);
  v9 = websGetVar(a1, (int)"CifsFullAction", (int)byte_4A2DDC);
  if ( strcmp(v12, Var) )
    return 1;
  if ( strcmp(v13, v3) )
    return 1;
  if ( strcmp(v14, v4) )
    return 1;
  if ( strcmp(v15, v5) )
    return 1;
  if ( strcmp(v16, v22) )
    return 1;
  if ( strcmp(v17, v23) )
    return 1;
  if ( strcmp(v18, v6) )
    return 1;
  if ( strcmp(v19, v7) )
    return 1;
  if ( strcmp(v20, v8) )
    return 1;
  v11 = strcmp(v21, v9) == 0;
  result = 0;
  if ( !v11 )
    return 1;
  return result;
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0042F800) --------------------------------------------------------
int   WriteCIFSVar(int a1)
{
  int v2; // $s2
  int v3; // $s3
  int v4; // $s4
  int v5; // $s5
  int v6; // $s6
  int v7; // $s7
  int v8; // $fp
  int v9; // $s0
  int Var; // [sp+18h] [-8h]
  int v12; // [sp+1Ch] [-4h]

  Var = websGetVar(a1, (int)"CifsServerFolder", (int)byte_4A2DDC);
  v12 = websGetVar(a1, (int)"CifsUserName", (int)byte_4A2DDC);
  v2 = websGetVar(a1, (int)"CifsPassword", (int)byte_4A2DDC);
  v3 = websGetVar(a1, (int)"CifsScheduleEnable", (int)byte_4A2DDC);
  v4 = websGetVar(a1, (int)"CifsScheduleDay", (int)byte_4A2DDC);
  v5 = websGetVar(a1, (int)"CifsScheduleMode", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"CifsScheduleTimeStart", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"CifsScheduleTimeStop", (int)byte_4A2DDC);
  v8 = websGetVar(a1, (int)"CifsMaxRecordTime", (int)byte_4A2DDC);
  v9 = websGetVar(a1, (int)"CifsFullAction", (int)byte_4A2DDC);
  nvram_bufset(0, "CifsServerFolder", Var);
  nvram_bufset(0, "CifsUserName", v12);
  nvram_bufset(0, "CifsPassword", v2);
  nvram_bufset(0, "CifsScheduleEnable", v3);
  nvram_bufset(0, "CifsScheduleDay", v4);
  nvram_bufset(0, "CifsScheduleMode", v5);
  nvram_bufset(0, "CifsScheduleTimeStart", v6);
  nvram_bufset(0, "CifsScheduleTimeStop", v7);
  nvram_bufset(0, "CifsMaxRecordTime", v8);
  nvram_bufset(0, "CifsFullAction", v9);
  return 0;
}
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);

//----- (0042FACC) --------------------------------------------------------
int   sub_42FACC(int a1)
{
  int result; // $v0
  int Var; // $v0
  int v4; // $v1

  websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
  result = websTestVar(a1, (int)"WebDebugLevel");
  if ( result )
  {
    Var = websGetVar(a1, (int)"WebDebugLevel", (int)byte_4A2DDC);
    result = atoi(Var);
    v4 = result & 0x1F;
    if ( !result )
      v4 = 16;
    Debug_Trace_Level = v4;
  }
  return result;
}
// 4E3420: using guessed type int Debug_Trace_Level;
// 4E9F38: using guessed type int   atoi(_DWORD);

//----- (0042FBA4) --------------------------------------------------------
int   sub_42FBA4(int a1)
{
  char *ErrorMessage; // $v0
  int result; // $v0

  ErrorMessage = (char *)websGetErrorMessage(0);
  webAddReplyMessage(a1, ErrorMessage, 0);
  websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
  result = 3;
  *(_DWORD *)(a1 + 288) = 3;
  return result;
}

//----- (0042FC28) --------------------------------------------------------
int   sub_42FC28(int a1)
{
  char *ErrorMessage; // $v0
  int result; // $v0

  ErrorMessage = (char *)websGetErrorMessage(1);
  webAddReplyMessage(a1, ErrorMessage, 0);
  websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
  doSystem((int)"ralink_init clear 2860");
  result = doSystem((int)"ralink_init renew 2860 /etc_ro/Wireless/RT2860AP/RT2860_default_vlan");
  *(_DWORD *)(a1 + 288) = 3;
  *(_DWORD *)(a1 + 296) = 0;
  return result;
}

//----- (0042FCE8) --------------------------------------------------------
int *  sub_42FCE8(int a1)
{
  char *Var; // $s0
  int v4; // $s1

  if ( websTestVar(a1, (int)"ConfigSystemLanguage") )
  {
    Var = (char *)websGetVar(a1, (int)"WebLanguage", (int)&word_4A0308);
    v4 = atoi(Var);
    trace(1, (int)"setSystemLanguage: %s!\n", Var);
    switch_language(1, v4);
  }
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F38: using guessed type int   atoi(_DWORD);

//----- (0042FE04) --------------------------------------------------------
int *  sub_42FE04(int a1)
{
  int v2; // $s2
  int v3; // $s4
  int v4; // $s5
  int Var; // $s0
  int v7; // $v0
  int v8; // [sp+18h] [-8h] BYREF

  v2 = websTestVar(a1, (int)"ConfigAuthorizationMode");
  v3 = websGetVarCheck(a1, "HTTPAuthentication", &v8);
  v4 = 0;
  if ( websTestVar(a1, (int)"ConfigReboot") )
  {
    Var = websGetVar(a1, (int)"ConfigReboot", (int)byte_4A2DDC);
    if ( !strcasecmp(Var, "Yes") )
    {
      v2 = 1;
      v4 = 3;
    }
    else if ( !strcasecmp(Var, "No") )
    {
      v2 = 1;
    }
  }
  if ( v3 )
    return websetReplayPage(a1, v3, "ReplySuccessPage", "ReplyErrorPage");
  if ( !v2 )
    return websetReplayPage(a1, v3, "ReplySuccessPage", "ReplyErrorPage");
  nvram_bufget(0, "HTTPAuthentication");
  websGetVar(a1, (int)"HTTPAuthentication", (int)byte_4A2DDC);
  v7 = websGetVar(a1, (int)"HTTPAuthentication", (int)byte_4A2DDC);
  nvram_bufset(0, "HTTPAuthentication", v7);
  nvram_commit(0);
  if ( v4 <= 0 )
    return websetReplayPage(a1, v3, "ReplySuccessPage", "ReplyErrorPage");
  *(_DWORD *)(a1 + 288) = 3;
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00430028) --------------------------------------------------------
int *  sub_430028(int a1)
{
  _BYTE *v2; // $s0
  _BYTE *v3; // $v0
  _BYTE *v4; // $s1
  char *v5; // $v0
  char *ErrorMessage; // $v0

  v2 = (_BYTE *)nvram_bufget(0, "EmailSMTPServerAddress");
  v4 = (_BYTE *)nvram_bufget(0, "EmailSenderAddress");
  v3 = (_BYTE *)nvram_bufget(0, "EmailReceiverAddress");
  if ( v2 && *v2 && v4 && *v4 && v3 && *v3 )
  {
    ErrorMessage = (char *)websGetErrorMessage(10);
    webAddReplyMessage(a1, ErrorMessage, 0);
    setSysInfoShort(27, 1);
    trace(1, (int)"Call test E-Mail function!\n");
    setSysInfoLong(57, 1024);
  }
  else
  {
    v5 = (char *)websGetErrorMessage(11);
    webAddReplyMessage(a1, v5, 0);
    setSysInfoShort(27, 10);
  }
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (004301CC) --------------------------------------------------------
int *  sub_4301CC(int a1)
{
  _BYTE *v2; // $v0
  char *v3; // $v0
  char *ErrorMessage; // $v0

  v2 = (_BYTE *)nvram_bufget(0, "FTPHostAddress");
  if ( v2 && *v2 )
  {
    ErrorMessage = (char *)websGetErrorMessage(12);
    webAddReplyMessage(a1, ErrorMessage, 0);
    setSysInfoShort(26, 1);
    trace(1, (int)"Call test FTP function!\n");
    setSysInfoLong(57, 2048);
    return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
  }
  else
  {
    v3 = (char *)websGetErrorMessage(13);
    webAddReplyMessage(a1, v3, 0);
    setSysInfoShort(26, 14);
    return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
  }
}
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0043032C) --------------------------------------------------------
int *  sub_43032C(int a1)
{
  _BYTE *Var; // $v0

  Var = (_BYTE *)websGetVar(a1, (int)"WirelessCountry", (int)&word_4A0308);
  *Var -= 48;
  setSysInfoBuffer(69, (int)Var, 1);
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4A0308: using guessed type __int16 word_4A0308;

//----- (004303B8) --------------------------------------------------------
int *  sub_4303B8(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  _BYTE *v4; // $v0
  char *v5; // $s1
  _BYTE *v6; // $v0
  char *v7; // $s2
  _BYTE *v8; // $v0
  char *v9; // $s3
  _BYTE *v10; // $v0
  char *v12; // [sp+20h] [-8h] BYREF

  websConfigGetFromVar(a1, (int)"SSIDSelection", byte_4A2DDC, &v12);
  v2 = (char *)strdupWithoutNull(v12);
  v3 = v2;
  v12 = v2;
  if ( !v2 )
    return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
  v4 = (_BYTE *)strchr(v2, 40);
  v5 = v4 + 1;
  if ( v4 )
  {
    *v4 = 0;
    v6 = (_BYTE *)strchr(v4 + 1, 44);
    v7 = v6 + 1;
    if ( v6 )
    {
      *v6 = 0;
      v8 = (_BYTE *)strchr(v6 + 1, 44);
      v9 = v8 + 1;
      if ( v8 )
      {
        *v8 = 0;
        v10 = (_BYTE *)strchr(v8 + 1, 41);
        if ( v10 )
        {
          *v10 = 0;
          trace(2, (int)"SSIDSelection=(%s,%s,%s,%s)\n", v3, v5, v7, v9);
          websSetVar(a1, "SSID", v3);
          websSetVar(a1, "ConnectionMode", v5);
          websSetVar(a1, "WirelessChannel", v7);
          websSetVar(a1, "WEPEncryption", v9);
        }
      }
    }
    v3 = v12;
  }
  if ( !v3 )
    return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
  free2(v3);
  v12 = 0;
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);

//----- (004305F0) --------------------------------------------------------
int *  sub_4305F0(int a1)
{
  setSysInfoNone(43);
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}

//----- (0043064C) --------------------------------------------------------
int *  sub_43064C(int a1)
{
  void *v2; // $v0
  int v3; // $s3
  int v4; // $s7
  int v5; // $s1
  int v6; // $s0
  int v7; // $s0
  int v8; // $s0
  int v9; // $s0
  int v10; // $s5
  int v11; // $s0
  int v12; // $s1
  int v13; // $s5
  int Var; // $s1
  int v16; // $s0
  char *v17; // $s1
  char *v18; // $s1
  int v19; // $s3
  int v20; // $s2
  int v21; // $fp
  int v22; // $s1
  int v23; // $s2
  int v24; // $s3
  int v25; // $v0
  _DWORD v26[2]; // [sp+18h] [-50h] BYREF
  _DWORD v27[6]; // [sp+20h] [-48h] BYREF
  int v28; // [sp+38h] [-30h] BYREF
  int v29; // [sp+40h] [-28h] BYREF
  int v30; // [sp+44h] [-24h] BYREF
  int v31; // [sp+48h] [-20h] BYREF
  int v32; // [sp+4Ch] [-1Ch] BYREF
  int v33; // [sp+50h] [-18h] BYREF
  int v34; // [sp+54h] [-14h] BYREF
  int v35; // [sp+58h] [-10h]
  int v36; // [sp+5Ch] [-Ch]
  int v37; // [sp+60h] [-8h]

  if ( websTestVar(a1, (int)"PPPoEPassword") )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v18 = (char *)allocDecodePasswordByName(a1, (int)"PPPoEPassword");
      websSetVar(a1, "PPPoEPassword", v18);
      if ( v18 )
        free2(v18);
    }
  }
  if ( websTestVar(a1, (int)"DDNSPassword") )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v17 = (char *)allocDecodePasswordByName(a1, (int)"DDNSPassword");
      websSetVar(a1, "DDNSPassword", v17);
      if ( v17 )
        free2(v17);
    }
  }
  v3 = websTestVar(a1, (int)"ConfigSystemWizard");
  v2 = (void *)nvram_bufget(0, "CameraName");
  v4 = strdupWithoutNull(v2);
  v5 = CheckNetworkVar(a1);
  v6 = websGetVarCheck(a1, "DDNSEnable", &v29);
  v7 = v6 | websGetVarCheck(a1, "DDNSProvider", &v30);
  v8 = v7 | websGetVarCheck(a1, "DDNSHostName", &v31);
  v9 = v8 | websGetVarCheck(a1, "DDNSUserName", &v32);
  v10 = v9 | websGetVarCheck(a1, "DDNSPassword", &v33);
  v11 = v10 | websGetVarCheck(a1, "DDNSTimeout", &v34);
  v12 = v5 | v11 | CheckSystemVar(a1);
  v13 = v12 | CheckDateVar(a1);
  Var = websGetVar(a1, (int)"DateTimeMode", (int)byte_4A2DDC);
  v36 = websGetVar(a1, (int)"CameraName", (int)byte_4A2DDC);
  v35 = 0;
  if ( websTestVar(a1, (int)"ConfigReboot") )
  {
    v16 = websGetVar(a1, (int)"ConfigReboot", (int)byte_4A2DDC);
    if ( !strcasecmp(v16, "Yes") )
    {
      v3 = 1;
      v35 = 3;
    }
    else if ( !strcasecmp(v16, "No") )
    {
      v3 = 1;
    }
  }
  if ( !v13 && v3 )
  {
    v19 = SystemNetworkChanged(a1);
    v20 = SystemDDNSChanged(a1);
    v37 = OSDTimeChanged(a1);
    v21 = SystemDateChanged(a1);
    WriteNetworkVar(a1);
    WriteSystemVar(a1);
    WriteDateVar(a1);
    nvram_commit(0);
    if ( v19 )
    {
      doSystem((int)"sleep 3 && lan.sh &");
      trace(1, (int)"Network settings was changed!\n");
    }
    else if ( v20 )
    {
      doSystem((int)"sleep 3 && ddns.sh &");
      trace(1, (int)"DDNS settings was changed!\n");
    }
    if ( Var && !strcmp(Var, "1") )
    {
      v22 = websGetVar(a1, (int)"Date", (int)byte_4A2DDC);
      v23 = websGetVar(a1, (int)"Time", (int)byte_4A2DDC);
      qmemcpy(v27, "100717482009", 12);
      qmemcpy(v26, "date -s ", sizeof(v26));
      memset(&v27[3], 0, 12);
      v24 = websGetVar(a1, (int)"TimeZone", (int)byte_4A2DDC);
      LOWORD(v27[0]) = *(_WORD *)(v22 + 5);
      HIWORD(v27[0]) = *(_WORD *)(v22 + 8);
      LOWORD(v27[1]) = *(_WORD *)v23;
      HIWORD(v27[1]) = *(_WORD *)(v23 + 3);
      v27[2] = *(_DWORD *)v22;
      websTimeoutCancel(a1);
      doSystem((int)v26);
      snprintf(v26, 32, "date -s %s", (char *)v23);
      doSystem((int)v26);
      v28 = -16;
      gettimeofday(&v28, 0);
      v25 = atol(v24);
      v28 -= 60 * v25;
      setSysInfoBuffer(109, (int)&v28, 8);
      Sleep(1);
      *(_DWORD *)(a1 + 236) = websTimeoutSched(60, (int)websTimeout, a1);
    }
    if ( v21 )
    {
      doSystem((int)"ntp.sh &");
      trace(1, (int)"DateTime settings was changed!\n");
    }
    if ( v37 || v4 && v36 && strcmp(v4, v36) )
      doSystem((int)"cameraname.sh &");
    if ( v35 > 0 )
      *(_DWORD *)(a1 + 288) = 3;
  }
  if ( v4 )
    free2(v4);
  return websetReplayPage(a1, v13, "ReplySuccessPage", "ReplyErrorPage");
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FAC: using guessed type int   gettimeofday(_DWORD, _DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA09C: using guessed type int   atol(_DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (00430EA0) --------------------------------------------------------
int *  sub_430EA0(int a1)
{
  int v2; // $fp
  void *v3; // $s3
  void *v4; // $s4
  void *v5; // $s2
  int v6; // $s7
  char *v7; // $s3
  int v8; // $s4
  int v9; // $s1
  int v11; // $s0
  char *v12; // $s1
  int v13; // $s5
  int v14; // [sp+18h] [-10h]
  int v15; // [sp+1Ch] [-Ch]
  char *Var; // [sp+20h] [-8h]

  if ( websTestVar(a1, (int)"AdminPassword") )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v12 = (char *)allocDecodePasswordByName(a1, (int)"AdminPassword");
      websSetVar(a1, "AdminPassword", v12);
      if ( v12 )
        free2(v12);
    }
  }
  v2 = websTestVar(a1, (int)"ConfigSystemAdmin");
  v3 = (void *)nvram_bufget(0, "AdminID");
  v4 = (void *)nvram_bufget(0, "AdminPassword");
  v5 = (void *)nvram_bufget(0, "CameraName");
  v15 = CheckSystemVar(a1);
  Var = (char *)websGetVar(a1, (int)"AdminID", (int)byte_4A2DDC);
  websGetVar(a1, (int)"AdminPassword", (int)byte_4A2DDC);
  v6 = websGetVar(a1, (int)"CameraName", (int)byte_4A2DDC);
  v14 = 0;
  v7 = (char *)strdupWithoutNull(v3);
  v8 = strdupWithoutNull(v4);
  v9 = strdupWithoutNull(v5);
  if ( websTestVar(a1, (int)"ConfigReboot") )
  {
    v11 = websGetVar(a1, (int)"ConfigReboot", (int)byte_4A2DDC);
    if ( !strcasecmp(v11, "Yes") )
    {
      v2 = 1;
      v14 = 3;
    }
    else if ( !strcasecmp(v11, "No") )
    {
      v2 = 1;
    }
  }
  if ( !v15 && v2 )
  {
    v13 = OSDTimeChanged(a1);
    WriteSystemVar(a1);
    nvram_commit(0);
    doSystem((int)"sed -e 's/^%s:/%s:/' /etc/passwd > /etc/newpw", v7, Var);
    doSystem((int)"cp /etc/newpw /etc/passwd");
    doSystem((int)"rm -f /etc/newpw");
    doSystem((int)"chpasswd.sh");
    if ( v13 || v9 && v6 && strcmp(v9, v6) )
      doSystem((int)"cameraname.sh &");
    if ( v14 > 0 )
      *(_DWORD *)(a1 + 288) = 3;
  }
  if ( v7 )
    free2(v7);
  if ( v8 )
    free2(v8);
  if ( v9 )
    free2(v9);
  return websetReplayPage(a1, v15, "ReplySuccessPage", "ReplyErrorPage");
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (004312FC) --------------------------------------------------------
int *  sub_4312FC(int a1)
{
  int v2; // $fp
  void *v3; // $s5
  void *v4; // $s4
  void *v5; // $s3
  int v6; // $s1
  int v7; // $s4
  int v8; // $s2
  int v9; // $s5
  int v11; // $s0
  int v12; // $s0
  int v13; // $v0
  int (*v14)(); // $t9
  int v15; // [sp+18h] [-10h]
  int Var; // [sp+1Ch] [-Ch]
  int v17; // [sp+20h] [-8h]
  int v18; // [sp+24h] [-4h]

  v2 = websTestVar(a1, (int)"ConfigSystemControl");
  v3 = (void *)nvram_bufget(0, "AccessControlEnable");
  v4 = (void *)nvram_bufget(0, "SnapshotURLAuthentication");
  v5 = (void *)nvram_bufget(0, "CameraName");
  v15 = CheckSystemVar(a1);
  Var = websGetVar(a1, (int)"AccessControlEnable", (int)byte_4A2DDC);
  v17 = websGetVar(a1, (int)"SnapshotURLAuthentication", (int)byte_4A2DDC);
  v18 = websGetVar(a1, (int)"CameraName", (int)byte_4A2DDC);
  v6 = strdupWithoutNull(v3);
  v7 = strdupWithoutNull(v4);
  v8 = strdupWithoutNull(v5);
  v9 = 0;
  if ( websTestVar(a1, (int)"ConfigReboot") )
  {
    v11 = websGetVar(a1, (int)"ConfigReboot", (int)byte_4A2DDC);
    if ( !strcasecmp(v11, "Yes") )
    {
      v2 = 1;
      v9 = 3;
    }
    else if ( !strcasecmp(v11, "No") )
    {
      v2 = 1;
    }
  }
  if ( !v15 && v2 )
  {
    v12 = OSDTimeChanged(a1);
    WriteSystemVar(a1);
    nvram_commit(0);
    if ( v6 && Var && strcmp(v6, Var) || v7 && v17 && strcmp(v7, v17) )
    {
      if ( !Var || (v13 = strcmp(Var, &word_4A0308), v14 = websEnableAllUser, v13) )
        v14 = websDisableAllUser;
      v14();
    }
    if ( v12 || v8 && v18 && strcmp(v8, v18) )
      doSystem((int)"cameraname.sh &");
    if ( v9 > 0 )
      *(_DWORD *)(a1 + 288) = 3;
  }
  if ( v6 )
    free2(v6);
  if ( v7 )
    free2(v7);
  if ( v8 )
    free2(v8);
  return websetReplayPage(a1, v15, "ReplySuccessPage", "ReplyErrorPage");
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00431708) --------------------------------------------------------
int *  sub_431708(int a1)
{
  BOOL v2; // $s3
  int v3; // $s0
  char *v5; // $v0
  char *ErrorMessage; // $v0
  char *v7; // $s2
  int v8; // $s0
  int v9; // $v0
  int v10; // $s3
  int v11; // $v0
  int v12; // $v0
  char *v13; // $v0
  char *v14; // $v0
  char *v15; // [sp+18h] [-18h] BYREF
  char *v16; // [sp+1Ch] [-14h] BYREF
  char *v17; // [sp+20h] [-10h] BYREF
  int v18; // [sp+24h] [-Ch] BYREF
  int v19; // [sp+28h] [-8h] BYREF

  if ( websTestVar(a1, (int)"UserPassword") )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v7 = (char *)allocDecodePasswordByName(a1, (int)"UserPassword");
      websSetVar(a1, "UserPassword", v7);
      if ( v7 )
        free2(v7);
    }
  }
  v2 = websTestVarValue(a1, (int)"UserAdd", (int)"Yes");
  v3 = 0;
  if ( !websConfigGetFromVar(a1, (int)"UserName", byte_4A2DDC, &v15) )
  {
    ErrorMessage = (char *)websGetErrorMessage(46);
    webAddReplyMessage(a1, ErrorMessage, 1);
    v3 = -1;
  }
  if ( !websConfigGetFromVar(a1, (int)"UserPassword", byte_4A2DDC, &v16) )
  {
    v5 = (char *)websGetErrorMessage(47);
    webAddReplyMessage(a1, v5, 1);
    v3 = -1;
  }
  websConfigGetFromVar(a1, (int)"UserPrivilege", (char *)&word_4A0308, &v17);
  if ( !v3 )
  {
    if ( v2 )
    {
      v8 = websGetVarCheck(a1, "UserName", &v18);
      v3 = v8 | websGetVarCheck(a1, "UserPassword", &v19);
      if ( !v3 )
      {
        v9 = websAddUser((int)v15, (int)v16, (int)v17);
        v10 = v9;
        if ( v9 < 0 )
        {
          if ( v9 == -2 )
          {
            v14 = (char *)websGetErrorMessage(48);
            webAddReplyMessage(a1, v14, 0);
          }
          if ( v10 == -1 )
          {
            v13 = (char *)websGetErrorMessage(6);
            webAddReplyMessage(a1, v13, 0);
          }
          v3 = 1;
        }
        else
        {
          v11 = nvram_bufget(0, "AccessControlEnable");
          if ( !strcmp(v11, &word_4A0308) )
          {
            v12 = atoi(v17);
            umAddUser(v15, v16, v12);
          }
        }
      }
    }
  }
  return websetReplayPage(a1, v3, "ReplySuccessPage", "ReplyErrorPage");
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00431A80) --------------------------------------------------------
int *  sub_431A80(int a1)
{
  BOOL v2; // $s4
  int v3; // $s3
  int v5; // $s0
  int v6; // $v0
  char *v7; // [sp+18h] [-10h] BYREF
  int v8; // [sp+1Ch] [-Ch] BYREF
  int v9; // [sp+20h] [-8h] BYREF

  v2 = websTestVarValue(a1, (int)"UserDelete", (int)"Yes");
  v3 = 0;
  if ( websTestVar(a1, (int)"HexUserName") && !websTestVar(a1, (int)"UserName") )
    copyStringHexVar(a1, "UserName", (int)"HexUserName", (int)byte_4A2DDC);
  if ( websConfigGetFromVar(a1, (int)"UserName", byte_4A2DDC, &v7) )
  {
    if ( v2 )
    {
      v5 = websGetVarCheck(a1, "UserName", &v8);
      v3 = v5 | websGetVarCheck(a1, "UserPassword", &v9);
      if ( !v3 )
      {
        v3 = websDeleteUser((int)v7);
        if ( !v3 )
        {
          v6 = nvram_bufget(0, "AccessControlEnable");
          if ( !strcmp(v6, &word_4A0308) )
            umDelUser((int)v7);
        }
      }
    }
  }
  else
  {
    v3 = -1;
  }
  return websetReplayPage(a1, v3, "ReplySuccessPage", "ReplyErrorPage");
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00431C74) --------------------------------------------------------
int *  sub_431C74(int a1)
{
  int v2; // $s3
  int v3; // $s1
  int v4; // $s0
  int v5; // $s0
  int v6; // $s0
  int v7; // $s0
  int v8; // $s4
  int v9; // $s1
  int v10; // $s4
  int Var; // $s0
  char *v13; // $s1
  char *v14; // $s1
  int v15; // $s5
  int v16; // $s3
  int v17; // [sp+18h] [-18h] BYREF
  int v18; // [sp+1Ch] [-14h] BYREF
  int v19; // [sp+20h] [-10h] BYREF
  int v20; // [sp+24h] [-Ch] BYREF
  int v21; // [sp+28h] [-8h] BYREF
  int v22; // [sp+2Ch] [-4h] BYREF

  if ( websTestVar(a1, (int)"PPPoEPassword") )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v14 = (char *)allocDecodePasswordByName(a1, (int)"PPPoEPassword");
      websSetVar(a1, "PPPoEPassword", v14);
      if ( v14 )
        free2(v14);
    }
  }
  if ( websTestVar(a1, (int)"DDNSPassword") )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v13 = (char *)allocDecodePasswordByName(a1, (int)"DDNSPassword");
      websSetVar(a1, "DDNSPassword", v13);
      if ( v13 )
        free2(v13);
    }
  }
  v2 = websTestVar(a1, (int)"ConfigSystemNetwork");
  v3 = CheckNetworkVar(a1);
  v4 = websGetVarCheck(a1, "DDNSEnable", &v17);
  v5 = v4 | websGetVarCheck(a1, "DDNSProvider", &v18);
  v6 = v5 | websGetVarCheck(a1, "DDNSHostName", &v19);
  v7 = v6 | websGetVarCheck(a1, "DDNSUserName", &v20);
  v8 = v7 | websGetVarCheck(a1, "DDNSPassword", &v21);
  v9 = v3 | v8 | websGetVarCheck(a1, "DDNSTimeout", &v22);
  v10 = 0;
  if ( websTestVar(a1, (int)"ConfigReboot") )
  {
    Var = websGetVar(a1, (int)"ConfigReboot", (int)byte_4A2DDC);
    if ( !strcasecmp(Var, "Yes") )
    {
      v2 = 1;
      v10 = 3;
    }
    else if ( !strcasecmp(Var, "No") )
    {
      v2 = 1;
    }
  }
  if ( v9 || !v2 )
    return websetReplayPage(a1, v9, "ReplySuccessPage", "ReplyErrorPage");
  v15 = SystemNetworkChanged(a1);
  v16 = SystemDDNSChanged(a1);
  WriteNetworkVar(a1);
  nvram_commit(0);
  if ( v15 )
  {
    doSystem((int)"sleep 3 && lan.sh &");
    trace(1, (int)"Network settings was changed!\n");
  }
  else if ( v16 )
  {
    doSystem((int)"sleep 3 && ddns.sh &");
    trace(1, (int)"DDNS settings was changed!\n");
  }
  if ( v10 <= 0 )
    return websetReplayPage(a1, v9, "ReplySuccessPage", "ReplyErrorPage");
  *(_DWORD *)(a1 + 288) = 3;
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);

//----- (004320E8) --------------------------------------------------------
int *  sub_4320E8(int a1)
{
  int v2; // $s2
  int v3; // $s7
  int v4; // $s6
  void *v5; // $s0
  int Var; // $s5
  int v7; // $s3
  int v9; // $s0
  char *v10; // $s2
  char *v11; // $s2
  char *v12; // $s2
  char *v13; // $s2
  char *v14; // $s2
  char *v15; // $s2
  char *v16; // $s2
  int v17; // $s0
  _BOOL2 v18; // $a1
  char *v19; // $s0
  int v20; // [sp+18h] [-8h]
  BOOL v21; // [sp+1Ch] [-4h]

  if ( websTestVar(a1, (int)"Key1") )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v16 = (char *)allocDecodePasswordByName(a1, (int)"Key1");
      websSetVar(a1, "Key1", v16);
      if ( v16 )
        free2(v16);
    }
  }
  if ( websTestVar(a1, (int)"Key2") )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v15 = (char *)allocDecodePasswordByName(a1, (int)"Key2");
      websSetVar(a1, "Key2", v15);
      if ( v15 )
        free2(v15);
    }
  }
  if ( websTestVar(a1, (int)"Key3") )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v14 = (char *)allocDecodePasswordByName(a1, (int)"Key3");
      websSetVar(a1, "Key3", v14);
      if ( v14 )
        free2(v14);
    }
  }
  if ( websTestVar(a1, (int)"Key4") )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v13 = (char *)allocDecodePasswordByName(a1, (int)"Key4");
      websSetVar(a1, "Key4", v13);
      if ( v13 )
        free2(v13);
    }
  }
  if ( websTestVar(a1, (int)"APKey1") )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v12 = (char *)allocDecodePasswordByName(a1, (int)"APKey1");
      websSetVar(a1, "APKey1", v12);
      if ( v12 )
        free2(v12);
    }
  }
  if ( websTestVar(a1, (int)"APPreSharedKey") )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v11 = (char *)allocDecodePasswordByName(a1, (int)"APPreSharedKey");
      websSetVar(a1, "APPreSharedKey", v11);
      if ( v11 )
        free2(v11);
    }
  }
  if ( websTestVar(a1, (int)"PreSharedKey") )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v10 = (char *)allocDecodePasswordByName(a1, (int)"PreSharedKey");
      websSetVar(a1, "PreSharedKey", v10);
      if ( v10 )
        free2(v10);
    }
  }
  v2 = websTestVar(a1, (int)"ConfigSystemWireless");
  v20 = 0;
  v21 = 0;
  if ( v2 )
    v21 = websTestVar(a1, (int)"WirelessDisable") != 0;
  v3 = websTestVar(a1, (int)"APEnable");
  v4 = CheckWirelessVar(a1);
  v5 = (void *)nvram_bufget(0, "WirelessDisable");
  Var = websGetVar(a1, (int)"WirelessDisable", (int)byte_4A2DDC);
  v7 = strdupWithoutNull(v5);
  if ( websTestVar(a1, (int)"ConfigReboot") )
  {
    v9 = websGetVar(a1, (int)"ConfigReboot", (int)byte_4A2DDC);
    if ( !strcasecmp(v9, "Yes") )
    {
      v2 = 1;
      v20 = 3;
    }
    else if ( !strcasecmp(v9, "No") )
    {
      v2 = 1;
    }
  }
  if ( !v4 && v2 )
  {
    v17 = SystemWirelessChanged(a1);
    WriteWirelessVar(a1);
    if ( v17 )
      nvram_bufset(0, "WirelessEverLinkOK", &word_4A0308);
    nvram_commit(0);
    if ( v17 )
    {
      if ( v7 && Var && strcmp(v7, Var) )
      {
        v18 = strcmp(Var, &word_4A0308) != 0;
        setSysInfoShort(45, v18);
      }
      trace(1, (int)"set EVENT_WLAN_ENABLE!\n");
      setSysInfoShort(149, !v21);
      setSysInfoLong(57, 0x40000000);
      trace(1, (int)"Wireless settings was changed!\n");
    }
    if ( v3 )
    {
      v19 = (char *)websGetVar(a1, (int)"APEnable", (int)&word_4A0308);
      trace(1, (int)"APEnable was setted(%s)!\n", v19);
      if ( v19 )
      {
        if ( !strcmp(v19, &word_4A0308) )
        {
          doSystem((int)"sleep 3 && gpio ap 0 &");
        }
        else if ( !strcmp(v19, "1") )
        {
          doSystem((int)"sleep 3 && gpio ap 1 &");
        }
      }
    }
    doSystem((int)"sleep 3 && wlan.sh &");
    if ( v20 > 0 )
      *(_DWORD *)(a1 + 288) = 3;
  }
  if ( v7 )
    free2(v7);
  return websetReplayPage(a1, v4, "ReplySuccessPage", "ReplyErrorPage");
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00432984) --------------------------------------------------------
int *  sub_432984(int a1)
{
  int v2; // $s1
  int v3; // $s5
  int v4; // $a0
  int Var; // $s0
  int v7; // $s7
  int v8; // $s2
  int v9; // $s6
  int v10; // $s0
  int v11; // $s1
  int v12; // $fp
  int v13; // $s6
  int v14; // $v0
  int v15; // $s0
  BOOL v16; // $s4
  int v17; // $v0
  int v18; // $s1
  BOOL v19; // $s0
  int v20; // $v0
  unsigned __int16 v21; // $v0
  int v22; // $v0
  unsigned __int16 v23; // $v0
  int v24; // $v0
  unsigned __int16 v25; // $v0
  int v26; // $v0
  unsigned __int16 v27; // $v0
  int v28; // $v0
  unsigned __int16 v29; // $v0
  int v30; // $v0
  unsigned __int16 v31; // $v0
  _DWORD v32[2]; // [sp+18h] [-18h] BYREF
  __int16 v33; // [sp+20h] [-10h] BYREF
  __int16 v34; // [sp+22h] [-Eh]
  __int16 v35; // [sp+24h] [-Ch]
  int v36; // [sp+28h] [-8h]

  v2 = websTestVar(a1, (int)"ConfigSystemStream");
  v36 = 0;
  v3 = CheckStreamVar(a1);
  if ( websTestVar(a1, (int)"ConfigReboot") )
  {
    Var = websGetVar(a1, (int)"ConfigReboot", (int)byte_4A2DDC);
    if ( !strcasecmp(Var, "Yes") )
    {
      v2 = 1;
      v36 = 3;
    }
    else if ( !strcasecmp(Var, "No") )
    {
      v2 = 1;
    }
  }
  v4 = a1;
  if ( v3 )
    return websetReplayPage(v4, v3, "ReplySuccessPage", "ReplyErrorPage");
  if ( !v2 )
    goto LABEL_4;
  v7 = StreamImageChanged(a1);
  v8 = nvram_bufget(0, "AudioEnable");
  v9 = nvram_bufget(0, "AudioVolume");
  v10 = websGetVar(a1, (int)"AudioEnable", (int)byte_4A2DDC);
  v11 = websGetVar(a1, (int)"AudioVolume", (int)byte_4A2DDC);
  v12 = 0;
  if ( strcmp(v8, v10) || strcmp(v9, v11) )
    v12 = 1;
  v13 = StreamVideoChanged(a1);
  v15 = nvram_bufget(0, "VideoResolution");
  v14 = websGetVar(a1, (int)"VideoResolution", (int)byte_4A2DDC);
  v16 = strcmp(v15, v14) != 0;
  v18 = nvram_bufget(0, "VideoResolution264");
  v17 = websGetVar(a1, (int)"VideoResolution264", (int)byte_4A2DDC);
  v19 = strcmp(v18, v17) != 0;
  WriteStreamVar(a1);
  nvram_commit(0);
  if ( v7 )
  {
    setSysInfoLong(57, 16);
    trace(1, (int)"Image settings was changed!\n");
  }
  if ( v12 )
  {
    v32[0] = 0;
    v32[1] = 0;
    setSysInfoBuffer(94, (int)v32, 1);
    setSysInfoLong(57, 32);
    trace(1, (int)"Audio settings was changed!\n");
  }
  if ( v13 )
  {
    if ( v16 )
    {
      v26 = nvram_bufget(0, "VideoResolution");
      v27 = atoi(v26);
      if ( v27 < 3u )
        v33 = v27;
      else
        v33 = 1;
      v28 = nvram_bufget(0, "CompressionRate");
      v29 = atoi(v28);
      if ( v29 < 5u )
        v34 = v29;
      else
        v34 = 2;
      v30 = nvram_bufget(0, "FrameRate");
      v31 = atoi(v30);
      if ( v31 < 0x1Fu )
        v35 = v31;
      else
        v35 = 0;
      setSysInfoBuffer(17, (int)&v33, 6);
    }
    if ( v19 )
    {
      v20 = nvram_bufget(0, "VideoResolution264");
      v21 = atoi(v20);
      if ( v21 < 3u )
        v33 = v21;
      else
        v33 = 1;
      v22 = nvram_bufget(0, "BitRate264");
      v23 = atoi(v22);
      if ( v23 < 0xBu )
        v34 = v23;
      else
        v34 = 8;
      v24 = nvram_bufget(0, "FrameRate264");
      v25 = atoi(v24);
      if ( v25 < 0x1Fu )
        v35 = v25;
      else
        v35 = 10;
      setSysInfoBuffer(86, (int)&v33, 6);
    }
    setSysInfoLong(57, 64);
    setSysInfoLong(57, 128);
    setSysInfoLong(57, 256);
    doSystem((int)"video.sh &");
    trace(1, (int)"Video settings was changed!\n");
  }
  if ( v36 <= 0 )
  {
LABEL_4:
    v4 = a1;
    return websetReplayPage(v4, v3, "ReplySuccessPage", "ReplyErrorPage");
  }
  *(_DWORD *)(a1 + 288) = 3;
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00433054) --------------------------------------------------------
int *  sub_433054(int a1)
{
  int v2; // $s1
  int v3; // $s0
  int v4; // $s5
  int v5; // $a0
  int Var; // $s0
  int v8; // $s6
  int v9; // $s2
  int v10; // $s4
  int v11; // $s7
  int v12; // $v0
  int v13; // $s1
  int v14; // $s7
  int v15; // $s4
  int v16; // $v0
  int v17; // $s1
  int v18; // $v0
  int v19; // $s1
  BOOL v20; // $s0
  int v21; // $v0
  __int16 v22; // $v0
  int v23; // $v0
  unsigned __int16 v24; // $v0
  int v25; // $v0
  unsigned __int16 v26; // $v0
  int v27; // $v0
  unsigned __int16 v28; // $v0
  int v29; // $v0
  unsigned __int16 v30; // $v0
  int v31; // $v0
  unsigned __int16 v32; // $v0
  int v33; // $v0
  unsigned __int16 v34; // $v0
  _DWORD v35[2]; // [sp+18h] [-20h] BYREF
  __int16 v36; // [sp+20h] [-18h] BYREF
  __int16 v37; // [sp+22h] [-16h]
  __int16 v38; // [sp+24h] [-14h]
  int v39; // [sp+28h] [-10h]
  int v40; // [sp+2Ch] [-Ch]
  BOOL v41; // [sp+30h] [-8h]

  v2 = websTestVar(a1, (int)"ConfigDayNightStream");
  v39 = 0;
  v3 = CheckStreamVar(a1);
  v4 = v3 | CheckDayNightVar(a1);
  if ( websTestVar(a1, (int)"ConfigReboot") )
  {
    Var = websGetVar(a1, (int)"ConfigReboot", (int)byte_4A2DDC);
    if ( !strcasecmp(Var, "Yes") )
    {
      v2 = 1;
      v39 = 3;
    }
    else if ( !strcasecmp(Var, "No") )
    {
      v2 = 1;
    }
  }
  v5 = a1;
  if ( v4 )
    return websetReplayPage(v5, v4, "ReplySuccessPage", "ReplyErrorPage");
  if ( !v2 )
    goto LABEL_4;
  v8 = StreamImageChanged(a1);
  v9 = nvram_bufget(0, "AudioEnable");
  v10 = nvram_bufget(0, "AudioVolume");
  v11 = websGetVar(a1, (int)"AudioEnable", (int)byte_4A2DDC);
  v13 = websGetVar(a1, (int)"AudioVolume", (int)byte_4A2DDC);
  v12 = strcmp(v9, v11);
  v14 = 0;
  if ( v12 || strcmp(v10, v13) )
    v14 = 1;
  v15 = StreamVideoChanged(a1);
  v40 = SystemDayNightChanged(a1);
  v17 = nvram_bufget(0, "VideoResolution");
  v16 = websGetVar(a1, (int)"VideoResolution", (int)byte_4A2DDC);
  v41 = strcmp(v17, v16) != 0;
  v19 = nvram_bufget(0, "VideoResolution264");
  v18 = websGetVar(a1, (int)"VideoResolution264", (int)byte_4A2DDC);
  v20 = strcmp(v19, v18) != 0;
  WriteStreamVar(a1);
  WriteDayNightVar(a1);
  nvram_commit(0);
  if ( v8 )
  {
    setSysInfoLong(57, 16);
    trace(1, (int)"Image settings was changed!\n");
  }
  if ( v14 )
  {
    v35[0] = 0;
    v35[1] = 0;
    setSysInfoBuffer(94, (int)v35, 1);
    setSysInfoLong(57, 32);
    trace(1, (int)"Audio settings was changed!\n");
  }
  if ( v15 )
  {
    if ( v41 )
    {
      v29 = nvram_bufget(0, "VideoResolution");
      v30 = atoi(v29);
      if ( v30 < 3u )
        v36 = v30;
      else
        v36 = 1;
      v31 = nvram_bufget(0, "CompressionRate");
      v32 = atoi(v31);
      if ( v32 < 5u )
        v37 = v32;
      else
        v37 = 2;
      v33 = nvram_bufget(0, "FrameRate");
      v34 = atoi(v33);
      if ( v34 < 0x1Fu )
        v38 = v34;
      else
        v38 = 0;
      setSysInfoBuffer(17, (int)&v36, 6);
    }
    if ( v20 )
    {
      v23 = nvram_bufget(0, "VideoResolution264");
      v24 = atoi(v23);
      if ( v24 < 3u )
        v36 = v24;
      else
        v36 = 1;
      v25 = nvram_bufget(0, "BitRate264");
      v26 = atoi(v25);
      if ( v26 < 0xBu )
        v37 = v26;
      else
        v37 = 8;
      v27 = nvram_bufget(0, "FrameRate264");
      v28 = atoi(v27);
      if ( v28 < 0x1Fu )
        v38 = v28;
      else
        v38 = 10;
      setSysInfoBuffer(86, (int)&v36, 6);
    }
    setSysInfoLong(57, 64);
    setSysInfoLong(57, 128);
    setSysInfoLong(57, 256);
    doSystem((int)"video.sh &");
    trace(1, (int)"Video settings was changed!\n");
  }
  if ( v40 )
  {
    v21 = websGetVar(a1, (int)"DayNightMode", (int)byte_4A2DDC);
    v22 = atoi(v21);
    setSysInfoShort(73, v22);
    setSysInfoLong(57, 0x400000);
    trace(1, (int)"DayNightMode settings was changed!\n");
  }
  if ( v39 <= 0 )
  {
LABEL_4:
    v5 = a1;
    return websetReplayPage(v5, v4, "ReplySuccessPage", "ReplyErrorPage");
  }
  *(_DWORD *)(a1 + 288) = 3;
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00433804) --------------------------------------------------------
int *  sub_433804(int a1)
{
  int v2; // $s0
  int v3; // $s3
  int v4; // $a0
  int v6; // $s6
  int v7; // $s7
  int Var; // $v0
  int v9; // $s0
  BOOL v10; // $fp
  int v11; // $v0
  int v12; // $s1
  BOOL v13; // $s0
  int v14; // $v0
  unsigned __int16 v15; // $v0
  int v16; // $v0
  unsigned __int16 v17; // $v0
  int v18; // $v0
  unsigned __int16 v19; // $v0
  int v20; // $v0
  unsigned __int16 v21; // $v0
  int v22; // $v0
  unsigned __int16 v23; // $v0
  int v24; // $v0
  unsigned __int16 v25; // $v0
  __int16 v26; // [sp+18h] [-8h] BYREF
  __int16 v27; // [sp+1Ah] [-6h]
  __int16 v28; // [sp+1Ch] [-4h]

  v2 = websTestVar(a1, (int)"ConfigVideo");
  v3 = CheckStreamVar(a1);
  if ( v3 || !v2 )
    goto LABEL_3;
  v6 = StreamImageChanged(a1);
  v7 = StreamVideoChanged(a1);
  v9 = nvram_bufget(0, "VideoResolution");
  Var = websGetVar(a1, (int)"VideoResolution", (int)byte_4A2DDC);
  v10 = strcmp(v9, Var) != 0;
  v12 = nvram_bufget(0, "VideoResolution264");
  v11 = websGetVar(a1, (int)"VideoResolution264", (int)byte_4A2DDC);
  v13 = strcmp(v12, v11) != 0;
  WriteStreamVar(a1);
  nvram_commit(0);
  if ( v6 )
  {
    setSysInfoLong(57, 16);
    trace(1, (int)"Image settings was changed!\n");
  }
  if ( v7 )
  {
    if ( v10 )
    {
      v20 = nvram_bufget(0, "VideoResolution");
      v21 = atoi(v20);
      if ( v21 < 3u )
        v26 = v21;
      else
        v26 = 1;
      v22 = nvram_bufget(0, "CompressionRate");
      v23 = atoi(v22);
      if ( v23 < 5u )
        v27 = v23;
      else
        v27 = 2;
      v24 = nvram_bufget(0, "FrameRate");
      v25 = atoi(v24);
      if ( v25 < 0x1Fu )
        v28 = v25;
      else
        v28 = 0;
      setSysInfoBuffer(17, (int)&v26, 6);
    }
    if ( v13 )
    {
      v14 = nvram_bufget(0, "VideoResolution264");
      v15 = atoi(v14);
      if ( v15 < 3u )
        v26 = v15;
      else
        v26 = 1;
      v16 = nvram_bufget(0, "BitRate264");
      v17 = atoi(v16);
      if ( v17 < 0xBu )
        v27 = v17;
      else
        v27 = 8;
      v18 = nvram_bufget(0, "FrameRate264");
      v19 = atoi(v18);
      if ( v19 < 0x1Fu )
        v28 = v19;
      else
        v28 = 10;
      setSysInfoBuffer(86, (int)&v26, 6);
    }
    setSysInfoLong(57, 64);
    setSysInfoLong(57, 128);
    setSysInfoLong(57, 256);
    doSystem((int)"video.sh &");
    trace(1, (int)"Video settings was changed!\n");
    v4 = a1;
  }
  else
  {
LABEL_3:
    v4 = a1;
  }
  return websetReplayPage(v4, v3, "ReplySuccessPage", "ReplyErrorPage");
}
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00433CD0) --------------------------------------------------------
int *  sub_433CD0(int a1)
{
  int v2; // $s1
  int v3; // $s3
  int v4; // $s4
  int v5; // $a0
  int Var; // $s0
  char *v8; // $s1
  int v9; // $s0
  int v10; // $s1
  int v11; // $s6
  int v12; // $s7
  int v13; // $fp
  int v14; // $s0

  if ( websTestVar(a1, (int)"EmailPassword") )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v8 = (char *)allocDecodePasswordByName(a1, (int)"EmailPassword");
      websSetVar(a1, "EmailPassword", v8);
      if ( v8 )
        free2(v8);
    }
  }
  v2 = websTestVar(a1, (int)"ConfigSystemEmail");
  v3 = CheckEmailVar(a1);
  v4 = 0;
  if ( websTestVar(a1, (int)"ConfigReboot") )
  {
    Var = websGetVar(a1, (int)"ConfigReboot", (int)byte_4A2DDC);
    if ( !strcasecmp(Var, "Yes") )
    {
      v2 = 1;
      v4 = 3;
    }
    else if ( !strcasecmp(Var, "No") )
    {
      v2 = 1;
    }
  }
  v5 = a1;
  if ( v3 )
    return websetReplayPage(v5, v3, "ReplySuccessPage", "ReplyErrorPage");
  if ( !v2 )
    goto LABEL_5;
  v9 = SystemEmailChanged(a1);
  WriteEmailVar(a1);
  nvram_commit(0);
  if ( v9 )
  {
    v10 = websGetVar(a1, (int)"EmailScheduleEnable", (int)byte_4A2DDC);
    v11 = websGetVar(a1, (int)"EmailScheduleMode", (int)byte_4A2DDC);
    v12 = websGetVar(a1, (int)"EmailMotionMode", (int)byte_4A2DDC);
    v13 = websGetVar(a1, (int)"EmailMotionFrameInterval", (int)byte_4A2DDC);
    v14 = 0;
    if ( !strcmp(v10, "1") && !strcmp(v11, "2") && !strcmp(v12, "1") )
      v14 = (strcmp(v13, &word_4A0308) != 0) + 1;
    setSysInfoShort(76, v14);
    trace(1, (int)"SET_EMAIL_FRAME_TIME=%d\n", v14);
    setSysInfoLong(57, 2);
    trace(1, (int)"Email settings was changed!\n");
  }
  if ( v4 <= 0 )
  {
LABEL_5:
    v5 = a1;
    return websetReplayPage(v5, v3, "ReplySuccessPage", "ReplyErrorPage");
  }
  *(_DWORD *)(a1 + 288) = 3;
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);

//----- (004340E4) --------------------------------------------------------
int *  sub_4340E4(int a1)
{
  int v2; // $s2
  int v3; // $s3
  int v4; // $s4
  int Var; // $s0
  char *v7; // $s2
  int v8; // $s0

  if ( websTestVar(a1, (int)"FTPPassword") )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v7 = (char *)allocDecodePasswordByName(a1, (int)"FTPPassword");
      websSetVar(a1, "FTPPassword", v7);
      if ( v7 )
        free2(v7);
    }
  }
  v2 = websTestVar(a1, (int)"ConfigSystemFTP");
  v3 = CheckFTPVar(a1);
  v4 = 0;
  if ( websTestVar(a1, (int)"ConfigReboot") )
  {
    Var = websGetVar(a1, (int)"ConfigReboot", (int)byte_4A2DDC);
    if ( !strcasecmp(Var, "Yes") )
    {
      v2 = 1;
      v4 = 3;
    }
    else if ( !strcasecmp(Var, "No") )
    {
      v2 = 1;
    }
  }
  if ( v3 || !v2 )
    return websetReplayPage(a1, v3, "ReplySuccessPage", "ReplyErrorPage");
  v8 = SystemFTPChanged(a1);
  WriteFTPVar(a1);
  nvram_commit(0);
  if ( v8 )
  {
    setSysInfoLong(57, 1);
    trace(1, (int)"FTP settings was changed!\n");
  }
  if ( v4 <= 0 )
    return websetReplayPage(a1, v3, "ReplySuccessPage", "ReplyErrorPage");
  *(_DWORD *)(a1 + 288) = 3;
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);

//----- (00434394) --------------------------------------------------------
int *  sub_434394(int a1)
{
  int v2; // $s1
  int v3; // $s5
  int Var; // $s3
  int v5; // $s6
  int v6; // $a0
  int v8; // $s0
  int v9; // $s7
  int v10; // $s0
  int v11; // $s1
  int v12; // $s3
  int v13; // $v0
  _DWORD v14[3]; // [sp+18h] [-28h] BYREF
  _DWORD v15[5]; // [sp+24h] [-1Ch] BYREF
  int v16; // [sp+38h] [-8h] BYREF

  v2 = websTestVar(a1, (int)"ConfigSystemDate");
  v3 = CheckDateVar(a1);
  Var = websGetVar(a1, (int)"DateTimeMode", (int)byte_4A2DDC);
  v5 = 0;
  if ( websTestVar(a1, (int)"ConfigReboot") )
  {
    v8 = websGetVar(a1, (int)"ConfigReboot", (int)byte_4A2DDC);
    if ( !strcasecmp(v8, "Yes") )
    {
      v2 = 1;
      v5 = 3;
    }
    else if ( !strcasecmp(v8, "No") )
    {
      v2 = 1;
    }
  }
  v6 = a1;
  if ( v3 )
    return websetReplayPage(v6, v3, "ReplySuccessPage", "ReplyErrorPage");
  if ( !v2 )
    goto LABEL_4;
  v9 = SystemDateChanged(a1);
  WriteDateVar(a1);
  nvram_commit(0);
  if ( Var && !strcmp(Var, "1") )
  {
    v10 = websGetVar(a1, (int)"Date", (int)byte_4A2DDC);
    v11 = websGetVar(a1, (int)"Time", (int)byte_4A2DDC);
    qmemcpy(v15, "17482009", 8);
    qmemcpy(v14, "date -s 1007", sizeof(v14));
    memset(&v15[2], 0, 12);
    v12 = websGetVar(a1, (int)"TimeZone", (int)byte_4A2DDC);
    LOWORD(v14[2]) = *(_WORD *)(v10 + 5);
    HIWORD(v14[2]) = *(_WORD *)(v10 + 8);
    LOWORD(v15[0]) = *(_WORD *)v11;
    HIWORD(v15[0]) = *(_WORD *)(v11 + 3);
    v15[1] = *(_DWORD *)v10;
    websTimeoutCancel(a1);
    doSystem((int)v14);
    snprintf(v14, 32, "date -s %s", (char *)v11);
    doSystem((int)v14);
    v16 = -16;
    gettimeofday(&v16, 0);
    v13 = atol(v12);
    v16 -= 60 * v13;
    setSysInfoBuffer(109, (int)&v16, 8);
    Sleep(1);
    *(_DWORD *)(a1 + 236) = websTimeoutSched(60, (int)websTimeout, a1);
  }
  if ( v9 )
  {
    doSystem((int)"ntp.sh &");
    trace(1, (int)"DateTime settings was changed!\n");
  }
  if ( v5 <= 0 )
  {
LABEL_4:
    v6 = a1;
    return websetReplayPage(v6, v3, "ReplySuccessPage", "ReplyErrorPage");
  }
  *(_DWORD *)(a1 + 288) = 3;
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FAC: using guessed type int   gettimeofday(_DWORD, _DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);
// 4EA09C: using guessed type int   atol(_DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (00434838) --------------------------------------------------------
int *  sub_434838(int a1)
{
  char *v2; // $s0
  char *v3; // $s5
  int v4; // $s1
  int v6; // $s3
  int v7; // $s4
  int v8; // $s0
  int Var; // $s0
  char *v10; // $v0
  char *v11; // $s0
  int v12; // $v1
  int v13; // $v0

  if ( !websTestVar(a1, (int)"ConfigTemp") )
  {
    v6 = websTestVar(a1, (int)"ConfigSystemMotion");
    v4 = CheckMotionVar(a1);
    v7 = 0;
    if ( websTestVar(a1, (int)"ConfigReboot") )
    {
      Var = websGetVar(a1, (int)"ConfigReboot", (int)byte_4A2DDC);
      if ( !strcasecmp(Var, "Yes") )
      {
        v6 = 1;
        v7 = 3;
      }
      else if ( !strcasecmp(Var, "No") )
      {
        v6 = 1;
      }
    }
    if ( !v4 && v6 )
    {
      v8 = SystemMotionChanged(a1);
      WriteMotionVar(a1);
      nvram_commit(0);
      if ( v8 )
      {
        setSysInfoLong(57, 0x4000);
        trace(1, (int)"Motion Detection settings was changed!\n");
      }
      if ( v7 > 0 )
        *(_DWORD *)(a1 + 288) = 3;
    }
    return websetReplayPage(a1, v4, "ReplySuccessPage", "ReplyErrorPage");
  }
  v2 = (char *)websGetVar(a1, (int)"MotionDetectionBlockSet", (int)byte_4A2DDC);
  v3 = (char *)websGetVar(a1, (int)"ConfigTemp", (int)byte_4A2DDC);
  trace(1, (int)"MotionDetectionBlockSet:%s\n", v2);
  if ( (unsigned int)strlen(v2) >= 0x1B )
  {
    v10 = (char *)strdupWithoutNull(v2);
    v11 = v10;
    if ( v10 )
    {
      v12 = v10[25];
      if ( v12 == 13 || v12 == 10 )
      {
        v10[25] = 0;
        websSetVar(a1, "MotionDetectionBlockSet", v10);
      }
      if ( v11 )
        free2(v11);
    }
  }
  v4 = CheckMotionVar(a1);
  if ( v4 )
    return websetReplayPage(a1, v4, "ReplySuccessPage", "ReplyErrorPage");
  v13 = websGetVar(a1, (int)"MotionDetectionBlockSet", (int)byte_4A2DDC);
  strcpy(aXxxxxxxxxxxxxx_0, v13);
  trace(1, (int)"TempMotionDetectionBlockSet settings was changed by %s!\n", v3);
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);
// 4EA0C8: using guessed type int   strcpy(_DWORD, _DWORD);

//----- (00434BE4) --------------------------------------------------------
int *  sub_434BE4(int a1)
{
  int v2; // $s1
  int v3; // $s3
  int v4; // $s4
  int Var; // $s0
  int v7; // $s0
  int v8; // $v0
  __int16 v9; // $v0

  v2 = websTestVar(a1, (int)"ConfigDayNightMode");
  v3 = CheckDayNightVar(a1);
  v4 = 0;
  if ( websTestVar(a1, (int)"ConfigReboot") )
  {
    Var = websGetVar(a1, (int)"ConfigReboot", (int)byte_4A2DDC);
    if ( !strcasecmp(Var, "Yes") )
    {
      v2 = 1;
      v4 = 3;
    }
    else if ( !strcasecmp(Var, "No") )
    {
      v2 = 1;
    }
  }
  if ( v3 || !v2 )
    return websetReplayPage(a1, v3, "ReplySuccessPage", "ReplyErrorPage");
  v7 = SystemDayNightChanged(a1);
  WriteDayNightVar(a1);
  nvram_commit(0);
  if ( v7 )
  {
    v8 = websGetVar(a1, (int)"DayNightMode", (int)byte_4A2DDC);
    v9 = atoi(v8);
    setSysInfoShort(73, v9);
    setSysInfoLong(57, 0x400000);
    trace(1, (int)"DayNightMode settings was changed!\n");
  }
  if ( v4 <= 0 )
    return websetReplayPage(a1, v3, "ReplySuccessPage", "ReplyErrorPage");
  *(_DWORD *)(a1 + 288) = 3;
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);

//----- (00434E50) --------------------------------------------------------
int *  sub_434E50(int a1)
{
  int v2; // $s4
  int v3; // $s0
  int v4; // $s5
  int v5; // $s3
  int v6; // $s2
  int v7; // $s0
  int v8; // $s3
  int v9; // $s5
  int Var; // $s0
  int v12; // $s4
  int v13; // [sp+18h] [-18h] BYREF
  int v14; // [sp+1Ch] [-14h] BYREF
  int v15; // [sp+20h] [-10h] BYREF
  int v16; // [sp+24h] [-Ch] BYREF
  int v17; // [sp+28h] [-8h] BYREF
  int v18; // [sp+2Ch] [-4h] BYREF

  v2 = websTestVar(a1, (int)"ConfigSystemSoundDB");
  nvram_bufget(0, "SoundDetectionEnable");
  v3 = websGetVarCheck(a1, "SoundDetectionEnable", &v13);
  v4 = v3 | websGetVarCheck(a1, "SoundDetectionDB", &v14);
  v5 = v4 | websGetVarCheck(a1, "SoundDetectionScheduleDay", &v15);
  v6 = v5 | websGetVarCheck(a1, "SoundDetectionScheduleMode", &v16);
  v7 = v6 | websGetVarCheck(a1, "SoundDetectionScheduleTimeStart", &v17);
  v8 = v7 | websGetVarCheck(a1, "SoundDetectionScheduleTimeStop", &v18);
  v9 = 0;
  if ( websTestVar(a1, (int)"ConfigReboot") )
  {
    Var = websGetVar(a1, (int)"ConfigReboot", (int)byte_4A2DDC);
    if ( !strcasecmp(Var, "Yes") )
    {
      v2 = 1;
      v9 = 3;
    }
    else if ( !strcasecmp(Var, "No") )
    {
      v2 = 1;
    }
  }
  if ( v8 || !v2 )
    return websetReplayPage(a1, v8, "ReplySuccessPage", "ReplyErrorPage");
  v12 = SystemSoundDBChanged(a1);
  WriteSoundDBVar(a1);
  nvram_commit(0);
  if ( v12 )
  {
    setSysInfoLong(57, 0x10000000);
    trace(1, (int)"Sound Detection settings was changed!\n");
  }
  if ( v9 <= 0 )
    return websetReplayPage(a1, v8, "ReplySuccessPage", "ReplyErrorPage");
  *(_DWORD *)(a1 + 288) = 3;
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00435134) --------------------------------------------------------
int *  sub_435134(int a1)
{
  int v2; // $s2
  int v3; // $s3
  int v4; // $s4
  int Var; // $s0
  char *v7; // $s2
  int v8; // $s0

  if ( websTestVar(a1, (int)"CifsPassword") )
  {
    if ( websTestVar(a1, (int)"SessionKey") )
    {
      v7 = (char *)allocDecodePasswordByName(a1, (int)"CifsPassword");
      websSetVar(a1, "CifsPassword", v7);
      if ( v7 )
        free2(v7);
    }
  }
  v2 = websTestVar(a1, (int)"ConfigSystemCIFS");
  v3 = CheckCIFSVar(a1);
  v4 = 0;
  if ( websTestVar(a1, (int)"ConfigReboot") )
  {
    Var = websGetVar(a1, (int)"ConfigReboot", (int)byte_4A2DDC);
    if ( !strcasecmp(Var, "Yes") )
    {
      v2 = 1;
      v4 = 3;
    }
    else if ( !strcasecmp(Var, "No") )
    {
      v2 = 1;
    }
  }
  if ( v3 || !v2 )
    return websetReplayPage(a1, v3, "ReplySuccessPage", "ReplyErrorPage");
  v8 = SystemCIFSChanged(a1);
  WriteCIFSVar(a1);
  nvram_commit(0);
  if ( v8 )
  {
    setSysInfoLong(57, 0x1000000);
    trace(1, (int)"CIFS Recording settings was changed!\n");
  }
  if ( v4 <= 0 )
    return websetReplayPage(a1, v3, "ReplySuccessPage", "ReplyErrorPage");
  *(_DWORD *)(a1 + 288) = 3;
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);

//----- (004353E4) --------------------------------------------------------
int *  sub_4353E4(int a1)
{
  _BYTE *v2; // $v0
  char *v3; // $v0
  char *ErrorMessage; // $v0

  v2 = (_BYTE *)nvram_bufget(0, "CifsServerFolder");
  if ( v2 && *v2 )
  {
    ErrorMessage = (char *)websGetErrorMessage(107);
    webAddReplyMessage(a1, ErrorMessage, 0);
    setSysInfoShort(95, 1);
    trace(1, (int)"Call test CIFS function!\n");
    setSysInfoLong(57, 0x20000000);
    return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
  }
  else
  {
    v3 = (char *)websGetErrorMessage(108);
    webAddReplyMessage(a1, v3, 0);
    setSysInfoShort(95, 9);
    return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
  }
}
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00435544) --------------------------------------------------------
int *  sub_435544(int a1)
{
  char *Var; // $s1
  void *v3; // $s6
  int v4; // $v0
  void *v5; // $s0
  char *v6; // $s2
  int v7; // $v0
  _BYTE *v8; // $s1
  void *v9; // $s0
  int v10; // $a0
  char *v11; // $a2
  _DWORD *User; // $v0
  int v14; // $v0
  int v15; // $v0
  char v16[256]; // [sp+18h] [-108h] BYREF
  int v17; // [sp+118h] [-8h] BYREF

  Var = (char *)websGetVar(a1, (int)"password", (int)byte_4A2DDC);
  memset(v16, 0, 254);
  websDecode64((int)v16, Var, 0xFEu);
  if ( !*Var )
  {
    if ( !v16[0] )
      goto LABEL_3;
LABEL_18:
    websSetVar(a1, "name", byte_4A2DDC);
    websSetVar(a1, "password", byte_4A2DDC);
    websSetVar(a1, "group", byte_4A2DDC);
    return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
  }
  if ( !v16[0] )
    goto LABEL_18;
LABEL_3:
  websSetVar(a1, "password", v16);
  v3 = (void *)websGetVar(a1, (int)"name", (int)byte_4A2DDC);
  v5 = (void *)websGetVar(a1, (int)"password", (int)byte_4A2DDC);
  v4 = nvram_bufget(0, "AdminID");
  v17 = 0;
  v6 = (char *)v4;
  trace(1, (int)"setSystemUserModify!\n");
  v8 = (_BYTE *)strdupWithoutNull(v3);
  v7 = strdupWithoutNull(v5);
  v9 = (void *)v7;
  if ( !v8 || !v7 )
    goto LABEL_10;
  if ( v6 && !strcmp(v8, v6) )
  {
    if ( (unsigned int)strlen(v9) < 0x21 )
    {
      nvram_bufset(0, "AdminPassword", v9);
      nvram_commit(0);
      doSystem((int)"sed -e 's/^%s:/%s:/' /etc/passwd > /etc/newpw", v6, v6);
      doSystem((int)"cp /etc/newpw /etc/passwd");
      doSystem((int)"rm -f /etc/newpw");
      doSystem((int)"chpasswd.sh");
      v10 = a1;
      v11 = "administator";
      goto LABEL_11;
    }
LABEL_10:
    websSetVar(a1, "name", byte_4A2DDC);
    websSetVar(a1, "password", byte_4A2DDC);
    v10 = a1;
    v11 = byte_4A2DDC;
    goto LABEL_11;
  }
  if ( !*v8 || (unsigned int)strlen(v8) >= 0xD || (unsigned int)strlen(v9) >= 9 )
    goto LABEL_10;
  User = umGetUser((int)v8);
  if ( User )
    allocFmtString(&v17, 8, (int)"%d", User[1] - 1);
  else
    v17 = strdupWithoutNull(&word_4A0308);
  if ( !v17 || websAddUser((int)v8, (int)v9, v17) < 0 )
    goto LABEL_10;
  v14 = nvram_bufget(0, "AccessControlEnable");
  if ( !strcmp(v14, &word_4A0308) )
  {
    v15 = atoi(v17);
    umAddUser(v8, v9, v15);
  }
  v11 = "user";
  v10 = a1;
LABEL_11:
  websSetVar(v10, "group", v11);
  if ( v8 )
    free2(v8);
  if ( v9 )
    free2(v9);
  if ( v17 )
  {
    free2(v17);
    v17 = 0;
    return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
  }
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00435B30) --------------------------------------------------------
int *  sub_435B30(int a1)
{
  int v2; // $s2
  int v3; // $s4
  int v4; // $s5
  int Var; // $s0
  int v7; // $v0
  int v8; // [sp+18h] [-8h] BYREF

  v2 = websTestVar(a1, (int)"ConfigSystemPanTilt");
  v3 = websGetVarCheck(a1, "DwellingTime", &v8);
  v4 = 0;
  if ( websTestVar(a1, (int)"ConfigReboot") )
  {
    Var = websGetVar(a1, (int)"ConfigReboot", (int)byte_4A2DDC);
    if ( !strcasecmp(Var, "Yes") )
    {
      v2 = 1;
      v4 = 3;
    }
    else if ( !strcasecmp(Var, "No") )
    {
      v2 = 1;
    }
  }
  if ( v3 )
    return websetReplayPage(a1, v3, "ReplySuccessPage", "ReplyErrorPage");
  if ( !v2 )
    return websetReplayPage(a1, v3, "ReplySuccessPage", "ReplyErrorPage");
  v7 = websGetVar(a1, (int)"DwellingTime", (int)byte_4A2DDC);
  nvram_bufset(0, "DwellingTime", v7);
  nvram_commit(0);
  if ( v4 <= 0 )
    return websetReplayPage(a1, v3, "ReplySuccessPage", "ReplyErrorPage");
  *(_DWORD *)(a1 + 288) = 3;
  return websetReplayPage(a1, 0, "ReplySuccessPage", "ReplyErrorPage");
}
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);

//----- (00435D28) --------------------------------------------------------
int formDefineManagement()
{
  websSetFormDefine("setDebugLevel", (int)sub_42FACC);
  websSetFormDefine("setSystemReboot", (int)sub_42FBA4);
  websSetFormDefine("setSystemFactoryReset", (int)sub_42FC28);
  websSetFormDefine("setSystemLanguage", (int)sub_42FCE8);
  websSetFormDefine("setAuthorizationMode", (int)sub_42FE04);
  websSetFormDefine("setTestEmail", (int)sub_430028);
  websSetFormDefine("setTestFTP", (int)sub_4301CC);
  websSetFormDefine("setSystemRegion", (int)sub_43032C);
  websSetFormDefine("setSystemAPSelect", (int)sub_4303B8);
  websSetFormDefine("setSystemAPReScan", (int)sub_4305F0);
  websSetFormDefine("setSystemWizard", (int)sub_43064C);
  websSetFormDefine("setSystemAdmin", (int)sub_430EA0);
  websSetFormDefine("setSystemControl", (int)sub_4312FC);
  websSetFormDefine("setSystemAddUser", (int)sub_431708);
  websSetFormDefine("setSystemDeleteUser", (int)sub_431A80);
  websSetFormDefine("setSystemNetwork", (int)sub_431C74);
  websSetFormDefine("setSystemWireless", (int)sub_4320E8);
  websSetFormDefine("setSystemStream", (int)sub_432984);
  websSetFormDefine("setDayNightStream", (int)sub_433054);
  websSetFormDefine("setSystemVideo", (int)sub_433804);
  websSetFormDefine("setSystemEmail", (int)sub_433CD0);
  websSetFormDefine("setSystemFTP", (int)sub_4340E4);
  websSetFormDefine("setSystemDate", (int)sub_434394);
  websSetFormDefine("setSystemMotion", (int)sub_434838);
  websSetFormDefine("setDayNightMode", (int)sub_434BE4);
  websSetFormDefine("setSystemSoundDB", (int)sub_434E50);
  websSetFormDefine("setSystemCIFS", (int)sub_435134);
  websSetFormDefine("setTestCIFS", (int)sub_4353E4);
  websSetFormDefine("setSystemUserModify", (int)sub_435544);
  return websSetFormDefine("setSystemPanTilt", (int)sub_435B30);
}

//----- (004360FC) --------------------------------------------------------
int   getMTDPartSize(int a1)
{
  int v2; // $s0
  int v3; // $s6
  int v4; // $v0
  char *v5; // $a1
  _BYTE v7[128]; // [sp+20h] [-100h] BYREF
  _BYTE v8[32]; // [sp+A0h] [-80h] BYREF
  _BYTE v9[96]; // [sp+C0h] [-60h] BYREF

  v2 = fopen("/proc/mtd", "r");
  v3 = 0;
  if ( v2 )
  {
    while ( 1 )
    {
      v4 = fgets(v7, 128, v2);
      v5 = "%31s %31s %31s %31s";
      if ( !v4 )
        break;
      if ( sscanf(v7, "%31s %31s %31s %31s", &v9[32], v9, &v9[64], v8) >= 0 && !strcmp(v8, a1) )
      {
        v3 = strtol(v9, 0, 16);
        break;
      }
    }
    fclose(v2);
    return v3;
  }
  else
  {
    fwrite("mtd support not enable?", 1, 23, stderr);
    return 0;
  }
}
// 4361F0: variable 'v5' is possibly undefined
// 4E9F54: using guessed type int   fwrite(_DWORD, _DWORD, _DWORD, _DWORD);
// 4E9F70: using guessed type int stderr;
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F98: using guessed type int   fclose(_DWORD);
// 4E9FA8: using guessed type int   fopen(_DWORD, _DWORD);
// 4E9FBC: using guessed type int sscanf(_DWORD, char *, ...);
// 4EA030: using guessed type int   strtol(_DWORD, _DWORD, _DWORD);
// 4EA084: using guessed type int   fgets(_DWORD, _DWORD, _DWORD);

//----- (00436254) --------------------------------------------------------
int   sub_436254(int a1)
{
  char *v3; // $s0
  char *v4; // $a0
  int v5; // $v1
  int v6; // $v0

  if ( websConnValid(a1) )
  {
    if ( websConnValidateUrl(a1, *(void **)(a1 + 136)) < 0 )
    {
      trace(16, (int)"websCgiReplyMessage wp=(%s)!\n", "Invalid URL");
      websConnError(a1, 500, (int)"Invalid URL");
    }
    else
    {
      v3 = *(char **)(a1 + 148);
      v4 = &v3[strlen(v3) - 1];
      v5 = *v4;
      if ( v5 == 47 || v5 == 92 )
        *v4 = 0;
      v6 = open(v3, 0);
      *(_DWORD *)(a1 + 256) = v6;
      if ( v6 < 0 )
      {
        websConnError(a1, 404, (int)"cgibin: Cannot open URL(%s)\n", *(char **)(a1 + 144));
      }
      else
      {
        websWriteActiveHeader((_DWORD *)a1, 200, 0, (char *)(a1 + 68), 0);
        if ( websParaRequest(a1, v3) >= 0 )
          websConnClose(a1, 200);
      }
    }
  }
  else
  {
    trace(16, (int)"websCgiReplyMessage wp=(%s)!\n", "Invalid ptr");
  }
  return 1;
}
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);

//----- (004363F8) --------------------------------------------------------
int   sub_4363F8(
        int a1,
        signed int a2,
        int a3,
        _DWORD *a4,
        char *a5,
        int a6,
        unsigned int a7,
        _DWORD *a8,
        int a9)
{
  int v11; // $v0
  int v12; // $s1
  int v13; // $v0
  int v14; // $s3
  int *v15; // $s4
  int *v16; // $a2
  unsigned int *v17; // $a3
  int *v18; // $s2
  unsigned int v19; // $t2
  int v20; // $t1
  int v21; // $a0
  int v22; // $a1
  _DWORD *v23; // $v0
  char *v24; // $v0
  unsigned int v25; // $v0
  int v26; // $s0
  unsigned int v27; // $v0
  unsigned int v28; // $v0
  int v29; // $v0
  int v30; // $v0
  int v31; // $s0
  float v32; // $f20
  float v33; // $f0
  int v34; // $a0
  int *v35; // $a1
  int i; // $v1
  int v37; // $v0
  _DWORD *v38; // $v0
  char *v39; // $v0
  unsigned int v40; // $v1
  int v41; // $t1
  _DWORD *v42; // $v0
  char *v43; // $v0
  unsigned int v44; // $a2
  int v45; // $v0
  char v46[56]; // [sp+20h] [-110h] BYREF
  signed int v47; // [sp+58h] [-D8h]
  unsigned int v48; // [sp+B8h] [-78h] BYREF
  int v49; // [sp+BCh] [-74h]
  int v50; // [sp+C4h] [-6Ch]
  int v51; // [sp+D0h] [-60h]
  char v52[32]; // [sp+D8h] [-58h] BYREF
  int v53; // [sp+F8h] [-38h] BYREF
  __int16 v54; // [sp+FCh] [-34h]
  char v55[16]; // [sp+100h] [-30h] BYREF
  char v56[16]; // [sp+110h] [-20h] BYREF
  int v57; // [sp+120h] [-10h]
  int v58; // [sp+124h] [-Ch]
  int v59; // [sp+128h] [-8h]

  v57 = 36;
  if ( a2 )
  {
    v53 = 0;
    v54 = 0;
    getSysInfoBuffer(25, (int)&v53, 6);
    if ( !(_BYTE)v53 && BYTE1(v53) == 255 )
    {
      *a4 = 1;
      v57 = 30;
    }
  }
  if ( a7 < 0x40 )
  {
    sprintf(a9, "Bad size: \"%s\" is no valid image\n", a5);
    return 0;
  }
  v11 = open(a5, 0);
  v12 = v11;
  if ( v11 < 0 )
  {
    v23 = (_DWORD *)_errno_location();
    v24 = (char *)strerror(*v23);
    sprintf(a9, "Can't open %s: %s\n", a5, v24);
    return 0;
  }
  if ( fstat(v11, v46) < 0 )
  {
    close(v12);
    v38 = (_DWORD *)_errno_location();
    v39 = (char *)strerror(*v38);
    sprintf(a9, "Can't stat %s: %s\n", a5, v39);
    return 0;
  }
  v13 = mmap(0, v47, 1, 1, v12, 0);
  v14 = v13;
  if ( v13 == -1 )
  {
    close(v12);
    v42 = (_DWORD *)_errno_location();
    v43 = (char *)strerror(*v42);
    sprintf(a9, "Can't mmap %s: %s\n", a5, v43);
    return 0;
  }
  if ( v47 < a2 )
  {
    munmap(v13, v47);
    close(v12);
    sprintf(a9, "*** Warning: \"%s\" file size is too small!\n", a5);
    return 0;
  }
  v15 = (int *)(v13 + a6);
  if ( a2 )
  {
    strcpy(v55, "Signature: ");
    strcpy(v56, "Release ");
    v25 = strlen(v55);
    v26 = memsearch((int)v15 - a2, a2, (unsigned __int8 *)v55, v25);
    if ( !v26 )
    {
      munmap(v14, v47);
      close(v12);
      sprintf(a9, "*** Warning: \"%s\" has not signature!\n", a5);
      return 0;
    }
    if ( a1 == 1 )
      goto LABEL_27;
    v27 = strlen(v56);
    v58 = memsearch(v26, 0x40u, (unsigned __int8 *)v56, v27);
    v28 = strlen(v56);
    v29 = memsearch(a3, 0x40u, (unsigned __int8 *)v56, v28);
    v59 = v29;
    if ( !v58 || !v29 || memcmp(v26, a3, v57) )
    {
      munmap(v14, v47);
      close(v12);
      sprintf(a9, "*** Warning: \"%s\" has bad signature!\n", a5);
      return 0;
    }
    if ( !*a4 )
    {
      v30 = strlen(v56);
      v31 = v59 + v30;
      v32 = atof(v58 + v30);
      v33 = atof(v31);
      if ( v33 < v32 )
LABEL_27:
        *a4 = 1;
    }
    v34 = 0;
    v35 = (int *)((char *)v15 - a2);
    for ( i = (int)(a7 + a2) / 4; i; v34 += v37 )
    {
      --i;
      v37 = *v35++;
    }
    if ( v34 != 1437226410 )
    {
      munmap(v14, v47);
      close(v12);
      sprintf(a9, "*** Warning: \"%s\" has bad checksum!\n", a5);
      return 0;
    }
  }
  v16 = v15;
  v17 = &v48;
  v18 = v15 + 16;
  do
  {
    v19 = *v16;
    v20 = v16[1];
    v21 = v16[2];
    v22 = v16[3];
    v16 += 4;
    *v17 = v19;
    v17[1] = v20;
    v17[2] = v21;
    v17[3] = v22;
    v17 += 4;
  }
  while ( v16 != v18 );
  if ( strcmp(v52, "Linux Kernel Image") )
  {
    munmap(v14, v47);
    close(v12);
    sprintf(a9, "Bad Magic Name: \"%s\"\n", v52);
    return 0;
  }
  if ( (HIBYTE(v48) | ((v48 & 0xFF0000) >> 8) | ((v48 & 0xFF00) << 8) | (v48 << 24)) != 0x27051956 )
  {
    munmap(v14, v47);
    close(v12);
    sprintf(a9, "Bad Magic Number: \"%s\" is no valid image\n", a5);
    return 0;
  }
  v40 = ((v49 & 0xFF000000) >> 24) | ((v49 & 0xFF0000u) >> 8) | ((v49 & 0xFF00) << 8);
  v41 = v49 << 24;
  v49 = 0;
  if ( crc32(0, &v48, 64) != (v40 | v41) )
  {
    munmap(v14, v47);
    close(v12);
    sprintf(a9, "*** Warning: \"%s\" has bad header checksum!\n", a5);
    return 0;
  }
  v44 = ((v50 & 0xFF000000) >> 24) | ((v50 & 0xFF0000u) >> 8) | ((v50 & 0xFF00) << 8) | (v50 << 24);
  *a8 = v44 + 64;
  v45 = crc32(0, v18, v44);
  if ( v45 != (((v51 & 0xFF000000) >> 24) | ((v51 & 0xFF0000u) >> 8) | ((v51 & 0xFF00) << 8) | (v51 << 24)) )
  {
    munmap(v14, v47);
    close(v12);
    sprintf(a9, "*** Warning: \"%s\" has corrupted data!\n", a5);
    return 0;
  }
  if ( getMTDPartSize((int)"\"Kernel\"") < a7 )
  {
    munmap(v14, v47);
    close(v12);
    sprintf(a9, "*** Warning: the image file(0x%x) is bigger than Kernel MTD partition.\n", a7);
    return 0;
  }
  munmap(v14, v47);
  close(v12);
  return 1;
}
// 4368C4: conditional instruction was optimized away because $s2.4!=0
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F40: using guessed type int _errno_location(void);
// 4E9F78: using guessed type int sprintf(_DWORD, char *, ...);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);
// 4E9FF0: using guessed type int   crc32(_DWORD, _DWORD, _DWORD);
// 4EA018: using guessed type int   fstat(_DWORD, _DWORD);
// 4EA01C: using guessed type double   atof(_DWORD);
// 4EA048: using guessed type int   mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4EA0A0: using guessed type int   munmap(_DWORD, _DWORD);
// 4EA0AC: using guessed type int   strerror(_DWORD);

//----- (00436D04) --------------------------------------------------------
int   uploadconfig(_DWORD *a1)
{
  int Var; // $v0
  signed int v3; // $s1
  int v4; // $s0
  int v5; // $s6
  int v6; // $s7
  char *v7; // $v0
  int v9; // $s5
  int v10; // $v0
  int v11; // $s3
  int v12; // $a1
  int i; // $a1
  _BYTE *v14; // $v0
  char v15; // $t0
  int v16; // $a0
  unsigned int v17; // $v0
  int v18; // $a3
  _BYTE *v19; // $a2
  _BYTE *v20; // $t3
  int v21; // $v1
  _WORD *v22; // $a0
  char *v23; // $s0
  int v24; // $s6
  int v25; // $s1
  char *v26; // $s5
  int v27; // $s4
  int v28; // $v0
  int v29; // $a1
  int v30; // $s3
  int v31; // $a1
  int v32; // $v0
  int v33; // $a1
  char *v34; // $a0
  char *v35; // $v0
  char *ErrorMessage; // $v0
  char *v37; // $v0
  _BYTE v38[20480]; // [sp+20h] [-A050h] BYREF
  int v39[5120]; // [sp+5020h] [-5050h] BYREF
  char v40[64]; // [sp+A020h] [-50h] BYREF
  int v41; // [sp+A060h] [-10h] BYREF
  int v42; // [sp+A064h] [-Ch] BYREF
  int v43; // [sp+A068h] [-8h]

  Var = websGetVar((int)a1, (int)WebFileMark, (int)byte_4A2DDC);
  if ( strcmp(Var, WebConfigFile) )
  {
    websetReplayPage((int)a1, 1, "ReplySuccessPage", "ReplyErrorPage");
    ErrorMessage = (char *)websGetErrorMessage(3);
    webAddReplyMessage((int)a1, ErrorMessage, 0);
    sub_436254((int)a1);
    return -1;
  }
  v3 = a1[50];
  if ( v3 >= 16385 )
  {
    websetReplayPage((int)a1, 1, "ReplySuccessPage", "ReplyErrorPage");
    v37 = (char *)websGetErrorMessage(8);
    webAddReplyMessage((int)a1, v37, 0);
    sub_436254((int)a1);
    return -2;
  }
  v4 = a1[45];
  v5 = a1[51];
  v6 = 0;
  if ( (unsigned int)(v3 - 4096) >= 0x4001 )
    goto LABEL_4;
  v9 = v3 / 2;
  memset(v38, 0, sizeof(v38));
  memset(v39, 0, sizeof(v39));
  v10 = fopen(v4, "r+");
  v11 = v10;
  if ( !v10 )
    goto LABEL_4;
  fseek(v10, v5, 0);
  if ( fread(v38, 1, v3, v11) != v3 )
  {
    fclose(v11);
LABEL_4:
    websetReplayPage((int)a1, 1, "ReplySuccessPage", "ReplyErrorPage");
    v7 = (char *)websGetErrorMessage(8);
    webAddReplyMessage((int)a1, v7, 0);
    sub_436254((int)a1);
    return -3;
  }
  memset(v40, 0, sizeof(v40));
  getSysInfoBuffer(1, (int)v40, 64);
  allocFmtString(&v42, 254, (int)"%s%s", "Steven Wu", v40);
  if ( v42 )
  {
    v17 = strlen(v42);
    CBlowfish(v42, v17);
    Blowfish_DeCode((int)v38, v39, v3);
    if ( v42 )
    {
      free2(v42);
      v42 = 0;
    }
  }
  for ( i = 0; i < v3; v14[20480] = ((v15 + 121) ^ 0x5A) - 101 )
  {
    v14 = &v38[i];
    v15 = v38[i++ + 20480];
  }
  v16 = v3 - 1;
  if ( v3 - 1 >= 0 )
  {
    i = (int)&v38[v16];
    do
    {
      if ( v3 - 1 == v16 )
        v43 = 32 * (*(_BYTE *)(i + 20480) & 7);
      if ( v16 )
        *(_BYTE *)(i + 20480) = (*(_BYTE *)(i + 20480) >> 3) + 32 * (*(_BYTE *)(i + 20479) & 7);
      else
        LOBYTE(v39[0]) = (LOBYTE(v39[0]) >> 3) + v43;
      --v16;
      --i;
    }
    while ( v16 >= 0 );
  }
  v18 = 0;
  if ( v9 > 0 )
  {
    v19 = v38;
    do
    {
      v20 = &v38[v18];
      i = (unsigned __int8)v38[v18++ + 20480 + v9];
      v19[1] = v20[20480];
      *v19 = i;
      v19 += 2;
    }
    while ( v18 < v9 );
  }
  v21 = 0;
  if ( v9 > 0 )
  {
    v22 = v38;
    i = v3 / 2;
    do
    {
      --i;
      v21 = (unsigned __int16)(v21 + *v22++);
    }
    while ( i );
  }
  if ( v21 != 23130 || (fseek(v11, v5, 0), fwrite(v38, 1, v3, v11) != v3) )
    v6 = -1;
  if ( v11 )
    fclose(v11);
  if ( v6 < 0 )
    goto LABEL_4;
  ++LockCriticalCMD;
  v23 = (char *)a1[45];
  v24 = a1[51] + 2;
  v25 = a1[50] - 2;
  v26 = (char *)strdupWithoutNull("/var/setrestoreconfig");
  if ( v26 )
  {
    doSystem((int)"cp %s /var/tmpcgi", v23);
    v27 = fopen(v26, "w+");
    if ( v27 )
    {
      v28 = fopen(v23, "r");
      v30 = v28;
      if ( !v28 )
      {
        fclose(v27);
        remove(v26);
        v34 = v26;
        goto LABEL_42;
      }
      if ( fseek(v28, v24, 0) == -1 )
        trace(1, (int)"fseek error\n");
      while ( v25 > 0 )
      {
        v32 = fread(&v41, 1, 1, v30);
        --v25;
        v31 = 1;
        if ( !v32 )
          break;
        fwrite(&v41, 1, 1, v27);
      }
      fclose(v27);
      fclose(v30);
      doSystem((int)"ralink_init clear 2860");
      doSystem((int)"ralink_init renew 2860 %s", v26);
      remove(v26);
    }
    v34 = v26;
LABEL_42:
    free2(v34);
  }
  websetReplayPage((int)a1, 0, "ReplySuccessPage", "ReplyErrorPage");
  v35 = (char *)websGetErrorMessage(7);
  webAddReplyMessage((int)a1, v35, 0);
  sub_436254((int)a1);
  websEndAuthentication();
  nvram_close(0);
  nvram_init(0);
  websStartAuthentication();
  nvram_bufset(0, "WirelessEverLinkOK", &word_4A0308);
  nvram_commit(0);
  if ( getSysInfoShort(65) != 2 )
  {
    set_reboot_time(3, 1);
    doSystem((int)"sleep 3 && reboot &");
  }
  return 0;
}
// 4372C4: conditional instruction was optimized away because $s5.4!=0
// 436EF8: variable 'v12' is possibly undefined
// 43711C: variable 'i' is possibly undefined
// 437250: variable 'v31' is possibly undefined
// 437268: variable 'v33' is possibly undefined
// 43757C: variable 'v29' is possibly undefined
// 4A0308: using guessed type __int16 word_4A0308;
// 4E34C8: using guessed type int LockCriticalCMD;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F1C: using guessed type int   nvram_init(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F54: using guessed type int   fwrite(_DWORD, _DWORD, _DWORD, _DWORD);
// 4E9F64: using guessed type int   nvram_close(_DWORD);
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9F98: using guessed type int   fclose(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FA8: using guessed type int   fopen(_DWORD, _DWORD);
// 4E9FB4: using guessed type int   fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 4E9FF8: using guessed type int   fseek(_DWORD, _DWORD, _DWORD);
// 4EA064: using guessed type int   remove(_DWORD);

//----- (004375D0) --------------------------------------------------------
int   uploadfirmware(_DWORD *a1)
{
  int Var; // $v0
  int v3; // $v0
  int v4; // $v0
  void *v5; // $a0
  int v6; // $s0
  BOOL v7; // $s1
  char *v8; // $s5
  int v9; // $s4
  unsigned int v10; // $s0
  __int16 v11; // $v0
  int v12; // $v1
  char *v13; // $v0
  char *v15; // $v0
  char *SysInfoLong; // $v0
  char *v17; // $v0
  char *ErrorMessage; // $v0
  char *v19; // $v0
  char *v20; // $v0
  char v21[256]; // [sp+30h] [-190h] BYREF
  _BYTE v22[128]; // [sp+130h] [-90h] BYREF
  unsigned int v23; // [sp+1B0h] [-10h] BYREF
  int v24; // [sp+1B4h] [-Ch] BYREF
  int v25; // [sp+1B8h] [-8h]

  if ( !websTestVar((int)a1, (int)"ReplySuccessPage") )
    websSetVar((int)a1, "ReplySuccessPage", "/cgi/upgradestatus.cgi");
  if ( !websTestVar((int)a1, (int)"ReplyErrorPage") )
    websSetVar((int)a1, "ReplyErrorPage", "/cgi/upgradestatus.cgi");
  Var = websGetVar((int)a1, (int)WebFileMark, (int)byte_4A2DDC);
  if ( !strcmp(Var, WebDownloadFile) )
  {
    if ( (int)a1[50] <= 0xFFFFF )
    {
      webAddReplyMessage((int)a1, v21, 0);
      websetReplayPage((int)a1, 1, "ReplySuccessPage", "ReplyErrorPage");
      ErrorMessage = (char *)websGetErrorMessage(3);
      webAddReplyMessage((int)a1, ErrorMessage, 0);
      websSetVar((int)a1, "DownloadStatus", "-2");
      nvram_bufset(0, "LastDownloadStatus", "-2");
      nvram_commit(0);
      sub_436254((int)a1);
      return -2;
    }
    else
    {
      memset(v22, 0, sizeof(v22));
      getSysInfoBuffer(64, (int)v22, 128);
      v3 = websGetVar((int)a1, (int)"ForceBootCodeUpgrade", (int)&word_4A0308);
      v4 = strcmp(v3, "1");
      v5 = (void *)a1[45];
      v24 = 0;
      v25 = a1[51];
      v6 = a1[52];
      v7 = v4 == 0;
      v8 = (char *)strdupWithoutNull(v5);
      if ( v8 )
      {
        v9 = v25 + 327680;
        v10 = v6 - (v25 + 327680);
        if ( sub_4363F8(v7, 327680, (int)v22, &v24, v8, v25 + 327680, v10, &v23, (int)v21) )
        {
          ++LockCriticalCMD;
          websSetVar((int)a1, "DownloadTime", "160");
          webAddReplyMessage((int)a1, "Flash Programming...", 0);
          websetReplayPage((int)a1, 0, "ReplySuccessPage", "ReplyErrorPage");
          websSetVar((int)a1, "DownloadStatus", (char *)&word_4A0308);
          nvram_bufset(0, "LastDownloadStatus", "1");
          nvram_commit(0);
          sub_436254((int)a1);
          setSysInfoShort(65, 2);
          trace(1, (int)"clear SSL serverkey/serververt key!\n");
          nvram_bufset(0, "SSLCertificate1", byte_4A2DDC);
          nvram_bufset(0, "SSLCertificate2", byte_4A2DDC);
          nvram_commit(0);
          doSystem((int)"sleep 3");
          doSystem((int)"ifconfig br0 0.0.0.0 &");
          if ( v24 == 1 )
          {
            printf("write bootloader");
            doSystem((int)"/bin/mtd_write -o %d -l %d write %s Bootloader", v25, 196608, v8);
          }
          v23 = v10;
          sprintf(v21, "writeimage file(0x%x,0x%x)\n", v9, v10);
          webAddReplyMessage((int)a1, v21, 0);
          v11 = doSystem((int)"/bin/mtd_write -o %d -l %d write %s Kernel", v9, v23, v8);
          v12 = -1;
          if ( (v11 & 0x7F) == 0 )
          {
            v12 = 0;
            if ( (v11 & 0xFF00) != 0 )
              v12 = -1;
          }
          if ( v12 == -1 )
          {
            SysInfoLong = (char *)getSysInfoLong(30);
            doSystem((int)"ifconfig br0 %s", SysInfoLong);
            websetReplayPage((int)a1, 1, "ReplySuccessPage", "ReplyErrorPage");
            v17 = (char *)websGetErrorMessage(5);
            webAddReplyMessage((int)a1, v17, 0);
            websSetVar((int)a1, "DownloadStatus", "-3");
            nvram_bufset(0, "LastDownloadStatus", "-3");
            nvram_commit(0);
            --LockCriticalCMD;
          }
          else
          {
            websetReplayPage((int)a1, 0, "ReplySuccessPage", "ReplyErrorPage");
            v13 = (char *)websGetErrorMessage(2);
            webAddReplyMessage((int)a1, v13, 0);
            websSetVar((int)a1, "DownloadStatus", (char *)&word_4A0308);
            nvram_bufset(0, "LastDownloadStatus", &word_4A0308);
            nvram_commit(0);
            set_reboot_time(3, 1);
            doSystem((int)"sleep 3 && reboot &");
          }
          free2(v8);
          return 0;
        }
        else
        {
          webAddReplyMessage((int)a1, v21, 0);
          websetReplayPage((int)a1, 1, "ReplySuccessPage", "ReplyErrorPage");
          v15 = (char *)websGetErrorMessage(3);
          webAddReplyMessage((int)a1, v15, 0);
          websSetVar((int)a1, "DownloadStatus", "-2");
          nvram_bufset(0, "LastDownloadStatus", "-2");
          nvram_commit(0);
          sub_436254((int)a1);
          free2(v8);
          return -3;
        }
      }
      else
      {
        webAddReplyMessage((int)a1, v21, 0);
        websetReplayPage((int)a1, 1, "ReplySuccessPage", "ReplyErrorPage");
        v20 = (char *)websGetErrorMessage(3);
        webAddReplyMessage((int)a1, v20, 0);
        websSetVar((int)a1, "DownloadStatus", "-4");
        nvram_bufset(0, "LastDownloadStatus", "-4");
        nvram_commit(0);
        sub_436254((int)a1);
        return -4;
      }
    }
  }
  else
  {
    websetReplayPage((int)a1, 1, "ReplySuccessPage", "ReplyErrorPage");
    v19 = (char *)websGetErrorMessage(3);
    webAddReplyMessage((int)a1, v19, 0);
    websSetVar((int)a1, "DownloadStatus", "-2");
    nvram_bufset(0, "LastDownloadStatus", "-2");
    nvram_commit(0);
    sub_436254((int)a1);
    return -1;
  }
}
// 437A88: conditional instruction was optimized away because $s5.4!=0
// 4A0308: using guessed type __int16 word_4A0308;
// 4E34C8: using guessed type int LockCriticalCMD;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);
// 4E9F78: using guessed type int sprintf(_DWORD, char *, ...);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA0BC: using guessed type int printf(char *, ...);

//----- (00437FD8) --------------------------------------------------------
int   npcuploadfirmware(int a1)
{
  int v2; // $s0
  char *v3; // $s2
  int v4; // $v0
  int v6; // $s5
  unsigned int v7; // $s4
  __int16 v8; // $v0
  int v9; // $v1
  int v10; // $v0
  char *v11; // $a2
  _BYTE v12[256]; // [sp+30h] [-1B0h] BYREF
  _BYTE v13[128]; // [sp+130h] [-B0h] BYREF
  char v14[8]; // [sp+1B0h] [-30h] BYREF
  char v15[32]; // [sp+1B8h] [-28h] BYREF
  unsigned int v16; // [sp+1D8h] [-8h] BYREF
  int v17; // [sp+1DCh] [-4h] BYREF

  v2 = 0;
  if ( *(int *)(a1 + 200) <= 0xFFFFF )
  {
    nvram_bufset(0, "LastDownloadStatus", "-2");
    v2 = -2;
    nvram_commit(0);
  }
  v3 = (char *)strdupWithoutNull(*(void **)(a1 + 180));
  if ( !v3 )
  {
    v11 = "-4";
    goto LABEL_18;
  }
  if ( v2 )
  {
LABEL_5:
    strcpy(v15, "fail");
    memset(&v15[5], 0, 27);
    v4 = strlen(v15);
    websWriteNormalHeader(a1, 200, v4, "application/Dlink-inf", 0);
    websWriteFmt(a1, (int)v15);
    websConnClose(a1, 200);
    goto LABEL_6;
  }
  memset(v13, 0, sizeof(v13));
  getSysInfoBuffer(64, (int)v13, 128);
  v6 = *(_DWORD *)(a1 + 204);
  v7 = *(_DWORD *)(a1 + 208) - (v6 + 327680);
  v17 = 0;
  if ( !sub_4363F8(0, 327680, (int)v13, &v17, v3, v6 + 327680, v7, &v16, (int)v12) )
  {
    v11 = "-2";
LABEL_18:
    nvram_bufset(0, "LastDownloadStatus", v11);
    nvram_commit(0);
    goto LABEL_5;
  }
  ++LockCriticalCMD;
  setSysInfoShort(65, 2);
  trace(1, (int)"clear SSL serverkey/serververt key!\n");
  nvram_bufset(0, "SSLCertificate1", byte_4A2DDC);
  nvram_bufset(0, "SSLCertificate2", byte_4A2DDC);
  nvram_commit(0);
  if ( v17 == 1 )
  {
    printf("write bootloader");
    doSystem((int)"/bin/mtd_write -o %d -l %d write %s Bootloader", v6, 196608, v3);
  }
  v16 = v7;
  v8 = doSystem((int)"/bin/mtd_write -o %d -l %d write %s Kernel", v6 + 327680, v7, v3);
  v9 = -1;
  if ( (v8 & 0x7F) == 0 )
  {
    v9 = 0;
    if ( (v8 & 0xFF00) != 0 )
      v9 = -1;
  }
  if ( v9 == -1 )
  {
    nvram_bufset(0, "LastDownloadStatus", "-3");
    nvram_commit(0);
    --LockCriticalCMD;
    goto LABEL_5;
  }
  strcpy(v14, "ok");
  nvram_bufset(0, "LastDownloadStatus", &word_4A0308);
  nvram_commit(0);
  v10 = strlen(v14);
  websWriteNormalHeader(a1, 200, v10, "application/Dlink-inf", 0);
  websWriteFmt(a1, (int)v14);
  websConnClose(a1, 200);
  set_reboot_time(3, 1);
  doSystem((int)"sleep 3 && reboot &");
LABEL_6:
  if ( v3 )
    free2(v3);
  return 0;
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E34C8: using guessed type int LockCriticalCMD;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA0BC: using guessed type int printf(char *, ...);

//----- (004384C4) --------------------------------------------------------
int   websCgibinProcessor(int a1)
{
  unsigned int v2; // $v1
  int StrInFile; // $v0
  int v4; // $s0
  int v5; // $s6
  unsigned __int8 *MemInFile; // $fp
  int v8; // $s7
  int i; // $s1
  int v10; // $v0
  int v11; // $s0
  char *v12; // $s4
  int v13; // $s2
  int v14; // $v0
  int v15; // $s1
  char *v16; // $s1
  int v17; // $s5
  int v18; // $s0
  _BYTE *v19; // $v0
  int v20; // $v0
  int v21; // $s0
  int v22; // $v0
  int v23; // $s0
  int v24; // $v0
  int v25; // $s5
  _BYTE *v26; // $v0
  int v27; // $s4
  int v28; // $v0
  int v29; // $s0
  int v30; // $v0
  int *v31; // $a0
  int v32; // $s0
  int v33; // $v0
  int v34; // $s1
  unsigned int v35; // $v1
  int (  *v36)(_DWORD *); // $t9
  int v37; // [sp+18h] [-8h]

  trace(1, (int)"websCgibinProcessor=%s\n", *(char **)(a1 + 136));
  v2 = *(_DWORD *)(a1 + 228);
  if ( ((v2 >> 15) & 1) == 0 && ((v2 >> 23) & 1) == 0 && ((v2 >> 14) & 1) == 0 )
  {
    websConnError(a1, 404, (int)"File Not Found");
    return 1;
  }
  if ( (v2 & 1) == 0 )
  {
    websConnError(a1, 405, (int)"Method Not Allowed.");
    return 1;
  }
  StrInFile = findStrInFile(*(_DWORD *)(a1 + 180), 0, (unsigned __int8 *)WebCRLF, 2);
  v4 = StrInFile;
  v37 = 0;
  if ( StrInFile == -1 )
  {
    v5 = -1;
LABEL_7:
    doSystem((int)"ls -all /var &");
    if ( !websConnValid(a1) )
      trace(16, (int)"websParseCgiFile wp=(%s)!\n", "Invalid ptr");
    if ( v5 == -1 )
      trace(16, (int)"websParseCgiFile err=(%s)!\n", "First CRLF not found");
    if ( v5 == -2 )
      trace(16, (int)"websParseCgiFile err=(%s)!\n", "Boundary not found");
    if ( v5 == -3 )
      trace(16, (int)"websParseCgiFile err=(%s)!\n", "Upload file not found");
    websConnError(a1, 500, (int)"Missing CGI data.");
    return 1;
  }
  MemInFile = (unsigned __int8 *)getMemInFile(*(_DWORD *)(a1 + 180), 0, StrInFile);
  v8 = v4;
  if ( !MemInFile )
  {
    v5 = -2;
    goto LABEL_7;
  }
  for ( i = v4 + 2; ; i = v11 + 2 )
  {
    v10 = findStrInFile(*(_DWORD *)(a1 + 180), i, (unsigned __int8 *)WebCRLF, 2);
    v11 = v10;
    v12 = 0;
    if ( v10 == -1 )
      break;
    v13 = getMemInFile(*(_DWORD *)(a1 + 180), i, v10 - i);
    if ( !v13 )
      break;
    v15 = strlen(WebMultiParaName);
    v14 = strncasecmp(v13, WebMultiParaName, v15);
    v16 = (char *)(v15 + v13);
    if ( !v14 )
    {
      v17 = v11 + 2;
      if ( strchr(v16, 59) )
      {
        v18 = findStrInFile(*(_DWORD *)(a1 + 180), v11 + 2, (unsigned __int8 *)WebCRLF, 2);
        if ( v18 == -1 )
        {
          free2(v13);
          break;
        }
        v19 = (_BYTE *)strchr(v16, 34);
        if ( v19 )
          *v19 = 0;
        websSetVar(a1, WebFileMark, v16);
        v20 = getMemInFile(*(_DWORD *)(a1 + 180), v17, v18 - v17);
        v21 = v18 + 4;
        v12 = (char *)v20;
        v22 = findStrInFile(*(_DWORD *)(a1 + 180), v21, MemInFile, v8);
        if ( v22 != -1 )
        {
          *(_DWORD *)(a1 + 204) = v21;
          *(_DWORD *)(a1 + 200) = v22 - 2 - v21;
          *(_DWORD *)(a1 + 208) = v22 - 2;
          v37 = 1;
        }
        v11 = v22 + v8;
      }
      else
      {
        v23 = v11 + 4;
        v24 = findStrInFile(*(_DWORD *)(a1 + 180), v23, MemInFile, v8);
        v25 = v24;
        if ( v24 != -1 )
        {
          v27 = v24 - v23 - 2;
          v26 = (_BYTE *)strchr(v16, 34);
          if ( v26 )
            *v26 = 0;
          v12 = (char *)getMemInFile(*(_DWORD *)(a1 + 180), v23, v27);
          websSetVar(a1, v16, v12);
        }
        v11 = v25 + v8;
      }
    }
    free2(v13);
    if ( v12 )
      free2(v12);
  }
  free2(MemInFile);
  if ( !v37 )
  {
    v5 = -3;
    goto LABEL_7;
  }
  v28 = fork();
  v29 = v28;
  if ( !v28 )
  {
    v32 = strdupWithoutNull(*(void **)(a1 + 180));
    if ( !v32 )
      exit(1);
    v34 = 0;
    v33 = getpid();
    trace(16, (int)"now in the cgibin child process(%d, %s).\n", v33, *(char **)(a1 + 144));
    v35 = *(_DWORD *)(a1 + 228);
    v36 = uploadconfig;
    if ( ((v35 >> 15) & 1) == 0 )
    {
      v36 = uploadfirmware;
      if ( ((v35 >> 14) & 1) == 0 )
      {
        if ( ((v35 >> 23) & 1) == 0 )
        {
          trace(16, (int)"Function not implement!\n");
          webAddReplyMessage(a1, "Function not implement!", 0);
          websetReplayPage(a1, 1, "ReplySuccessPage", "ReplyErrorPage");
          sub_436254(a1);
LABEL_55:
          remove(v32);
          free2(v32);
          exit(v34);
        }
        v36 = (int (  *)(_DWORD *))npcuploadfirmware;
      }
    }
    v34 = v36((_DWORD *)a1);
    goto LABEL_55;
  }
  if ( v28 == -1 )
  {
    trace(16, (int)"cgibin fork process failure.\n");
    websConnError(a1, 501, (int)"Fork process failure.");
    remove(*(_DWORD *)(a1 + 180));
  }
  else
  {
    v30 = AllocEntry(&dword_4E7CF8, &dword_4E506C, 8);
    if ( v30 >= 0 )
    {
      v31 = *(int **)(4 * v30 + dword_4E7CF8);
      v31[1] = v29;
      *v31 = a1;
      websTimeoutCancel(a1);
    }
  }
  return 1;
}
// 438848: conditional instruction was optimized away because $s4.4==0
// 4387E4: conditional instruction was optimized away because $s2.4!=0
// 43882C: conditional instruction was optimized away because $s2.4!=0
// 438864: conditional instruction was optimized away because $fp.4!=0
// 438B88: conditional instruction was optimized away because $s0.4!=0
// 4E506C: using guessed type int dword_4E506C;
// 4E7CF8: using guessed type int dword_4E7CF8;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F3C: using guessed type void   __noreturn exit(_DWORD);
// 4E9FC0: using guessed type int fork(void);
// 4EA040: using guessed type int   strncasecmp(_DWORD, _DWORD, _DWORD);
// 4EA064: using guessed type int   remove(_DWORD);
// 4EA088: using guessed type int getpid(void);

//----- (00438C34) --------------------------------------------------------
void websCgiReapChildren()
{
  int i; // $s2
  int *v1; // $s0
  int v2; // $s1
  BOOL v3; // $v0
  void (*v4)(); // $t9
  char *v5; // $a1
  int v6; // $a3
  int v7; // [sp+18h] [-8h] BYREF

  for ( i = 0; dword_4E506C >= i; ++i )
  {
    v1 = *(int **)(4 * i + dword_4E7CF8);
    if ( v1 )
    {
      v2 = *v1;
      v3 = websReapChildren(v1[1], (int)&v7);
      v4 = websRefreshCookieDigest;
      if ( !v3 )
      {
        websConnClose(v2, 200);
        v5 = "cgibin child(%d) exited, status=%d\n";
        v6 = (unsigned __int16)(v7 & 0xFF00) >> 8;
        if ( (v7 & 0x7F) != 0
          && (v5 = "cgibin child(%d) killed (signal %d)\n", v6 = v7 & 0x7F, (unsigned __int8)v7 == 127) )
        {
          trace(16, (int)"cgibin child(%d) stopped (signal %d)\n", v1[1], (unsigned __int16)(v7 & 0xFF00) >> 8);
        }
        else
        {
          trace(16, (int)v5, v1[1], v6);
        }
        dword_4E506C = FreeEntryId(&dword_4E7CF8, i);
        v4 = (void (*)())&free;
      }
      v4();
    }
  }
}
// 4E506C: using guessed type int dword_4E506C;
// 4E7CF8: using guessed type int dword_4E7CF8;
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00438DAC) --------------------------------------------------------
int *  authorizationmode(int a1)
{
  int v2; // $v0
  int v3; // $v0
  char *v4; // $a0
  int v5; // $v0
  int v6; // $s1
  int v7; // $s0
  int Var; // $s0
  char *v10; // $a2

  if ( (*(_DWORD *)(a1 + 228) & 1) != 0 || **(_BYTE **)(a1 + 160) )
  {
    if ( !websTestVar(a1, (int)"mode") )
      goto LABEL_5;
    Var = websGetVar(a1, (int)"mode", (int)byte_4A2DDC);
    if ( !strcmp(Var, "basic") )
    {
      v10 = (char *)&word_4A0308;
    }
    else
    {
      if ( strcmp(Var, "digest") )
        goto LABEL_5;
      v10 = "1";
    }
    websSetVar(a1, "HTTPAuthentication", v10);
    if ( CheckAuthorizationModeVar(a1) )
      goto LABEL_5;
    if ( AuthorizationModeChanged(a1) )
    {
      WriteAuthorizationModeVar(a1);
      nvram_commit(0);
    }
  }
  v2 = nvram_bufget(0, "HTTPAuthentication");
  v3 = atoi(v2);
  if ( v3 )
  {
    if ( v3 != 1 )
    {
LABEL_5:
      v4 = "{\n\"result\" : {\"code\":\"-1\",\n\"message\":\"Invalid parameter.\"}\n}";
      goto LABEL_6;
    }
    v4 = "{\n\"result\" : {\"code\":\"0\"},\n\"mode\":\"digest\"\n}";
  }
  else
  {
    v4 = "{\n\"result\" : {\"code\":\"0\"},\n\"mode\":\"basic\"\n}";
  }
LABEL_6:
  v5 = strdupWithoutNull(v4);
  v6 = v5;
  if ( !v5 )
    return websConnError(a1, 503, (int)"Insufficient memory");
  v7 = strlen(v5);
  websJsonWriteHeader(a1, v7);
  if ( v7 > 0 )
    websWriteFmt(a1, v6);
  free2(v6);
  return websConnClose(a1, 200);
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00439050) --------------------------------------------------------
int *  iocontrol(int a1)
{
  int v2; // $s3
  int v3; // $s5
  int v4; // $s0
  int v5; // $s1
  int Var; // $v0
  int v8; // $v0
  unsigned int SysInfoShort; // $s3
  int v10; // $v0
  int v11; // $v0

  v2 = nvram_bufget(0, "EmailScheduleEnable");
  v3 = nvram_bufget(0, "EmailScheduleMode");
  v4 = nvram_bufget(0, "FTPScheduleEnable");
  v5 = nvram_bufget(0, "FTPScheduleMode");
  if ( (*(_DWORD *)(a1 + 228) & 1) != 0 )
  {
    if ( !strcmp(v4, "1") && !strcmp(v5, "3") && websTestVar(a1, (int)"ImageUpload") )
    {
      Var = websGetVar(a1, (int)"ImageUpload", (int)&word_4A0308);
      v8 = atoi(Var);
      if ( v8 )
      {
        if ( v8 == 1 )
          setSysInfoLong(57, 4);
      }
      else
      {
        setSysInfoLong(57, 8);
      }
    }
    if ( !strcmp(v2, "1") && !strcmp(v3, "3") && websTestVar(a1, (int)"ImageEmail") )
    {
      v10 = websGetVar(a1, (int)"ImageEmail", (int)&word_4A0308);
      v11 = atoi(v10);
      if ( v11 )
      {
        if ( v11 == 1 )
          setSysInfoLong(57, 0x80000);
      }
      else
      {
        setSysInfoLong(57, 0x100000);
      }
    }
    return websReplyNoContent(a1);
  }
  else
  {
    SysInfoShort = (unsigned __int16)getSysInfoShort(72);
    websWriteNormalHeader(a1, 200, 0, "text/html", 0);
    websWriteFmt(a1, (int)"ImageUpload=%d&ImageEmail=%d&CurrentTime=", SysInfoShort & 1, (SysInfoShort >> 1) & 1);
    getCurrentTimeString(a1, (int)"%Y-%m-%d %X\r\n");
    return websConnClose(a1, 200);
  }
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00439390) --------------------------------------------------------
int *  snapimage(int a1)
{
  int SysInfoLong; // $v0
  int v3; // $s2
  int v4; // $s1
  int v5; // $s5
  int v6; // $v0
  int v7; // $s0
  int v8; // $a2
  int v9; // $s1
  int v10; // $s4
  int v11; // $s2
  signed int v12; // $a2
  int v13; // $v0
  int v14; // $v1
  int *result; // $v0

  SysInfoLong = getSysInfoLong(21);
  v3 = SysInfoLong;
  v4 = 10000;
  if ( SysInfoLong <= 0 )
  {
    trace(16, (int)"FRAME_IMAGE: service unavailable!\n");
    return websConnError(a1, 503, (int)"Service Unavailable");
  }
  else
  {
    v5 = SysInfoLong + 44;
    v6 = mmalloc(SysInfoLong + 44);
    v7 = v6;
    if ( v6 )
    {
      *(_WORD *)(v6 + 32) = 0;
      *(_DWORD *)(v6 + 36) = 0;
      *(_DWORD *)(v6 + 40) = v3;
      *(_WORD *)(v6 + 18) = 0;
      setSysInfoBuffer(19, v6, v5);
      v8 = *(_DWORD *)(v7 + 40);
      if ( !v8 )
      {
        while ( 1 )
        {
          usleep(1000);
          *(_WORD *)(v7 + 32) = 0;
          *(_DWORD *)(v7 + 36) = 0;
          *(_DWORD *)(v7 + 40) = v3;
          *(_WORD *)(v7 + 18) = 0;
          setSysInfoBuffer(19, v7, v5);
          v8 = *(_DWORD *)(v7 + 40);
          --v4;
          if ( v8 )
            break;
          if ( v4 <= 0 )
          {
            result = websConnError(a1, 500, (int)"Invalid URL");
            goto LABEL_20;
          }
        }
      }
      v9 = v8;
      v10 = 1000;
      v11 = v7 + 44;
      websWriteNormalHeader(a1, 200, v8, "image/jpeg", 0);
      while ( v9 > 0 )
      {
        v12 = v9;
        if ( *(unsigned __int8 *)(a1 + 228) >> 7 && v9 >= 513 )
          v12 = 512;
        v13 = websWritePartial(a1, v11, v12);
        v14 = v10;
        if ( v13 < 0 )
          break;
        if ( !v13 )
        {
          --v10;
          if ( v14 <= 0 )
            break;
          usleep(5000);
          continue;
        }
        v11 += v13;
        v9 -= v13;
        v10 = 1000;
      }
      websConnClose(a1, 200);
      *(_WORD *)(v7 + 18) = 0;
      result = ((int *(*)(int, int, int, ...))setSysInfoBuffer)(20, v7, v5);
LABEL_20:
      if ( v7 )
        return (int *)free2(v7);
    }
    else
    {
      trace(16, (int)"FRAME_IMAGE: allocate buffer failure!\n");
      return websConnError(a1, 500, (int)"Invalid URL");
    }
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA090: using guessed type int   usleep(_DWORD);

//----- (0043965C) --------------------------------------------------------
int *  resetdevice(int a1)
{
  int Var; // $v0
  int v4; // $v0

  if ( websTestVar(a1, (int)"Reset") )
  {
    Var = websGetVar(a1, (int)"Reset", (int)byte_4A2DDC);
    if ( !webncasestrcmp(Var, (int)"Yes") )
    {
      if ( LockCriticalCMD <= 0 )
      {
        ++LockCriticalCMD;
        if ( getSysInfoShort(65) != 2 )
        {
          doSystem((int)"sleep %d && reboot &", 3);
          set_reboot_time(3, 1);
        }
      }
      else
      {
        PendRebootCMD = 3;
        PendRebootMode = 1;
      }
    }
  }
  else if ( websTestVar(a1, (int)"FactoryReset") )
  {
    v4 = websGetVar(a1, (int)"FactoryReset", (int)byte_4A2DDC);
    if ( !webncasestrcmp(v4, (int)"Yes") )
    {
      if ( LockCriticalCMD <= 0 )
      {
        ++LockCriticalCMD;
        doSystem((int)"ralink_init clear 2860");
        doSystem((int)"ralink_init renew 2860 /etc_ro/Wireless/RT2860AP/RT2860_default_vlan");
        if ( getSysInfoShort(65) != 2 )
        {
          doSystem((int)"sleep %d && reboot &", 3);
          set_reboot_time(3, 0);
        }
      }
      else
      {
        PendRebootCMD = 3;
        PendRebootMode = 0;
      }
    }
  }
  return websReplyNoContent(a1);
}
// 4E34C0: using guessed type int PendRebootMode;
// 4E34C4: using guessed type int PendRebootCMD;
// 4E34C8: using guessed type int LockCriticalCMD;

//----- (004398A8) --------------------------------------------------------
int *  getconfig(int a1, char *a2)
{
  int v4; // $s7
  int v5; // $s0
  int v6; // $s1
  int v7; // $v0
  int *v8; // $s4
  unsigned __int8 *v9; // $s3
  int v10; // $v0
  int v11; // $s6
  int v12; // $a2
  int *result; // $v0
  int *v14; // $a0
  int v15; // $a3
  int *v16; // $a1
  int v17; // $a0
  int v18; // $a2
  int *v19; // $a1
  unsigned __int8 *v20; // $t1
  int v21; // $a1
  _BYTE *v22; // $a0
  int i; // $a1
  unsigned __int8 *v24; // $a3
  unsigned __int8 v25; // $t0
  int v26; // $s0
  int v27; // $s2
  int v28; // $s1
  signed int v29; // $a2
  int v30; // $v0
  int v31; // $v1
  unsigned int v32; // $v0
  __int16 v33; // [sp+28h] [-E8h]
  _BYTE v34[56]; // [sp+30h] [-E0h] BYREF
  int v35; // [sp+68h] [-A8h]
  char v36[64]; // [sp+C8h] [-48h] BYREF
  int v37; // [sp+108h] [-8h] BYREF

  v33 = 0;
  LOBYTE(v4) = 0;
  if ( !a2 )
    return websConnError(a1, 503, (int)"Insufficient memory");
  if ( stat(a2, v34) < 0 )
    return websConnError(a1, 400, (int)"Cannot stat page for URL");
  v5 = v35;
  v6 = 2 * ((v35 + 1) / 2) + 2;
  v8 = (int *)mmalloc(v6);
  v7 = mmalloc(v6);
  v9 = (unsigned __int8 *)v7;
  if ( v8 && v7 )
  {
    memset(v8, 0, v6);
    memset(v9, 0, v6);
    v10 = open(a2, 0);
    v11 = v10;
    if ( v10 < 0 )
    {
      websConnError(a1, 404, (int)"getconfig: Cannot open URL(%s)\n", a2);
      goto LABEL_8;
    }
    v12 = read(v10, (char *)v8 + 2, v5);
    if ( v12 != v5 )
    {
      trace(1, (int)"getconfig: Cannot read URL(%d)\n", v12);
      websConnError(a1, 404, (int)"Cannot read URL");
      close(v11);
LABEL_8:
      free2(v8);
      return (int *)free2(v9);
    }
    v15 = v6 >> 1;
    if ( v6 >> 1 > 0 )
    {
      v16 = v8;
      v17 = v6 >> 1;
      do
      {
        --v17;
        v33 += *(_WORD *)v16;
        v16 = (int *)((char *)v16 + 2);
      }
      while ( v17 );
    }
    v18 = 0;
    *(_WORD *)v8 = 23130 - v33;
    if ( v6 >> 1 > 0 )
    {
      v19 = v8;
      do
      {
        v20 = &v9[v18];
        *v20 = *((_BYTE *)v19 + 1);
        ++v18;
        v20[v15] = *(_BYTE *)v19;
        v19 = (int *)((char *)v19 + 2);
      }
      while ( v18 < v15 );
    }
    v21 = 0;
    if ( v6 > 0 )
    {
      v22 = v9;
      do
      {
        while ( 1 )
        {
          if ( !v21 )
            v4 = *v9 >> 5;
          if ( v6 - 1 == v21 )
            break;
          ++v21;
          *v22 = 8 * (*v22 & 0x1F) + (v22[1] >> 5);
          ++v22;
          if ( v21 >= v6 )
            goto LABEL_27;
        }
        ++v21;
        *v22 = 8 * (*v22 & 0x1F) + v4;
        ++v22;
      }
      while ( v21 < v6 );
LABEL_27:
      for ( i = 0; i < v6; ++i )
      {
        v24 = &v9[i];
        v25 = v9[i];
        *v24 = ((v25 + 101) ^ 0x5A) - 121;
      }
    }
    v37 = 0;
    memset(v36, 0, sizeof(v36));
    getSysInfoBuffer(1, (int)v36, 64);
    allocFmtString(&v37, 254, (int)"%s%s", "Steven Wu", v36);
    if ( v37 )
    {
      v32 = strlen(v37);
      CBlowfish(v37, v32);
      Blowfish_EnCode((int)v9, v8, v6);
      if ( v37 )
      {
        free2(v37);
        v37 = 0;
      }
    }
    websWriteSpecialHeader(
      a1,
      200,
      v6,
      "application/octet-stream",
      0,
      (int)"Content-Transfer-Encoding: binary\r\nContent-Disposition: attachment; filename=\"Config.CFG\"\r\n",
      0);
    v26 = v6;
    v27 = 1000;
    v28 = (int)v8;
LABEL_31:
    if ( v26 > 0 )
    {
      while ( 1 )
      {
        v29 = v26;
        if ( *(unsigned __int8 *)(a1 + 228) >> 7 && v26 >= 513 )
          v29 = 512;
        v30 = websWritePartial(a1, v28, v29);
        v31 = v27;
        if ( v30 < 0 )
          break;
        if ( v30 )
        {
          v28 += v30;
          v27 = 1000;
          v26 -= v30;
          goto LABEL_31;
        }
        --v27;
        if ( v31 <= 0 )
          break;
        usleep(5000);
      }
    }
    websConnClose(a1, 200);
    close(v11);
    v14 = v8;
  }
  else
  {
    trace(1, (int)"getconfig: allocate buffer failure\n");
    result = websConnError(a1, 503, (int)"Allocate buffer failure");
    v14 = v8;
    if ( !v8 )
      goto LABEL_12;
  }
  result = (int *)free2(v14);
LABEL_12:
  if ( v9 )
    return (int *)free2(v9);
  return result;
}
// 439BF4: conditional instruction was optimized away because $s1.4>=1
// 439D38: conditional instruction was optimized away because $s0.4>=1
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F58: using guessed type int   stat(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FE0: using guessed type int   read(_DWORD, _DWORD, _DWORD);
// 4EA090: using guessed type int   usleep(_DWORD);

//----- (00439E58) --------------------------------------------------------
int   gotopresetion(int a1)
{
  int result; // $v0
  void *v2; // $a0
  int v3; // $s0
  char *v4; // $s1
  char v5[64]; // [sp+20h] [-60h] BYREF
  int v6[2]; // [sp+60h] [-20h] BYREF
  int v7; // [sp+68h] [-18h]
  int v8; // [sp+6Ch] [-14h]
  char *v9; // [sp+70h] [-10h] BYREF
  char *v10; // [sp+74h] [-Ch] BYREF
  char *v11; // [sp+78h] [-8h] BYREF

  snprintf(v5, 64, "SetPosition%d", a1);
  trace(1, (int)"PanTilt Preset Position Move=%s\n", v5);
  result = nvram_bufget(0, v5);
  if ( result )
  {
    v2 = (void *)result;
    result = *(unsigned __int8 *)result;
    if ( result )
    {
      v3 = strdupWithoutNull(v2);
      result = (int)byte_4A2DDC;
      if ( v3 )
      {
        v11 = byte_4A2DDC;
        v10 = byte_4A2DDC;
        v9 = byte_4A2DDC;
        ParseSetPoition(v3, &v9, &v10, &v11, byte_4A2DDC);
        if ( v10 )
        {
          v4 = v11;
          if ( v11 )
          {
            v6[0] = 9;
            v6[1] = 0;
            v7 = 0;
            v8 = 0;
            v7 = atoi(v10);
            v8 = atoi(v4);
            pantilt_cmd(v6);
          }
        }
        return free2(v3);
      }
    }
  }
  return result;
}
// 439F64: conditional instruction was optimized away because $s0.4!=0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (00439FDC) --------------------------------------------------------
int *  pantiltcontrol(int a1)
{
  int Var; // $v0
  int v4; // $v0
  int v5; // $s5
  int v6; // $v0
  int v7; // $s2
  int v8; // $s3
  int v9; // $s0
  int v10; // $s5
  int v11; // $s6
  int v12; // $v0
  int v13; // $s2
  char *v14; // $s3
  int v15; // $s0
  int v16; // $v0
  int v17; // $v0
  int v18; // $v0
  int v19; // $a3
  int v20; // $v0
  int v21; // $v0
  int v22; // $s6
  int v23; // $v0
  int v24; // $s7
  int v25; // $s3
  char *v26; // $s5
  int v27; // $v0
  int v28; // $v0
  int v29; // $v0
  unsigned int v30; // $s1
  int *v31; // $v0
  void *v32; // $v0
  int v33; // $v0
  int v34; // $s2
  _BYTE *v35; // $v0
  _BYTE *v36; // $s7
  int v37; // $s6
  int v38; // $v0
  void *v39; // $v0
  int v40; // $v0
  int v41; // $s2
  _BYTE *v42; // $v0
  _BYTE *v43; // $s6
  int v44; // [sp+20h] [-A0h] BYREF
  int v45; // [sp+24h] [-9Ch]
  int v46; // [sp+28h] [-98h]
  int v47; // [sp+2Ch] [-94h]
  int v48; // [sp+30h] [-90h] BYREF
  int v49; // [sp+34h] [-8Ch]
  int v50; // [sp+38h] [-88h]
  int v51; // [sp+3Ch] [-84h]
  int v52[2]; // [sp+40h] [-80h] BYREF
  int v53; // [sp+48h] [-78h]
  int v54; // [sp+4Ch] [-74h]
  _BYTE v55[48]; // [sp+50h] [-70h] BYREF
  char v56[64]; // [sp+80h] [-40h] BYREF

  if ( websTestVar(a1, (int)"PanTiltSingleMove") )
  {
    Var = websGetVar(a1, (int)"PanSingleMoveDegree", (int)&word_4A0308);
    v5 = atoi(Var);
    v4 = websGetVar(a1, (int)"TiltSingleMoveDegree", (int)&word_4A0308);
    v7 = atoi(v4);
    v6 = websGetVar(a1, (int)"PanTiltSingleMove", (int)&word_4A0308);
    v8 = atoi(v6);
    v44 = 0;
    v45 = 0;
    v46 = 0;
    v47 = 0;
    v29 = nvram_bufget(0, "Mirror");
    v30 = atoi(v29);
    v31 = trace(1, (int)"PanTiltSingleMove=>CONFIG_CHECK_MIRROR\n");
    if ( (v30 & 1) != 0 )
    {
      switch ( (unsigned int)v31 )
      {
        case 0u:
          v8 = 2;
          goto LABEL_44;
        case 1u:
        case 4u:
        case 7u:
          goto LABEL_44;
        case 2u:
          v8 = 0;
          goto LABEL_44;
        case 3u:
          v8 = 5;
          goto LABEL_44;
        case 5u:
          v8 = 3;
          goto LABEL_44;
        case 6u:
          v8 = 8;
          goto LABEL_44;
        case 8u:
          v8 = 6;
          goto LABEL_44;
        default:
          break;
      }
    }
    else
    {
LABEL_44:
      if ( ((v30 >> 1) & 1) != 0 )
      {
        switch ( (unsigned int)v31 )
        {
          case 0u:
            v8 = 6;
            goto LABEL_60;
          case 1u:
            v8 = 7;
            goto LABEL_60;
          case 2u:
            v8 = 8;
            goto LABEL_60;
          case 3u:
          case 4u:
          case 5u:
            goto LABEL_60;
          case 6u:
            v8 = 0;
            goto LABEL_60;
          case 7u:
            v8 = 1;
            goto LABEL_60;
          case 8u:
            v8 = 2;
            goto LABEL_60;
          default:
            break;
        }
      }
      else
      {
LABEL_60:
        switch ( (unsigned int)v31 )
        {
          case 0u:
          case 1u:
          case 2u:
            v38 = 7;
            goto LABEL_62;
          case 3u:
            v44 = 5;
            v45 = v5;
            break;
          case 4u:
            v39 = (void *)nvram_bufget(0, "HomePosition");
            v40 = strdupWithoutNull(v39);
            v41 = v40;
            if ( v40 )
            {
              v42 = (_BYTE *)strchr(v40, 47);
              if ( v42 )
              {
                *v42 = 0;
                v44 = 9;
                v43 = v42 + 1;
                v46 = atoi(v41);
                v47 = atoi(v43);
                trace(1, (int)"Go to Home Position=>(%d,%d)\n", v46, v47);
              }
              else
              {
                v44 = 1;
                trace(1, (int)"Go to Default Home Position\n");
              }
              if ( v41 )
                free2(v41);
            }
            break;
          case 5u:
            v44 = 6;
            v45 = v5;
            break;
          case 6u:
          case 7u:
          case 8u:
            v38 = 8;
LABEL_62:
            v44 = v38;
            v45 = v7;
            break;
          default:
            break;
        }
      }
      trace(1, (int)"PanTiltSingleMove=(%d,%d,%d)\n", v8, v44, v45);
      if ( v8 == 4 || v45 )
        pantilt_cmd(&v44);
    }
    if ( !v8 || v8 == 2 || v8 == 6 || v8 == 8 )
    {
      v9 = 5000;
      do
      {
        usleep(1000);
        v49 = 0;
        v50 = 0;
        v51 = 0;
        v48 = 20;
        pantilt_cmd(&v48);
        --v9;
      }
      while ( (v49 & 3) != 0 && v9 > 0 );
      v46 = 0;
      v47 = 0;
      if ( v8 != 2 && (v8 < 3 || v8 == 6) )
      {
        v44 = 5;
        v45 = v5;
      }
      else
      {
        v44 = 6;
        v45 = v5;
      }
      trace(1, (int)"PanTiltSingleMove=(%d,%d,%d)\n", v8, v44, v45);
      if ( v45 )
        pantilt_cmd(&v44);
    }
  }
  if ( websTestVar(a1, (int)"PanTiltPresetPositionMove") )
  {
    v27 = websGetVar(a1, (int)"PanTiltPresetPositionMove", (int)byte_4A2DDC);
    v28 = atoi(v27);
    if ( v28 )
    {
      if ( (unsigned int)(v28 - 1) < 0x18 )
        gotopresetion(v28);
    }
    else
    {
      v48 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      v32 = (void *)nvram_bufget(0, "HomePosition");
      v33 = strdupWithoutNull(v32);
      v34 = v33;
      if ( v33 )
      {
        v35 = (_BYTE *)strchr(v33, 47);
        if ( v35 )
        {
          *v35 = 0;
          v48 = 9;
          v36 = v35 + 1;
          v50 = atoi(v34);
          v37 = v50;
          v51 = atoi(v36);
          trace(1, (int)"Go to Home Position=>(%d,%d)\n", v37, v51);
        }
        else
        {
          v48 = 1;
          trace(1, (int)"Go to Default Home Position\n");
        }
        if ( v34 )
          free2(v34);
        pantilt_cmd(&v48);
      }
    }
  }
  if ( websTestVar(a1, (int)"PanTiltHorizontal") )
  {
    if ( websTestVar(a1, (int)"PanTiltVertical") )
    {
      if ( websTestVar(a1, (int)"SetPosition") )
      {
        if ( websTestVar(a1, (int)"SetName") )
        {
          v20 = websGetVar(a1, (int)"PanTiltHorizontal", (int)byte_4A2DDC);
          v22 = atoi(v20);
          v21 = websGetVar(a1, (int)"PanTiltVertical", (int)byte_4A2DDC);
          v24 = atoi(v21);
          v23 = websGetVar(a1, (int)"SetPosition", (int)byte_4A2DDC);
          v25 = atoi(v23);
          v26 = (char *)websGetVar(a1, (int)"SetName", (int)byte_4A2DDC);
          if ( (unsigned int)(v25 - 1) < 0x18 )
          {
            snprintf(v52, 64, "SetPosition%d", v25);
            snprintf(v56, 64, "%s/%d/%d", v26, v22, v24);
            trace(1, (int)"PanTilt Set Preset Position=>(%s=%s)\n", (char *)v52, v56);
            nvram_bufset(0, v52, v56);
            nvram_commit(0);
          }
        }
      }
    }
  }
  if ( websTestVar(a1, (int)"ClearPosition") )
  {
    v18 = websGetVar(a1, (int)"ClearPosition", (int)byte_4A2DDC);
    v19 = atoi(v18);
    if ( (unsigned int)(v19 - 1) < 0x18 )
    {
      snprintf(&v48, 64, "SetPosition%d", v19);
      trace(1, (int)"ClearPosition=%s\n", (char *)&v48);
      nvram_bufset(0, &v48, byte_4A2DDC);
      nvram_commit(0);
    }
  }
  if ( websTestVar(a1, (int)"PanTiltHorizontal") )
  {
    if ( websTestVar(a1, (int)"PanTiltVertical") )
    {
      if ( websTestVar(a1, (int)"PanTiltPositionMove") )
      {
        v15 = websGetVar(a1, (int)"PanTiltPositionMove", (int)byte_4A2DDC);
        if ( !strncasecmp(v15, "true", 4) && strlen(v15) == 4 )
        {
          v48 = 9;
          v49 = 0;
          v50 = 0;
          v51 = 0;
          v16 = websGetVar(a1, (int)"PanTiltHorizontal", (int)byte_4A2DDC);
          v50 = atoi(v16);
          v17 = websGetVar(a1, (int)"PanTiltVertical", (int)byte_4A2DDC);
          v51 = atoi(v17);
          trace(1, (int)"PanTilt Move Position=(%d,%d)\n", v50, v51);
          pantilt_cmd(&v48);
        }
      }
    }
  }
  if ( websTestVar(a1, (int)"SetCurrentPosition") )
  {
    if ( websTestVar(a1, (int)"SetName") )
    {
      v48 = 4;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      pantilt_cmd(&v48);
      v10 = v50;
      v11 = v51;
      v12 = websGetVar(a1, (int)"SetCurrentPosition", (int)byte_4A2DDC);
      v13 = atoi(v12);
      v14 = (char *)websGetVar(a1, (int)"SetName", (int)byte_4A2DDC);
      if ( (unsigned int)(v13 - 1) < 0x18 )
      {
        snprintf(v52, 64, "SetPosition%d", v13);
        snprintf(v56, 64, "%s/%d/%d", v14, v10, v11);
        trace(1, (int)"PanTilt Set Preset Current Position=>(%s=%s)\n", (char *)v52, v56);
        nvram_bufset(0, v52, v56);
        nvram_commit(0);
      }
    }
  }
  if ( websTestVar(a1, (int)"SetHomePosition") )
  {
    v52[0] = 4;
    v52[1] = 0;
    v53 = 0;
    v54 = 0;
    pantilt_cmd(v52);
    snprintf(v55, 64, "%d/%d", v53, v54);
    nvram_bufset(0, "HomePosition", v55);
    nvram_commit(0);
  }
  if ( websTestVar(a1, (int)"ResetHomePosition") )
  {
    nvram_bufset(0, "HomePosition", byte_4A2DDC);
    nvram_commit(0);
  }
  return websReplyNoContent(a1);
}
// 43A2A8: conditional instruction was optimized away because $s3.4==0
// 43AD64: conditional instruction was optimized away because $s3.4==8
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4EA040: using guessed type int   strncasecmp(_DWORD, _DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA090: using guessed type int   usleep(_DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (0043ADC4) --------------------------------------------------------
int *  ptzpresetlist(int a1)
{
  int v2; // $fp
  int i; // $s0
  _BYTE *v4; // $v0
  int v5; // $v0
  int v6; // $s2
  int v7; // $v0
  int v9; // $v0
  _BYTE v10[64]; // [sp+20h] [-1090h] BYREF
  _BYTE v11[64]; // [sp+60h] [-1050h] BYREF
  _BYTE v12[2048]; // [sp+A0h] [-1010h] BYREF
  _BYTE v13[2048]; // [sp+8A0h] [-810h] BYREF
  char *v14; // [sp+10A0h] [-10h] BYREF
  char *v15; // [sp+10A4h] [-Ch] BYREF
  char *v16; // [sp+10A8h] [-8h] BYREF

  if ( (*(_DWORD *)(a1 + 228) & 1) != 0 )
  {
    trace(1, (int)"ptzpresetlist Invalid method\n");
    snprintf(v10, 64, "400 Bad Request");
    v9 = strlen(v10);
    websWriteNormalHeader(a1, 400, v9, "application/Dlink-inf", 0);
    websWriteFmt(a1, (int)v10);
    return websConnClose(a1, 400);
  }
  else
  {
    memset(v12, 0, sizeof(v12));
    memset(v13, 0, sizeof(v13));
    strcat(v12, "presets=");
    v2 = 0;
    for ( i = 1; i < 25; ++i )
    {
      while ( 1 )
      {
        memset(v11, 0, sizeof(v11));
        snprintf(v11, 64, "SetPosition%d", i);
        v4 = (_BYTE *)nvram_bufget(0, v11);
        if ( v4 )
        {
          if ( *v4 )
          {
            v5 = strdupWithoutNull(v4);
            v6 = v5;
            if ( v5 )
            {
              v16 = byte_4A2DDC;
              v15 = byte_4A2DDC;
              v14 = byte_4A2DDC;
              ParseSetPoition(v5, &v14, &v15, &v16, byte_4A2DDC);
              if ( v15 && *v15 && v16 && *v16 )
              {
                if ( v2 )
                  snprintf(v10, 64, ",%s", v14);
                else
                  snprintf(v10, 64, "%s", v14);
                strcat(v12, v10);
                snprintf(v10, 64, "%s=%s,%s\r\n", v14, v15, v16);
                strcat(v13, v10);
                ++v2;
              }
              if ( v6 )
                break;
            }
          }
        }
        if ( ++i >= 25 )
          goto LABEL_16;
      }
      free2(v6);
    }
LABEL_16:
    strcat(v12, "\r\n");
    strcat(v12, v13);
    v7 = strlen(v12);
    websWriteNormalHeader(a1, 200, v7, "application/Dlink-inf", 0);
    websWriteFmt(a1, (int)v12);
    return websConnClose(a1, 200);
  }
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA00C: using guessed type int   strcat(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (0043B1E0) --------------------------------------------------------
int *  ptzpreset(int a1)
{
  int v2; // $s1
  int v3; // $v0
  int v4; // $a0
  int v5; // $a1
  char *Var; // $s7
  int v8; // $fp
  int v9; // $s4
  BOOL v10; // $a2
  bool v11; // dc
  int v12; // $s1
  int v13; // $s1
  BOOL v14; // $a1
  _BYTE *v15; // $v0
  char **v16; // $a2
  int v17; // $s0
  BOOL v18; // $t3
  _BYTE *v19; // $v0
  int v20; // $s0
  char *v21; // $s5
  char *v22; // $fp
  int v23; // $s1
  BOOL v24; // $t3
  _BYTE *v25; // $v0
  char **v26; // $a2
  int v27; // $s0
  int v28; // $fp
  int v29; // $s6
  char *v30; // $a2
  int v31; // $v0
  char v32[64]; // [sp+20h] [-A0h] BYREF
  char v33[64]; // [sp+60h] [-60h] BYREF
  int v34; // [sp+A0h] [-20h] BYREF
  int v35; // [sp+A4h] [-1Ch]
  int v36; // [sp+A8h] [-18h]
  int v37; // [sp+ACh] [-14h]
  char *v38; // [sp+B0h] [-10h] BYREF
  char *v39; // [sp+B4h] [-Ch] BYREF
  char *v40; // [sp+B8h] [-8h] BYREF
  char *v41; // [sp+BCh] [-4h]

  v2 = 0;
  if ( !websTestVar(a1, (int)"name") || !websTestVar(a1, (int)"act") )
  {
    trace(1, (int)"ptzpreset Invalid argument\n");
    snprintf(v32, 64, "400 Bad Request");
    v3 = strlen(v32);
    goto LABEL_4;
  }
  Var = (char *)websGetVar(a1, (int)"name", (int)byte_4A2DDC);
  v41 = (char *)websGetVar(a1, (int)"act", (int)byte_4A2DDC);
  v8 = 0;
  v9 = 0;
  if ( !strcmp(v41, "add") )
  {
    v2 = 4;
  }
  else if ( !strcmp(v41, "del") )
  {
    v2 = 5;
  }
  else if ( !strcmp(v41, "go") )
  {
    v2 = 2;
  }
  v10 = v2 < 5;
  if ( v2 == 4 )
  {
    v23 = 1;
    while ( 1 )
    {
      memset(v33, 0, sizeof(v33));
      snprintf(v33, 64, "SetPosition%d", v23);
      v25 = (_BYTE *)nvram_bufget(0, v33);
      if ( !v25 || !*v25 )
        break;
      v27 = strdupWithoutNull(v25);
      v26 = &v39;
      if ( !v27 )
        goto LABEL_39;
      v40 = byte_4A2DDC;
      v39 = byte_4A2DDC;
      v38 = byte_4A2DDC;
      ParseSetPoition(v27, &v38, &v39, &v40, byte_4A2DDC);
      ++v8;
      if ( !strcmp(Var, v38) )
      {
        free2(v27);
        v9 = v23;
LABEL_47:
        if ( !v9 )
        {
          trace(1, (int)"ptzpreset add table full\n", v26);
          snprintf(v32, 64, "presetsnum=%d", v8);
          v31 = strlen(v32);
          goto LABEL_54;
        }
        if ( *Var && (unsigned int)strlen(Var) < 0x21 )
        {
          v34 = 4;
          v35 = 0;
          v36 = 0;
          v37 = 0;
          pantilt_cmd(&v34);
          v28 = v36;
          v29 = v37;
          snprintf(v33, 64, "SetPosition%d", v9);
          snprintf(v32, 64, "%s/%d/%d", Var, v28, v29);
          trace(1, (int)"ptzpreset Set Preset Current Position=>(%s=%s)\n", v33, v32);
          v30 = v32;
          goto LABEL_52;
        }
        trace(1, (int)"ptzpreset Invalid argument\n", v26);
        snprintf(v32, 64, "400 Bad Request");
        v3 = strlen(v32);
LABEL_4:
        websWriteNormalHeader(a1, 400, v3, "application/Dlink-inf", 0);
        websWriteFmt(a1, (int)v32);
        v4 = a1;
        v5 = 400;
        return websConnClose(v4, v5);
      }
      ++v23;
      free2(v27);
      v24 = v23 < 25;
LABEL_40:
      if ( !v24 )
        goto LABEL_47;
    }
    if ( !v9 )
      v9 = v23;
LABEL_39:
    v24 = ++v23 < 25;
    goto LABEL_40;
  }
  if ( v2 >= 5 )
  {
    v11 = v2 != 5;
    v13 = 1;
    if ( !v11 )
    {
      while ( 1 )
      {
        memset(v33, 0, sizeof(v33));
        snprintf(v33, 64, "SetPosition%d", v13);
        v15 = (_BYTE *)nvram_bufget(0, v33);
        if ( v15 && *v15 && (v17 = strdupWithoutNull(v15), v16 = &v39, v17) )
        {
          v40 = byte_4A2DDC;
          v39 = byte_4A2DDC;
          v38 = byte_4A2DDC;
          ParseSetPoition(v17, &v38, &v39, &v40, byte_4A2DDC);
          ++v8;
          if ( !strcmp(Var, v38) )
          {
            free2(v17);
            if ( !v13 )
            {
LABEL_55:
              trace(1, (int)"ptzpreset no such a preset exists for delete\n", v16);
              snprintf(v32, 64, "presetsnum=%d", v8);
              v31 = strlen(v32);
              goto LABEL_54;
            }
            snprintf(v33, 64, "SetPosition%d", v13);
            trace(1, (int)"ptzpreset ClearPosition=%s\n", v33);
            v30 = byte_4A2DDC;
LABEL_52:
            nvram_bufset(0, v33, v30);
            nvram_commit(0);
            goto LABEL_53;
          }
          ++v13;
          free2(v17);
          v14 = v13 < 25;
        }
        else
        {
          v14 = ++v13 < 25;
        }
        if ( !v14 )
          goto LABEL_55;
      }
    }
    goto LABEL_11;
  }
  v11 = v2 == 2;
  v12 = 1;
  if ( !v11 )
  {
LABEL_11:
    trace(1, (int)"ptzpreset Invalid argument\n", v10);
    snprintf(v32, 64, "400 Bad Request");
    v3 = strlen(v32);
    goto LABEL_4;
  }
  while ( 1 )
  {
    memset(v33, 0, sizeof(v33));
    snprintf(v33, 64, "SetPosition%d", v12);
    v19 = (_BYTE *)nvram_bufget(0, v33);
    ++v12;
    if ( v19 )
    {
      if ( *v19 )
      {
        v20 = strdupWithoutNull(v19);
        if ( v20 )
          break;
      }
    }
    v18 = v12 < 25;
LABEL_27:
    if ( !v18 )
      goto LABEL_53;
  }
  v40 = byte_4A2DDC;
  v39 = byte_4A2DDC;
  v38 = byte_4A2DDC;
  ParseSetPoition(v20, &v38, &v39, &v40, byte_4A2DDC);
  if ( !v38 || (v21 = v39) == 0 || (v22 = v40) == 0 || strcmp(Var, v38) )
  {
    free2(v20);
    v18 = v12 < 25;
    goto LABEL_27;
  }
  v34 = 9;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v36 = atoi(v21);
  v37 = atoi(v22);
  pantilt_cmd(&v34);
  trace(1, (int)"ptzpreset Goto Position=>(%s=%d,%d)\n", Var, v36, v37);
LABEL_53:
  snprintf(v32, 64, "name=%s\r\nact=%s\r\n", Var, v41);
  v31 = strlen(v32);
LABEL_54:
  websWriteNormalHeader(a1, 200, v31, "application/Dlink-inf", 0);
  websWriteFmt(a1, (int)v32);
  v4 = a1;
  v5 = 200;
  return websConnClose(v4, v5);
}
// 43B664: conditional instruction was optimized away because $s0.4!=0
// 43B7E8: variable 'v26' is possibly undefined
// 43B988: variable 'v16' is possibly undefined
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (0043BB00) --------------------------------------------------------
int *  ptzmovepos(int a1)
{
  int v2; // $s2
  int v3; // $s0
  int v4; // $s1
  int v5; // $v0
  int Var; // $v0
  int v8; // $v0
  int v9; // [sp+20h] [-70h] BYREF
  int v10; // [sp+24h] [-6Ch]
  int v11; // [sp+28h] [-68h]
  int v12; // [sp+2Ch] [-64h]
  int v13[4]; // [sp+30h] [-60h] BYREF
  _BYTE v14[64]; // [sp+40h] [-50h] BYREF
  int v15; // [sp+80h] [-10h] BYREF
  int v16; // [sp+84h] [-Ch] BYREF
  int v17; // [sp+88h] [-8h] BYREF
  int v18; // [sp+8Ch] [-4h] BYREF

  v2 = 5000;
  if ( websTestVar(a1, (int)"p") )
  {
    v9 = 4;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    pantilt_cmd(&v9);
    v3 = v11;
    v4 = v12;
    if ( !websTestVar(a1, (int)"p") )
      goto LABEL_3;
LABEL_18:
    Var = websGetVar(a1, (int)"p", (int)&word_4A0308);
    v3 = atoi(Var);
    if ( !websTestVar(a1, (int)"t") )
      goto LABEL_4;
LABEL_19:
    v8 = websGetVar(a1, (int)"t", (int)&word_4A0308);
    v4 = atoi(v8);
    goto LABEL_4;
  }
  if ( !websTestVar(a1, (int)"t") )
    goto LABEL_15;
  v9 = 4;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  pantilt_cmd(&v9);
  v3 = v11;
  v4 = v12;
  if ( websTestVar(a1, (int)"p") )
    goto LABEL_18;
LABEL_3:
  if ( websTestVar(a1, (int)"t") )
    goto LABEL_19;
LABEL_4:
  get_pantilt_range(&v15, &v16, &v17, &v18);
  if ( v15 < v3 )
    v3 = v15;
  if ( v3 < v16 )
    v3 = v16;
  if ( v17 < v4 )
    v4 = v17;
  if ( v4 < v18 )
    v4 = v18;
  v13[2] = v3;
  v13[0] = 9;
  v13[3] = v4;
  v13[1] = 0;
  pantilt_cmd(v13);
  do
  {
    usleep(1000);
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v9 = 20;
    pantilt_cmd(&v9);
    --v2;
  }
  while ( (v10 & 3) != 0 && v2 > 0 );
LABEL_15:
  v9 = 4;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  pantilt_cmd(&v9);
  snprintf(v14, 64, "p=%d\r\nt=%d\r\n", v11, v12);
  v5 = strlen(v14);
  websWriteNormalHeader(a1, 200, v5, "application/Dlink-inf", 0);
  websWriteFmt(a1, (int)v14);
  return websConnClose(a1, 200);
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4EA090: using guessed type int   usleep(_DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (0043BE7C) --------------------------------------------------------
int *  ptzmoverel(int a1)
{
  int Var; // $v0
  int v3; // $v0
  int v4; // $s2
  int v5; // $s0
  int v6; // $s1
  BOOL v7; // $v0
  int v8; // $v0
  int v10; // $s5
  int v11; // $s3
  int v12; // $v0
  int v13; // [sp+20h] [-60h] BYREF
  int v14; // [sp+24h] [-5Ch]
  int v15; // [sp+28h] [-58h]
  int v16; // [sp+2Ch] [-54h]
  int v17[4]; // [sp+30h] [-50h] BYREF
  _BYTE v18[64]; // [sp+40h] [-40h] BYREF

  Var = websGetVar(a1, (int)"p", (int)&word_4A0308);
  v4 = atoi(Var);
  v3 = websGetVar(a1, (int)"t", (int)&word_4A0308);
  v5 = atoi(v3);
  v6 = 5000;
  if ( websTestVar(a1, (int)"p") )
  {
    v7 = (unsigned int)(v4 + 32) < 0x41;
  }
  else
  {
    if ( !websTestVar(a1, (int)"t") )
    {
LABEL_4:
      trace(1, (int)"ptzmoverel Invalid argument=(%d,%d)\n", v4, v5);
      snprintf(v18, 64, "400 Bad Request");
      v8 = strlen(v18);
      websWriteNormalHeader(a1, 400, v8, "application/Dlink-inf", 0);
      websWriteFmt(a1, (int)v18);
      return websConnClose(a1, 400);
    }
    v7 = (unsigned int)(v4 + 32) < 0x41;
  }
  if ( !v7 || (unsigned int)(v5 + 32) >= 0x41 )
    goto LABEL_4;
  trace(1, (int)"ptzmoverel=(%d,%d)\n", v4, v5);
  v13 = 4;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  pantilt_cmd(&v13);
  v10 = v15;
  v11 = v16;
  v17[0] = 9;
  v17[2] = v15 + v4;
  v17[3] = v16 + v5;
  v17[1] = 0;
  pantilt_cmd(v17);
  do
  {
    usleep(1000);
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v13 = 20;
    pantilt_cmd(&v13);
    --v6;
  }
  while ( (v14 & 3) != 0 && v6 > 0 );
  v13 = 4;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  pantilt_cmd(&v13);
  snprintf(v18, 64, "p=%d\r\nt=%d\r\n", v15 - v10, v16 - v11);
  v12 = strlen(v18);
  websWriteNormalHeader(a1, 200, v12, "application/Dlink-inf", 0);
  websWriteFmt(a1, (int)v18);
  return websConnClose(a1, 200);
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4EA090: using guessed type int   usleep(_DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (0043C1FC) --------------------------------------------------------
int *  ptzhome(int a1)
{
  int v2; // $s3
  int v3; // $s2
  int v4; // $s1
  int v5; // $s5
  int Var; // $s0
  int v7; // $v0
  int v9; // $v0
  void *v10; // $v0
  int v11; // $v0
  int v12; // $s1
  _BYTE *v13; // $v0
  _BYTE *v14; // $s0
  int v15; // $v0
  int v16; // $v0
  void *v17; // $v0
  int v18; // $v0
  int v19; // $s6
  _BYTE *v20; // $v0
  _BYTE *v21; // $s2
  int v22; // [sp+20h] [-70h] BYREF
  int v23; // [sp+24h] [-6Ch]
  int v24; // [sp+28h] [-68h]
  int v25; // [sp+2Ch] [-64h]
  int v26[4]; // [sp+30h] [-60h] BYREF
  _BYTE v27[64]; // [sp+40h] [-50h] BYREF
  int v28; // [sp+80h] [-10h] BYREF
  int v29; // [sp+84h] [-Ch] BYREF
  int v30; // [sp+88h] [-8h] BYREF
  int v31; // [sp+8Ch] [-4h] BYREF

  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 5000;
  if ( websTestVar(a1, (int)"act") )
  {
    Var = websGetVar(a1, (int)"act", (int)byte_4A2DDC);
    if ( strcmp(Var, "get") )
    {
      if ( !strcmp(Var, "set") )
      {
        v4 = 1;
      }
      else if ( !strcmp(Var, "go") )
      {
        v4 = 2;
      }
      else if ( !strcmp(Var, "reset") )
      {
        v4 = 3;
      }
    }
    if ( v4 == 1 )
    {
      if ( websTestVar(a1, (int)"p") && websTestVar(a1, (int)"t") )
      {
        v15 = websGetVar(a1, (int)"p", (int)&word_4A0308);
        v2 = atoi(v15);
        v16 = websGetVar(a1, (int)"t", (int)&word_4A0308);
        v3 = atoi(v16);
        get_pantilt_range(&v28, &v29, &v30, &v31);
        if ( v28 < v2 )
          v2 = v28;
        if ( v2 < v29 )
          v2 = v29;
        if ( v30 < v3 )
          v3 = v30;
        if ( v3 < v31 )
          v3 = v31;
      }
      else
      {
        v22 = 4;
        v23 = 0;
        v24 = 0;
        v25 = 0;
        pantilt_cmd(&v22);
        v2 = v24;
        v3 = v25;
      }
      snprintf(v27, 64, "%d/%d", v2, v3);
      nvram_bufset(0, "HomePosition", v27);
      nvram_commit(0);
      trace(1, (int)"Set Home Position=>(%d,%d)\n", v2, v3);
    }
    else if ( v4 < 2 )
    {
      v10 = (void *)nvram_bufget(0, "HomePosition");
      v11 = strdupWithoutNull(v10);
      v12 = v11;
      if ( v11 )
      {
        v13 = (_BYTE *)strchr(v11, 47);
        if ( v13 )
        {
          *v13 = 0;
          v14 = v13 + 1;
          v2 = atoi(v12);
          v3 = atoi(v14);
        }
        else
        {
          v22 = 2;
          v23 = 0;
          v24 = 0;
          v25 = 0;
          pantilt_cmd(&v22);
          v2 = v24;
          v3 = v25;
        }
        if ( v12 )
          free2(v12);
        trace(1, (int)"Get Home Position=>(%d,%d)\n", v2, v3);
      }
    }
    else if ( v4 == 2 )
    {
      v17 = (void *)nvram_bufget(0, "HomePosition");
      v18 = strdupWithoutNull(v17);
      v19 = v18;
      if ( v18 )
      {
        v20 = (_BYTE *)strchr(v18, 47);
        if ( v20 )
        {
          *v20 = 0;
          v21 = v20 + 1;
          v2 = atoi(v19);
          v3 = atoi(v21);
        }
        else
        {
          v22 = 2;
          v23 = 0;
          v24 = 0;
          v25 = 0;
          pantilt_cmd(&v22);
          v2 = v24;
          v3 = v25;
        }
        if ( v19 )
          free2(v19);
      }
      trace(1, (int)"Go to Home Position=>(%d,%d)\n", v2, v3);
      v26[0] = 9;
      v26[2] = v2;
      v26[3] = v3;
      v26[1] = 0;
      pantilt_cmd(v26);
      do
      {
        usleep(1000);
        v23 = 0;
        v24 = 0;
        v25 = 0;
        v22 = 20;
        pantilt_cmd(&v22);
        --v5;
      }
      while ( (v23 & 3) != 0 && v5 > 0 );
      v22 = 4;
      v23 = 0;
      v24 = 0;
      v25 = 0;
      pantilt_cmd(&v22);
      v2 = v24;
      v3 = v25;
    }
    else
    {
      v22 = 2;
      v23 = 0;
      v24 = 0;
      v25 = 0;
      pantilt_cmd(&v22);
      v2 = v24;
      v3 = v25;
      trace(1, (int)"Reset Home Position=>(%d,%d)\n", v24, v25);
      nvram_bufset(0, "HomePosition", byte_4A2DDC);
      nvram_commit(0);
    }
    snprintf(v27, 64, "p=%d\r\nt=%d\r\n", v2, v3);
    v7 = strlen(v27);
    websWriteNormalHeader(a1, 200, v7, "application/Dlink-inf", 0);
    websWriteFmt(a1, (int)v27);
    return websConnClose(a1, 200);
  }
  else
  {
    trace(1, (int)"ptzhome Invalid argument\n");
    snprintf(v27, 64, "400 Bad Request");
    v9 = strlen(v27);
    websWriteNormalHeader(a1, 400, v9, "application/Dlink-inf", 0);
    websWriteFmt(a1, (int)v27);
    return websConnClose(a1, 400);
  }
}
// 43C2B8: conditional instruction was optimized away because $s1.4==3
// 43C494: conditional instruction was optimized away because $s1.4==0
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F6C: using guessed type int   nvram_bufset(_DWORD, _DWORD, _DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA090: using guessed type int   usleep(_DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (0043C9BC) --------------------------------------------------------
int *  ptzpatrolpan(int a1)
{
  int v2; // $v0
  int v4; // $v0
  _BYTE v5[64]; // [sp+20h] [-40h] BYREF

  if ( (*(_DWORD *)(a1 + 228) & 1) != 0 )
  {
    trace(1, (int)"ptzpatrolpan Invalid method\n", "autopan=0\r\nautopatrol=0\r\n");
    snprintf(v5, 64, "400 Bad Request");
    v4 = strlen(v5);
    websWriteNormalHeader(a1, 400, v4, "application/Dlink-inf", 0);
    websWriteFmt(a1, (int)v5);
    return websConnClose(a1, 400);
  }
  else
  {
    snprintf(v5, 64, "autopan=0\r\nautopatrol=0\r\n");
    v2 = strlen(v5);
    websWriteNormalHeader(a1, 200, v2, "application/Dlink-inf", 0);
    websWriteFmt(a1, (int)v5);
    return websConnClose(a1, 200);
  }
}
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (0043CB3C) --------------------------------------------------------
int *  ptzptdc(int a1)
{
  int v2; // $s1
  int Var; // $s0
  int v4; // $v0
  _BYTE v6[256]; // [sp+38h] [-120h] BYREF

  v2 = 0;
  if ( websTestVar(a1, (int)"command") )
  {
    Var = websGetVar(a1, (int)"command", (int)byte_4A2DDC);
    if ( strcmp(Var, "get_pos") )
    {
      if ( !strcmp(Var, "get_boundary") )
      {
        v2 = 1;
      }
      else if ( !strcmp(Var, "get_view_angle") )
      {
        v2 = 2;
      }
      else if ( !strcmp(Var, "set_relative_pos") )
      {
        v2 = 3;
      }
      else if ( !strcmp(Var, "go_home") )
      {
        v2 = 4;
      }
    }
    // __asm { jr      $t0  # loc_43CBF4 loc_43CD1C loc_43CECC loc_43CF18 loc_43CF9C } delete
  }
  trace(1, (int)"ptzptdc Invalid argument or method\n");
  snprintf(v6, 256, "400 Bad Request");
  v4 = strlen(v6);
  websWriteNormalHeader(a1, 400, v4, "text/xml", 0);
  websWriteFmt(a1, (int)v6);
  return websConnClose(a1, 400);
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (0043D2C0) --------------------------------------------------------
int *  audiodetection(int a1)
{
  int v2; // $s3
  int v3; // $s3
  char *v4; // $s2
  int v5; // $v0
  int Var; // $s2
  char *v8; // $s0
  char *v9; // $a2

  trace(1, (int)"audiodetection(wp->query=%s)!\n", *(char **)(a1 + 160));
  v2 = 0;
  if ( (*(_DWORD *)(a1 + 228) & 1) == 0 && !**(_BYTE **)(a1 + 160) )
    goto LABEL_6;
  if ( websTestVar(a1, (int)"enable") )
  {
    Var = websGetVar(a1, (int)"enable", (int)"no");
    if ( !strcmp(Var, "no") )
    {
      v9 = (char *)&word_4A0308;
    }
    else
    {
      if ( strcmp(Var, "yes") )
      {
        v2 = 1;
        goto LABEL_4;
      }
      v9 = "1";
    }
    websSetVar(a1, "SoundDetectionEnable", v9);
  }
LABEL_4:
  if ( websTestVar(a1, (int)"sounddblevel") )
  {
    v8 = (char *)websGetVar(a1, (int)"sounddblevel", (int)&word_4A0308);
    if ( (unsigned int)atoi(v8) < 0x65 )
      websSetVar(a1, "SoundDetectionDB", v8);
    else
      v2 |= 1u;
  }
  if ( !v2 )
  {
    websSetVar(a1, "SoundDetectionScheduleMode", (char *)&word_4A0308);
    if ( !CheckSoundDBVar(a1) )
    {
      if ( SystemSoundDBChanged(a1) )
      {
        WriteSoundDBVar(a1);
        nvram_commit(0);
        setSysInfoLong(57, 0x10000000);
        trace(1, (int)"Sound Detection settings was changed!\n");
      }
    }
  }
LABEL_6:
  v3 = nvram_bufget(0, "SoundDetectionEnable");
  v4 = (char *)nvram_bufget(0, "SoundDetectionDB");
  websWriteNormalHeader(a1, 200, 0, "application/Dlink-inf", 0);
  v5 = atoi(v3);
  if ( v5 )
  {
    if ( v5 == 1 )
      websWriteFmt(a1, (int)"enable=yes\r\n");
  }
  else
  {
    websWriteFmt(a1, (int)"enable=no\r\n");
  }
  websWriteFmt(a1, (int)"sounddblevel=%s\r\n", v4);
  return websConnClose(a1, 200);
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0043D6A4) --------------------------------------------------------
int *  nipcauserverify(int a1)
{
  int v2; // $v1
  char *v3; // $a2
  int v4; // $v0
  _BYTE v6[64]; // [sp+20h] [-40h] BYREF

  memset(v6, 0, sizeof(v6));
  v2 = *(_DWORD *)(a1 + 192);
  v3 = "group=Administrator\r\n";
  if ( v2 == 3
    || (v3 = "group=Controller\r\n", v2 == 2)
    || (v3 = "group=User\r\n", v2 == 1)
    || (v3 = "group=None\r\n", !v2) )
  {
    snprintf(v6, 64, v3);
  }
  v4 = strlen(v6);
  websWriteNormalHeader(a1, 200, v4, "application/Dlink-inf", 0);
  websWriteFmt(a1, (int)v6);
  return websConnClose(a1, 200);
}
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (0043D7E0) --------------------------------------------------------
int *  nipcacamerainfo(int a1)
{
  int v2; // $s2
  char *v3; // $v0
  char *v4; // $s2
  int v5; // $v0
  char *Var; // $s0
  char *v8; // $s0
  void *v9; // $s0
  int v10; // $s2
  int v11; // $s0
  _BYTE v12[1024]; // [sp+20h] [-400h] BYREF

  trace(1, (int)"nipcacamerainfo(wp->query=%s)!\n", *(char **)(a1 + 160));
  v2 = 0;
  if ( (*(_DWORD *)(a1 + 228) & 1) == 0 && !**(_BYTE **)(a1 + 160) )
    goto LABEL_6;
  if ( !websTestVar(a1, (int)"name") )
  {
LABEL_4:
    if ( !websTestVar(a1, (int)"location") )
      goto LABEL_5;
    goto LABEL_10;
  }
  Var = (char *)websGetVar(a1, (int)"name", (int)byte_4A2DDC);
  if ( !checkcameraname(a1, (int)Var, 1, 32, 0) )
  {
    websSetVar(a1, "CameraName", Var);
    goto LABEL_4;
  }
  v2 = 1;
  if ( !websTestVar(a1, (int)"location") )
    goto LABEL_5;
LABEL_10:
  v8 = (char *)websGetVar(a1, (int)"location", (int)byte_4A2DDC);
  trace(1, (int)"nipcacamerainfo(location=%s)!\n", v8);
  if ( !checkmaxstring(a1, (int)v8, 64, 0) )
  {
    websSetVar(a1, "Location", v8);
LABEL_5:
    if ( v2 )
      goto LABEL_6;
    goto LABEL_12;
  }
  if ( v2 | 1 )
    goto LABEL_6;
LABEL_12:
  if ( !CheckSystemVar(a1) )
  {
    v9 = (void *)nvram_bufget(0, "CameraName");
    v10 = websGetVar(a1, (int)"CameraName", (int)byte_4A2DDC);
    v11 = strdupWithoutNull(v9);
    WriteSystemVar(a1);
    nvram_commit(0);
    if ( v11 )
    {
      if ( v10 && strcmp(v11, v10) )
        doSystem((int)"cameraname.sh &");
      free2(v11);
    }
  }
LABEL_6:
  nvram_bufget(0, "Location");
  websGetVar(a1, (int)"Location", (int)byte_4A2DDC);
  v4 = (char *)nvram_bufget(0, "CameraName");
  v3 = (char *)nvram_bufget(0, "Location");
  snprintf(v12, 1024, "name=%s\r\nlocation=%s\r\n", v4, v3);
  v5 = strlen(v12);
  websWriteNormalHeader(a1, 200, v5, "application/Dlink-inf", 0);
  websWriteFmt(a1, (int)v12);
  return websConnClose(a1, 200);
}
// 43DB6C: conditional instruction was optimized away because $s0.4!=0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (0043DBEC) --------------------------------------------------------
int *  nipcarebootdevice(int a1)
{
  int Var; // $v0
  int v3; // $s1
  char *v4; // $a1
  int v5; // $a0

  Var = websGetVar(a1, (int)"reboot", (int)byte_4A2DDC);
  v3 = 0;
  if ( !strcmp(Var, "go") )
  {
    if ( LockCriticalCMD <= 0 )
    {
      ++LockCriticalCMD;
      v3 = 1;
      if ( getSysInfoShort(65) != 2 )
      {
        doSystem((int)"sleep %d && reboot &", 3);
        set_reboot_time(3, 1);
      }
    }
    else
    {
      PendRebootCMD = 3;
      PendRebootMode = 1;
    }
  }
  websWriteNormalHeader(a1, 200, 0, "application/Dlink-inf", 0);
  v4 = "reboot=yes\r\n";
  v5 = a1;
  if ( v3 != 1 )
  {
    v5 = a1;
    v4 = "reboot=fail\r\n";
  }
  websWriteFmt(v5, (int)v4);
  return websConnClose(a1, 200);
}
// 4E34C0: using guessed type int PendRebootMode;
// 4E34C4: using guessed type int PendRebootCMD;
// 4E34C8: using guessed type int LockCriticalCMD;
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (0043DD4C) --------------------------------------------------------
int *  nipcafactoryreset(int a1)
{
  int Var; // $v0
  int v3; // $s1
  char *v4; // $a1
  int v5; // $a0

  Var = websGetVar(a1, (int)"reset", (int)byte_4A2DDC);
  v3 = 0;
  if ( !strcmp(Var, "go") )
  {
    if ( LockCriticalCMD <= 0 )
    {
      ++LockCriticalCMD;
      doSystem((int)"ralink_init clear 2860");
      v3 = 1;
      doSystem((int)"ralink_init renew 2860 /etc_ro/Wireless/RT2860AP/RT2860_default_vlan");
      if ( getSysInfoShort(65) != 2 )
      {
        doSystem((int)"sleep %d && reboot &", 3);
        set_reboot_time(3, 0);
      }
    }
    else
    {
      PendRebootCMD = 3;
      PendRebootMode = 0;
    }
  }
  websWriteNormalHeader(a1, 200, 0, "application/Dlink-inf", 0);
  v4 = "reset=yes\r\n";
  v5 = a1;
  if ( v3 != 1 )
  {
    v5 = a1;
    v4 = "reset=fail\r\n";
  }
  websWriteFmt(v5, (int)v4);
  return websConnClose(a1, 200);
}
// 4E34C0: using guessed type int PendRebootMode;
// 4E34C4: using guessed type int PendRebootCMD;
// 4E34C8: using guessed type int LockCriticalCMD;
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (0043DEDC) --------------------------------------------------------
int *  nipcamicrophone(int a1)
{
  int v2; // $s1
  int v3; // $s0
  int v4; // $s1
  int v5; // $v0
  int v7; // $s0
  int Var; // $s0
  char *v9; // $s0
  _BYTE v10[64]; // [sp+20h] [-48h] BYREF
  _DWORD v11[2]; // [sp+60h] [-8h] BYREF

  trace(1, (int)"nipcamicrophone(wp->query=%s)!\n", *(char **)(a1 + 160));
  v2 = 0;
  if ( (*(_DWORD *)(a1 + 228) & 1) != 0 || **(_BYTE **)(a1 + 160) )
  {
    if ( websTestVar(a1, (int)"enable") )
    {
      Var = websGetVar(a1, (int)"enable", (int)&word_4A0308);
      if ( !strcmp(Var, "no") )
      {
        websSetVar(a1, "AudioEnable", (char *)&word_4A0308);
      }
      else if ( !strcmp(Var, "yes") )
      {
        websSetVar(a1, "AudioEnable", "1");
      }
      else
      {
        v2 = 1;
      }
    }
    if ( websTestVar(a1, (int)"volume") )
    {
      v9 = (char *)websGetVar(a1, (int)"volume", (int)&word_4A0308);
      if ( checkenumrange(a1, (int)v9, (_BYTE **)&audiovol_select) )
        v2 |= 1u;
      else
        websSetVar(a1, "AudioVolume", v9);
    }
    if ( !v2 && !CheckStreamVar(a1) && StreamAudioChanged(a1) )
    {
      WriteStreamVar(a1);
      nvram_commit(0);
      v11[0] = 0;
      v11[1] = 0;
      setSysInfoBuffer(94, (int)v11, 1);
      setSysInfoLong(57, 32);
      trace(1, (int)"Audio settings was changed!\n");
    }
    v3 = nvram_bufget(0, "AudioEnable");
    v4 = nvram_bufget(0, "AudioVolume");
    if ( !strcmp(v3, "1") )
      goto LABEL_7;
LABEL_10:
    snprintf(v10, 64, "enable=no\r\nvolume=%s\r\n", v4);
    goto LABEL_8;
  }
  v7 = nvram_bufget(0, "AudioEnable");
  v4 = nvram_bufget(0, "AudioVolume");
  if ( strcmp(v7, "1") )
    goto LABEL_10;
LABEL_7:
  snprintf(v10, 64, "enable=yes\r\nvolume=%s\r\n", v4);
LABEL_8:
  v5 = strlen(v10);
  websWriteNormalHeader(a1, 200, v5, "application/Dlink-inf", 0);
  websWriteFmt(a1, (int)v10);
  return websConnClose(a1, 200);
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F8C: using guessed type int   nvram_commit(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (0043E2EC) --------------------------------------------------------
int *  nipcaportalinfo(int a1)
{
  int v2; // $s0
  int v3; // $s2
  int v4; // $s5
  int v5; // $s4
  int v6; // $s0
  int v7; // $v0
  int v8; // $v0
  int v9; // $v0
  char *SelectString; // $v0
  int v11; // $v0
  char *v12; // $v0

  v2 = nvram_bufget(0, "AudioEnable");
  v3 = nvram_bufget(0, "AudioVolume");
  v4 = nvram_bufget(0, "MotionDetectionEnable");
  v5 = nvram_bufget(0, "VideoResolution");
  websWriteNormalHeader(a1, 200, 0, "application/Dlink-inf", 0);
  if ( !strcmp(v2, "1") )
    websWriteFmt(a1, (int)"mic_enable=yes\r\nmic_volume=%s\r\n", v3);
  else
    websWriteFmt(a1, (int)"mic_enable=no\r\nmic_volume=%s\r\n", v3);
  websWriteFmt(a1, (int)"spk_enable=NA\r\nspk_volume=NA\r\n");
  v6 = nvram_bufget(0, "DayNightMode");
  if ( !strcmp(v6, &word_4A0308) )
  {
    websWriteFmt(a1, (int)"icr_mode=auto\r\n");
  }
  else if ( !strcmp(v6, "1") )
  {
    websWriteFmt(a1, (int)"icr_mode=manual\r\n");
  }
  else if ( !strcmp(v6, "2") )
  {
    websWriteFmt(a1, (int)"icr_mode=day\r\n");
  }
  else if ( !strcmp(v6, "3") )
  {
    websWriteFmt(a1, (int)"icr_mode=night\r\n");
  }
  else
  {
    if ( !strcmp(v6, "4") )
    {
      websWriteFmt(a1, (int)"icr_mode=schedule\r\n");
      websWriteFmt(a1, (int)"dgtalkie=no\r\n");
      v7 = nvram_bufget(0, "SoundDetectionEnable");
      if ( strcmp(v7, "1") )
        goto LABEL_9;
LABEL_14:
      websWriteFmt(a1, (int)"adt_enable=yes\r\n");
      if ( strcmp(v4, "1") )
        goto LABEL_10;
LABEL_15:
      websWriteFmt(a1, (int)"md_enable=yes\r\n");
      goto LABEL_16;
    }
    websWriteFmt(a1, (int)"icr_mode=invalid\r\n");
  }
  websWriteFmt(a1, (int)"dgtalkie=no\r\n");
  v8 = nvram_bufget(0, "SoundDetectionEnable");
  if ( !strcmp(v8, "1") )
    goto LABEL_14;
LABEL_9:
  websWriteFmt(a1, (int)"adt_enable=no\r\n");
  if ( !strcmp(v4, "1") )
    goto LABEL_15;
LABEL_10:
  websWriteFmt(a1, (int)"md_enable=no\r\n");
LABEL_16:
  websWriteFmt(a1, (int)"sd_status=NA\r\nsd_total=NA\r\nsd_used=NA\r\nsd_free=NA\r\n");
  websWriteFmt(a1, (int)"rec_enable=NA\r\nrec_type=NA\r\nrec_profileid=NA\r\nrec_file_formate=NA\r\n");
  websWriteFmt(a1, (int)"vprofilenum=2\r\n");
  websWriteFmt(a1, (int)"vprofile1=MJPEG\r\n");
  websWriteFmt(a1, (int)"vprofileurl1=/video.cgi\r\n");
  websWriteFmt(a1, (int)"vDprofileurl1=/dgvideo.cgi\r\n");
  v9 = atoi(v5);
  SelectString = (char *)websGetSelectString(resolution_select, v9);
  websWriteFmt(a1, (int)"vprofileres1=%s\r\n", SelectString);
  websWriteFmt(a1, (int)"vprofile2=H264\r\n");
  websWriteFmt(a1, (int)"vprofileurl2=/h264.mpt\r\n");
  websWriteFmt(a1, (int)"vDprofileurl2=/dgh264.mpt\r\n");
  v11 = atoi(v5);
  v12 = (char *)websGetSelectString(resolution_select, v11);
  websWriteFmt(a1, (int)"vprofileres2=%s\r\n", v12);
  return websConnClose(a1, 200);
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E378C: using guessed type char *resolution_select[3];
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0043E858) --------------------------------------------------------
int   websFrameProcessor(int a1)
{
  unsigned int v2; // $s5
  int v3; // $s2
  char *v4; // $s4
  int v5; // $s0
  char *v6; // $v1
  int v7; // $v0
  int *v8; // $t0
  int v9; // $s1
  char *TempFileName; // $v0
  int v12; // $v0
  int *v13; // $t0
  _BYTE *v14; // $s0
  int v15; // $a2
  char *v16; // $a3
  int Var; // $v0
  int v18; // $v0
  int v19; // $s0
  int v20; // $a1
  int v21; // $a0
  int v22; // $v0
  __int16 v23; // $v0
  int v24; // $v0
  int v25; // $s0
  int v26; // $v0
  int v27[2]; // [sp+28h] [-1B0h] BYREF
  int v28; // [sp+30h] [-1A8h]
  int v29; // [sp+34h] [-1A4h]
  _BYTE v30[256]; // [sp+38h] [-1A0h] BYREF
  _BYTE v31[64]; // [sp+138h] [-A0h] BYREF
  _DWORD v32[4]; // [sp+178h] [-60h] BYREF
  _BYTE v33[64]; // [sp+188h] [-50h] BYREF
  int v34; // [sp+1C8h] [-10h] BYREF
  int v35; // [sp+1CCh] [-Ch] BYREF
  int v36; // [sp+1D0h] [-8h] BYREF
  int v37; // [sp+1D4h] [-4h] BYREF

  trace(1, (int)"websFrameProcessor=%s\n", *(char **)(a1 + 136));
  v2 = -2;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  if ( off_4E5074 )
  {
    v6 = (char *)&framesupportPathList;
    while ( 1 )
    {
      v7 = webncasestrcmp(*(_DWORD *)(a1 + 136), *((_DWORD *)v6 + 1));
      v8 = (int *)((char *)&framesupportPathList + v5);
      if ( !v7 )
        break;
      ++v3;
      v5 = 8 * v3;
      v6 = (char *)&framesupportPathList + 8 * v3;
      if ( !*((_DWORD *)v6 + 1) )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    v8 = (int *)((char *)&framesupportPathList + v5);
  }
  v9 = *v8;
  if ( *v8 == 4 )
  {
    TempFileName = (char *)websGetTempFileName();
    v4 = TempFileName;
    if ( TempFileName )
    {
      doSystem((int)"echo \"#The following line must not be removed.\" > %s", TempFileName);
      doSystem((int)"echo \"Restore\" >> %s", v4);
      doSystem((int)"ralink_init show 2860 >> %s", v4);
    }
  }
  switch ( v9 )
  {
    case 0:
      v2 = fork();
      switch ( v2 )
      {
        case 0u:
          v26 = getpid();
          trace(16, (int)"now in the frame child process(%d, %s).\n", v26, *(char **)(a1 + 144));
          if ( v9 )
            exit(0);
          snapimage(a1);
          exit(0);
        case 0xFFFFFFFF:
          trace(16, (int)"\nframe fork process failure.\n");
          websConnError(a1, 501, (int)"Fork process failure.");
          break;
        case 0xFFFFFFFE:
          trace(16, (int)"\ntask busy.\n");
          websConnError(a1, 501, (int)"task busy.");
          break;
        default:
          v12 = AllocEntry(&dword_4E7CFC, &dword_4E5150, 16);
          if ( v12 >= 0 )
          {
            v13 = *(int **)(4 * v12 + dword_4E7CFC);
            v13[3] = v3;
            *v13 = a1;
            v13[1] = v2;
            v13[2] = v9;
            websTimeoutCancel(a1);
          }
          break;
      }
      break;
    case 1:
      authorizationmode(a1);
      break;
    case 2:
      resetdevice(a1);
      break;
    case 3:
      v14 = v33;
      memset(v33, 0, sizeof(v33));
      snprintf(v33, 64, "%s", "3.9.3");
      v15 = strlen(v33);
      v16 = "text/html";
      goto LABEL_24;
    case 4:
      getconfig(a1, v4);
      break;
    case 5:
      iocontrol(a1);
      break;
    case 6:
      Var = websGetVar(a1, (int)"AudioMute", (int)&word_4A0308);
      v19 = atoi(Var);
      v18 = websGetVar(a1, (int)"REMOTE_ADDR", (int)byte_4A2DDC);
      v20 = inet_addr(v18);
      if ( v19 )
      {
        if ( v19 == 1 )
          setSysInfoLong(52, v20);
      }
      else
      {
        setSysInfoLong(51, v20);
      }
      goto LABEL_31;
    case 7:
      v21 = nvram_bufget(0, "DayNightMode");
      if ( (*(_DWORD *)(a1 + 228) & 1) != 0 && !strcmp(v21, "1") && websTestVar(a1, (int)"IRLed") )
      {
        v22 = websGetVar(a1, (int)"IRLed", (int)&word_4A0308);
        v23 = atoi(v22);
        setSysInfoShort(74, v23);
      }
LABEL_31:
      websReplyNoContent(a1);
      break;
    case 8:
      pantiltcontrol(a1);
      break;
    case 9:
      get_pantilt_range(&v34, &v35, &v36, &v37);
      v14 = v30;
      snprintf(v30, 256, "pmax=%d\r\npmin=%d\r\ntmax=%d\r\ntmin=%d\r\ncustomizedhome=yes\r\n", v34, v35, v36, v37);
      v24 = strlen(v30);
      goto LABEL_39;
    case 10:
      v27[0] = 4;
      v27[1] = 0;
      v28 = 0;
      v29 = 0;
      pantilt_cmd(v27);
      v14 = v31;
      snprintf(v31, 64, "p=%d\r\nt=%d\r\n", v28, v29);
      v24 = strlen(v31);
LABEL_39:
      v15 = v24;
      v16 = "application/Dlink-inf";
LABEL_24:
      websWriteNormalHeader(a1, 200, v15, v16, 0);
      websWriteFmt(a1, (int)v14);
      goto LABEL_25;
    case 11:
      ptzpresetlist(a1);
      break;
    case 12:
      ptzpreset(a1);
      break;
    case 13:
      ptzmovepos(a1);
      break;
    case 14:
      ptzmoverel(a1);
      break;
    case 15:
      ptzhome(a1);
      break;
    case 16:
      ptzpatrolpan(a1);
      break;
    case 18:
      ptzptdc(a1);
      break;
    case 19:
      memset(v32, 0, sizeof(v32));
      getSysInfoBuffer(94, (int)v32, 1);
      v25 = SLOBYTE(v32[0]);
      websWriteNormalHeader(a1, 200, 0, "application/Dlink-inf", 0);
      websWriteFmt(a1, (int)"audio_detect_val=%d\r\n", v25);
LABEL_25:
      websConnClose(a1, 200);
      break;
    case 20:
      audiodetection(a1);
      break;
    case 21:
      nipcauserverify(a1);
      break;
    case 22:
      nipcacamerainfo(a1);
      break;
    case 23:
      nipcarebootdevice(a1);
      break;
    case 24:
      nipcafactoryreset(a1);
      break;
    case 25:
      nipcamicrophone(a1);
      break;
    case 26:
      nipcaportalinfo(a1);
      break;
    default:
      websConnError(a1, 500, (int)"Not Implemented");
      break;
  }
  if ( v2 >= 0xFFFFFFFE && v9 == 4 && v4 )
  {
    remove(v4);
    free2(v4);
  }
  return 1;
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E5074: using guessed type char *off_4E5074;
// 4E5150: using guessed type int dword_4E5150;
// 4E7CFC: using guessed type int dword_4E7CFC;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F3C: using guessed type void   __noreturn exit(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FC0: using guessed type int fork(void);
// 4EA004: using guessed type int   inet_addr(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA064: using guessed type int   remove(_DWORD);
// 4EA088: using guessed type int getpid(void);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (0043F138) --------------------------------------------------------
void websFrameReapChildren()
{
  int i; // $s2
  int *v1; // $s0
  int v2; // $s1
  BOOL v3; // $v0
  void (*v4)(); // $t9
  _BYTE v5[8]; // [sp+18h] [-8h] BYREF

  for ( i = 0; dword_4E5150 >= i; ++i )
  {
    v1 = *(int **)(4 * i + dword_4E7CFC);
    if ( v1 )
    {
      v2 = *v1;
      v3 = websReapChildren(v1[1], (int)v5);
      v4 = websRefreshCookieDigest;
      if ( !v3 )
      {
        websConnClose(v2, 200);
        trace(16, (int)"frame child exited(%d)!\n", v1[1]);
        dword_4E5150 = FreeEntryId(&dword_4E7CFC, i);
        v4 = (void (*)())&free;
      }
      v4();
    }
  }
}
// 4E5150: using guessed type int dword_4E5150;
// 4E7CFC: using guessed type int dword_4E7CFC;
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (0043F264) --------------------------------------------------------
int *  imagepush(int a1, int a2, char *a3, int a4, int a5)
{
  int *result; // $v0
  int *v10; // $s2
  _DWORD *v11; // $v0
  char *v12; // $v0

  result = (int *)websSocketGetPtr(*(_DWORD *)(a1 + 212));
  v10 = result;
  if ( result )
  {
    if ( a2 && a2 != 2 )
    {
      websWriteSpecialHeader(
        a1,
        200,
        0,
        0,
        0,
        (int)"Content-Type: multipart/x-mixed-replace;boundary=%s\r\n",
        &Webboundary[2]);
      fcntl(v10[28], 2);
      result = (int *)execve(a3, a4, a5);
      if ( result != (int *)-1 )
        return result;
LABEL_7:
      puts("content-type: text/html\n\nExecution of cgi process failed");
      v11 = (_DWORD *)_errno_location();
      v12 = (char *)strerror(*v11);
      return trace(16, (int)"Can't execve %s: %s\n", a3, v12);
    }
    websWriteSpecialHeader(
      a1,
      200,
      0,
      0,
      0,
      (int)"Content-Type: multipart/x-mixed-replace;boundary=%s\r\n",
      Webboundary);
    fcntl(v10[28], 2);
    result = (int *)execve(a3, a4, a5);
    if ( result == (int *)-1 )
      goto LABEL_7;
  }
  return result;
}
// 4E9F08: using guessed type int   fcntl(_DWORD, _DWORD);
// 4E9F40: using guessed type int _errno_location(void);
// 4EA074: using guessed type int   puts(_DWORD);
// 4EA08C: using guessed type int   execve(_DWORD, _DWORD, _DWORD);
// 4EA0AC: using guessed type int   strerror(_DWORD);

//----- (0043F464) --------------------------------------------------------
int *  h264videopush(int a1, int a2, char *a3, int a4, int a5)
{
  int *result; // $v0
  int *v10; // $s1
  _DWORD *v11; // $v0
  char *v12; // $v0

  result = (int *)websSocketGetPtr(*(_DWORD *)(a1 + 212));
  v10 = result;
  if ( result )
  {
    if ( a2 != 12 )
    {
      websWriteNormalHeader(a1, 200, 0, (char *)(a1 + 68), 0);
      fcntl(v10[28], 2);
      result = (int *)execve(a3, a4, a5);
      if ( result != (int *)-1 )
        return result;
LABEL_6:
      puts("content-type: text/html\n\nExecution of cgi process failed");
      v11 = (_DWORD *)_errno_location();
      v12 = (char *)strerror(*v11);
      return trace(16, (int)"Can't execve %s: %s\n", a3, v12);
    }
    websWriteSpecialHeader(
      a1,
      200,
      0,
      0,
      0,
      (int)"Content-Type: multipart/x-mixed-replace;boundary=%s\r\n",
      &Webboundary[2]);
    fcntl(v10[28], 2);
    result = (int *)execve(a3, a4, a5);
    if ( result == (int *)-1 )
      goto LABEL_6;
  }
  return result;
}
// 4E9F08: using guessed type int   fcntl(_DWORD, _DWORD);
// 4E9F40: using guessed type int _errno_location(void);
// 4EA074: using guessed type int   puts(_DWORD);
// 4EA08C: using guessed type int   execve(_DWORD, _DWORD, _DWORD);
// 4EA0AC: using guessed type int   strerror(_DWORD);

//----- (0043F648) --------------------------------------------------------
int   websStreamProcessor(int a1, int a2, int a3, int a4, char *a5)
{
  int v6; // $a0
  int v7; // $s4
  int Ptr; // $s7
  char **v9; // $s1
  int *v10; // $s0
  bool v11; // dc
  int v12; // $t0
  int v13; // $s1
  char **v14; // $v0
  char **v15; // $s6
  int v16; // $s3
  int v17; // $s0
  char **v18; // $t4
  int v19; // $a2
  int v20; // $a1
  int v21; // $a3
  int *v22; // $s2
  char *v23; // $v0
  char *v24; // $v0
  char *v25; // $v0
  int v26; // $s0
  int v27; // $v0
  int v28; // $s0
  char **v29; // $t1
  int v30; // $a2
  BOOL v31; // $a2
  int v32; // $a0
  unsigned int v33; // $ra
  int *v34; // $s0
  int v35; // $a0
  int v37; // $v0
  char *v38; // $v0
  int v39; // $s0
  int v40; // $a0
  char *v41; // $v0
  int v42; // $v0
  int *v43; // $t3
  unsigned int v44; // $t5
  char *v45; // $t4
  char *v46; // $v0
  int v47; // $s0
  char *Var; // $v0
  char **v49; // $s0
  char *v50; // $a0
  int *v51; // $s0
  int v52; // $a0
  int v53; // $v0
  char *i; // $a0
  int v55; // $a0
  int v56; // $a1
  int v57; // $v0
  int v58; // $v0
  char **v59; // $s0
  char *v60; // $s1
  int v61; // $s0
  char *v62; // $a3
  _DWORD *v63; // $v0
  int v64; // $v0
  char *v65; // $s0
  int v66; // $v0
  _DWORD *v67; // $v0
  int v68; // $v0
  _WORD v69[4]; // [sp+20h] [-18h] BYREF
  char *v70; // [sp+28h] [-10h] BYREF
  int v71; // [sp+2Ch] [-Ch]
  unsigned int v72; // [sp+30h] [-8h]
  int v73; // [sp+34h] [-4h]

  v6 = *(_DWORD *)(a1 + 212);
  v70 = 0;
  v7 = 0;
  Ptr = websSocketGetPtr(v6);
  trace(1, (int)"websStreamProcessor=%s\n", *(char **)(a1 + 136));
  v72 = -2;
  v73 = 0;
  if ( off_4E5158[0] )
  {
    v9 = off_4E5158;
    v10 = (int *)off_4E5158;
    do
    {
      v9 += 3;
      if ( !webncasestrcmp(*(_DWORD *)(a1 + 136), *v10) )
        break;
      ++v7;
      v10 += 3;
      v11 = *v9 != 0;
      v73 = 2 * v7;
    }
    while ( v11 );
  }
  v12 = 4 * (v73 + v7);
  v13 = *(_DWORD *)((char *)&StearmSupportPathList + v12);
  if ( v13 == 15 )
  {
    websConnError(a1, 500, (int)"Not Implemented");
    return 1;
  }
  allocFmtString((int *)&v70, 254, (int)"%s", *(char **)((char *)&StearmSupportPathList + v12 + 8));
  trace(1, (int)"streamPath=%s\n", v70);
  if ( !v70 )
  {
    websConnError(a1, 503, (int)"Insufficient memory");
    return 1;
  }
  if ( !access(v70, 1) )
  {
    v14 = (char **)mmalloc(40);
    v15 = v14;
    v71 = 10;
    if ( v14 )
    {
      *v14 = v70;
      v16 = 1;
      if ( !strchr(a5, 61) )
      {
        v53 = strlen(a5);
        websDecodeUrl(a5, a5, v53);
        for ( i = a5; ; i = 0 )
        {
          v55 = strtok(i, " ");
          if ( !v55 )
            break;
          v56 = v71;
          v57 = v16++;
          v11 = v16 < v71;
          v15[v57] = (char *)v55;
          if ( !v11 )
          {
            v58 = mmalloc(8 * v56);
            v59 = (char **)v58;
            if ( v58 )
            {
              memcpy(v58, v15, 4 * v71);
              if ( v15 )
                free2(v15);
              v15 = v59;
              v71 *= 2;
            }
          }
        }
      }
      v15[v16] = 0;
      v17 = 0;
      if ( *v15 )
      {
        v18 = v15;
        do
        {
          v19 = v17++;
          trace(1, (int)"Stream argp%2d==>%s\n", v19, *v18);
          v18 = &v15[v17];
        }
        while ( *v18 );
      }
    }
    v22 = (int *)mmalloc(256);
    if ( !v22 )
      goto LABEL_32;
    v23 = *(char **)(a1 + 172);
    if ( !v23 )
      v23 = byte_4A2DDC;
    allocFmtString(v22, 254, (int)"%s=%s", "REMOTE_USER", v23);
    v24 = *(char **)(a1 + 164);
    if ( !v24 )
      v24 = byte_4A2DDC;
    allocFmtString(v22 + 1, 254, (int)"%s=%s", "AUTH_TYPE", v24);
    if ( (*(_DWORD *)(a1 + 228) & 1) != 0 )
      v25 = "POST";
    else
      v25 = "GET";
    allocFmtString(v22 + 2, 254, (int)"%s=%s", "HTTP_REQUEST", v25);
    v26 = 3;
    if ( Ptr )
    {
      allocFmtString(v22 + 3, 254, (int)"%s=%d", "SOCK_HANDLE", *(_DWORD *)(Ptr + 112));
      allocFmtString(v22 + 4, 254, (int)"%s=%d", "SOCK_PORT", *(_DWORD *)(Ptr + 104));
      v26 = 5;
    }
    if ( !v13 || v13 == 2 || v13 == 1 )
    {
      if ( v13 == 2 )
        v38 = "1";
      else
        v38 = (char *)&word_4A0308;
      allocFmtString(&v22[v26], 254, (int)"%s=%s", "MOTION_DETECTION", v38);
      allocFmtString(&v22[v26 + 1], 254, (int)"%s=%s", "HTTP_BOUNDRY", Webboundary);
      allocFmtString(&v22[v26 + 2], 254, (int)"%s=%s", "HTTP_CONTENTTYPE", Webcontenttypejpeg);
      v39 = v26 + 3;
      if ( v13 && (v40 = v39, v13 != 2) )
      {
        v41 = "1";
      }
      else
      {
        v40 = v39;
        v41 = (char *)&word_4A0308;
      }
      allocFmtString(&v22[v40], 254, (int)"%s=%s", "MULTI_PART", v41);
      v26 = v39 + 1;
    }
    if ( v13 == 9 )
    {
      Var = (char *)websGetVar(a1, (int)"Profile", (int)"1");
      allocFmtString(&v22[v26], 254, (int)"%s=%s", "HTTP_PROFILE", Var);
      allocFmtString(&v22[v26 + 1], 254, (int)"%s=%s", "HTTP_FILETYPE", "flv");
      v26 += 2;
    }
    if ( (unsigned int)(v13 - 10) < 3 )
    {
      v46 = (char *)websGetVar(a1, (int)"Profile", (int)"1");
      allocFmtString(&v22[v26], 254, (int)"%s=%s", "HTTP_PROFILE", v46);
      allocFmtString(&v22[v26 + 1], 254, (int)"%s=%s", "HTTP_FILETYPE", "raw");
      v47 = v26 + 2;
      if ( v13 == 10 )
        allocFmtString(&v22[v47++], 254, (int)"%s=%s", "HTTP_TIMEFRAME", (char *)&word_4A0308);
      if ( v13 == 11 )
        allocFmtString(&v22[v47++], 254, (int)"%s=%s", "HTTP_TIMEFRAME", "1");
      v21 = 12;
      v27 = v47;
      if ( v13 != 12 )
        goto LABEL_29;
      allocFmtString(&v22[v47], 254, (int)"%s=%s", "HTTP_TIMEFRAME", "2");
      allocFmtString(&v22[v47 + 1], 254, (int)"%s=%s", "HTTP_BOUNDRY", Webboundary);
      allocFmtString(&v22[v47 + 2], 254, (int)"%s=%s", "HTTP_CONTENTTYPE", Webcontenttypeh264);
      v26 = v47 + 3;
    }
    v27 = v26;
LABEL_29:
    v22[v27] = 0;
    v20 = *v22;
    v28 = 0;
    if ( *v22 )
    {
      v29 = (char **)v22;
      do
      {
        v30 = v28++;
        trace(1, (int)"Stream envp%2d==>%s\n", v30, *v29);
        v21 = v22[v28];
        v29 = (char **)&v22[v28];
      }
      while ( v21 );
    }
LABEL_32:
    if ( !v13
      || (v31 = 1, v13 == 2)
      || v13 == 1
      || v13 == 3
      || v13 == 5
      || (v32 = 9, v13 == 6)
      || v13 == 9
      || v13 == 10
      || v13 == 11
      || v13 == 12
      || v13 == 13
      || v13 == 4
      || v13 == 14 )
    {
      getSysInfoBuffer(70, (int)v69, 4);
    }
    if ( (!v13
       || (v20 = 1, v13 == 2)
       || v13 == 1
       || v13 == 9
       || (v21 = 11, v13 == 10)
       || v13 == 11
       || v13 == 12
       || v13 == 13
       || v13 == 14)
      && (v31 = v69[0] < 10)
      || (v13 == 3 || (v32 = 6, v13 == 5) || v13 == 6 || (v33 = v13 - 7, v13 == 4)) && (v33 = v13 - 7, v69[1] < 10)
      || v33 < 2 )
    {
      v72 = fork(v32, v20, v31, v21);
      if ( !v72 )
      {
        v37 = getpid();
        trace(
          16,
          (int)"now in the stream child process(%d, %s, %s).\n",
          v37,
          *(char **)(a1 + 144),
          *((char **)&StearmSupportPathList + v73 + v7 + 2));
        switch ( v13 )
        {
          case 0:
          case 1:
          case 2:
            imagepush(a1, v13, v70, (int)v15, (int)v22);
            break;
          case 3:
          case 8:
            v60 = v70;
            v61 = websSocketGetPtr(*(_DWORD *)(a1 + 212));
            if ( !v61 )
              goto LABEL_82;
            v62 = "audio/x-wav";
            goto LABEL_131;
          case 4:
            v60 = v70;
            v61 = websSocketGetPtr(*(_DWORD *)(a1 + 212));
            if ( !v61 )
              goto LABEL_82;
            v62 = "audio/ACAS";
LABEL_131:
            websWriteNormalHeader(a1, 200, 0, v62, 0);
            fcntl(*(_DWORD *)(v61 + 112), 2);
            if ( execve(v60, v15, v22) != -1 )
              goto LABEL_82;
            puts("content-type: text/html\n\nExecution of cgi process failed");
            v63 = (_DWORD *)_errno_location();
            v64 = strerror(*v63);
            trace(16, (int)"Can't execve %s: %s\n", v60, v64);
            break;
          case 7:
            v65 = v70;
            v66 = websSocketGetPtr(*(_DWORD *)(a1 + 212));
            if ( !v66 )
              goto LABEL_82;
            if ( (*(_DWORD *)(a1 + 228) & 1) != 0 )
            {
              websConnError(a1, 405, (int)"Method Not Allowed.");
            }
            else
            {
              fcntl(*(_DWORD *)(v66 + 112), 2);
              if ( execve(v65, v15, v22) != -1 )
LABEL_82:
                exit(0);
              puts("content-type: text/html\n\nExecution of cgi process failed");
              v67 = (_DWORD *)_errno_location();
              v68 = strerror(*v67);
              trace(16, (int)"Can't execve %s: %s\n", v65, v68);
            }
            break;
          case 9:
          case 10:
          case 11:
          case 12:
            h264videopush(a1, v13, v70, (int)v15, (int)v22);
            break;
          default:
            goto LABEL_82;
        }
        exit(0);
      }
    }
    if ( v72 < 0xFFFFFFFE )
    {
      v42 = AllocEntry(&dword_4E7D00, &dword_4E5250, 28);
      if ( v42 < 0 )
      {
        v49 = v15;
        if ( v15 )
        {
          v50 = *v15;
          if ( *v15 )
          {
            do
            {
              free2(v50);
              *v49++ = 0;
              if ( !v49 )
                break;
              v50 = *v49;
            }
            while ( *v49 );
          }
        }
        v51 = v22;
        if ( v22 )
        {
          v52 = *v22;
          if ( *v22 )
          {
            do
            {
              free2(v52);
              *v51++ = 0;
              if ( !v51 )
                break;
              v52 = *v51;
            }
            while ( *v51 );
          }
        }
        if ( v70 )
        {
          free2(v70);
          v70 = 0;
        }
        if ( v15 )
          free2(v15);
        if ( v22 )
          free2(v22);
      }
      else
      {
        v43 = *(int **)(4 * v42 + dword_4E7D00);
        v44 = v72;
        v43[5] = v13;
        v43[4] = v44;
        v43[6] = v7;
        v45 = v70;
        v43[2] = (int)v15;
        v43[1] = (int)v45;
        v43[3] = (int)v22;
        *v43 = a1;
        websTimeoutCancel(a1);
      }
    }
    else
    {
      v34 = v22;
      if ( v22 )
      {
        v35 = *v22;
        if ( *v22 )
        {
          do
          {
            free2(v35);
            *v34++ = 0;
            if ( !v34 )
              break;
            v35 = *v34;
          }
          while ( *v34 );
        }
      }
      if ( v70 )
      {
        free2(v70);
        v70 = 0;
      }
      if ( v15 )
        free2(v15);
      if ( v22 )
        free2(v22);
      if ( v72 == -1 )
      {
        trace(16, (int)"\nstream fork process failure.\n", v31);
        websConnError(a1, 501, (int)"Fork process failure.");
      }
      else if ( v72 == -2 )
      {
        trace(16, (int)"\ntask busy.\n", v31, v21);
        websConnError(a1, 501, (int)"task busy.");
      }
    }
    return 1;
  }
  websConnError(a1, 500, (int)"Stream CGI process file is not executable");
  if ( v70 )
  {
    free2(v70);
    v70 = 0;
  }
  return 1;
}
// 43FBC4: variable 'v31' is possibly undefined
// 43FBC4: variable 'v21' is possibly undefined
// 43FCDC: variable 'v32' is possibly undefined
// 43FCDC: variable 'v20' is possibly undefined
// 4A0308: using guessed type __int16 word_4A0308;
// 4E5158: using guessed type char *off_4E5158[2];
// 4E5250: using guessed type int dword_4E5250;
// 4E7D00: using guessed type int dword_4E7D00;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F08: using guessed type int   fcntl(_DWORD, _DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F3C: using guessed type void   __noreturn exit(_DWORD);
// 4E9F40: using guessed type int _errno_location(void);
// 4E9F50: using guessed type int   access(_DWORD, _DWORD);
// 4E9FC0: using guessed type int   fork(_DWORD, _DWORD, _DWORD, _DWORD);
// 4E9FCC: using guessed type int   strtok(_DWORD, _DWORD);
// 4EA074: using guessed type int   puts(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);
// 4EA088: using guessed type int getpid(void);
// 4EA08C: using guessed type int   execve(_DWORD, _DWORD, _DWORD);
// 4EA0AC: using guessed type int   strerror(_DWORD);

//----- (004405E0) --------------------------------------------------------
void websStreamReapChildren()
{
  int i; // $s3
  int *v1; // $s1
  int v2; // $s0
  int v3; // $s2
  int v4; // $a0
  int v5; // $s0
  int v6; // $a1
  _DWORD *j; // $s0
  int v8; // $a0
  int v9; // $a0
  int v10; // $a0
  int *v11; // $a0
  int v12; // [sp+20h] [-8h] BYREF

  for ( i = 0; dword_4E5250 >= i; ++i )
  {
    v1 = *(int **)(4 * i + dword_4E7D00);
    if ( v1 )
    {
      v2 = *v1;
      if ( websReapChildren(v1[4], (int)&v12) )
      {
        websRefreshCookieDigest();
      }
      else
      {
        v3 = v1[5];
        v4 = v2;
        v5 = v1[6];
        websConnClose(v4, 200);
        if ( !v3
          || v3 == 2
          || v3 == 1
          || v3 == 3
          || v3 == 5
          || v3 == 6
          || v3 == 7
          || v3 == 8
          || v3 == 9
          || v3 == 10
          || v3 == 11
          || v3 == 12
          || v3 == 13 )
        {
          v6 = 3 * v5;
LABEL_22:
          if ( *((_DWORD *)&StearmSupportPathList + v6 + 2) )
          {
            if ( (v12 & 0x7F) != 0 )
            {
              if ( (unsigned __int8)v12 == 127 )
                trace(16, (int)"stream child(%d, %s) stopped (signal %d)\n", v1[4]);
              else
                trace(16, (int)"stream child(%d, %s) killed (signal %d)\n", v1[4]);
            }
            else
            {
              trace(16, (int)"stream child(%d, %s) exited, status=%d\n", v1[4]);
            }
          }
          else
          {
            trace(16, (int)"child exited!\n");
          }
          dword_4E5250 = FreeEntryId(&dword_4E7D00, i);
          for ( j = (_DWORD *)v1[3]; j; ++j )
          {
            if ( !*j )
              break;
            free2(*j);
            *j = 0;
          }
          v8 = v1[1];
          if ( v8 )
          {
            free2(v8);
            v1[1] = 0;
          }
          v9 = v1[2];
          if ( v9 )
          {
            free2(v9);
            v1[2] = 0;
          }
          v10 = v1[3];
          if ( v10 )
          {
            free2(v10);
            v11 = v1;
            v1[3] = 0;
          }
          else
          {
            v11 = v1;
          }
          free2(v11);
          continue;
        }
        v6 = 3 * v5;
        if ( v3 == 4 )
          goto LABEL_22;
        trace(16, (int)"\nstream child process free.\n");
      }
    }
  }
}
// 4E5250: using guessed type int dword_4E5250;
// 4E7D00: using guessed type int dword_4E7D00;
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (0044091C) --------------------------------------------------------
int InitBlowfish()
{
  int v0; // $t2
  int v1; // $s0
  _DWORD *v2; // $a2
  int v3; // $a3
  int v4; // $t0
  int v5; // $t1
  _DWORD *v6; // $v0
  int *v7; // $v1
  int i; // $v0
  _DWORD *v9; // $t2
  unsigned int v10; // $t0
  int j; // $t3
  int v12; // $t1
  int v13; // $a3
  unsigned __int8 *v14; // $s0
  unsigned int v15; // $a2
  _DWORD *v16; // $t5
  int v17; // $t6
  int v18; // $v1
  int v19; // $a3
  int v20; // $a0
  unsigned int v21; // $t2
  int *v22; // $t4
  int v23; // $t3
  unsigned int v24; // $t8
  int k; // $t8
  int *v26; // $t5
  int v27; // $t6
  int v28; // $a0
  unsigned int v29; // $t1
  int *v30; // $t4
  int v31; // $t3
  unsigned int v32; // $a3
  int result; // $v0
  int v34; // [sp+8h] [-8h]

  v0 = 0;
  do
  {
    v1 = v0;
    v2 = (_DWORD *)((char *)&ks3 + 4 * v0);
    v3 = ks0[v0];
    v4 = ks1[v0];
    v5 = ks2[v0++];
    v6 = &c[v1];
    v6[768] = *v2;
    *v6 = v3;
    v6[256] = v4;
    v6[512] = v5;
  }
  while ( v0 < 256 );
  v7 = &dword_4E8D40;
  for ( i = 17; i >= 0; --i )
    *v7++ = 0;
  v9 = c;
  v10 = 0;
  for ( j = 0; j < 18; ++j )
  {
    v12 = 0;
    v13 = 3;
    v14 = (unsigned __int8 *)&key + v10;
    do
    {
      v15 = keylen;
      --v13;
      v12 = (v12 << 8) | *v14;
      v10 = (unsigned __int16)(v10 + 1);
      if ( (unsigned int)keylen >= 0x39 )
        v15 = 56;
      if ( v10 >= v15 )
        v10 = 0;
      v14 = (unsigned __int8 *)&key + v10;
    }
    while ( v13 >= 0 );
    v9[1024] ^= v12;
    ++v9;
  }
  v16 = c;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  do
  {
    v20 = v18;
    v21 = v19;
    v22 = &dword_4E8D40;
    v23 = 15;
    do
    {
      --v23;
      v24 = v20 ^ *v22;
      v20 = v21
          ^ (((c[HIBYTE(v24)] + *(_DWORD *)((char *)&c[256] + ((v24 >> 14) & 0x3FC)))
            ^ *(_DWORD *)((char *)&c[512] + ((v24 >> 6) & 0x3FC)))
           + c[(unsigned __int8)(v20 ^ *(_BYTE *)v22++) + 768]);
      v21 = v24;
    }
    while ( v23 >= 0 );
    v18 = v24 ^ dword_4E8D84;
    v19 = v20 ^ dword_4E8D80;
    v17 += 2;
    v16[1024] = v24 ^ dword_4E8D84;
    v16[1025] = v19;
    v16 += 2;
  }
  while ( v17 < 18 );
  for ( k = 0; k < 4; ++k )
  {
    v26 = &c[256 * k];
    v27 = 0;
    do
    {
      v28 = v18;
      v29 = v19;
      v30 = &dword_4E8D40;
      v31 = 15;
      do
      {
        --v31;
        v32 = v28 ^ *v30;
        v28 = v29
            ^ (((c[HIBYTE(v32)] + *(_DWORD *)((char *)&c[256] + ((v32 >> 14) & 0x3FC)))
              ^ *(_DWORD *)((char *)&c[512] + ((v32 >> 6) & 0x3FC)))
             + c[(unsigned __int8)(v28 ^ *(_BYTE *)v30++) + 768]);
        v29 = v32;
      }
      while ( v31 >= 0 );
      result = dword_4E8D80;
      v34 = v32 ^ dword_4E8D84;
      v18 = v32 ^ dword_4E8D84;
      v19 = v28 ^ dword_4E8D80;
      v27 += 2;
      *v26 = v34;
      v26[1] = v19;
      v26 += 2;
    }
    while ( v27 < 256 );
  }
  return result;
}
// 4E5654: using guessed type _DWORD ks2[256];
// 4E5A54: using guessed type _DWORD ks1[256];
// 4E5E54: using guessed type _DWORD ks0[256];
// 4E7D3C: using guessed type int keylen;
// 4E7D40: using guessed type _DWORD c[1024];
// 4E8D40: using guessed type int dword_4E8D40;
// 4E8D80: using guessed type int dword_4E8D80;
// 4E8D84: using guessed type int dword_4E8D84;

//----- (00440BD4) --------------------------------------------------------
int   CBlowfish(int a1, unsigned int a2)
{
  unsigned int v3; // $a2
  unsigned int v4; // $a1
  _BYTE *v5; // $v1
  char v6; // $a0

  if ( a2 >= 0x39 )
    a2 = 56;
  keylen = a2;
  v3 = 0;
  if ( a2 )
  {
    v4 = keylen;
    do
    {
      v5 = (char *)&key + v3;
      v6 = *(_BYTE *)(a1 + v3++);
      *v5 = v6;
    }
    while ( v3 < v4 );
  }
  return InitBlowfish();
}
// 4E7D3C: using guessed type int keylen;

//----- (00440C34) --------------------------------------------------------
int   Blowfish_EnCode(int a1, int *a2, unsigned int a3)
{
  unsigned int i; // $a3
  _BYTE *v5; // $v1
  char v6; // $a0
  int *v7; // $t5
  int v8; // $t6
  int v9; // $a0
  unsigned int v10; // $t2
  int *v11; // $t4
  int v12; // $t3
  unsigned int v13; // $a3
  int v14; // $t3

  for ( i = 0; i < a3; *v5 = v6 )
  {
    v5 = (char *)a2 + i;
    v6 = *(_BYTE *)(a1 + i++);
  }
  v7 = a2;
  v8 = 0;
  if ( a3 >> 3 )
  {
    do
    {
      v9 = *v7;
      v10 = v7[1];
      v11 = &dword_4E8D40;
      v12 = 15;
      do
      {
        --v12;
        v13 = v9 ^ *v11;
        v9 = v10
           ^ (((c[HIBYTE(v13)] + *(_DWORD *)((char *)&c[256] + ((v13 >> 14) & 0x3FC)))
             ^ *(_DWORD *)((char *)&c[512] + ((v13 >> 6) & 0x3FC)))
            + c[(unsigned __int8)(v9 ^ *(_BYTE *)v11++) + 768]);
        v10 = v13;
      }
      while ( v12 >= 0 );
      ++v8;
      v14 = v9 ^ dword_4E8D80;
      *v7 = v13 ^ dword_4E8D84;
      v7[1] = v14;
      v7 += 2;
    }
    while ( v8 < (int)(a3 >> 3) );
  }
  return 0;
}
// 4E7D40: using guessed type _DWORD c[1024];
// 4E8D40: using guessed type int dword_4E8D40;
// 4E8D80: using guessed type int dword_4E8D80;
// 4E8D84: using guessed type int dword_4E8D84;

//----- (00440D28) --------------------------------------------------------
int   Blowfish_DeCode(int a1, int *a2, unsigned int a3)
{
  unsigned int i; // $a3
  _BYTE *v5; // $v1
  char v6; // $a0
  int *v7; // $t5
  int v8; // $t6
  int v9; // $a1
  unsigned int v10; // $t2
  int v11; // $t4
  int *v12; // $t3
  unsigned int v13; // $a3
  int v14; // $t3

  for ( i = 0; i < a3; *v5 = v6 )
  {
    v5 = (char *)a2 + i;
    v6 = *(_BYTE *)(a1 + i++);
  }
  v7 = a2;
  v8 = 0;
  if ( a3 >> 3 )
  {
    do
    {
      v9 = *v7;
      v10 = v7[1];
      v11 = 17;
      v12 = &dword_4E8D84;
      do
      {
        --v11;
        v13 = v9 ^ *v12;
        v9 = v10
           ^ (((c[HIBYTE(v13)] + *(_DWORD *)((char *)&c[256] + ((v13 >> 14) & 0x3FC)))
             ^ *(_DWORD *)((char *)&c[512] + ((v13 >> 6) & 0x3FC)))
            + c[(unsigned __int8)(v9 ^ *(_BYTE *)v12--) + 768]);
        v10 = v13;
      }
      while ( v11 >= 2 );
      ++v8;
      v14 = v9 ^ dword_4E8D44;
      *v7 = v13 ^ dword_4E8D40;
      v7[1] = v14;
      v7 += 2;
    }
    while ( v8 < (int)(a3 >> 3) );
  }
  return 0;
}
// 4E7D40: using guessed type _DWORD c[1024];
// 4E8D40: using guessed type int dword_4E8D40;
// 4E8D44: using guessed type int dword_4E8D44;
// 4E8D84: using guessed type int dword_4E8D84;

//----- (00440E20) --------------------------------------------------------
int *  sub_440E20(int *a1)
{
  int v2; // $s4
  int v3; // $s6
  int v4; // $s3
  int v5; // $s5
  int v6; // $s1
  signed int v7; // $s0
  int v8; // $v0
  int *result; // $v0

  websSetTimeStamp(a1);
  v2 = a1[66];
  v3 = a1[65];
  v4 = mmalloc(512);
  v5 = 1000;
  v6 = 0;
  if ( v4 )
  {
    while ( 1 )
    {
      v7 = read(a1[64], v4, 512);
      if ( v7 <= 0 )
        break;
      v6 = websWritePartial((int)a1, v4, v7);
      v8 = v5;
      if ( v6 < 0 )
        break;
      v2 += v6;
      if ( !v6 )
      {
        --v5;
        if ( v8 <= 0 )
          break;
        usleep(5000);
      }
      if ( v6 != v7 )
      {
        lseek(a1[64], v6 - v7, 1);
        break;
      }
    }
    if ( !v7 )
      v2 = v3;
    free2(v4);
  }
  else
  {
    websConnError((int)a1, 200, (int)"Can't allocate read buffer");
  }
  a1[66] = v2;
  if ( v6 < 0 )
    return websConnClose((int)a1, 200);
  result = (int *)(v2 < v3);
  if ( v2 >= v3 || !v5 )
    return websConnClose((int)a1, 200);
  return result;
}
// 440F28: conditional instruction was optimized away because $s3.4!=0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FE0: using guessed type int   read(_DWORD, _DWORD, _DWORD);
// 4EA04C: using guessed type int   lseek(_DWORD, _DWORD, _DWORD);
// 4EA090: using guessed type int   usleep(_DWORD);

//----- (00440FDC) --------------------------------------------------------
int   websGetFileProcessor(int a1, int a2, int a3, void *a4)
{
  unsigned int v6; // $s2
  char *v7; // $s0
  char *v8; // $a0
  int v9; // $v1
  int v10; // $v0
  int v12; // $v0
  _DWORD *v13; // $v0
  char *v14; // $v0
  int v15; // $s5
  unsigned int v16; // $s4
  int v17; // $s2
  char *v18; // $a3
  int v19; // $a0
  _BYTE v20[24]; // [sp+20h] [-98h] BYREF
  int v21; // [sp+38h] [-80h]
  int v22; // [sp+58h] [-60h]

  trace(1, (int)"websGetFileProcessor=%s\n", *(char **)(a1 + 136));
  v6 = *(_DWORD *)(a1 + 228);
  if ( websConnValidateUrl(a1, a4) < 0 )
  {
    websConnError(a1, 500, (int)"Invalid URL");
    return 1;
  }
  v7 = *(char **)(a1 + 148);
  v8 = &v7[strlen(v7) - 1];
  v9 = *v8;
  if ( v9 != 47 && v9 != 92 )
  {
    v10 = open(v7, 0);
    *(_DWORD *)(a1 + 256) = v10;
    if ( v10 >= 0 )
      goto LABEL_5;
LABEL_10:
    v13 = (_DWORD *)_errno_location();
    v14 = (char *)strerror(*v13);
    websConnError(a1, 404, (int)"getfile: Cannot open URL(%s,%s)", *(char **)(a1 + 144), v14);
    return 1;
  }
  *v8 = 0;
  v12 = open(v7, 0);
  *(_DWORD *)(a1 + 256) = v12;
  if ( v12 < 0 )
    goto LABEL_10;
LABEL_5:
  if ( stat(v7, v20) < 0 )
  {
    websConnError(a1, 400, (int)"Cannot stat page for URL(%s)", v7);
    return 1;
  }
  if ( (v21 & 0xF000) != 0x8000 )
  {
    websConnError(a1, 404, (int)"File Not Found");
    return 1;
  }
  v15 = v22;
  if ( ((v6 >> 4) & 1) != 0 )
  {
    v16 = v6 >> 1;
    websWriteNormalHeader(a1, 200, v22, (char *)(a1 + 68), (int)v20);
    if ( ((v6 >> 1) & 1) != 0 || websPatchRequest((_DWORD *)a1, v7) >= 0 )
      goto LABEL_16;
    v17 = (v6 >> 3) & 1;
  }
  else
  {
    v16 = v6 >> 1;
    v17 = (v6 >> 3) & 1;
  }
  v18 = (char *)(a1 + 68);
  if ( v17 )
  {
    websWriteActiveHeader((_DWORD *)a1, 200, 0, v18, (int)v20);
    if ( (v16 & 1) != 0 || websParaRequest(a1, v7) >= 0 )
      goto LABEL_16;
  }
  else
  {
    websWriteNormalHeader(a1, 200, v15, v18, (int)v20);
    if ( (v16 & 1) != 0 )
    {
LABEL_16:
      websConnClose(a1, 200);
      return 1;
    }
    if ( v15 )
      *(_DWORD *)(a1 + 260) = v15;
    if ( *(unsigned __int8 *)(a1 + 228) >> 7 )
    {
      sub_440E20((int *)a1);
    }
    else
    {
      v19 = *(_DWORD *)(a1 + 212);
      *(_DWORD *)(a1 + 268) = sub_440E20;
      websSocketCreateEvent(v19, 4, (int)websSocketEvent, a1);
    }
  }
  return 1;
}
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F40: using guessed type int _errno_location(void);
// 4E9F58: using guessed type int   stat(_DWORD, _DWORD);
// 4EA0AC: using guessed type int   strerror(_DWORD);

//----- (00441344) --------------------------------------------------------
int   websForkGetFileProcessor(int a1)
{
  int v2; // $a0
  int v3; // $a1
  int v4; // $a2
  int v5; // $a3
  int v6; // $s1
  int v7; // $v0
  int v8; // $s0
  int v9; // $v0
  int *v10; // $t6
  int v12; // $v0
  int v13; // $s0
  int v14; // $s6
  int v15; // $v0
  int v16; // $a1
  int v17; // $s5
  int v18; // $s3
  int v19; // $s4
  int v20; // $s0
  _BYTE *v21; // $s1
  signed int v22; // $a2
  int v23; // $v0
  int v24; // $v1
  _BYTE v25[56]; // [sp+20h] [-498h] BYREF
  int v26; // [sp+58h] [-460h]
  _BYTE v27[1024]; // [sp+B8h] [-400h] BYREF

  trace(1, (int)"websForkGetFileProcessor=%s\n", *(char **)(a1 + 136));
  v6 = 0;
  if ( strstr(*(_DWORD *)(a1 + 136), "/media/") )
    v6 = 2;
  v7 = fork(v2, v3, v4, v5);
  v8 = v7;
  if ( !v7 )
  {
    v12 = getpid();
    trace(16, (int)"now in the sdcget child process(%d, %s).\n", v12, *(char **)(a1 + 144));
    if ( !v6 )
      exit(0);
    trace(1, (int)"websMediaFile=%s\n", *(char **)(a1 + 136));
    v13 = 60;
    v14 = 0;
    while ( access(*(_DWORD *)(a1 + 136), 4) && v13 > 0 )
    {
      --v13;
      usleep(100000);
    }
    if ( access(*(_DWORD *)(a1 + 136), 4) )
    {
      websConnError(a1, 404, (int)"sdcget: Cannot open URL(%s)\n", *(char **)(a1 + 144));
    }
    else
    {
      while ( 1 )
      {
        v15 = stat(*(_DWORD *)(a1 + 136), v25);
        if ( v15 >= 0 || v13 <= 0 )
          break;
        --v13;
        trace(1, (int)"websMediaFile delay=%s\n", *(char **)(a1 + 136));
        usleep(100000);
      }
      if ( !v15 )
        v14 = v26;
      websWriteNormalHeader(a1, 200, v14, (char *)(a1 + 68), 0);
      v17 = fopen(*(_DWORD *)(a1 + 136), "r");
      if ( v17 )
      {
        v18 = 1000;
        if ( v14 > 0 )
        {
          do
          {
            v19 = fread(v27, 1, 1024, v17);
            v20 = v19;
            v21 = v27;
            while ( v20 > 0 )
            {
              v22 = v20;
              if ( *(unsigned __int8 *)(a1 + 228) >> 7 && v20 >= 513 )
                v22 = 512;
              v23 = websWritePartial(a1, (int)v21, v22);
              v24 = v18;
              if ( v23 < 0 )
                break;
              if ( v23 )
              {
                v21 += v23;
                v18 = 1000;
                v20 -= v23;
              }
              else
              {
                --v18;
                if ( v24 <= 0 )
                  break;
                usleep(5000);
              }
            }
            if ( v20 )
              break;
            v14 -= v19;
            if ( v14 <= 0 )
              break;
          }
          while ( v18 > 0 );
        }
        fclose(v17);
      }
      websConnClose(a1, 200);
    }
    exit(0);
  }
  if ( v7 == -1 )
  {
    trace(16, (int)"\nsdcget fork process failure.\n");
    websConnError(a1, 501, (int)"Fork process failure.");
  }
  else
  {
    v9 = AllocEntry(&dword_4E8D88, &dword_4E6254, 8);
    if ( v9 >= 0 )
    {
      v10 = *(int **)(4 * v9 + dword_4E8D88);
      v10[1] = v8;
      *v10 = a1;
      websTimeoutCancel(a1);
    }
  }
  return 1;
}
// 4413CC: variable 'v2' is possibly undefined
// 4413CC: variable 'v3' is possibly undefined
// 4413CC: variable 'v4' is possibly undefined
// 4413CC: variable 'v5' is possibly undefined
// 441708: variable 'v16' is possibly undefined
// 4E6254: using guessed type int dword_4E6254;
// 4E8D88: using guessed type int dword_4E8D88;
// 4E9F3C: using guessed type void   __noreturn exit(_DWORD);
// 4E9F50: using guessed type int   access(_DWORD, _DWORD);
// 4E9F58: using guessed type int   stat(_DWORD, _DWORD);
// 4E9F98: using guessed type int   fclose(_DWORD);
// 4E9FA8: using guessed type int   fopen(_DWORD, _DWORD);
// 4E9FB4: using guessed type int   fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 4E9FC0: using guessed type int   fork(_DWORD, _DWORD, _DWORD, _DWORD);
// 4E9FEC: using guessed type int   strstr(_DWORD, _DWORD);
// 4EA088: using guessed type int getpid(void);
// 4EA090: using guessed type int   usleep(_DWORD);

//----- (00441768) --------------------------------------------------------
int websSDCardReapChildren()
{
  int result; // $v0
  int i; // $s2
  int *v2; // $s1
  int v3; // $s0
  char *v4; // $a1
  int v5; // $a3
  int v6; // [sp+18h] [-8h] BYREF

  result = dword_4E6254;
  for ( i = 0; dword_4E6254 >= i; ++i )
  {
    while ( 1 )
    {
      v2 = *(int **)(4 * i + dword_4E8D88);
      if ( v2 )
      {
        v3 = *v2;
        result = websReapChildren(v2[1], (int)&v6);
        if ( !result )
          break;
      }
      if ( dword_4E6254 < ++i )
        return result;
    }
    websConnClose(v3, 200);
    v4 = "sdcget child(%d) exited, status=%d\n";
    v5 = (unsigned __int16)(v6 & 0xFF00) >> 8;
    if ( (v6 & 0x7F) != 0 && (v5 = v6 & 0x7F, v4 = "sdcget child(%d) killed (signal %d)\n", (unsigned __int8)v6 == 127) )
      trace(16, (int)"sdcget child(%d) stopped (signal %d)\n", v2[1], (unsigned __int16)(v6 & 0xFF00) >> 8);
    else
      trace(16, (int)v4, v2[1], v5);
    dword_4E6254 = FreeEntryId(&dword_4E8D88, i);
    result = free2(v2);
  }
  return result;
}
// 4E6254: using guessed type int dword_4E6254;
// 4E8D88: using guessed type int dword_4E8D88;
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (004418E8) --------------------------------------------------------
int   sub_4418E8(int a1)
{
  if ( *(unsigned __int8 *)(a1 + 228) >> 7 )
    return websWriteFmt(a1, (int)"%s", "https");
  else
    return websWriteFmt(a1, (int)"%s", "http");
}

//----- (00441930) --------------------------------------------------------
int   sub_441930(int a1)
{
  void *Var; // $v0
  int v3; // $s3
  int v4; // $v0
  unsigned __int8 *v5; // $s2
  int v6; // $s1
  _BYTE *v7; // $v0
  _BYTE *v8; // $a1
  int v9; // $t7
  int v10; // $a0
  char *v11; // $s0
  char *v12; // $v0
  int v14; // $v0
  _BYTE v15[16]; // [sp+18h] [-10h] BYREF

  Var = (void *)websGetVar(a1, (int)"HTTP_HOST", (int)&word_4A0308);
  v3 = WebSrv_HTTP_Port;
  v4 = strdupWithoutNull(Var);
  v5 = (unsigned __int8 *)v4;
  v6 = 0;
  if ( v4 )
  {
    v7 = (_BYTE *)strchr(v4, 58);
    if ( v7 )
    {
      *v7 = 0;
      v3 = atoi(v7 + 1);
    }
    if ( *(unsigned __int8 *)(a1 + 228) >> 7 )
    {
      v14 = nvram_bufget(0, "SecondHTTPPort");
      v3 = atoi(v14);
    }
    v8 = v5;
    if ( *v5 )
    {
      v9 = *v5 << 24;
      while ( 1 )
      {
        v10 = v9 >> 24;
        if ( (isalpha(2 * (v9 >> 24))) == 0 && v10 != 46 && v10 != 45 )
          break;
        v9 = (unsigned __int8)*++v8 << 24;
        if ( !*v8 )
          goto LABEL_12;
      }
      *v8 = 0;
    }
LABEL_12:
    v11 = (char *)AllocPrintableString(v5);
    v12 = stritoa(v3, v15, 16);
    if ( v11 )
    {
      v6 = websWriteFmt(a1, (int)"http://%s:%s", v11, v12);
      free2(v11);
    }
    else
    {
      v6 = websWriteFmt(a1, (int)"http://%s:%s", (char *)v5, v12);
    }
    free2(v5);
  }
  return v6;
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E3428: using guessed type int WebSrv_HTTP_Port;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA098: using guessed type int _ctype_b;

//----- (00441B88) --------------------------------------------------------
int   sub_441B88(int a1)
{
  void *Var; // $v0
  int v3; // $s0
  int v4; // $v0
  unsigned __int8 *v5; // $s1
  _BYTE *v6; // $v0
  _BYTE *v7; // $a2
  int v8; // $s0
  int v9; // $a1
  unsigned int v10; // $v0
  unsigned int v11; // $s0
  int v13; // $s0
  int SysInfoLong; // $s3
  void *v15; // $v0
  int v16; // $v0
  char v17[8]; // [sp+18h] [-8h] BYREF

  Var = (void *)websGetVar(a1, (int)"HTTP_HOST", (int)&word_4A0308);
  v3 = 0;
  strcpy(v17, ".local.");
  v4 = strdupWithoutNull(Var);
  v5 = (unsigned __int8 *)v4;
  if ( v4 )
  {
    v6 = (_BYTE *)strchr(v4, 58);
    if ( v6 )
      *v6 = 0;
    v7 = v5;
    if ( *v5 )
    {
      v8 = *v5 << 24;
      while ( 1 )
      {
        v9 = v8 >> 24;
        if ( (isalpha(2 * (v8 >> 24))) == 0 && v9 != 46 && v9 != 45 )
          break;
        v8 = (unsigned __int8)*++v7 << 24;
        if ( !*v7 )
          goto LABEL_10;
      }
      *v7 = 0;
    }
LABEL_10:
    v11 = strlen(v5);
    v10 = strlen(v17);
    if ( v10 < v11 && !webncasestrcmp((int)&v5[v11 - v10], (int)v17) )
    {
      v13 = nvram_bufget(0, "IPAddressMode");
      SysInfoLong = getSysInfoLong(30);
      if ( !strcmp(v13, "5") )
      {
        v16 = getSysInfoLong(59);
        if ( v16 )
          SysInfoLong = v16;
      }
      free2(v5);
      v15 = (void *)inet_ntoa(SysInfoLong);
      v5 = (unsigned __int8 *)strdupWithoutNull(v15);
    }
    v3 = WritePrintableString(a1, v5);
    if ( v5 )
      free2(v5);
  }
  return v3;
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F94: using guessed type int   inet_ntoa(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA098: using guessed type int _ctype_b;

//----- (00441E04) --------------------------------------------------------
int   sub_441E04(int a1)
{
  void *Var; // $v0
  int v3; // $s0
  int v4; // $s1
  int v5; // $s2
  _BYTE *v6; // $v0
  char *v7; // $v0
  int v9; // $v0
  _BYTE v10[16]; // [sp+18h] [-10h] BYREF

  Var = (void *)websGetVar(a1, (int)"HTTP_HOST", (int)&word_4A0308);
  v3 = WebSrv_HTTP_Port;
  v4 = 0;
  v5 = strdupWithoutNull(Var);
  if ( v5 )
  {
    v6 = (_BYTE *)strchr(v5, 58);
    if ( v6 )
    {
      *v6 = 0;
      v3 = atoi(v6 + 1);
    }
    if ( *(unsigned __int8 *)(a1 + 228) >> 7 )
    {
      v9 = nvram_bufget(0, "SecondHTTPPort");
      v3 = atoi(v9);
    }
    v7 = stritoa(v3, v10, 16);
    v4 = websWriteFmt(a1, (int)"%s", v7);
    free2(v5);
  }
  return v4;
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E3428: using guessed type int WebSrv_HTTP_Port;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00441F60) --------------------------------------------------------
int   sub_441F60(int a1)
{
  int SysInfoShort; // $v0

  SysInfoShort = getSysInfoShort(14);
  if ( (unsigned __int16)SysInfoShort >= 2u )
    return websWriteFmt(a1, (int)byte_4A2DDC);
  else
    return websWriteFmt(a1, (int)"%s", noyes_select[SysInfoShort]);
}
// 4E398C: using guessed type char *noyes_select[2];

//----- (00441FE8) --------------------------------------------------------
int   sub_441FE8(int a1)
{
  int SysInfoShort; // $v0

  SysInfoShort = getSysInfoShort(15);
  if ( (unsigned __int16)SysInfoShort >= 3u )
    return websWriteFmt(a1, (int)byte_4A2DDC);
  else
    return websWriteFmt(a1, (int)"%s", speed_select[SysInfoShort]);
}
// 4E3724: using guessed type char *speed_select[3];

//----- (00442070) --------------------------------------------------------
int   sub_442070(int a1)
{
  int SysInfoShort; // $v0

  SysInfoShort = getSysInfoShort(16);
  if ( (unsigned __int16)SysInfoShort >= 2u )
    return websWriteFmt(a1, (int)byte_4A2DDC);
  else
    return websWriteFmt(a1, (int)"%s", duples_select[SysInfoShort]);
}
// 4E392C: using guessed type char *duples_select[2];

//----- (004420F8) --------------------------------------------------------
int   sub_4420F8(int a1)
{
  int v2; // $s0
  int SysInfoLong; // $s1
  char *v4; // $v0
  int v6; // $v0
  char *v7; // $v0

  v2 = nvram_bufget(0, "IPAddressMode");
  SysInfoLong = getSysInfoLong(30);
  if ( !strcmp(v2, "5") && (v6 = getSysInfoLong(59)) != 0 )
  {
    v7 = (char *)inet_ntoa(v6);
    return websWriteFmt(a1, (int)"%s", v7);
  }
  else
  {
    v4 = (char *)inet_ntoa(SysInfoLong);
    return websWriteFmt(a1, (int)"%s", v4);
  }
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F94: using guessed type int   inet_ntoa(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00442214) --------------------------------------------------------
int   sub_442214(int a1)
{
  int v2; // $s0
  int v3; // $s2
  char *v4; // $s3
  int SysInfoLong; // $s1
  char *v6; // $v0
  char *v8; // $v0
  int v9; // $v0

  v2 = nvram_bufget(0, "IPAddressMode");
  v3 = nvram_bufget(0, "SecondHTTPPortEnable");
  v4 = (char *)nvram_bufget(0, "SecondHTTPPort");
  SysInfoLong = getSysInfoLong(30);
  if ( !strcmp(v2, "5") )
  {
    v9 = getSysInfoLong(59);
    if ( v9 )
      SysInfoLong = v9;
  }
  if ( strcmp(v4, "80") && !strcmp(v3, "3") )
  {
    v8 = (char *)inet_ntoa(SysInfoLong);
    return websWriteFmt(a1, (int)"%s:%s", v8, v4);
  }
  else
  {
    v6 = (char *)inet_ntoa(SysInfoLong);
    return websWriteFmt(a1, (int)"%s", v6);
  }
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F94: using guessed type int   inet_ntoa(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (004423C8) --------------------------------------------------------
int   sub_4423C8(int a1)
{
  int v2; // $s0
  int SysInfoLong; // $s1
  char *v4; // $v0
  int v6; // $v0
  char *v7; // $v0

  v2 = nvram_bufget(0, "IPAddressMode");
  SysInfoLong = getSysInfoLong(31);
  if ( !strcmp(v2, "5") && (v6 = getSysInfoLong(60)) != 0 )
  {
    v7 = (char *)inet_ntoa(v6);
    return websWriteFmt(a1, (int)"%s", v7);
  }
  else
  {
    v4 = (char *)inet_ntoa(SysInfoLong);
    return websWriteFmt(a1, (int)"%s", v4);
  }
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F94: using guessed type int   inet_ntoa(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (004424E4) --------------------------------------------------------
int   sub_4424E4(int a1)
{
  return websgetSysInfoNetAddress(a1, 32);
}

//----- (00442500) --------------------------------------------------------
int   sub_442500(int a1)
{
  return websgetSysInfoNetAddress(a1, 33);
}

//----- (0044251C) --------------------------------------------------------
int   sub_44251C(int a1)
{
  return websgetSysInfoNetAddress(a1, 34);
}

//----- (00442538) --------------------------------------------------------
int   sub_442538(int a1)
{
  return websgetSysInfoNetAddress(a1, 29);
}

//----- (00442554) --------------------------------------------------------
int   sub_442554(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"IPAddressMode", a2, a3);
}

//----- (0044257C) --------------------------------------------------------
int   sub_44257C(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"IPAddressMode", a2, a3);
}

//----- (004425A4) --------------------------------------------------------
int   sub_4425A4(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"IPAddress", a2, a3);
}

//----- (004425CC) --------------------------------------------------------
int   sub_4425CC(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"SubnetMask", a2, a3);
}

//----- (004425F4) --------------------------------------------------------
int   sub_4425F4(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"DefaultGateway", a2, a3);
}

//----- (0044261C) --------------------------------------------------------
int   sub_44261C(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"PPPoEUserID", a2, a3);
}

//----- (00442644) --------------------------------------------------------
int   sub_442644(int a1, int a2, _DWORD *a3)
{
  int v4; // $s0
  char *v5; // $s0
  int v6; // $s1
  char *v8; // $v0
  char v9[256]; // [sp+18h] [-100h] BYREF

  if ( a2 > 0 )
  {
    v4 = *a3;
    if ( !strcmp(*a3, "4") )
    {
      v8 = (char *)nvram_bufget(0, "PPPoEPassword");
      websEncode64(v9, v8, 255);
      return websWriteFmt(a1, (int)"%s", v9);
    }
    if ( !strcmp(v4, "5") )
      goto LABEL_4;
  }
  if ( ((*(_DWORD *)(a1 + 228) >> 22) & 1) == 0 )
    return websWritePasswordByName(a1, (int)"PPPoEPassword");
LABEL_4:
  v5 = (char *)allocEncodePasswordByName(a1, (int)"PPPoEPassword");
  v6 = websWriteFmt(a1, (int)"%s", v5);
  if ( v5 )
    free2(v5);
  return v6;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (004427B8) --------------------------------------------------------
int   sub_4427B8(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"DNSIPAddress1", a2, a3);
}

//----- (004427E0) --------------------------------------------------------
int   sub_4427E0(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"DNSIPAddress2", a2, a3);
}

//----- (00442808) --------------------------------------------------------
int   sub_442808(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"SecondHTTPPortEnable", a2, a3);
}

//----- (00442830) --------------------------------------------------------
int   sub_442830(int a1, int a2, _DWORD *a3)
{
  return getStringOfMatchValue(
           a1,
           (int)"SecondHTTPPortEnable",
           (int)&disableenable_select,
           (_BYTE **)&secondportenable_value,
           a2,
           a3);
}
// 4E3734: using guessed type __int16 *secondportenable_value;
// 4E3998: using guessed type _UNKNOWN *disableenable_select;

//----- (0044287C) --------------------------------------------------------
int   sub_44287C(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"SecondHTTPPortEnable", a2, a3);
}

//----- (004428A4) --------------------------------------------------------
int   sub_4428A4(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"SecondHTTPPort", a2, a3);
}

//----- (004428CC) --------------------------------------------------------
int   sub_4428CC(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"HTTPAuthentication", a2, a3);
}

//----- (004428F4) --------------------------------------------------------
int   sub_4428F4(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"UPnPEnable", a2, a3);
}

//----- (0044291C) --------------------------------------------------------
int   sub_44291C(int a1, int a2, _DWORD *a3)
{
  return getStringOfValueSelect(a1, (int)"UPnPEnable", (_BYTE **)&disableenable_select, a2, a3);
}
// 4E3998: using guessed type _UNKNOWN *disableenable_select;

//----- (00442964) --------------------------------------------------------
int   sub_442964(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"UPnPEnable", a2, a3);
}

//----- (0044298C) --------------------------------------------------------
int   sub_44298C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"UPnPPortForwarding", a2, a3);
}

//----- (004429B4) --------------------------------------------------------
int   sub_4429B4(int a1, int a2, _DWORD *a3)
{
  return getStringOfValueSelect(a1, (int)"UPnPPortForwarding", (_BYTE **)&disableenable_select, a2, a3);
}
// 4E3998: using guessed type _UNKNOWN *disableenable_select;

//----- (004429FC) --------------------------------------------------------
int   sub_4429FC(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"UPnPPortForwarding", a2, a3);
}

//----- (00442A24) --------------------------------------------------------
int   sub_442A24(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"BonjourEnable", a2, a3);
}

//----- (00442A4C) --------------------------------------------------------
int   sub_442A4C(int a1, int a2, _DWORD *a3)
{
  return getStringOfValueSelect(a1, (int)"BonjourEnable", (_BYTE **)&disableenable_select, a2, a3);
}
// 4E3998: using guessed type _UNKNOWN *disableenable_select;

//----- (00442A94) --------------------------------------------------------
int   sub_442A94(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"BonjourEnable", a2, a3);
}

//----- (00442ABC) --------------------------------------------------------
int   sub_442ABC(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"BonjourName", a2, a3);
}

//----- (00442AE4) --------------------------------------------------------
int formDefineInternet()
{
  websParaDefine("Protocol", (int)sub_4418E8);
  websParaDefine("JavaCodeBase", (int)sub_441930);
  websParaDefine("RemoteHostIPAddress", (int)sub_441B88);
  websParaDefine("RemoteHostPort", (int)sub_441E04);
  websParaDefine("EthernetLink", (int)sub_441F60);
  websParaDefine("EthernetSpeed", (int)sub_441FE8);
  websParaDefine("EthernetDuplex", (int)sub_442070);
  websParaDefine("CurrentIPAddress", (int)sub_4420F8);
  websParaDefine("CurrentIPAddressPort", (int)sub_442214);
  websParaDefine("CurrentSubnetMask", (int)sub_4423C8);
  websParaDefine("CurrentDefaultGateway", (int)sub_4424E4);
  websParaDefine("CurrentDNSAddress1", (int)sub_442500);
  websParaDefine("CurrentDNSAddress2", (int)sub_44251C);
  websParaDefine("GotIPFromUpnp", (int)sub_442538);
  websParaDefine("IPAddressMode", (int)sub_442554);
  websParaDefine("RadioOfIPAddressMode", (int)sub_44257C);
  websParaDefine("IPAddress", (int)sub_4425A4);
  websParaDefine("SubnetMask", (int)sub_4425CC);
  websParaDefine("DefaultGateway", (int)sub_4425F4);
  websParaDefine("PPPoEUserID", (int)sub_44261C);
  websParaDefine("PPPoEPassword", (int)sub_442644);
  websParaDefine("DNSIPAddress1", (int)sub_4427B8);
  websParaDefine("DNSIPAddress2", (int)sub_4427E0);
  websParaDefine("SecondHTTPPortEnable", (int)sub_442808);
  websParaDefine("StringOfSecondHTTPPortEnable", (int)sub_442830);
  websParaDefine("RadioOfSecondHTTPPortEnable", (int)sub_44287C);
  websParaDefine("SecondHTTPPort", (int)sub_4428A4);
  websParaDefine("HTTPAuthentication", (int)sub_4428CC);
  websParaDefine("UPnPEnable", (int)sub_4428F4);
  websParaDefine("StringOfUPnPEnable", (int)sub_44291C);
  websParaDefine("RadioOfUPnPEnable", (int)sub_442964);
  websParaDefine("UPnPPortForwarding", (int)sub_44298C);
  websParaDefine("StringOfUPnPPortForwarding", (int)sub_4429B4);
  websParaDefine("RadioOfUPnPPortForwarding", (int)sub_4429FC);
  websParaDefine("BonjourEnable", (int)sub_442A24);
  websParaDefine("StringOfBonjourEnable", (int)sub_442A4C);
  websParaDefine("RadioOfBonjourEnable", (int)sub_442A94);
  return websParaDefine("BonjourName", (int)sub_442ABC);
}

//----- (00442FB8) --------------------------------------------------------
int   sub_442FB8(int a1)
{
  _DWORD v3[4]; // [sp+18h] [-10h] BYREF

  memset(v3, 0, sizeof(v3));
  getSysInfoBuffer(69, (int)v3, 1);
  trace(1, (int)"COUNTRY_REGION=%d\n", SLOBYTE(v3[0]));
  return websWriteFmt(a1, (int)"%d", SLOBYTE(v3[0]));
}

//----- (00443048) --------------------------------------------------------
int   sub_443048(int a1, int a2, int *a3)
{
  int v3; // $s0
  int v5; // $v0
  int v6; // $a0
  char *v7; // $a2
  _DWORD v9[4]; // [sp+18h] [-10h] BYREF

  v3 = *a3;
  memset(v9, 0, sizeof(v9));
  getSysInfoBuffer(69, (int)v9, 1);
  trace(1, (int)"COUNTRY_REGION=%d\n", SLOBYTE(v9[0]));
  LOBYTE(v9[0]) += 48;
  if ( !LOBYTE(v9[0]) || (v5 = strcmp(v9, v3), v6 = a1, v7 = "checked", v5) )
  {
    v6 = a1;
    v7 = byte_4A2DDC;
  }
  return websWriteFmt(v6, (int)"%s", v7);
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (00443138) --------------------------------------------------------
int   sub_443138(int a1)
{
  int SysInfoShort; // $v0
  char *v3; // $v0
  _BYTE v5[16]; // [sp+18h] [-10h] BYREF

  SysInfoShort = getSysInfoShort(23);
  strcpy(v5, noyes_select[SysInfoShort]);
  v3 = strlower(v5);
  return websWriteFmt(a1, (int)"%s", v3);
}
// 4E398C: using guessed type char *noyes_select[2];
// 4EA0C8: using guessed type int   strcpy(_DWORD, _DWORD);

//----- (004431CC) --------------------------------------------------------
int   sub_4431CC(int a1)
{
  int SysInfoShort; // $v0

  SysInfoShort = getSysInfoShort(35);
  if ( (unsigned __int16)SysInfoShort >= 2u )
    return websWriteFmt(a1, (int)byte_4A2DDC);
  else
    return websWriteFmt(a1, (int)"%s", noyes_select[SysInfoShort]);
}
// 4E398C: using guessed type char *noyes_select[2];

//----- (00443254) --------------------------------------------------------
int   sub_443254(int a1)
{
  if ( ((*(_DWORD *)(a1 + 228) >> 5) & 1) != 0 )
    return websgetSysInfoString(a1, 36);
  else
    return websgetSysInfoPrintableString(a1, 36);
}

//----- (0044329C) --------------------------------------------------------
int   sub_44329C(int a1)
{
  int v3; // [sp+18h] [-8h] BYREF
  __int16 v4; // [sp+1Ch] [-4h]

  v3 = 0;
  v4 = 0;
  getSysInfoBuffer(37, (int)&v3, 6);
  return WriteMacString(a1, (unsigned __int8 *)&v3, 1);
}

//----- (00443304) --------------------------------------------------------
int   sub_443304(int a1)
{
  return websgetSysInfoShort(a1, 38);
}

//----- (00443320) --------------------------------------------------------
int   sub_443320(int a1)
{
  return websgetSysInfoShort(a1, 39);
}

//----- (0044333C) --------------------------------------------------------
int   sub_44333C(int a1)
{
  int SysInfoShort; // $v1

  SysInfoShort = getSysInfoShort(40);
  switch ( SysInfoShort )
  {
    case 18:
      return websWriteFmt(a1, (int)"%s", off_4E39D8[0]);
    case 34:
      return websWriteFmt(a1, (int)"%s", off_4E39DC[0]);
    case 20:
      return websWriteFmt(a1, (int)"%s", off_4E39E0[0]);
    case 36:
      return websWriteFmt(a1, (int)"%s", off_4E39E4);
  }
  return websWriteFmt(a1, (int)"%s", encryption_status[SysInfoShort]);
}
// 4E39D0: using guessed type char *encryption_status[6];
// 4E39D8: using guessed type char *off_4E39D8[4];
// 4E39DC: using guessed type char *off_4E39DC[3];
// 4E39E0: using guessed type char *off_4E39E0[2];
// 4E39E4: using guessed type char *off_4E39E4;

//----- (00443494) --------------------------------------------------------
int   sub_443494(int a1, int a2, _DWORD *a3)
{
  int v4; // $s0
  __int16 *SysInfoBuffer; // $s2
  int v6; // $s5
  int v7; // $s1
  int v8; // $v0
  char *v9; // $a2
  int v10; // $v0
  int v11; // $s0
  char *v12; // $a2
  int v14; // $v0
  int v15; // $s0
  int v16; // $s0
  int v17; // $s0
  int v18; // $v0
  int v19; // $s0
  int v20; // $s0
  int v21; // $s0
  int v22; // $s0
  int v23; // $s0
  int v24; // $s1
  int v25; // $s0
  int v26; // $s0
  int v27; // $v0
  int v28; // $s1
  int v29; // $s4
  int v30; // $s3
  int v31; // $s0
  int v32; // $s1
  int v33; // $s4
  int v34; // $v0
  int v35; // $s0
  int v36; // $s0
  int v37; // $v0
  int v38; // $fp
  int v39; // $s0
  int v40; // $s4
  int v41; // $s3
  int v42; // $s0
  int v43; // $v0
  int v44; // $s0
  int v45; // $s4
  int v46; // [sp+20h] [-18h] BYREF
  __int16 v47; // [sp+24h] [-14h]
  int v48; // [sp+28h] [-10h]
  int v49; // [sp+2Ch] [-Ch]
  int v50; // [sp+30h] [-8h]

  v48 = mmalloc(3584);
  v4 = 0;
  if ( v48 )
  {
    v49 = nvram_bufget(0, "SSID");
    v46 = 0;
    v47 = 0;
    memset(v48, 0, 3584);
    SysInfoBuffer = (__int16 *)getSysInfoBuffer(44, v48, 3584);
    v6 = 63;
    v50 = 0;
    do
    {
      while ( 1 )
      {
        v7 = SysInfoBuffer[21];
        trace(
          1,
          (int)"getFoundSSIDList SSID=%s, encry=%d, type=%d\n",
          (char *)SysInfoBuffer + 2,
          v7,
          SysInfoBuffer[27]);
        if ( (unsigned __int16)SysInfoBuffer[21] >= 0xAu )
          SysInfoBuffer[21] = 9;
        if ( v7 == 1 )
        {
          v7 = 2;
        }
        else if ( (unsigned int)(v7 - 2) >= 7 )
        {
          if ( v7 >= 9 )
            v7 = 5;
        }
        else
        {
          v7 = 4;
        }
        if ( memcmp(&v46, (char *)SysInfoBuffer + 35, 6)
          && *((_BYTE *)SysInfoBuffer + 2)
          && SysInfoBuffer != (__int16 *)-2
          && (unsigned int)strlen(SysInfoBuffer + 1) < 0x21 )
        {
          break;
        }
        --v6;
        SysInfoBuffer += 28;
        if ( v6 < 0 )
          goto LABEL_19;
      }
      v8 = atoi(*a3);
      if ( v8 == 2 )
      {
        v34 = websWriteFmt(a1, (int)"%s", WebTrendnetRowStart);
        v35 = v4 + v34 + websWriteFmt(a1, (int)"%d", ++v50);
        v36 = v35 + websWriteFmt(a1, (int)"%s", WebTrendnetNewColumn);
        if ( *((_BYTE *)SysInfoBuffer + 2) )
          v37 = WritePrintableString(a1, (_BYTE *)SysInfoBuffer + 2);
        else
          v37 = websWriteFmt(a1, (int)"%s", WebSpace);
        v38 = v36 + v37 + websWriteFmt(a1, (int)"%s", WebTrendnetNewColumn);
        v39 = v38 + WriteMacString(a1, (unsigned __int8 *)SysInfoBuffer + 35, 1);
        v40 = v39 + websWriteFmt(a1, (int)"%s", WebTrendnetNewColumn);
        v41 = v40 + websWriteFmt(a1, (int)"%d", *SysInfoBuffer);
        v42 = v41 + websWriteFmt(a1, (int)"%s", WebTrendnetNewColumn);
        if ( SysInfoBuffer[27] )
        {
          if ( SysInfoBuffer[27] == 1 )
            v43 = websWriteFmt(a1, (int)"%s", connectionmode_select[0]);
          else
            v43 = websWriteFmt(a1, (int)"unknow");
        }
        else
        {
          v43 = websWriteFmt(a1, (int)"%s", off_4E3784);
        }
        v44 = v42 + v43 + websWriteFmt(a1, (int)"%s", WebTrendnetNewColumn);
        v45 = v44 + websWriteFmt(a1, (int)"%s", encrypscan_status[SysInfoBuffer[21]]);
        v11 = v45 + websWriteFmt(a1, (int)"%s", WebTrendnetNewColumn);
        v10 = websWriteFmt(a1, (int)"%d", SysInfoBuffer[22]);
        v12 = WebRowEnd;
      }
      else if ( v8 == 3 )
      {
        if ( !strcmp(v49, SysInfoBuffer + 1) )
          v9 = WebOptionCheck;
        else
          v9 = WebOptionStart;
        v11 = v4 + websWriteFmt(a1, (int)"%s", v9);
        v10 = WritePrintableString(a1, (_BYTE *)SysInfoBuffer + 2);
        v12 = WebOptionEnd;
      }
      else
      {
        v15 = v4 + websWriteFmt(a1, (int)"%s", WebRowStart);
        v14 = websWriteFmt(a1, (int)"%s", WebSsidRadioSeclect);
        v16 = v15 + v14 + websWriteFmt(a1, (int)"%d", ++v50);
        v17 = v16 + websWriteFmt(a1, (int)"%s", WebSetValue);
        if ( *((_BYTE *)SysInfoBuffer + 2) )
          v18 = WriteHexString(a1, (unsigned __int8 *)SysInfoBuffer + 2);
        else
          v18 = websWriteFmt(a1, (int)"%s", WebSpace);
        v19 = v17 + v18 + websWriteFmt(a1, (int)"%s", "',");
        v20 = v19 + websWriteFmt(a1, (int)"%d", SysInfoBuffer[27]);
        v21 = v20 + websWriteFmt(a1, (int)"%s", ",");
        v22 = v21 + websWriteFmt(a1, (int)"%d", *SysInfoBuffer);
        v23 = v22 + websWriteFmt(a1, (int)"%s", ",");
        v24 = v23 + websWriteFmt(a1, (int)"%d", v7);
        v25 = v24 + websWriteFmt(a1, (int)"%s", ")\">");
        v26 = v25 + websWriteFmt(a1, (int)"%s", WebNewColumn);
        if ( *((_BYTE *)SysInfoBuffer + 2) )
          v27 = WritePrintableString(a1, (_BYTE *)SysInfoBuffer + 2);
        else
          v27 = websWriteFmt(a1, (int)"%s", WebSpace);
        v28 = v26 + v27 + websWriteFmt(a1, (int)"%s", WebNewColumn);
        v29 = v28 + WriteMacString(a1, (unsigned __int8 *)SysInfoBuffer + 35, 1);
        v30 = v29 + websWriteFmt(a1, (int)"%s", WebNewColumn);
        v31 = v30 + websWriteFmt(a1, (int)"%d", *SysInfoBuffer);
        v32 = v31 + websWriteFmt(a1, (int)"%s", WebNewColumn);
        v33 = v32 + websWriteFmt(a1, (int)"%s", encrypscan_status[SysInfoBuffer[21]]);
        v11 = v33 + websWriteFmt(a1, (int)"%s", WebNewColumn);
        v10 = websWriteFmt(a1, (int)"%d", SysInfoBuffer[22]);
        v12 = WebRowEnd;
      }
      --v6;
      v4 = v11 + v10 + websWriteFmt(a1, (int)"%s", v12);
      SysInfoBuffer += 28;
    }
    while ( v6 >= 0 );
LABEL_19:
    if ( v48 )
      free2(v48);
  }
  else
  {
    trace(16, (int)"getFoundSSIDList: allocate buffer failure!\n");
  }
  return v4;
}
// 4E3780: using guessed type char *connectionmode_select[2];
// 4E3784: using guessed type char *off_4E3784;
// 4E39A4: using guessed type char *encrypscan_status[5];
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00443C8C) --------------------------------------------------------
int   sub_443C8C(int a1)
{
  int v2; // $s5
  __int16 *SysInfoBuffer; // $s1
  int i; // $s3
  int v5; // $s5
  int v6; // $v0
  int v7; // $s0
  int v8; // $s2
  int v9; // $s0
  int v10; // $s5
  int v11; // $s2
  int v12; // $s0
  int v13; // $s5
  int v14; // $s2
  int v15; // $s0
  int v16; // $s5
  int v17; // $s2
  int v18; // $s0
  int v19; // $s5
  int v20; // $s2
  int v21; // $s0
  int v23; // [sp+20h] [-10h] BYREF
  __int16 v24; // [sp+24h] [-Ch]
  int v25; // [sp+28h] [-8h]

  v25 = mmalloc(3584);
  setSysInfoNone(43);
  v2 = 0;
  if ( v25 )
  {
    v23 = 0;
    v24 = 0;
    memset(v25, 0, 3584);
    SysInfoBuffer = (__int16 *)getSysInfoBuffer(44, v25, 3584);
    for ( i = 63; i >= 0; --i )
    {
      while ( 1 )
      {
        trace(
          1,
          (int)"getSiteSurveyList SSID=%s, encry=%d, type=%d\n",
          (char *)SysInfoBuffer + 2,
          SysInfoBuffer[21],
          SysInfoBuffer[27]);
        if ( (unsigned __int16)SysInfoBuffer[21] >= 0xAu )
          SysInfoBuffer[21] = 9;
        if ( memcmp(&v23, (char *)SysInfoBuffer + 35, 6)
          && *((_BYTE *)SysInfoBuffer + 2)
          && SysInfoBuffer != (__int16 *)-2
          && (unsigned int)strlen(SysInfoBuffer + 1) < 0x21 )
        {
          break;
        }
        --i;
        SysInfoBuffer += 28;
        if ( i < 0 )
          goto LABEL_15;
      }
      v5 = v2 + websWriteFmt(a1, (int)"%s", WebSSIDStr);
      if ( *((_BYTE *)SysInfoBuffer + 2) )
      {
        if ( ((*(_DWORD *)(a1 + 228) >> 5) & 1) != 0 )
          v6 = websWriteFmt(a1, (int)"%s", (char *)SysInfoBuffer + 2);
        else
          v6 = WritePrintableString(a1, (_BYTE *)SysInfoBuffer + 2);
        v5 += v6;
      }
      v7 = v5 + websWriteFmt(a1, (int)"%s", WebNewLine);
      v8 = v7 + websWriteFmt(a1, (int)"%s", WebBSSIDStr);
      v9 = v8 + WriteMacString(a1, (unsigned __int8 *)SysInfoBuffer + 35, 0);
      v10 = v9 + websWriteFmt(a1, (int)"%s", WebNewLine);
      v11 = v10 + websWriteFmt(a1, (int)"%s", WebChannelStr);
      v12 = v11 + websWriteFmt(a1, (int)"%d", *SysInfoBuffer);
      v13 = v12 + websWriteFmt(a1, (int)"%s", WebNewLine);
      v14 = v13 + websWriteFmt(a1, (int)"%s", WebEncryptionStr);
      v15 = v14 + websWriteFmt(a1, (int)"%d", SysInfoBuffer[21]);
      v16 = v15 + websWriteFmt(a1, (int)"%s", WebNewLine);
      v17 = v16 + websWriteFmt(a1, (int)"%s", WebModeStr);
      v18 = v17 + websWriteFmt(a1, (int)"%d", SysInfoBuffer[27]);
      v19 = v18 + websWriteFmt(a1, (int)"%s", WebNewLine);
      v20 = v19 + websWriteFmt(a1, (int)"%s", WebSignalStr);
      v21 = v20 + websWriteFmt(a1, (int)"%d", SysInfoBuffer[22]);
      v2 = v21 + websWriteFmt(a1, (int)"%s", WebNewLine);
      SysInfoBuffer += 28;
    }
LABEL_15:
    if ( v25 )
      free2(v25);
  }
  else
  {
    trace(16, (int)"getSiteSurveyList: allocate buffer failure!\n");
  }
  return v2;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);

//----- (004440A0) --------------------------------------------------------
int   sub_4440A0(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"WirelessDisable", a2, a3);
}

//----- (004440C8) --------------------------------------------------------
int   sub_4440C8(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"WirelessDisable", a2, a3);
}

//----- (004440F0) --------------------------------------------------------
int   sub_4440F0(int a1, int a2, _DWORD *a3)
{
  if ( ((*(_DWORD *)(a1 + 228) >> 5) & 1) != 0 )
    return getStringConfig(a1, (int)"SSID", a2, a3);
  else
    return getPrintableStringConfig(a1, (int)"SSID", a2, a3);
}

//----- (00444158) --------------------------------------------------------
int   sub_444158(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"WirelessChannel", a2, a3);
}

//----- (00444180) --------------------------------------------------------
int   sub_444180(int a1, int a2, _DWORD *a3)
{
  return getChannelSelectString(a1, (int)"WirelessChannel", (char **)&channel_select, a2, a3);
}
// 4E38E4: using guessed type _UNKNOWN *channel_select;

//----- (004441C8) --------------------------------------------------------
int   sub_4441C8(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"TransmissionRate", a2, a3);
}

//----- (004441F0) --------------------------------------------------------
int   sub_4441F0(int a1, int a2, _DWORD *a3)
{
  return getSelectString(a1, (int)"TransmissionRate", txrate_select, a2, a3);
}
// 4E3874: using guessed type char *txrate_select[13];

//----- (00444238) --------------------------------------------------------
int   sub_444238(int a1, int a2, _DWORD *a3)
{
  return getStringOfMatchValue(a1, (int)"TransmissionRate", (int)txrate_select, (_BYTE **)&txrate_value, a2, a3);
}
// 4E3874: using guessed type char *txrate_select[13];
// 4E38AC: using guessed type __int16 *txrate_value;

//----- (00444284) --------------------------------------------------------
int   sub_444284(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"ConnectionMode", a2, a3);
}

//----- (004442AC) --------------------------------------------------------
int   sub_4442AC(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"ConnectionMode", a2, a3);
}

//----- (004442D4) --------------------------------------------------------
int   sub_4442D4(int a1, int a2, _DWORD *a3)
{
  return getStringOfValueSelect(a1, (int)"ConnectionMode", connectionmode_select, a2, a3);
}
// 4E3780: using guessed type char *connectionmode_select[2];

//----- (0044431C) --------------------------------------------------------
int   sub_44431C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"WEPEncryption", a2, a3);
}

//----- (00444344) --------------------------------------------------------
int   sub_444344(int a1, int a2, _DWORD *a3)
{
  return getStringOfValueSelect(a1, (int)"WEPEncryption", (_BYTE **)&encryption_select, a2, a3);
}
// 4E3768: using guessed type _UNKNOWN *encryption_select;

//----- (0044438C) --------------------------------------------------------
int   sub_44438C(int a1, int a2, _DWORD *a3)
{
  int v5; // $v0
  BOOL v6; // $s0
  int v7; // $s2
  _BYTE *v8; // $s1
  int Var; // $v0
  _DWORD v11[4]; // [sp+18h] [-10h] BYREF

  v6 = a2 < 2;
  v5 = nvram_bufget(0, "WEPEncryption");
  memset(v11, 0, sizeof(v11));
  v7 = *a3;
  v8 = (_BYTE *)v5;
  if ( !v6 && !strcmp(*a3, "2") )
  {
    if ( websTestVar(a1, (int)"WEPEncryption") )
    {
      Var = websGetVar(a1, (int)"WEPEncryption", (int)byte_4A2DDC);
      v7 = a3[1];
      v8 = (_BYTE *)Var;
    }
    else
    {
      v7 = a3[1];
    }
  }
  if ( v8 && *v8 )
  {
    if ( !strcmp(v8, "3") )
      LOWORD(v11[0]) = 50;
    else
      strcpy(v11, v8);
  }
  if ( LOBYTE(v11[0]) && !strcmp(v11, v7) )
    return websWriteFmt(a1, (int)"%s", "checked");
  else
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0C8: using guessed type int   strcpy(_DWORD, _DWORD);

//----- (0044457C) --------------------------------------------------------
int   sub_44457C(int a1, int a2, _DWORD *a3)
{
  char *Var; // $s0
  int v7; // $s0
  int v8; // $v0
  _BYTE v10[16]; // [sp+18h] [-10h] BYREF

  Var = (char *)nvram_bufget(0, "TxKey");
  if ( a2 > 0 && !strcmp(*a3, "2") && websTestVar(a1, (int)"TxKey") )
    Var = (char *)websGetVar(a1, (int)"TxKey", (int)byte_4A2DDC);
  snprintf(v10, 16, "Key%s", Var);
  v7 = nvram_bufget(0, v10);
  if ( a2 > 0 && !strcmp(*a3, "2") && websTestVar(a1, (int)v10) )
    v7 = websGetVar(a1, (int)v10, (int)byte_4A2DDC);
  v8 = strlen(v7);
  if ( v8 == 5 || v8 == 10 )
    return websWriteFmt(a1, (int)&word_4A0308);
  else
    return websWriteFmt(a1, (int)"1");
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (00444764) --------------------------------------------------------
int   sub_444764(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"WEPKeyFormat", a2, a3);
}

//----- (0044478C) --------------------------------------------------------
int   sub_44478C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"AuthenticationType", a2, a3);
}

//----- (004447B4) --------------------------------------------------------
int   sub_4447B4(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"AuthenticationType", a2, a3);
}

//----- (004447DC) --------------------------------------------------------
int   sub_4447DC(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"TxKey", a2, a3);
}

//----- (00444804) --------------------------------------------------------
int   sub_444804(int a1, int a2, _DWORD *a3)
{
  return getStringOfMatchValue(a1, (int)"TxKey", (int)wepkey_select, (_BYTE **)&wepkey_value, a2, a3);
}
// 4E384C: using guessed type char *wepkey_select[4];
// 4E3860: using guessed type _UNKNOWN *wepkey_value;

//----- (00444850) --------------------------------------------------------
int   sub_444850(int a1, int a2, _DWORD *a3)
{
  int v4; // $s0
  char *v5; // $s0
  int v6; // $s1
  _BYTE *v8; // $v0
  char *v9; // $s0
  char v10[256]; // [sp+18h] [-100h] BYREF

  if ( a2 <= 0 )
    goto LABEL_7;
  v4 = *a3;
  if ( strcmp(*a3, "4") )
  {
    if ( !strcmp(v4, "5") )
    {
LABEL_4:
      v5 = (char *)allocEncodePasswordByName(a1, (int)"Key1");
      v6 = websWriteFmt(a1, (int)"%s", v5);
      if ( v5 )
        free2(v5);
      return v6;
    }
LABEL_7:
    if ( ((*(_DWORD *)(a1 + 228) >> 22) & 1) == 0 )
      return websWritePasswordByName(a1, (int)"Key1");
    goto LABEL_4;
  }
  v8 = (_BYTE *)nvram_bufget(0, "Key1");
  v9 = (char *)AllocPrintableString(v8);
  memset(v10, 0, 255);
  if ( v9 )
  {
    websEncode64(v10, v9, 255);
    free2(v9);
  }
  return websWriteFmt(a1, (int)"%s", v10);
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00444A20) --------------------------------------------------------
int   sub_444A20(int a1, int a2, _DWORD *a3)
{
  int v4; // $s0
  char *v5; // $s0
  int v6; // $s1
  _BYTE *v8; // $v0
  char *v9; // $s0
  char v10[256]; // [sp+18h] [-100h] BYREF

  if ( a2 <= 0 )
    goto LABEL_7;
  v4 = *a3;
  if ( strcmp(*a3, "4") )
  {
    if ( !strcmp(v4, "5") )
    {
LABEL_4:
      v5 = (char *)allocEncodePasswordByName(a1, (int)"Key2");
      v6 = websWriteFmt(a1, (int)"%s", v5);
      if ( v5 )
        free2(v5);
      return v6;
    }
LABEL_7:
    if ( ((*(_DWORD *)(a1 + 228) >> 22) & 1) == 0 )
      return websWritePasswordByName(a1, (int)"Key2");
    goto LABEL_4;
  }
  v8 = (_BYTE *)nvram_bufget(0, "Key2");
  v9 = (char *)AllocPrintableString(v8);
  memset(v10, 0, 255);
  if ( v9 )
  {
    websEncode64(v10, v9, 255);
    free2(v9);
  }
  return websWriteFmt(a1, (int)"%s", v10);
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00444BF0) --------------------------------------------------------
int   sub_444BF0(int a1, int a2, _DWORD *a3)
{
  int v4; // $s0
  char *v5; // $s0
  int v6; // $s1
  _BYTE *v8; // $v0
  char *v9; // $s0
  char v10[256]; // [sp+18h] [-100h] BYREF

  if ( a2 <= 0 )
    goto LABEL_7;
  v4 = *a3;
  if ( strcmp(*a3, "4") )
  {
    if ( !strcmp(v4, "5") )
    {
LABEL_4:
      v5 = (char *)allocEncodePasswordByName(a1, (int)"Key3");
      v6 = websWriteFmt(a1, (int)"%s", v5);
      if ( v5 )
        free2(v5);
      return v6;
    }
LABEL_7:
    if ( ((*(_DWORD *)(a1 + 228) >> 22) & 1) == 0 )
      return websWritePasswordByName(a1, (int)"Key3");
    goto LABEL_4;
  }
  v8 = (_BYTE *)nvram_bufget(0, "Key3");
  v9 = (char *)AllocPrintableString(v8);
  memset(v10, 0, 255);
  if ( v9 )
  {
    websEncode64(v10, v9, 255);
    free2(v9);
  }
  return websWriteFmt(a1, (int)"%s", v10);
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00444DC0) --------------------------------------------------------
int   sub_444DC0(int a1, int a2, _DWORD *a3)
{
  int v4; // $s0
  char *v5; // $s0
  int v6; // $s1
  _BYTE *v8; // $v0
  char *v9; // $s0
  char v10[256]; // [sp+18h] [-100h] BYREF

  if ( a2 <= 0 )
    goto LABEL_7;
  v4 = *a3;
  if ( strcmp(*a3, "4") )
  {
    if ( !strcmp(v4, "5") )
    {
LABEL_4:
      v5 = (char *)allocEncodePasswordByName(a1, (int)"Key4");
      v6 = websWriteFmt(a1, (int)"%s", v5);
      if ( v5 )
        free2(v5);
      return v6;
    }
LABEL_7:
    if ( ((*(_DWORD *)(a1 + 228) >> 22) & 1) == 0 )
      return websWritePasswordByName(a1, (int)"Key4");
    goto LABEL_4;
  }
  v8 = (_BYTE *)nvram_bufget(0, "Key4");
  v9 = (char *)AllocPrintableString(v8);
  memset(v10, 0, 255);
  if ( v9 )
  {
    websEncode64(v10, v9, 255);
    free2(v9);
  }
  return websWriteFmt(a1, (int)"%s", v10);
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00444F90) --------------------------------------------------------
int   sub_444F90(int a1, int a2, _DWORD *a3)
{
  int v4; // $s0
  char *v5; // $s0
  int v6; // $s1
  _BYTE *v8; // $v0
  char *v9; // $s0
  char v10[256]; // [sp+18h] [-100h] BYREF

  if ( a2 <= 0 )
    goto LABEL_7;
  v4 = *a3;
  if ( strcmp(*a3, "4") )
  {
    if ( !strcmp(v4, "5") )
    {
LABEL_4:
      v5 = (char *)allocEncodePasswordByName(a1, (int)"PreSharedKey");
      v6 = websWriteFmt(a1, (int)"%s", v5);
      if ( v5 )
        free2(v5);
      return v6;
    }
LABEL_7:
    if ( ((*(_DWORD *)(a1 + 228) >> 22) & 1) == 0 )
      return websWritePasswordByName(a1, (int)"PreSharedKey");
    goto LABEL_4;
  }
  v8 = (_BYTE *)nvram_bufget(0, "PreSharedKey");
  v9 = (char *)AllocPrintableString(v8);
  memset(v10, 0, 255);
  if ( v9 )
  {
    websEncode64(v10, v9, 255);
    free2(v9);
  }
  return websWriteFmt(a1, (int)"%s", v10);
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00445160) --------------------------------------------------------
int   sub_445160(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"BeaconInterval", a2, a3);
}

//----- (00445188) --------------------------------------------------------
int   sub_445188(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"Preamble", a2, a3);
}

//----- (004451B0) --------------------------------------------------------
int   sub_4451B0(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"Preamble", a2, a3);
}

//----- (004451D8) --------------------------------------------------------
int   sub_4451D8(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"WirelessMode", a2, a3);
}

//----- (00445200) --------------------------------------------------------
int   sub_445200(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"WirelessMode", a2, a3);
}

//----- (00445228) --------------------------------------------------------
int   sub_445228(int a1)
{
  return websgetSysInfoShort(a1, 107);
}

//----- (00445244) --------------------------------------------------------
int   sub_445244(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"APExtendName", a2, a3);
}

//----- (0044526C) --------------------------------------------------------
int   sub_44526C(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"APExtendName", a2, a3);
}

//----- (00445294) --------------------------------------------------------
int   sub_445294(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"APSSIDHidden", a2, a3);
}

//----- (004452BC) --------------------------------------------------------
int   sub_4452BC(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"APSSIDHidden", a2, a3);
}

//----- (004452E4) --------------------------------------------------------
int   sub_4452E4(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"APWEPEncryption", a2, a3);
}

//----- (0044530C) --------------------------------------------------------
int   sub_44530C(int a1, int a2, _DWORD *a3)
{
  return getStringOfValueSelect(a1, (int)"APWEPEncryption", (_BYTE **)&encryption_select, a2, a3);
}
// 4E3768: using guessed type _UNKNOWN *encryption_select;

//----- (00445354) --------------------------------------------------------
int   sub_445354(int a1, int a2, _DWORD *a3)
{
  int v5; // $v0
  BOOL v6; // $s0
  int v7; // $s2
  _BYTE *v8; // $s1
  int Var; // $v0
  _DWORD v11[4]; // [sp+18h] [-10h] BYREF

  v6 = a2 < 2;
  v5 = nvram_bufget(0, "APWEPEncryption");
  memset(v11, 0, sizeof(v11));
  v7 = *a3;
  v8 = (_BYTE *)v5;
  if ( !v6 && !strcmp(*a3, "2") )
  {
    if ( websTestVar(a1, (int)"APWEPEncryption") )
    {
      Var = websGetVar(a1, (int)"APWEPEncryption", (int)byte_4A2DDC);
      v7 = a3[1];
      v8 = (_BYTE *)Var;
    }
    else
    {
      v7 = a3[1];
    }
  }
  if ( v8 && *v8 )
  {
    if ( !strcmp(v8, "3") )
      LOWORD(v11[0]) = 50;
    else
      strcpy(v11, v8);
  }
  if ( LOBYTE(v11[0]) && !strcmp(v11, v7) )
    return websWriteFmt(a1, (int)"%s", "checked");
  else
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0C8: using guessed type int   strcpy(_DWORD, _DWORD);

//----- (00445544) --------------------------------------------------------
int   sub_445544(int a1, int a2, _DWORD *a3)
{
  int Var; // $s4
  int v7; // $v1

  Var = nvram_bufget(0, "APKey1");
  if ( a2 > 0 && !strcmp(*a3, "2") && websTestVar(a1, (int)"APKey1") )
    Var = websGetVar(a1, (int)"APKey1", (int)byte_4A2DDC);
  v7 = strlen(Var);
  if ( v7 == 5 || v7 == 10 )
    return websWriteFmt(a1, (int)&word_4A0308);
  else
    return websWriteFmt(a1, (int)"1", websWriteFmt);
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0044568C) --------------------------------------------------------
int   sub_44568C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"APWEPKeyFormat", a2, a3);
}

//----- (004456B4) --------------------------------------------------------
int   sub_4456B4(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"APAuthenticationType", a2, a3);
}

//----- (004456DC) --------------------------------------------------------
int   sub_4456DC(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"APAuthenticationType", a2, a3);
}

//----- (00445704) --------------------------------------------------------
int   sub_445704(int a1, int a2, _DWORD *a3)
{
  int v4; // $s0
  char *v5; // $s0
  int v6; // $s1
  _BYTE *v8; // $v0
  char *v9; // $s0
  char v10[256]; // [sp+18h] [-100h] BYREF

  if ( a2 <= 0 )
    goto LABEL_7;
  v4 = *a3;
  if ( strcmp(*a3, "4") )
  {
    if ( !strcmp(v4, "5") )
    {
LABEL_4:
      v5 = (char *)allocEncodePasswordByName(a1, (int)"APKey1");
      v6 = websWriteFmt(a1, (int)"%s", v5);
      if ( v5 )
        free2(v5);
      return v6;
    }
LABEL_7:
    if ( ((*(_DWORD *)(a1 + 228) >> 22) & 1) == 0 )
      return websWritePasswordByName(a1, (int)"APKey1");
    goto LABEL_4;
  }
  v8 = (_BYTE *)nvram_bufget(0, "APKey1");
  v9 = (char *)AllocPrintableString(v8);
  memset(v10, 0, 255);
  if ( v9 )
  {
    websEncode64(v10, v9, 255);
    free2(v9);
  }
  return websWriteFmt(a1, (int)"%s", v10);
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (004458D4) --------------------------------------------------------
int   sub_4458D4(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"APMaxClient", a2, a3);
}

//----- (004458FC) --------------------------------------------------------
int   sub_4458FC(int a1, int a2, _DWORD *a3)
{
  return getSelectString(a1, (int)"APMaxClient", (_BYTE **)&apclient_select, a2, a3);
}
// 4E3834: using guessed type _UNKNOWN *apclient_select;

//----- (00445944) --------------------------------------------------------
int   sub_445944(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"APSSID", a2, a3);
}

//----- (0044596C) --------------------------------------------------------
int   sub_44596C(int a1, int a2, _DWORD *a3)
{
  int v4; // $s0
  char *v5; // $s0
  int v6; // $s1
  _BYTE *v8; // $v0
  char *v9; // $s0
  char v10[256]; // [sp+18h] [-100h] BYREF

  if ( a2 <= 0 )
    goto LABEL_7;
  v4 = *a3;
  if ( strcmp(*a3, "4") )
  {
    if ( !strcmp(v4, "5") )
    {
LABEL_4:
      v5 = (char *)allocEncodePasswordByName(a1, (int)"APPreSharedKey");
      v6 = websWriteFmt(a1, (int)"%s", v5);
      if ( v5 )
        free2(v5);
      return v6;
    }
LABEL_7:
    if ( ((*(_DWORD *)(a1 + 228) >> 22) & 1) == 0 )
      return websWritePasswordByName(a1, (int)"APPreSharedKey");
    goto LABEL_4;
  }
  v8 = (_BYTE *)nvram_bufget(0, "APPreSharedKey");
  v9 = (char *)AllocPrintableString(v8);
  memset(v10, 0, 255);
  if ( v9 )
  {
    websEncode64(v10, v9, 255);
    free2(v9);
  }
  return websWriteFmt(a1, (int)"%s", v10);
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00445B3C) --------------------------------------------------------
int   sub_445B3C(int a1, int a2, _DWORD *a3)
{
  int v5; // $s6
  int v6; // $s0
  int SysInfoBuffer; // $s1
  int v8; // $s5
  int v9; // $a0
  char *v10; // $a2
  int v11; // $s0
  int v12; // $s0
  int v13; // $s0
  int v14; // $s0
  int v15; // $s0
  int v16; // $s0
  int v17; // $s0
  int v18; // $s0
  int v19; // $s2
  int v20; // $s0
  int v21; // $s2
  int v22; // $s0
  int v23; // $s2
  int v24; // $s0
  int v25; // $s2
  int v26; // $s0
  int v27; // $s2
  int v28; // $s0
  int v29; // $s0
  int v31; // [sp+18h] [-8h] BYREF
  __int16 v32; // [sp+1Ch] [-4h]

  v5 = mmalloc(1536);
  doSystem((int)"rptinfo 3");
  v6 = 0;
  if ( v5 )
  {
    memset(v5, 0, 1536);
    v31 = 0;
    v32 = 0;
    SysInfoBuffer = getSysInfoBuffer(108, v5, 1536);
    v8 = 0;
    while ( memcmp(&v31, SysInfoBuffer, 6) )
    {
      if ( atoi(*a3) == 2 )
      {
        v19 = v6 + websWriteFmt(a1, (int)"%s", WebMACStr);
        v20 = v19 + WriteMacString(a1, (unsigned __int8 *)SysInfoBuffer, 2);
        v21 = v20 + websWriteFmt(a1, (int)"%s", WebNewLine);
        v22 = v21 + websWriteFmt(a1, (int)"%s", WebConnectStr);
        v23 = v22 + websWriteFmt(a1, (int)"%d seconds", *(_DWORD *)(SysInfoBuffer + 8));
        v24 = v23 + websWriteFmt(a1, (int)"%s", WebNewLine);
        v25 = v24 + websWriteFmt(a1, (int)"%s", WebTXRateStr);
        v26 = v25 + websWriteFmt(a1, (int)"%d Mbps", *(_DWORD *)(SysInfoBuffer + 20));
        v27 = v26 + websWriteFmt(a1, (int)"%s", WebNewLine);
        v28 = v27 + websWriteFmt(a1, (int)"%s", WebWlanModeStr);
        v29 = v28 + websWriteFmt(a1, (int)"%s", (char *)(SysInfoBuffer + 12));
        ++v8;
        v6 = v29 + websWriteFmt(a1, (int)"%s", WebNewLine);
        SysInfoBuffer += 24;
        if ( v8 >= 64 )
          break;
      }
      else
      {
        v12 = v6 + websWriteFmt(a1, (int)"%s", WebRowStart);
        v13 = v12 + WriteMacString(a1, (unsigned __int8 *)SysInfoBuffer, 2);
        v14 = v13 + websWriteFmt(a1, (int)"%s", WebNewColumn);
        v15 = v14
            + websWriteFmt(
                a1,
                (int)"<script language=\"Javascript\">parseTime(\"%d\")</script>",
                *(_DWORD *)(SysInfoBuffer + 8));
        v16 = v15 + websWriteFmt(a1, (int)"%s", WebNewColumn);
        v17 = v16 + websWriteFmt(a1, (int)"%d Mbps", *(_DWORD *)(SysInfoBuffer + 20));
        v18 = v17 + websWriteFmt(a1, (int)"%s", WebNewColumn);
        if ( *(_BYTE *)(SysInfoBuffer + 12) )
        {
          v9 = a1;
          v10 = (char *)(SysInfoBuffer + 12);
        }
        else
        {
          v10 = WebSpace;
          v9 = a1;
        }
        ++v8;
        v11 = v18 + websWriteFmt(v9, (int)"%s", v10);
        v6 = v11 + websWriteFmt(a1, (int)"%s", WebRowEnd);
        SysInfoBuffer += 24;
        if ( v8 >= 64 )
          break;
      }
    }
    free2(v5);
  }
  else
  {
    trace(16, (int)"getConnectClientList: allocate buffer failure!\n");
  }
  return v6;
}
// 445ECC: conditional instruction was optimized away because $s6.4!=0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);

//----- (00445F38) --------------------------------------------------------
int   sub_445F38(int a1)
{
  return websgetSysInfoLong(a1, 138);
}

//----- (00445F54) --------------------------------------------------------
int   sub_445F54(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"APChannel", a2, a3);
}

//----- (00445F7C) --------------------------------------------------------
int   sub_445F7C(int a1, int a2, _DWORD *a3)
{
  return getChannelSelectString(a1, (int)"APChannel", (char **)&channel_select, a2, a3);
}
// 4E38E4: using guessed type _UNKNOWN *channel_select;

//----- (00445FC4) --------------------------------------------------------
int   sub_445FC4(int a1)
{
  _DWORD v3[4]; // [sp+18h] [-10h] BYREF

  doSystem((int)"gpio directchannel");
  memset(v3, 0, sizeof(v3));
  getSysInfoBuffer(140, (int)v3, 1);
  trace(1, (int)"DIRECT_CHANNEL=%d\n", SLOBYTE(v3[0]));
  return websWriteFmt(a1, (int)"%d", SLOBYTE(v3[0]));
}

//----- (0044606C) --------------------------------------------------------
int formDefineWireless()
{
  websParaDefine("WirelessCountry", (int)sub_442FB8);
  websParaDefine("RadioOfWirelessCountry", (int)sub_443048);
  websParaDefine("WirelessSupport", (int)sub_443138);
  websParaDefine("WirelessLink", (int)sub_4431CC);
  websParaDefine("WirelessCurrentSSID", (int)sub_443254);
  websParaDefine("WirelessCurrentAPMACAddress", (int)sub_44329C);
  websParaDefine("WirelessCurrentChannel", (int)sub_443304);
  websParaDefine("WirelessCurrentTransmissionRate", (int)sub_443320);
  websParaDefine("WirelessCurrentEncryption", (int)sub_44333C);
  websParaDefine("FoundSSIDList", (int)sub_443494);
  websParaDefine("SiteSurveyList", (int)sub_443C8C);
  websParaDefine("WirelessDisable", (int)sub_4440A0);
  websParaDefine("RadioOfWirelessDisable", (int)sub_4440C8);
  websParaDefine("SSID", (int)sub_4440F0);
  websParaDefine("WirelessChannel", (int)sub_444158);
  websParaDefine("SelectOfWirelessChannel", (int)sub_444180);
  websParaDefine("TransmissionRate", (int)sub_4441C8);
  websParaDefine("SelectOfTransmissionRate", (int)sub_4441F0);
  websParaDefine("StringOfTransmissionRate", (int)sub_444238);
  websParaDefine("ConnectionMode", (int)sub_444284);
  websParaDefine("RadioOfConnectionMode", (int)sub_4442AC);
  websParaDefine("StringOfConnectionMode", (int)sub_4442D4);
  websParaDefine("WEPEncryption", (int)sub_44431C);
  websParaDefine("StringOfEncryption", (int)sub_444344);
  websParaDefine("RadioOfWEPEncryWay", (int)sub_44438C);
  websParaDefine("WEPKeyLen", (int)sub_44457C);
  websParaDefine("WEPKeyFormat", (int)sub_444764);
  websParaDefine("AuthenticationType", (int)sub_44478C);
  websParaDefine("RadioOfAuthenticationType", (int)sub_4447B4);
  websParaDefine("TxKey", (int)sub_4447DC);
  websParaDefine("StringOfTxKey", (int)sub_444804);
  websParaDefine("Key1", (int)sub_444850);
  websParaDefine("Key2", (int)sub_444A20);
  websParaDefine("Key3", (int)sub_444BF0);
  websParaDefine("Key4", (int)sub_444DC0);
  websParaDefine("PreSharedKey", (int)sub_444F90);
  websParaDefine("BeaconInterval", (int)sub_445160);
  websParaDefine("Preamble", (int)sub_445188);
  websParaDefine("RadioOfPreamble", (int)sub_4451B0);
  websParaDefine("WirelessMode", (int)sub_4451D8);
  websParaDefine("RadioOfWirelessMode", (int)sub_445200);
  websParaDefine("RepeaterMode", (int)sub_445228);
  websParaDefine("APExtendName", (int)sub_445244);
  websParaDefine("RadioOfAPExtendName", (int)sub_44526C);
  websParaDefine("APSSIDHidden", (int)sub_445294);
  websParaDefine("RadioOfAPSSIDHidden", (int)sub_4452BC);
  websParaDefine("APWEPEncryption", (int)sub_4452E4);
  websParaDefine("StringOfAPEncryption", (int)sub_44530C);
  websParaDefine("RadioOfAPWEPEncryWay", (int)sub_445354);
  websParaDefine("APWEPKeyLen", (int)sub_445544);
  websParaDefine("APWEPKeyFormat", (int)sub_44568C);
  websParaDefine("APAuthenticationType", (int)sub_4456B4);
  websParaDefine("RadioOfAPAuthenticationType", (int)sub_4456DC);
  websParaDefine("APKey1", (int)sub_445704);
  websParaDefine("APMaxClient", (int)sub_4458D4);
  websParaDefine("SelectOfAPMaxClient", (int)sub_4458FC);
  websParaDefine("APSSID", (int)sub_445944);
  websParaDefine("APPreSharedKey", (int)sub_44596C);
  websParaDefine("ConnectClientList", (int)sub_445B3C);
  websParaDefine("APEnable", (int)sub_445F38);
  websParaDefine("APChannel", (int)sub_445F54);
  websParaDefine("SelectOfAPChannel", (int)sub_445F7C);
  return websParaDefine("Wchannel", (int)sub_445FC4);
}

//----- (00446860) --------------------------------------------------------
int   sub_446860(int a1)
{
  return websWriteFmt(a1, (int)"%d", Debug_Trace_Level);
}
// 4E3420: using guessed type int Debug_Trace_Level;

//----- (00446888) --------------------------------------------------------
int   sub_446888(int a1)
{
  int v2; // $s2
  int i; // $s0
  int v4; // $s2
  _BYTE v6[64]; // [sp+18h] [-40h] BYREF

  v2 = 0;
  for ( i = 0; i < *(_DWORD *)(a1 + 280); v2 = v4 + getStringVar(a1, (int)v6, (int)byte_4A2DDC) )
  {
    while ( !i )
    {
      snprintf(v6, 64, "Message%d", 0);
      i = 1;
      v2 += getStringVar(a1, (int)v6, (int)byte_4A2DDC);
      if ( *(int *)(a1 + 280) <= 1 )
        return v2;
    }
    v4 = v2 + websWriteFmt(a1, (int)"<BR>");
    snprintf(v6, 64, "Message%d", i++);
  }
  return v2;
}
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (004469B8) --------------------------------------------------------
int   sub_4469B8(int a1)
{
  return getStringVar(a1, (int)"EntryNo", (int)&word_4A0308);
}
// 4A0308: using guessed type __int16 word_4A0308;

//----- (004469DC) --------------------------------------------------------
int   sub_4469DC(int a1)
{
  int *v2; // $s1
  int v3; // $v1
  bool v4; // dc
  _BYTE v6[64]; // [sp+18h] [-40h] BYREF

  memset(v6, 0, sizeof(v6));
  v2 = (int *)&webMultiLanguageList;
  getSysInfoBuffer(79, (int)v6, 1);
  if ( off_4E417C )
  {
    while ( 1 )
    {
      v3 = *v2;
      v4 = *v2 == v6[0];
      v2 += 2;
      if ( v4 )
        break;
      if ( !v2[1] )
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    v3 = *v2;
  }
  if ( v3 == -1 )
    return websWriteFmt(a1, (int)"%d", 0);
  else
    return websWriteFmt(a1, (int)"%d", v6[0]);
}
// 4E417C: using guessed type char *off_4E417C;
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (00446ADC) --------------------------------------------------------
int   sub_446ADC(int a1)
{
  int *v2; // $a0
  int v3; // $s2
  int v4; // $s0
  int v5; // $v1
  bool v6; // dc
  int *v7; // $s1
  int result; // $v0
  char *v9; // $v0
  int v10; // $v0
  int v11; // $s0
  int v12; // $a0
  char *v13; // $v0
  int v14; // $v0
  int v15; // $s0
  _BYTE v16[64]; // [sp+18h] [-40h] BYREF

  memset(v16, 0, sizeof(v16));
  getSysInfoBuffer(79, (int)v16, 1);
  v2 = (int *)&webMultiLanguageList;
  v3 = v16[0];
  v4 = 0;
  if ( off_4E417C )
  {
    while ( 1 )
    {
      v5 = *v2;
      v6 = *v2 == v16[0];
      v2 += 2;
      if ( v6 )
        break;
      if ( !v2[1] )
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    v5 = *v2;
  }
  if ( v5 == -1 )
    v3 = 0;
  v7 = (int *)&webMultiLanguageList;
  result = 0;
  if ( off_4E417C )
  {
    do
    {
      while ( 1 )
      {
        v12 = *v7;
        if ( *v7 == v3 )
          break;
        v9 = stritoa(v12, v16, 64);
        v11 = v4 + websWriteFmt(a1, (int)"<OPTION value=\"%s\">", v9);
        v10 = websWriteFmt(a1, (int)"%s", (char *)v7[1]);
        v7 += 2;
        v4 = v11 + v10 + websWriteFmt(a1, (int)"%s", WebOptionEnd);
        if ( !v7[1] )
          return v4;
      }
      v13 = stritoa(v12, v16, 64);
      v15 = v4 + websWriteFmt(a1, (int)"<OPTION value=\"%s\" selected>", v13);
      v14 = websWriteFmt(a1, (int)"%s", (char *)v7[1]);
      v7 += 2;
      v4 = v15 + v14 + websWriteFmt(a1, (int)"%s", WebOptionEnd);
    }
    while ( v7[1] );
    return v4;
  }
  return result;
}
// 4E417C: using guessed type char *off_4E417C;
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (00446CC0) --------------------------------------------------------
int   sub_446CC0(int a1)
{
  int Var; // $v0

  Var = websGetVar(a1, (int)"RebootTime", (int)"80");
  return getStringVar(a1, (int)"RebootTime", Var);
}

//----- (00446D24) --------------------------------------------------------
int   sub_446D24(int a1)
{
  return getStringVar(a1, (int)"ForceBootCodeUpgrade", (int)&word_4A0308);
}
// 4A0308: using guessed type __int16 word_4A0308;

//----- (00446D48) --------------------------------------------------------
int   sub_446D48(int a1)
{
  int Var; // $v0

  Var = websGetVar(a1, (int)"DownloadTime", (int)"160");
  return getStringVar(a1, (int)"DownloadTime", Var);
}

//----- (00446DAC) --------------------------------------------------------
int   sub_446DAC(int a1)
{
  int v2; // $a0
  int v3; // $a2

  nvram_close(0);
  nvram_init(0);
  v2 = nvram_bufget(0, "LastDownloadStatus");
  v3 = 0;
  if ( v2 )
    v3 = atoi(v2);
  return websWriteFmt(a1, (int)"%d", v3);
}
// 4E9F1C: using guessed type int   nvram_init(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F64: using guessed type int   nvram_close(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00446E50) --------------------------------------------------------
int   sub_446E50(int a1)
{
  int v2; // $v0
  int v3; // $v1
  int v4; // $a0
  char *v6; // $v0
  char *ErrorMessage; // $v0

  nvram_close(0);
  nvram_init(0);
  v2 = nvram_bufget(0, "LastDownloadStatus");
  v3 = 0;
  if ( v2 )
    v3 = atoi(v2);
  v4 = 3;
  if ( v3 == -2 )
    goto LABEL_10;
  if ( v3 < -1 )
  {
    if ( v3 != -3 )
      return 0;
    v4 = 5;
    goto LABEL_10;
  }
  if ( v3 == -1 )
  {
    v4 = 4;
LABEL_10:
    ErrorMessage = (char *)websGetErrorMessage(v4);
    return websWriteFmt(a1, (int)"%s", ErrorMessage);
  }
  if ( v3 )
    return 0;
  v6 = (char *)websGetErrorMessage(2);
  return websWriteFmt(a1, (int)"%s", v6);
}
// 4E9F1C: using guessed type int   nvram_init(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F64: using guessed type int   nvram_close(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00446FA4) --------------------------------------------------------
int   sub_446FA4(int a1)
{
  char *v2; // $a3
  int v3; // $s0
  int result; // $v0
  int v5; // $v0
  int v6; // $s2
  int v7; // $s0
  char *v8; // [sp+10h] [-118h]
  char v9[256]; // [sp+20h] [-108h] BYREF
  char *v10; // [sp+120h] [-8h] BYREF

  if ( ((*(_DWORD *)(a1 + 228) >> 13) & 1) != 0 )
  {
    v2 = *(char **)(a1 + 172);
    v8 = *(char **)(a1 + 168);
    v10 = 0;
    allocFmtString((int *)&v10, 255, (int)"%s:%s", v2, v8);
    v3 = 0;
    if ( v10 && (websEncode64(v9, v10, 255), v3 = websWriteFmt(a1, (int)"%s", v9), v10) )
    {
      free2(v10);
      result = v3;
      v10 = 0;
    }
    else
    {
      return v3;
    }
  }
  else
  {
    v6 = 0;
    v5 = strdupWithoutNull(*(void **)(a1 + 164));
    v7 = v5;
    if ( v5 )
    {
      if ( !strncasecmp(v5, "Basic ", 6) )
        v6 = websWriteFmt(a1, (int)"%s", (char *)(v7 + 6));
      free2(v7);
      return v6;
    }
    else
    {
      return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
    }
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA040: using guessed type int   strncasecmp(_DWORD, _DWORD, _DWORD);

//----- (0044714C) --------------------------------------------------------
int   sub_44714C(int a1)
{
  _BYTE *v2; // $v0
  _BYTE *v3; // $s0
  _BYTE *v4; // $s2
  int v5; // $s4
  int v6; // $s1
  int v7; // $s0
  int v8; // $a1
  int v9; // $v0

  v3 = (_BYTE *)nvram_bufget(0, "AdminID");
  v2 = (_BYTE *)nvram_bufget(0, "AdminPassword");
  v4 = v2;
  v5 = 0;
  if ( v3 )
  {
    if ( v2 && !*v3 && !*v2 )
      goto LABEL_11;
    v6 = *(_DWORD *)(a1 + 172);
    if ( !v6 )
      return websWriteFmt(a1, (int)"%d", v5);
    if ( strcmp(v3, *(_DWORD *)(a1 + 172)) )
      return websWriteFmt(a1, (int)"%d", v5);
    v7 = strlen(v3);
    if ( v7 != strlen(v6) )
      return websWriteFmt(a1, (int)"%d", v5);
    if ( v4 )
    {
      v8 = *(_DWORD *)(a1 + 168);
      if ( !v8 )
        return websWriteFmt(a1, (int)"%d", v5);
      v9 = strcmp(v4, v8);
    }
    else
    {
      v9 = *(_DWORD *)(a1 + 168);
    }
    if ( !v9 )
LABEL_11:
      v5 = 1;
    return websWriteFmt(a1, (int)"%d", v5);
  }
  if ( !v2 )
    goto LABEL_11;
  return websWriteFmt(a1, (int)"%d", 0);
}
// 4471D4: conditional instruction was optimized away because $s0.4!=0
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00447304) --------------------------------------------------------
int   sub_447304(int a1)
{
  if ( !websTestVar(a1, (int)"UserName") )
    copyStringHexVar(a1, "UserName", (int)"HexUserName", (int)byte_4A2DDC);
  return getPrintableStringVar(a1, (int)"UserName", (int)byte_4A2DDC);
}

//----- (004473B8) --------------------------------------------------------
int   sub_4473B8(int a1, int a2, _DWORD *a3)
{
  int v6; // $s0
  int v7; // $v0
  int (*v8)(int, int, ...); // $t9
  int Var; // $v0
  unsigned __int8 *v11; // $s0
  int v12; // $v0
  int v13; // $s1
  char *StringVar; // $v0
  _BYTE v15[256]; // [sp+18h] [-108h] BYREF
  int v16; // [sp+118h] [-8h] BYREF

  if ( websTestVar(a1, (int)"UserPassword") )
  {
    if ( a2 <= 0 )
      goto LABEL_5;
    v6 = *a3;
    v7 = strcmp(*a3, "2");
    v8 = (int (*)(int, int, ...))getHexStringVar;
    if ( !v7 )
      return v8(a1, (int)"UserPassword");
    if ( strcmp(v6, "4") )
    {
LABEL_5:
      v8 = (int (*)(int, int, ...))getStringVar;
      return v8(a1, (int)"UserPassword");
    }
    StringVar = (char *)getStringVar(a1, (int)"UserPassword", (int)byte_4A2DDC);
    websEncode64(v15, StringVar, 255);
    return websWriteFmt(a1, (int)"%s", v15);
  }
  else
  {
    if ( !websTestVar(a1, (int)"UserName") )
      copyStringHexVar(a1, "UserName", (int)"HexUserName", (int)byte_4A2DDC);
    Var = websGetVar(a1, (int)"UserName", (int)byte_4A2DDC);
    v11 = (unsigned __int8 *)AllocPassFromConfigByUser(a1, Var, &v16);
    if ( v11 )
    {
      if ( a2 > 0 && !strcmp(*a3, "2") )
        v12 = WriteHexString(a1, v11);
      else
        v12 = websWriteFmt(a1, (int)"%s", (char *)v11);
      v13 = v12;
      free2(v11);
      return v13;
    }
    else
    {
      return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
    }
  }
}
// 447544: conditional instruction was optimized away because $s0.4!=0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (00447624) --------------------------------------------------------
int   sub_447624(int a1, int a2, _DWORD *a3)
{
  int v4; // $v0
  int v6; // $s0
  int v7; // $s7
  int SysInfoBuffer; // $s1
  int i; // $s6
  int v10; // $v0
  int v11; // $s4
  int v12; // $v1
  int v13; // $a0
  unsigned __int16 *v14; // $s2
  int v15; // $v0
  int v16; // $v0
  int v17; // $a0
  char *v18; // $v0
  int v19; // $s4
  int v20; // $s0
  int v21; // $s4
  int v22; // $s0
  int v23; // $s4
  int v24; // $s0
  int v25; // $s0
  int v26; // $v0
  int v28; // $s0
  char *v29; // $v0
  int v30; // $s0
  int v31; // $s0
  int v32; // $s0
  int v33; // $s0
  char *v34; // $v0
  int v35; // $s0
  int v36; // $v0
  char *v37; // $a2
  int v38; // $a0
  char *v39; // $v0
  int v40; // $s0
  int v41; // $s0
  int v42; // $s0
  int v43; // $s0
  char *v44; // $v0
  _BYTE v45[16]; // [sp+28h] [-28h] BYREF
  int v46; // [sp+38h] [-18h] BYREF
  int v47; // [sp+3Ch] [-14h]
  int v48; // [sp+40h] [-10h]
  int v49; // [sp+44h] [-Ch]
  int v50; // [sp+48h] [-8h] BYREF
  int v51; // [sp+4Ch] [-4h]

  v4 = mmalloc(3584);
  v51 = v4;
  v6 = 0;
  v7 = 0;
  if ( !v4 )
  {
    trace(16, (int)"getActiveUserTable: allocate buffer failure!\n");
    return v6;
  }
  SysInfoBuffer = getSysInfoBuffer(47, v4, 3584);
  for ( i = 63; i >= 0; --i )
  {
    while ( 1 )
    {
      v50 = *(_DWORD *)(SysInfoBuffer + 24);
      v10 = localtime(&v50);
      v11 = *(_DWORD *)(SysInfoBuffer + 8);
      v46 = 0;
      v47 = 0;
      v48 = 0;
      v49 = 0;
      v12 = *(_DWORD *)(SysInfoBuffer + 16);
      v13 = *(_DWORD *)(SysInfoBuffer + 20);
      v46 = *(_DWORD *)(SysInfoBuffer + 12);
      v47 = v12;
      v48 = v13;
      v14 = (unsigned __int16 *)v10;
      if ( !*(_DWORD *)SysInfoBuffer )
        goto LABEL_3;
      v15 = atoi(*a3);
      if ( v15 == 2 )
      {
        if ( *(_WORD *)(SysInfoBuffer + 38) && *(_WORD *)(SysInfoBuffer + 38) != 2 )
          goto LABEL_3;
        v28 = v6 + websWriteFmt(a1, (int)"%s", WebRowStart);
        ++v7;
        v30 = v28 + websWriteFmt(a1, (int)"%s", WebNewColumn);
        v29 = stritoa(v7, v45, 16);
        v31 = v30 + websWriteFmt(a1, (int)"%s", v29);
        v32 = v31 + websWriteFmt(a1, (int)"%s", WebNewColumn);
        v33 = v32 + websWriteFmt(a1, (int)"%s", (char *)&v46);
        v35 = v33 + websWriteFmt(a1, (int)"%s", WebNewColumn);
        v34 = (char *)inet_ntoa(v11);
        v36 = websWriteFmt(a1, (int)"%s", v34);
        v37 = WebNewColumn;
        v38 = a1;
        goto LABEL_19;
      }
      if ( v15 == 3 )
        break;
      if ( !*(_WORD *)(SysInfoBuffer + 38) || *(_WORD *)(SysInfoBuffer + 38) == 2 )
      {
        v16 = websWriteFmt(a1, (int)"%s", WebIPAddrStr);
        v17 = v11;
        v19 = v6 + v16;
        v18 = (char *)inet_ntoa(v17);
        v20 = v19 + websWriteFmt(a1, (int)"%s", v18);
        v21 = v20 + websWriteFmt(a1, (int)"%s", WebNewLine);
        v22 = v21 + websWriteFmt(a1, (int)"%s", WebUserStr);
        v23 = v22 + websWriteFmt(a1, (int)"%s", (char *)&v46);
        v24 = v23 + websWriteFmt(a1, (int)"%s", WebNewLine);
        v25 = v24 + websWriteFmt(a1, (int)"%s", WebAccTimeStr);
        if ( v14 )
          v25 += WriteTimerString(a1, (int)"%Y-%m-%d %X", v14[10], v14[8], v14[6], v14[4], v14[2], *v14);
        v26 = websWriteFmt(a1, (int)"%s", WebNewLine);
        goto LABEL_12;
      }
LABEL_3:
      --i;
      SysInfoBuffer += 56;
      if ( i < 0 )
        goto LABEL_13;
    }
    if ( *(_WORD *)(SysInfoBuffer + 38) && *(_WORD *)(SysInfoBuffer + 38) != 2 )
      goto LABEL_3;
    ++v7;
    v40 = v6 + websWriteFmt(a1, (int)"%s", WebTrendnetRowStart);
    v39 = stritoa(v7, v45, 16);
    v41 = v40 + websWriteFmt(a1, (int)"%s", v39);
    v42 = v41 + websWriteFmt(a1, (int)"%s", WebTrendnetNewColumn);
    v43 = v42 + websWriteFmt(a1, (int)"%s", (char *)&v46);
    v35 = v43 + websWriteFmt(a1, (int)"%s", WebTrendnetNewColumn);
    v44 = (char *)inet_ntoa(v11);
    v36 = websWriteFmt(a1, (int)"%s", v44);
    v37 = WebTrendnetNewColumn;
    v38 = a1;
LABEL_19:
    v25 = v35 + v36 + websWriteFmt(v38, (int)"%s", v37);
    if ( v14 )
      v25 += WriteTimerString(a1, (int)"%Y-%m-%d %X", v14[10], v14[8], v14[6], v14[4], v14[2], *v14);
    v26 = websWriteFmt(a1, (int)"%s", WebRowEnd);
LABEL_12:
    v6 = v25 + v26;
    SysInfoBuffer += 56;
  }
LABEL_13:
  if ( v51 )
    free2(v51);
  return v6;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F94: using guessed type int   inet_ntoa(_DWORD);
// 4E9FA4: using guessed type int   localtime(_DWORD);

//----- (00447B98) --------------------------------------------------------
int   sub_447B98(int a1)
{
  return getStringVar(a1, (int)"name", (int)byte_4A2DDC);
}

//----- (00447BBC) --------------------------------------------------------
int   sub_447BBC(int a1)
{
  char *Var; // $v0

  Var = (char *)websGetVar(a1, (int)"password", (int)byte_4A2DDC);
  return nipcaWritePasswordByString(a1, Var);
}

//----- (00447C14) --------------------------------------------------------
int   sub_447C14(int a1)
{
  return getStringVar(a1, (int)"group", (int)byte_4A2DDC);
}

//----- (00447C38) --------------------------------------------------------
int   sub_447C38(_DWORD *a1)
{
  return websWriteFmt((int)a1, (int)"%d", *a1);
}

//----- (00447C58) --------------------------------------------------------
int   sub_447C58(int a1)
{
  return websWriteFmt(a1, (int)"%s", *(char **)(a1 + 156));
}

//----- (00447C78) --------------------------------------------------------
int   sub_447C78(int a1)
{
  return websgetSysInfoString(a1, 1);
}

//----- (00447C94) --------------------------------------------------------
int   sub_447C94(int a1)
{
  return websgetSysInfoString(a1, 5);
}

//----- (00447CB0) --------------------------------------------------------
int   sub_447CB0(int a1)
{
  return websgetSysInfoString(a1, 4);
}

//----- (00447CCC) --------------------------------------------------------
int   sub_447CCC(int a1)
{
  int v2; // $s2
  int v3; // $s0
  int v4; // $v0
  int v5; // $a1
  _BYTE *v6; // $v0
  _BYTE v8[1024]; // [sp+18h] [-400h] BYREF

  memset(v8, 0, sizeof(v8));
  v2 = 0;
  v3 = fopen("/etc_ro/build", "r");
  if ( v3 )
  {
    v4 = fgets(v8, 1024, v3);
    v5 = 10;
    if ( v4 )
    {
      v6 = (_BYTE *)strchr(v8, 10);
      if ( v6 )
        *v6 = 0;
      v2 = websWriteFmt(a1, (int)"%s", v8);
    }
    fclose(v3);
  }
  return v2;
}
// 447DA8: variable 'v5' is possibly undefined
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F98: using guessed type int   fclose(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FA8: using guessed type int   fopen(_DWORD, _DWORD);
// 4EA084: using guessed type int   fgets(_DWORD, _DWORD, _DWORD);

//----- (00447DD4) --------------------------------------------------------
int   sub_447DD4(int a1, int a2, _DWORD *a3)
{
  int v4; // $s0
  unsigned __int16 SysInfoLong; // $v0
  unsigned __int16 v7; // $v0

  if ( a2 <= 0 )
    return websgetSysInfoString(a1, 3);
  v4 = *a3;
  if ( !strcmp(*a3, "2") )
  {
    SysInfoLong = getSysInfoLong(61);
    return websWriteFmt(a1, (int)"%d", SysInfoLong);
  }
  else
  {
    if ( strcmp(v4, "3") )
      return websgetSysInfoString(a1, 3);
    v7 = getSysInfoLong(61);
    return websWriteFmt(a1, (int)"%02d", v7);
  }
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (00447EDC) --------------------------------------------------------
int   sub_447EDC(int a1, int a2, _DWORD *a3)
{
  int v6; // $v0
  char *v7; // $s1
  char *v8; // $v0
  char *v9; // $s0
  _BYTE *v10; // $v0
  int v11; // $s2
  _BYTE v13[128]; // [sp+18h] [-80h] BYREF

  memset(v13, 0, sizeof(v13));
  getSysInfoBuffer(64, (int)v13, 128);
  v6 = strstr(v13, "Release ");
  v7 = (char *)(v6 + 8);
  if ( !v6 )
    return websWriteFmt(a1, (int)byte_4A2DDC);
  v8 = (char *)strstr(v7, " (");
  v9 = v8;
  if ( v8 )
  {
    v9 = v8 + 2;
    *v8 = 0;
    v10 = (_BYTE *)strchr(v8 + 2, 41);
    if ( v10 )
      *v10 = 0;
  }
  if ( !v7 || !v9 )
    return websWriteFmt(a1, (int)byte_4A2DDC);
  if ( a2 <= 0 )
    return websWriteFmt(a1, (int)"%s", v7);
  v11 = *a3;
  if ( !strcmp(*a3, "2") )
    return websWriteFmt(a1, (int)"%s (%s)", v7, v9);
  if ( !strcmp(v11, "3") )
    return websWriteFmt(a1, (int)"%s", v9);
  else
    return websWriteFmt(a1, (int)"%s", v7);
}
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FEC: using guessed type int   strstr(_DWORD, _DWORD);

//----- (004480DC) --------------------------------------------------------
int   sub_4480DC(int a1, int a2, int *a3)
{
  unsigned int SysInfoLong; // $v0
  int v7; // $s1
  int v8; // $a0
  _DWORD v10[4]; // [sp+18h] [-10h] BYREF

  SysInfoLong = getSysInfoLong(7);
  v7 = HIBYTE(SysInfoLong) | (SysInfoLong >> 8) & 0xFF00 | ((SysInfoLong & 0xFF00) << 8) | (SysInfoLong << 24);
  memset(&v10[1], 0, 12);
  if ( a2 > 0 && (v8 = *a3, v10[0] = 0, !strcmp(v8, "2")) )
  {
    LOBYTE(v10[0]) = v7;
    return websWriteFmt(a1, (int)"%s", (char *)v10);
  }
  else
  {
    v10[0] = v7;
    return websWriteFmt(a1, (int)"%s", (char *)v10);
  }
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (004481EC) --------------------------------------------------------
int   sub_4481EC(int a1)
{
  _DWORD v3[4]; // [sp+18h] [-18h] BYREF
  int SysInfoLong; // [sp+28h] [-8h]

  SysInfoLong = getSysInfoLong(8);
  v3[0] = (unsigned __int8)(HIBYTE(SysInfoLong) + 48);
  BYTE1(v3[0]) = 46;
  v3[1] = (unsigned __int8)(SysInfoLong + 48);
  v3[2] = 0;
  v3[3] = 0;
  return websWriteFmt(a1, (int)"%s", (char *)v3);
}

//----- (00448294) --------------------------------------------------------
int   sub_448294(int a1)
{
  return websgetSysInfoString(a1, 2);
}

//----- (004482B0) --------------------------------------------------------
int   sub_4482B0(int a1)
{
  return websgetSysInfoString(a1, 6);
}

//----- (004482CC) --------------------------------------------------------
int   sub_4482CC(int a1, int a2, _DWORD *a3)
{
  int v6; // $v0
  int v7; // $a0
  int v8; // $a2
  int v10; // [sp+18h] [-8h] BYREF
  __int16 v11; // [sp+1Ch] [-4h]

  v10 = 0;
  v11 = 0;
  getSysInfoBuffer(25, (int)&v10, 6);
  if ( a2 <= 0 || (v6 = strcmp(*a3, "2"), v7 = a1, v8 = 2, v6) )
  {
    v7 = a1;
    v8 = 1;
  }
  return WriteMacString(v7, (unsigned __int8 *)&v10, v8);
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (00448388) --------------------------------------------------------
int   sub_448388(int a1)
{
  int v2; // $s1
  char *v3; // $s0
  int v4; // $v0
  int v5; // $a1
  char *v6; // $v0
  int v7; // $v0
  _BYTE v9[1024]; // [sp+18h] [-400h] BYREF

  v2 = fopen("/mydlink/version", "r");
  v3 = 0;
  if ( !v2 )
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
  while ( 1 )
  {
    v4 = fgets(v9, 1024, v2);
    v5 = 61;
    if ( !v4 )
      break;
    while ( 1 )
    {
      v6 = (char *)strchr(v9, 61);
      v3 = v6;
      if ( !v6 )
        break;
      *v6 = 0;
      v3 = v6 + 1;
      if ( strcmp(v9, "VERSION") )
      {
        v7 = fgets(v9, 1024, v2);
        v3 = 0;
        v5 = 61;
        if ( v7 )
          continue;
      }
      goto LABEL_6;
    }
  }
LABEL_6:
  fclose(v2);
  if ( v3 )
    return websWriteFmt(a1, (int)"%s", v3);
  else
    return websWriteFmt(a1, (int)"%s", byte_4A2DDC);
}
// 448478: variable 'v5' is possibly undefined
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F98: using guessed type int   fclose(_DWORD);
// 4E9FA8: using guessed type int   fopen(_DWORD, _DWORD);
// 4EA084: using guessed type int   fgets(_DWORD, _DWORD, _DWORD);

//----- (00448504) --------------------------------------------------------
int   sub_448504(int a1)
{
  int v2; // $v0
  int v3; // $v0
  char v5[16]; // [sp+18h] [-10h] BYREF

  v2 = time(0);
  srand(v2);
  v3 = rand();
  stritoa(v3, v5, 16);
  return websWriteFmt(a1, (int)"%s", v5);
}
// 4E9F90: using guessed type int   time(_DWORD);
// 4E9F9C: using guessed type int   srand(_DWORD);
// 4E9FE8: using guessed type int rand(void);

//----- (004485A8) --------------------------------------------------------
int   sub_4485A8(int a1)
{
  return websWriteFmt(a1, (int)"%s", "2.1.8");
}

//----- (004485CC) --------------------------------------------------------
int   sub_4485CC(int a1)
{
  return websWriteFmt(a1, (int)"%s", "1.9.7");
}

//----- (004485F0) --------------------------------------------------------
int   sub_4485F0(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"CameraName", a2, a3);
}

//----- (00448618) --------------------------------------------------------
int   sub_448618(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"Location", a2, a3);
}

//----- (00448640) --------------------------------------------------------
int   sub_448640(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"AdminID", a2, a3);
}

//----- (00448668) --------------------------------------------------------
int   sub_448668(int a1, int a2, _DWORD *a3)
{
  int v6; // $s0
  int v7; // $v0
  int (  *v8)(int, int, int, _DWORD *); // $t9
  char *v9; // $s0
  int v10; // $s1
  char *v12; // $v0
  char v13[256]; // [sp+18h] [-100h] BYREF

  if ( a2 <= 0 )
    goto LABEL_6;
  v6 = *a3;
  v7 = strcmp(*a3, "2");
  v8 = getHexStringConfig;
  if ( !v7 )
    return v8(a1, (int)"AdminPassword", a2, a3);
  if ( !strcmp(v6, "3") )
  {
    v8 = getHashMd5StringConfig;
    return v8(a1, (int)"AdminPassword", a2, a3);
  }
  if ( !strcmp(v6, "4") )
  {
    v12 = (char *)nvram_bufget(0, "AdminPassword");
    websEncode64(v13, v12, 255);
    return websWriteFmt(a1, (int)"%s", v13);
  }
  if ( strcmp(v6, "5") )
  {
LABEL_6:
    if ( ((*(_DWORD *)(a1 + 228) >> 22) & 1) == 0 )
      return websWritePasswordByName(a1, (int)"AdminPassword");
  }
  v9 = (char *)allocEncodePasswordByName(a1, (int)"AdminPassword");
  v10 = websWriteFmt(a1, (int)"%s", v9);
  if ( v9 )
    free2(v9);
  return v10;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00448860) --------------------------------------------------------
int   sub_448860(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"LEDControl", a2, a3);
}

//----- (00448888) --------------------------------------------------------
int   sub_448888(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"LEDControl", a2, a3);
}

//----- (004488B0) --------------------------------------------------------
int   sub_4488B0(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"SnapshotURLAuthentication", a2, a3);
}

//----- (004488D8) --------------------------------------------------------
int   sub_4488D8(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"SnapshotURLAuthentication", a2, a3);
}

//----- (00448900) --------------------------------------------------------
int   sub_448900(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"OSDEnable", a2, a3);
}

//----- (00448928) --------------------------------------------------------
int   sub_448928(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"OSDEnable", a2, a3);
}

//----- (00448950) --------------------------------------------------------
int   sub_448950(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"AccessControlEnable", a2, a3);
}

//----- (00448978) --------------------------------------------------------
int   sub_448978(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"AccessControlEnable", a2, a3);
}

//----- (004489A0) --------------------------------------------------------
int   sub_4489A0(int a1, int a2, _DWORD *a3)
{
  int v4; // $fp
  int v5; // $s0
  int v6; // $s5
  int result; // $v0
  _BYTE *v8; // $v0
  int v9; // $v0
  unsigned __int8 *v10; // $s4
  char *v11; // $v0
  char *v12; // $s2
  char *v13; // $s3
  char *v14; // $v0
  int v15; // $v0
  int v16; // $v0
  char *v17; // $v0
  int v18; // $s2
  int v19; // $s0
  int v20; // $s2
  int v21; // $s0
  int v22; // $s0
  int v23; // $v0
  int v24; // $s2
  char *v25; // $v0
  int v26; // $s3
  int v27; // $s0
  int v28; // $s2
  int v29; // $s3
  int v30; // $s0
  int v31; // $s2
  int v32; // $s3
  int v33; // $s0
  int v34; // $s2
  int v35; // $s3
  int v36; // $s0
  int v37; // $s0
  int v38; // $v0
  char **v39; // $v1
  int v40; // $v0
  char **v41; // $a1
  int v42; // $s0
  int v43; // $s0
  int v44; // $s0
  int v45; // $s0
  int v46; // $s2
  int v47; // $s0
  int v48; // $s0
  char **v49; // $v1
  int v50; // $v0
  char **v51; // $s3
  _BYTE v52[64]; // [sp+18h] [-58h] BYREF
  _DWORD v53[4]; // [sp+58h] [-18h] BYREF
  int v54; // [sp+68h] [-8h]

  memset(v53, 0, sizeof(v53));
  getSysInfoBuffer(79, (int)v53, 1);
  v4 = SLOBYTE(v53[0]);
  v5 = 0;
  v6 = 1;
  v54 = 0;
  do
  {
    while ( 1 )
    {
      snprintf(v52, 64, "User%d", v6);
      v8 = (_BYTE *)nvram_bufget(0, v52);
      if ( !v8 )
        goto LABEL_2;
      if ( !*v8 )
        goto LABEL_2;
      v9 = strdupWithoutNull(v8);
      v10 = (unsigned __int8 *)v9;
      if ( !v9 )
        goto LABEL_2;
      v11 = (char *)strchr(v9, 47);
      v12 = v11;
      v13 = 0;
      if ( v11 )
      {
        v12 = v11 + 1;
        *v11 = 0;
        v14 = (char *)strrchr(v11 + 1, 47);
        v13 = v14;
        if ( v14 )
        {
          *v14 = 0;
          v13 = v14 + 1;
        }
      }
      v15 = atoi(*a3);
      if ( v15 == 2 )
      {
        v24 = v5 + websWriteFmt(a1, (int)"%s", WebRowStart);
        v23 = websWriteFmt(a1, (int)"%s", WebNewColumn);
        ++v54;
        v26 = v24 + v23;
        v25 = stritoa(v54, v53, 16);
        v27 = v26 + websWriteFmt(a1, (int)"%s", v25);
        v28 = v27 + websWriteFmt(a1, (int)"%s", WebNewColumn);
        v29 = v28 + WritePrintableString(a1, v10);
        v30 = v29 + websWriteFmt(a1, (int)"%s", WebNewColumn);
        v31 = v30 + websWriteFmt(a1, (int)"%s", WebEditStart);
        v32 = v31 + WriteHexString(a1, v10);
        v33 = v32 + websWriteFmt(a1, (int)"%s", WebEditEnd);
        v34 = v33 + websWriteFmt(a1, (int)"%s", WebNewColumn);
        v35 = v34 + websWriteFmt(a1, (int)"%s", WebTrashStart);
        v36 = v35 + WriteHexString(a1, v10);
        v37 = v36 + websWriteFmt(a1, (int)"%s", WebTrashEnd);
        v38 = websWriteFmt(a1, (int)"%s", WebRowEnd);
LABEL_21:
        v5 = v37 + v38;
        goto LABEL_12;
      }
      if ( v15 < 3 )
      {
        if ( v15 != 1 )
          goto LABEL_12;
        v42 = v5 + websWriteFmt(a1, (int)"%s", WebUserStr);
        v43 = v42 + websWriteFmt(a1, (int)"%s", (char *)v10);
        v44 = v43 + websWriteFmt(a1, (int)"%s", WebNewLine);
        v45 = v44 + websWriteFmt(a1, (int)"%s", WebPassStr);
        v46 = v45 + websWritePasswordByString(a1, v12);
        v47 = v46 + websWriteFmt(a1, (int)"%s", WebNewLine);
        v48 = v47 + websWriteFmt(a1, (int)"%s", WebPrivStr);
        v37 = v48 + websWriteFmt(a1, (int)"%s", v13);
        v38 = websWriteFmt(a1, (int)"%s", WebNewLine);
        goto LABEL_21;
      }
      if ( v15 != 3 )
      {
        if ( v15 != 4 )
          goto LABEL_12;
        v16 = websWriteFmt(a1, (int)"%s", WebTrendnetRowStart);
        ++v54;
        v18 = v5 + v16;
        v17 = stritoa(v54, v53, 16);
        v19 = v18 + websWriteFmt(a1, (int)"%s", v17);
        v20 = v19 + websWriteFmt(a1, (int)"%s", WebTrendnetNewColumn);
        v21 = v20 + WritePrintableString(a1, v10);
        v22 = v21 + websWriteFmt(a1, (int)"%s", WebTrendnetNewColumn);
        if ( !v13 )
          v13 = (char *)&word_4A0308;
        switch ( v4 )
        {
          case 1:
            v49 = Chinese_noyes_select;
            v50 = *v13;
            goto LABEL_37;
          case 2:
            v51 = &Taiwan_noyes_select[*v13];
            goto LABEL_38;
          case 3:
            v49 = German_noyes_select;
            v50 = *v13;
            goto LABEL_37;
          case 4:
            v49 = French_noyes_select;
            v50 = *v13;
            goto LABEL_37;
          case 5:
            v49 = Italian_noyes_select;
            v50 = *v13;
            goto LABEL_37;
          case 6:
            v49 = Spanish_noyes_select;
            v50 = *v13;
            goto LABEL_37;
          case 7:
            v49 = Korean_noyes_select;
            v50 = *v13;
            goto LABEL_37;
          default:
            v49 = noyes_select;
            v50 = *v13;
LABEL_37:
            v51 = &v49[v50];
LABEL_38:
            v37 = v22 + websWriteFmt(a1, (int)"%s", *(v51 - 48));
            v38 = websWriteFmt(a1, (int)"%s", WebRowEnd);
            break;
        }
        goto LABEL_21;
      }
      if ( !v13 )
        v13 = (char *)&word_4A0308;
      switch ( v4 )
      {
        case 1:
          v39 = Chinese_noyes_select;
          v40 = *v13;
          goto LABEL_26;
        case 2:
          v39 = Taiwan_noyes_select;
          v40 = *v13;
          goto LABEL_26;
        case 3:
          v41 = &German_noyes_select[*v13];
          goto LABEL_27;
        case 4:
          v39 = French_noyes_select;
          v40 = *v13;
          goto LABEL_26;
        case 5:
          v39 = Italian_noyes_select;
          v40 = *v13;
          goto LABEL_26;
        case 6:
          v39 = Spanish_noyes_select;
          v40 = *v13;
          goto LABEL_26;
        case 7:
          v39 = Korean_noyes_select;
          v40 = *v13;
          goto LABEL_26;
        default:
          v39 = noyes_select;
          v40 = *v13;
LABEL_26:
          v41 = &v39[v40];
LABEL_27:
          v5 += websWriteFmt(a1, (int)"<OPTION>%s(%s)</OPTION>", (char *)v10, *(v41 - 48));
          break;
      }
LABEL_12:
      if ( v10 )
        break;
LABEL_2:
      ++v6;
      result = v5;
      if ( v6 >= 9 )
        return result;
    }
    ++v6;
    free2(v10);
    result = v5;
  }
  while ( v6 < 9 );
  return result;
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E3938: using guessed type char *Korean_noyes_select[2];
// 4E3944: using guessed type char *Spanish_noyes_select[2];
// 4E3950: using guessed type char *Italian_noyes_select[2];
// 4E395C: using guessed type char *French_noyes_select[2];
// 4E3968: using guessed type char *German_noyes_select[2];
// 4E3974: using guessed type char *Taiwan_noyes_select[2];
// 4E3980: using guessed type char *Chinese_noyes_select[2];
// 4E398C: using guessed type char *noyes_select[2];
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4EA028: using guessed type int   strrchr(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (004490C0) --------------------------------------------------------
int   sub_4490C0(int a1, int a2, _DWORD *a3)
{
  int v4; // $v0
  _BYTE *v6; // $v0
  int v7; // $s0
  _BYTE *v8; // $v0
  int v9; // $s1
  _BYTE v10[64]; // [sp+18h] [-40h] BYREF

  if ( a2 <= 0 )
    return 0;
  v4 = atoi(*a3);
  if ( (unsigned int)(v4 - 1) >= 8 )
    return 0;
  snprintf(v10, 64, "User%d", v4);
  v6 = (_BYTE *)nvram_bufget(0, v10);
  if ( !v6 )
    return 0;
  if ( !*v6 )
    return 0;
  v7 = strdupWithoutNull(v6);
  if ( !v7 )
    return 0;
  v8 = (_BYTE *)strchr(v7, 47);
  if ( v8 )
    *v8 = 0;
  v9 = websWriteFmt(a1, (int)"%s", v7);
  free2(v7);
  return v9;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (004491F4) --------------------------------------------------------
int   sub_4491F4(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"DateTimeMode", a2, a3);
}

//----- (0044921C) --------------------------------------------------------
int   sub_44921C(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"DateTimeMode", a2, a3);
}

//----- (00449244) --------------------------------------------------------
int   sub_449244(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"TimeServerIPAddress", a2, a3);
}

//----- (0044926C) --------------------------------------------------------
int   sub_44926C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"TimeServerProtocol", a2, a3);
}

//----- (00449294) --------------------------------------------------------
int   sub_449294(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"TimeServerProtocol", a2, a3);
}

//----- (004492BC) --------------------------------------------------------
int   sub_4492BC(int a1, int a2, _DWORD *a3)
{
  _BYTE *Var; // $v0
  int v6; // $v0
  char v7[16]; // [sp+18h] [-10h] BYREF

  strcpy(v7, "TimeZone");
  if ( a2 > 0 && !strcmp(*a3, "2") && websTestVar(a1, (int)v7) )
    Var = (_BYTE *)websGetVar(a1, (int)v7, (int)&word_4A0308);
  else
    Var = (_BYTE *)nvram_bufget(0, v7);
  if ( !Var || !*Var )
    return websWriteFmt(a1, (int)"%s", &word_4A0308);
  v6 = atoi(Var);
  return websWriteFmt(a1, (int)"%d", v6 / 60);
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00449414) --------------------------------------------------------
int   sub_449414(int a1, int a2, _DWORD *a3)
{
  int v4; // $s2
  int v5; // $s0
  int v6; // $v0
  int v7; // $a2
  int v8; // $a0
  int *v9; // $a1
  int v10; // $t5
  int v11; // $a2
  int *v12; // $a1
  int v13; // $a0
  int *i; // $v1
  int v15; // $a0
  char v17[16]; // [sp+18h] [-18h] BYREF
  _BYTE *Var; // [sp+28h] [-8h] BYREF

  strcpy(v17, "TimeZoneIndex");
  Var = 0;
  v4 = 0;
  if ( a2 > 0 && !strcmp(*a3, "2") && websTestVar(a1, (int)v17) )
    Var = (_BYTE *)websGetVar(a1, (int)v17, (int)&word_4A0308);
  else
    Var = (_BYTE *)nvram_bufget(0, v17);
  v5 = 0;
  if ( Var && *Var )
    v5 = atoi(Var);
  websGetVarCheck(a1, "TimeZone", (int *)&Var);
  v6 = atoi(Var);
  v7 = 0;
  if ( TimeZoneList[0] )
  {
    v8 = 0;
    while ( 1 )
    {
      v9 = &TimeZoneList[v8];
      ++v7;
      v10 = TimeZoneList[v8 + 1];
      v8 = 2 * v7;
      if ( v10 == v6 )
        break;
      if ( !TimeZoneList[2 * v7] )
        goto LABEL_11;
    }
    v4 = *v9;
  }
LABEL_11:
  if ( !v5 )
    goto LABEL_17;
  if ( !TimeZoneList[0] )
  {
LABEL_18:
    v15 = a1;
    return websWriteFmt(v15, (int)"%d", v5);
  }
  v11 = 1;
  v12 = TimeZoneList;
  v13 = 2;
  for ( i = (int *)&unk_4E3AD8; *v12 != v5; i = &TimeZoneList[2 * v11] )
  {
    v12 = &TimeZoneList[v13];
    if ( !*i )
      goto LABEL_18;
    ++v11;
    v13 = 2 * v11;
  }
  v15 = a1;
  if ( v12[1] != v6 )
  {
LABEL_17:
    v5 = v4;
    goto LABEL_18;
  }
  return websWriteFmt(v15, (int)"%d", v5);
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E3AD0: using guessed type int TimeZoneList[186];
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (00449650) --------------------------------------------------------
int   sub_449650(int a1)
{
  return getCurrentTimeString(a1, (int)"%m-%d-%Y %r");
}

//----- (00449670) --------------------------------------------------------
int   sub_449670(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"Date", a2, a3);
}

//----- (00449698) --------------------------------------------------------
int   sub_449698(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"Time", a2, a3);
}

//----- (004496C0) --------------------------------------------------------
int   sub_4496C0(int a1)
{
  return getCurrentTimeString(a1, (int)"%Y");
}

//----- (004496E0) --------------------------------------------------------
int   sub_4496E0(int a1)
{
  return getCurrentTimeString(a1, (int)"%m");
}

//----- (00449700) --------------------------------------------------------
int   sub_449700(int a1)
{
  return getCurrentTimeString(a1, (int)"%d");
}

//----- (00449720) --------------------------------------------------------
int   sub_449720(int a1)
{
  return getCurrentTimeString(a1, (int)"%H");
}

//----- (00449740) --------------------------------------------------------
int   sub_449740(int a1)
{
  return getCurrentTimeString(a1, (int)"%M");
}

//----- (00449760) --------------------------------------------------------
int   sub_449760(int a1)
{
  return getCurrentTimeString(a1, (int)"%S");
}

//----- (00449780) --------------------------------------------------------
int   sub_449780(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"DSTEnable", a2, a3);
}

//----- (004497A8) --------------------------------------------------------
int   sub_4497A8(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"DSTEnable", a2, a3);
}

//----- (004497D0) --------------------------------------------------------
int   sub_4497D0(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"DSTOffset", a2, a3);
}

//----- (004497F8) --------------------------------------------------------
int   sub_4497F8(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"DSTStartMonth", a2, a3);
}

//----- (00449820) --------------------------------------------------------
int   sub_449820(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"DSTStartWeek", a2, a3);
}

//----- (00449848) --------------------------------------------------------
int   sub_449848(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"DSTStartDay", a2, a3);
}

//----- (00449870) --------------------------------------------------------
int   sub_449870(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"DSTStartTime", a2, a3);
}

//----- (00449898) --------------------------------------------------------
int   sub_449898(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"DSTEndMonth", a2, a3);
}

//----- (004498C0) --------------------------------------------------------
int   sub_4498C0(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"DSTEndWeek", a2, a3);
}

//----- (004498E8) --------------------------------------------------------
int   sub_4498E8(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"DSTEndDay", a2, a3);
}

//----- (00449910) --------------------------------------------------------
int   sub_449910(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"DSTEndTime", a2, a3);
}

//----- (00449938) --------------------------------------------------------
int   sub_449938(int a1)
{
  return websWriteFmt(a1, (int)"%s", "no");
}

//----- (0044995C) --------------------------------------------------------
int formDefineDevice()
{
  websParaDefine("WebDebugLevel", (int)sub_446860);
  websParaDefine("Message", (int)sub_446888);
  websParaDefine("EntryNo", (int)sub_4469B8);
  websParaDefine("WebLanguage", (int)sub_4469DC);
  websParaDefine("SelectOfWebLanguage", (int)sub_446ADC);
  websParaDefine("RebootTime", (int)sub_446CC0);
  websParaDefine("ForceBootCodeUpgrade", (int)sub_446D24);
  websParaDefine("DownloadTime", (int)sub_446D48);
  websParaDefine("LastDownloadStatus", (int)sub_446DAC);
  websParaDefine("DownloadStatus", (int)sub_446E50);
  websParaDefine("Authroized", (int)sub_446FA4);
  websParaDefine("AdminLogin", (int)sub_44714C);
  websParaDefine("UserName", (int)sub_447304);
  websParaDefine("UserPassword", (int)sub_4473B8);
  websParaDefine("ActiveUserTable", (int)sub_447624);
  websParaDefine("ModName", (int)sub_447B98);
  websParaDefine("ModPassword", (int)sub_447BBC);
  websParaDefine("ModGroup", (int)sub_447C14);
  websParaDefine("TimeStamp", (int)sub_447C38);
  websParaDefine("SessionKey", (int)sub_447C58);
  websParaDefine("ModelName", (int)sub_447C78);
  websParaDefine("ModelDescription", (int)sub_447C94);
  websParaDefine("ReleaseDate", (int)sub_447CB0);
  websParaDefine("ReleaseTime", (int)sub_447CCC);
  websParaDefine("FirmwareVersion", (int)sub_447DD4);
  websParaDefine("BootCodeVersion", (int)sub_447EDC);
  websParaDefine("HardwareVersion", (int)sub_4480DC);
  websParaDefine("ROMVersion", (int)sub_4481EC);
  websParaDefine("Company", (int)sub_448294);
  websParaDefine("CompanyURL", (int)sub_4482B0);
  websParaDefine("MACAddress", (int)sub_4482CC);
  websParaDefine("MyDlinkAgentVersion", (int)sub_448388);
  websParaDefine("ReGetIndex", (int)sub_448504);
  websParaDefine("CGIVersion", (int)sub_4485A8);
  websParaDefine("NipcaVersion", (int)sub_4485CC);
  websParaDefine("CameraName", (int)sub_4485F0);
  websParaDefine("Location", (int)sub_448618);
  websParaDefine("AdminID", (int)sub_448640);
  websParaDefine("AdminPassword", (int)sub_448668);
  websParaDefine("LEDControl", (int)sub_448860);
  websParaDefine("RadioOfLEDControl", (int)sub_448888);
  websParaDefine("SnapshotURLAuthentication", (int)sub_4488B0);
  websParaDefine("RadioOfSnapshotURLAuthentication", (int)sub_4488D8);
  websParaDefine("OSDEnable", (int)sub_448900);
  websParaDefine("RadioOfOSDEnable", (int)sub_448928);
  websParaDefine("AccessControlEnable", (int)sub_448950);
  websParaDefine("RadioOfAccessControlEnable", (int)sub_448978);
  websParaDefine("UserTable", (int)sub_4489A0);
  websParaDefine("UserID", (int)sub_4490C0);
  websParaDefine("DateTimeMode", (int)sub_4491F4);
  websParaDefine("RadioOfDateTimeMode", (int)sub_44921C);
  websParaDefine("TimeServerIPAddress", (int)sub_449244);
  websParaDefine("TimeServerProtocol", (int)sub_44926C);
  websParaDefine("RadioOfTimeServerProtocol", (int)sub_449294);
  websParaDefine("TimeZone", (int)sub_4492BC);
  websParaDefine("TimeZoneIndex", (int)sub_449414);
  websParaDefine("CurrentTime", (int)sub_449650);
  websParaDefine("Date", (int)sub_449670);
  websParaDefine("Time", (int)sub_449698);
  websParaDefine("YearOfTime", (int)sub_4496C0);
  websParaDefine("MonthOfTime", (int)sub_4496E0);
  websParaDefine("DateOfTime", (int)sub_449700);
  websParaDefine("HourOfTime", (int)sub_449720);
  websParaDefine("MinuteOfTime", (int)sub_449740);
  websParaDefine("SecondOfTime", (int)sub_449760);
  websParaDefine("DSTEnable", (int)sub_449780);
  websParaDefine("RadioOfDSTEnable", (int)sub_4497A8);
  websParaDefine("DSTOffset", (int)sub_4497D0);
  websParaDefine("DSTStartMonth", (int)sub_4497F8);
  websParaDefine("DSTStartWeek", (int)sub_449820);
  websParaDefine("DSTStartDay", (int)sub_449848);
  websParaDefine("DSTStartTime", (int)sub_449870);
  websParaDefine("DSTEndMonth", (int)sub_449898);
  websParaDefine("DSTEndWeek", (int)sub_4498C0);
  websParaDefine("DSTEndDay", (int)sub_4498E8);
  websParaDefine("DSTEndTime", (int)sub_449910);
  return websParaDefine("DCSAuthentication", (int)sub_449938);
}

//----- (0044A310) --------------------------------------------------------
int   sub_44A310(int a1)
{
  int SysInfoShort; // $v1

  SysInfoShort = getSysInfoShort(26);
  if ( (unsigned __int16)SysInfoShort >= 0xFu )
    SysInfoShort = 14;
  return websWriteFmt(a1, (int)"%s", FtpTest_status[SysInfoShort]);
}
// 4E3A90: using guessed type char *FtpTest_status[15];

//----- (0044A384) --------------------------------------------------------
int   sub_44A384(int a1)
{
  int SysInfoShort; // $v1

  SysInfoShort = getSysInfoShort(27);
  if ( (unsigned __int16)SysInfoShort >= 0xBu )
    SysInfoShort = 10;
  return websWriteFmt(a1, (int)"%s", EmailTest_status[SysInfoShort]);
}
// 4E3A60: using guessed type char *EmailTest_status[11];

//----- (0044A3F8) --------------------------------------------------------
int   sub_44A3F8(int a1)
{
  int SysInfoShort; // $v1

  SysInfoShort = getSysInfoShort(95);
  if ( (unsigned __int16)SysInfoShort >= 0xAu )
    SysInfoShort = 9;
  return websWriteFmt(a1, (int)"%s", CIFSTest_status[SysInfoShort]);
}
// 4E3A34: using guessed type char *CIFSTest_status[10];

//----- (0044A46C) --------------------------------------------------------
int   sub_44A46C(int a1)
{
  int v2; // $v0
  __int16 SysInfoShort; // $s0
  int v4; // $v0
  unsigned __int16 v5; // $s0
  int v6; // $v1

  SysInfoShort = getSysInfoShort(71);
  v2 = nvram_bufget(0, "UPnPPortForwarding");
  v4 = strcmp(v2, &word_4A0308);
  v5 = SysInfoShort + 1;
  v6 = 0;
  if ( v4 )
  {
    v6 = (__int16)v5;
    if ( v5 >= 0xAu )
      v6 = 9;
  }
  return websWriteFmt(a1, (int)"%s", *(&UPnP_status + v6));
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E39EC: using guessed type _UNKNOWN *UPnP_status;
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0044A534) --------------------------------------------------------
int   sub_44A534(int a1)
{
  int SysInfoShort; // $s0
  int v3; // $v0
  char **v4; // $a2
  char *v6; // $a2
  char v7[128]; // [sp+18h] [-80h] BYREF

  SysInfoShort = getSysInfoShort(28);
  v3 = nvram_bufget(0, "DDNSEnable");
  if ( !strcmp(v3, &word_4A0308) )
    SysInfoShort = 0;
  if ( (unsigned int)(SysInfoShort - 1) >= 4 )
  {
    v6 = (char *)*(&DDNS_status + SysInfoShort);
  }
  else
  {
    getSysInfoBuffer(46, (int)v7, 128);
    v4 = (char **)(&DDNS_status + SysInfoShort);
    if ( v7[0] )
      return websWriteFmt(a1, (int)"%s, %s", *v4, v7);
    v6 = *v4;
  }
  return websWriteFmt(a1, (int)"%s", v6);
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E3A18: using guessed type _UNKNOWN *DDNS_status;
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0044A678) --------------------------------------------------------
int   sub_44A678(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"DDNSEnable", a2, a3);
}

//----- (0044A6A0) --------------------------------------------------------
int   sub_44A6A0(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"DDNSEnable", a2, a3);
}

//----- (0044A6C8) --------------------------------------------------------
int   sub_44A6C8(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"DDNSProvider", a2, a3);
}

//----- (0044A6F0) --------------------------------------------------------
int   sub_44A6F0(int a1, int a2, _DWORD *a3)
{
  return getLogoSelectString(a1, (int)"DDNSProvider", (char **)webDDNSProviderList, a2, a3);
}
// 4E41C0: using guessed type char *webDDNSProviderList[4];

//----- (0044A738) --------------------------------------------------------
int   sub_44A738(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"DDNSHostName", a2, a3);
}

//----- (0044A760) --------------------------------------------------------
int   sub_44A760(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"DDNSUserName", a2, a3);
}

//----- (0044A788) --------------------------------------------------------
int   sub_44A788(int a1, int a2, _DWORD *a3)
{
  int v4; // $s0
  char *v5; // $s0
  int v6; // $s1
  char *v8; // $v0
  char v9[256]; // [sp+18h] [-100h] BYREF

  if ( a2 > 0 )
  {
    v4 = *a3;
    if ( !strcmp(*a3, "4") )
    {
      v8 = (char *)nvram_bufget(0, "DDNSPassword");
      websEncode64(v9, v8, 255);
      return websWriteFmt(a1, (int)"%s", v9);
    }
    if ( !strcmp(v4, "5") )
      goto LABEL_4;
  }
  if ( ((*(_DWORD *)(a1 + 228) >> 22) & 1) == 0 )
    return websWritePasswordByName(a1, (int)"DDNSPassword");
LABEL_4:
  v5 = (char *)allocEncodePasswordByName(a1, (int)"DDNSPassword");
  v6 = websWriteFmt(a1, (int)"%s", v5);
  if ( v5 )
    free2(v5);
  return v6;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0044A8FC) --------------------------------------------------------
int   sub_44A8FC(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"DDNSTimeout", a2, a3);
}

//----- (0044A924) --------------------------------------------------------
int   sub_44A924(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"EmailSMTPServerAddress", a2, a3);
}

//----- (0044A94C) --------------------------------------------------------
int   sub_44A94C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"EmailSMTPPortNumber", a2, a3);
}

//----- (0044A974) --------------------------------------------------------
int   sub_44A974(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"EmailSenderAddress", a2, a3);
}

//----- (0044A99C) --------------------------------------------------------
int   sub_44A99C(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"EmailReceiverAddress", a2, a3);
}

//----- (0044A9C4) --------------------------------------------------------
int   sub_44A9C4(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"EmailUserName", a2, a3);
}

//----- (0044A9EC) --------------------------------------------------------
int   sub_44A9EC(int a1, int a2, _DWORD *a3)
{
  int v4; // $s0
  char *v5; // $s0
  int v6; // $s1
  char *v8; // $v0
  char v9[256]; // [sp+18h] [-100h] BYREF

  if ( a2 > 0 )
  {
    v4 = *a3;
    if ( !strcmp(*a3, "4") )
    {
      v8 = (char *)nvram_bufget(0, "EmailPassword");
      websEncode64(v9, v8, 255);
      return websWriteFmt(a1, (int)"%s", v9);
    }
    if ( !strcmp(v4, "5") )
      goto LABEL_4;
  }
  if ( ((*(_DWORD *)(a1 + 228) >> 22) & 1) == 0 )
    return websWritePasswordByName(a1, (int)"EmailPassword");
LABEL_4:
  v5 = (char *)allocEncodePasswordByName(a1, (int)"EmailPassword");
  v6 = websWriteFmt(a1, (int)"%s", v5);
  if ( v5 )
    free2(v5);
  return v6;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0044AB60) --------------------------------------------------------
int   sub_44AB60(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"EmailTLSAuthentication", a2, a3);
}

//----- (0044AB88) --------------------------------------------------------
int   sub_44AB88(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"EmailTLSAuthentication", a2, a3);
}

//----- (0044ABB0) --------------------------------------------------------
int   sub_44ABB0(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"EmailScheduleEnable", a2, a3);
}

//----- (0044ABD8) --------------------------------------------------------
int   sub_44ABD8(int a1, int a2, _DWORD *a3)
{
  return getCheckConfig(a1, (int)"EmailScheduleEnable", a2, a3);
}

//----- (0044AC00) --------------------------------------------------------
int   sub_44AC00(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"EmailScheduleDay", a2, a3);
}

//----- (0044AC28) --------------------------------------------------------
int   sub_44AC28(int a1, int a2, _DWORD *a3)
{
  return getCheckConfig(a1, (int)"EmailScheduleDay", a2, a3);
}

//----- (0044AC50) --------------------------------------------------------
int   sub_44AC50(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"EmailScheduleMode", a2, a3);
}

//----- (0044AC78) --------------------------------------------------------
int   sub_44AC78(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"EmailScheduleMode", a2, a3);
}

//----- (0044ACA0) --------------------------------------------------------
int   sub_44ACA0(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"EmailScheduleTimeStart", a2, a3);
}

//----- (0044ACC8) --------------------------------------------------------
int   sub_44ACC8(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"EmailScheduleTimeStop", a2, a3);
}

//----- (0044ACF0) --------------------------------------------------------
int   sub_44ACF0(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"EmailScheduleInterval", a2, a3);
}

//----- (0044AD18) --------------------------------------------------------
int   sub_44AD18(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"EmailMotionMode", a2, a3);
}

//----- (0044AD40) --------------------------------------------------------
int   sub_44AD40(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"EmailMotionMode", a2, a3);
}

//----- (0044AD68) --------------------------------------------------------
int   sub_44AD68(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"EmailMotionFrameInterval", a2, a3);
}

//----- (0044AD90) --------------------------------------------------------
int   sub_44AD90(int a1, int a2, _DWORD *a3)
{
  return getSelectStringOfMatchValue(
           a1,
           (int)"EmailMotionFrameInterval",
           (int)&motioninterval_select,
           (_BYTE **)&motioninterval_value,
           a2,
           a3);
}
// 4E381C: using guessed type char *motioninterval_select;
// 4E3828: using guessed type __int16 *motioninterval_value;

//----- (0044ADDC) --------------------------------------------------------
int   sub_44ADDC(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"FTPHostAddress", a2, a3);
}

//----- (0044AE04) --------------------------------------------------------
int   sub_44AE04(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FTPPortNumber", a2, a3);
}

//----- (0044AE2C) --------------------------------------------------------
int   sub_44AE2C(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"FTPUserName", a2, a3);
}

//----- (0044AE54) --------------------------------------------------------
int   sub_44AE54(int a1, int a2, _DWORD *a3)
{
  int v4; // $s0
  char *v5; // $s0
  int v6; // $s1
  char *v8; // $v0
  char v9[256]; // [sp+18h] [-100h] BYREF

  if ( a2 > 0 )
  {
    v4 = *a3;
    if ( !strcmp(*a3, "4") )
    {
      v8 = (char *)nvram_bufget(0, "FTPPassword");
      websEncode64(v9, v8, 255);
      return websWriteFmt(a1, (int)"%s", v9);
    }
    if ( !strcmp(v4, "5") )
      goto LABEL_4;
  }
  if ( ((*(_DWORD *)(a1 + 228) >> 22) & 1) == 0 )
    return websWritePasswordByName(a1, (int)"FTPPassword");
LABEL_4:
  v5 = (char *)allocEncodePasswordByName(a1, (int)"FTPPassword");
  v6 = websWriteFmt(a1, (int)"%s", v5);
  if ( v5 )
    free2(v5);
  return v6;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0044AFC8) --------------------------------------------------------
int   sub_44AFC8(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"FTPDirectoryPath", a2, a3);
}

//----- (0044AFF0) --------------------------------------------------------
int   sub_44AFF0(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FTPPassiveMode", a2, a3);
}

//----- (0044B018) --------------------------------------------------------
int   sub_44B018(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"FTPPassiveMode", a2, a3);
}

//----- (0044B040) --------------------------------------------------------
int   sub_44B040(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FTPScheduleEnable", a2, a3);
}

//----- (0044B068) --------------------------------------------------------
int   sub_44B068(int a1, int a2, _DWORD *a3)
{
  return getCheckConfig(a1, (int)"FTPScheduleEnable", a2, a3);
}

//----- (0044B090) --------------------------------------------------------
int   sub_44B090(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FTPScheduleDay", a2, a3);
}

//----- (0044B0B8) --------------------------------------------------------
int   sub_44B0B8(int a1, int a2, _DWORD *a3)
{
  return getCheckConfig(a1, (int)"FTPScheduleDay", a2, a3);
}

//----- (0044B0E0) --------------------------------------------------------
int   sub_44B0E0(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FTPScheduleMode", a2, a3);
}

//----- (0044B108) --------------------------------------------------------
int   sub_44B108(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"FTPScheduleMode", a2, a3);
}

//----- (0044B130) --------------------------------------------------------
int   sub_44B130(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"FTPScheduleTimeStart", a2, a3);
}

//----- (0044B158) --------------------------------------------------------
int   sub_44B158(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"FTPScheduleTimeStop", a2, a3);
}

//----- (0044B180) --------------------------------------------------------
int   sub_44B180(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FTPScheduleVideoFrequencyMode", a2, a3);
}

//----- (0044B1A8) --------------------------------------------------------
int   sub_44B1A8(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"FTPScheduleVideoFrequencyMode", a2, a3);
}

//----- (0044B1D0) --------------------------------------------------------
int   sub_44B1D0(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"FTPScheduleFramePerSecond", a2, a3);
}

//----- (0044B1F8) --------------------------------------------------------
int   sub_44B1F8(int a1, int a2, _DWORD *a3)
{
  return getSelectStringOfMatchValue(
           a1,
           (int)"FTPScheduleFramePerSecond",
           (int)&frame_select,
           (_BYTE **)&frame_value,
           a2,
           a3);
}
// 4E37F4: using guessed type _UNKNOWN *frame_select;
// 4E3808: using guessed type _UNKNOWN *frame_value;

//----- (0044B244) --------------------------------------------------------
int   sub_44B244(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FTPScheduleSecondPerFrame", a2, a3);
}

//----- (0044B26C) --------------------------------------------------------
int   sub_44B26C(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"FTPScheduleBaseFileName", a2, a3);
}

//----- (0044B294) --------------------------------------------------------
int   sub_44B294(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FTPScheduleFileMode", a2, a3);
}

//----- (0044B2BC) --------------------------------------------------------
int   sub_44B2BC(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"FTPScheduleFileMode", a2, a3);
}

//----- (0044B2E4) --------------------------------------------------------
int   sub_44B2E4(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FTPScheduleMaxFileSequenceNumber", a2, a3);
}

//----- (0044B30C) --------------------------------------------------------
int   sub_44B30C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FTPCreateFolderInterval", a2, a3);
}

//----- (0044B334) --------------------------------------------------------
int   sub_44B334(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"EmailScheduleEnableVideo", a2, a3);
}

//----- (0044B35C) --------------------------------------------------------
int   sub_44B35C(int a1, int a2, _DWORD *a3)
{
  return getCheckConfig(a1, (int)"EmailScheduleEnableVideo", a2, a3);
}

//----- (0044B384) --------------------------------------------------------
int   sub_44B384(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"EmailScheduleDayVideo", a2, a3);
}

//----- (0044B3AC) --------------------------------------------------------
int   sub_44B3AC(int a1, int a2, _DWORD *a3)
{
  return getCheckConfig(a1, (int)"EmailScheduleDayVideo", a2, a3);
}

//----- (0044B3D4) --------------------------------------------------------
int   sub_44B3D4(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"EmailScheduleModeVideo", a2, a3);
}

//----- (0044B3FC) --------------------------------------------------------
int   sub_44B3FC(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"EmailScheduleModeVideo", a2, a3);
}

//----- (0044B424) --------------------------------------------------------
int   sub_44B424(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"EmailScheduleTimeStartVideo", a2, a3);
}

//----- (0044B44C) --------------------------------------------------------
int   sub_44B44C(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"EmailScheduleTimeStopVideo", a2, a3);
}

//----- (0044B474) --------------------------------------------------------
int   sub_44B474(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"EmailScheduleIntervalVideo", a2, a3);
}

//----- (0044B49C) --------------------------------------------------------
int   sub_44B49C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"EmailScheduleVideoLimitSize", a2, a3);
}

//----- (0044B4C4) --------------------------------------------------------
int   sub_44B4C4(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"EmailScheduleVideoLimitTime", a2, a3);
}

//----- (0044B4EC) --------------------------------------------------------
int   sub_44B4EC(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FTPScheduleEnableVideo", a2, a3);
}

//----- (0044B514) --------------------------------------------------------
int   sub_44B514(int a1, int a2, _DWORD *a3)
{
  return getCheckConfig(a1, (int)"FTPScheduleEnableVideo", a2, a3);
}

//----- (0044B53C) --------------------------------------------------------
int   sub_44B53C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FTPScheduleDayVideo", a2, a3);
}

//----- (0044B564) --------------------------------------------------------
int   sub_44B564(int a1, int a2, _DWORD *a3)
{
  return getCheckConfig(a1, (int)"FTPScheduleDayVideo", a2, a3);
}

//----- (0044B58C) --------------------------------------------------------
int   sub_44B58C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FTPScheduleModeVideo", a2, a3);
}

//----- (0044B5B4) --------------------------------------------------------
int   sub_44B5B4(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"FTPScheduleModeVideo", a2, a3);
}

//----- (0044B5DC) --------------------------------------------------------
int   sub_44B5DC(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"FTPScheduleTimeStartVideo", a2, a3);
}

//----- (0044B604) --------------------------------------------------------
int   sub_44B604(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"FTPScheduleTimeStopVideo", a2, a3);
}

//----- (0044B62C) --------------------------------------------------------
int   sub_44B62C(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"FTPScheduleBaseFileNameVideo", a2, a3);
}

//----- (0044B654) --------------------------------------------------------
int   sub_44B654(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FTPScheduleVideoLimitSize", a2, a3);
}

//----- (0044B67C) --------------------------------------------------------
int   sub_44B67C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FTPScheduleVideoLimitTime", a2, a3);
}

//----- (0044B6A4) --------------------------------------------------------
int   sub_44B6A4(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"CifsServerFolder", a2, a3);
}

//----- (0044B6CC) --------------------------------------------------------
int   sub_44B6CC(int a1, int a2, _DWORD *a3)
{
  return getPrintableStringConfig(a1, (int)"CifsUserName", a2, a3);
}

//----- (0044B6F4) --------------------------------------------------------
int   sub_44B6F4(int a1, int a2, _DWORD *a3)
{
  int v4; // $s0
  char *v5; // $s0
  int v6; // $s1
  char *v8; // $v0
  char v9[256]; // [sp+18h] [-100h] BYREF

  if ( a2 > 0 )
  {
    v4 = *a3;
    if ( !strcmp(*a3, "4") )
    {
      v8 = (char *)nvram_bufget(0, "CifsPassword");
      websEncode64(v9, v8, 255);
      return websWriteFmt(a1, (int)"%s", v9);
    }
    if ( !strcmp(v4, "5") )
      goto LABEL_4;
  }
  if ( ((*(_DWORD *)(a1 + 228) >> 22) & 1) == 0 )
    return websWritePasswordByName(a1, (int)"CifsPassword");
LABEL_4:
  v5 = (char *)allocEncodePasswordByName(a1, (int)"CifsPassword");
  v6 = websWriteFmt(a1, (int)"%s", v5);
  if ( v5 )
    free2(v5);
  return v6;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0044B868) --------------------------------------------------------
int   sub_44B868(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"CifsScheduleEnable", a2, a3);
}

//----- (0044B890) --------------------------------------------------------
int   sub_44B890(int a1, int a2, _DWORD *a3)
{
  return getCheckConfig(a1, (int)"CifsScheduleEnable", a2, a3);
}

//----- (0044B8B8) --------------------------------------------------------
int   sub_44B8B8(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"CifsScheduleDay", a2, a3);
}

//----- (0044B8E0) --------------------------------------------------------
int   sub_44B8E0(int a1, int a2, _DWORD *a3)
{
  return getCheckConfig(a1, (int)"CifsScheduleDay", a2, a3);
}

//----- (0044B908) --------------------------------------------------------
int   sub_44B908(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"CifsScheduleMode", a2, a3);
}

//----- (0044B930) --------------------------------------------------------
int   sub_44B930(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"CifsScheduleMode", a2, a3);
}

//----- (0044B958) --------------------------------------------------------
int   sub_44B958(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"CifsScheduleTimeStart", a2, a3);
}

//----- (0044B980) --------------------------------------------------------
int   sub_44B980(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"CifsScheduleTimeStop", a2, a3);
}

//----- (0044B9A8) --------------------------------------------------------
int   sub_44B9A8(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"CifsMaxRecordTime", a2, a3);
}

//----- (0044B9D0) --------------------------------------------------------
int   sub_44B9D0(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"CifsFullAction", a2, a3);
}

//----- (0044B9F8) --------------------------------------------------------
int   sub_44B9F8(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"CifsFullAction", a2, a3);
}

//----- (0044BA20) --------------------------------------------------------
int formDefineNetworkAPI()
{
  websParaDefine("ResultOfFTPServerTest", (int)sub_44A310);
  websParaDefine("ResultOfEmailTest", (int)sub_44A384);
  websParaDefine("ResultOfCIFSServerTest", (int)sub_44A3F8);
  websParaDefine("StatusOfUPnPPortForwarding", (int)sub_44A46C);
  websParaDefine("StatusOfDynamicDNS", (int)sub_44A534);
  websParaDefine("DDNSEnable", (int)sub_44A678);
  websParaDefine("RadioOfDDNSEnable", (int)sub_44A6A0);
  websParaDefine("DDNSProvider", (int)sub_44A6C8);
  websParaDefine("LogoSelectDDNSProvider", (int)sub_44A6F0);
  websParaDefine("DDNSHostName", (int)sub_44A738);
  websParaDefine("DDNSUserName", (int)sub_44A760);
  websParaDefine("DDNSPassword", (int)sub_44A788);
  websParaDefine("DDNSTimeout", (int)sub_44A8FC);
  websParaDefine("EmailSMTPServerAddress", (int)sub_44A924);
  websParaDefine("EmailSMTPPortNumber", (int)sub_44A94C);
  websParaDefine("EmailSenderAddress", (int)sub_44A974);
  websParaDefine("EmailReceiverAddress", (int)sub_44A99C);
  websParaDefine("EmailUserName", (int)sub_44A9C4);
  websParaDefine("EmailPassword", (int)sub_44A9EC);
  websParaDefine("EmailTLSAuthentication", (int)sub_44AB60);
  websParaDefine("RadioOfEmailTLSAuthentication", (int)sub_44AB88);
  websParaDefine("EmailScheduleEnable", (int)sub_44ABB0);
  websParaDefine("CheckOfEmailScheduleEnable", (int)sub_44ABD8);
  websParaDefine("EmailScheduleDay", (int)sub_44AC00);
  websParaDefine("CheckOfEmailScheduleDay", (int)sub_44AC28);
  websParaDefine("EmailScheduleMode", (int)sub_44AC50);
  websParaDefine("RadioOfEmailScheduleMode", (int)sub_44AC78);
  websParaDefine("EmailScheduleTimeStart", (int)sub_44ACA0);
  websParaDefine("EmailScheduleTimeStop", (int)sub_44ACC8);
  websParaDefine("EmailScheduleInterval", (int)sub_44ACF0);
  websParaDefine("EmailMotionMode", (int)sub_44AD18);
  websParaDefine("RadioOfEmailMotionMode", (int)sub_44AD40);
  websParaDefine("EmailMotionFrameInterval", (int)sub_44AD68);
  websParaDefine("SelectOfEmailMotionFrameInterval", (int)sub_44AD90);
  websParaDefine("FTPHostAddress", (int)sub_44ADDC);
  websParaDefine("FTPPortNumber", (int)sub_44AE04);
  websParaDefine("FTPUserName", (int)sub_44AE2C);
  websParaDefine("FTPPassword", (int)sub_44AE54);
  websParaDefine("FTPDirectoryPath", (int)sub_44AFC8);
  websParaDefine("FTPPassiveMode", (int)sub_44AFF0);
  websParaDefine("RadioOfFTPPassiveMode", (int)sub_44B018);
  websParaDefine("FTPScheduleEnable", (int)sub_44B040);
  websParaDefine("CheckOfFTPScheduleEnable", (int)sub_44B068);
  websParaDefine("FTPScheduleDay", (int)sub_44B090);
  websParaDefine("CheckOfFTPScheduleDay", (int)sub_44B0B8);
  websParaDefine("FTPScheduleMode", (int)sub_44B0E0);
  websParaDefine("RadioOfFTPScheduleMode", (int)sub_44B108);
  websParaDefine("FTPScheduleTimeStart", (int)sub_44B130);
  websParaDefine("FTPScheduleTimeStop", (int)sub_44B158);
  websParaDefine("FTPScheduleVideoFrequencyMode", (int)sub_44B180);
  websParaDefine("RadioOfFTPScheduleVideoFrequencyMode", (int)sub_44B1A8);
  websParaDefine("FTPScheduleFramePerSecond", (int)sub_44B1D0);
  websParaDefine("SelectOfFTPScheduleFramePerSecond", (int)sub_44B1F8);
  websParaDefine("FTPScheduleSecondPerFrame", (int)sub_44B244);
  websParaDefine("FTPScheduleBaseFileName", (int)sub_44B26C);
  websParaDefine("FTPScheduleFileMode", (int)sub_44B294);
  websParaDefine("RadioOfFTPScheduleFileMode", (int)sub_44B2BC);
  websParaDefine("FTPScheduleMaxFileSequenceNumber", (int)sub_44B2E4);
  websParaDefine("FTPCreateFolderInterval", (int)sub_44B30C);
  websParaDefine("EmailScheduleEnableVideo", (int)sub_44B334);
  websParaDefine("CheckOfEmailScheduleEnableVideo", (int)sub_44B35C);
  websParaDefine("EmailScheduleDayVideo", (int)sub_44B384);
  websParaDefine("CheckOfEmailScheduleDayVideo", (int)sub_44B3AC);
  websParaDefine("EmailScheduleModeVideo", (int)sub_44B3D4);
  websParaDefine("RadioOfEmailScheduleModeVideo", (int)sub_44B3FC);
  websParaDefine("EmailScheduleTimeStartVideo", (int)sub_44B424);
  websParaDefine("EmailScheduleTimeStopVideo", (int)sub_44B44C);
  websParaDefine("EmailScheduleIntervalVideo", (int)sub_44B474);
  websParaDefine("EmailScheduleVideoLimitSize", (int)sub_44B49C);
  websParaDefine("EmailScheduleVideoLimitTime", (int)sub_44B4C4);
  websParaDefine("FTPScheduleEnableVideo", (int)sub_44B4EC);
  websParaDefine("CheckOfFTPScheduleEnableVideo", (int)sub_44B514);
  websParaDefine("FTPScheduleDayVideo", (int)sub_44B53C);
  websParaDefine("CheckOfFTPScheduleDayVideo", (int)sub_44B564);
  websParaDefine("FTPScheduleModeVideo", (int)sub_44B58C);
  websParaDefine("RadioOfFTPScheduleModeVideo", (int)sub_44B5B4);
  websParaDefine("FTPScheduleTimeStartVideo", (int)sub_44B5DC);
  websParaDefine("FTPScheduleTimeStopVideo", (int)sub_44B604);
  websParaDefine("FTPScheduleBaseFileNameVideo", (int)sub_44B62C);
  websParaDefine("FTPScheduleVideoLimitSize", (int)sub_44B654);
  websParaDefine("FTPScheduleVideoLimitTime", (int)sub_44B67C);
  websParaDefine("CifsServerFolder", (int)sub_44B6A4);
  websParaDefine("CifsUserName", (int)sub_44B6CC);
  websParaDefine("CifsPassword", (int)sub_44B6F4);
  websParaDefine("CifsScheduleEnable", (int)sub_44B868);
  websParaDefine("CheckOfCifsScheduleEnable", (int)sub_44B890);
  websParaDefine("CifsScheduleDay", (int)sub_44B8B8);
  websParaDefine("CheckOfCifsScheduleDay", (int)sub_44B8E0);
  websParaDefine("CifsScheduleMode", (int)sub_44B908);
  websParaDefine("RadioOfCifsScheduleMode", (int)sub_44B930);
  websParaDefine("CifsScheduleTimeStart", (int)sub_44B958);
  websParaDefine("CifsScheduleTimeStop", (int)sub_44B980);
  websParaDefine("CifsMaxRecordTime", (int)sub_44B9A8);
  websParaDefine("CifsFullAction", (int)sub_44B9D0);
  return websParaDefine("RadioOfCifsFullAction", (int)sub_44B9F8);
}

//----- (0044C614) --------------------------------------------------------
int   checklivefile(int a1, int a2)
{
  int v4; // $s1
  int v5; // $s2
  int v6; // $s4
  int v7; // $s1
  int v8; // $s0
  int result; // $v0
  int Var; // $v0
  int v11; // $t2
  int v12; // $t5
  int v13; // $t1
  int i; // $a3
  int *v15; // $a2
  int v16; // $v0
  int v17; // $v1
  int v18; // $v0
  int v19; // $a0
  int v20; // $v0
  int *v21; // $t1

  v4 = strlen(livefilestart);
  v5 = atoi(a2 + 2 + v4);
  v6 = atoi(a2 + 34 + v4);
  v7 = atoi(a2 + 66 + v4);
  trace(1, (int)"Live view = (%d, %d, %d\n", v5, v6, v7);
  v8 = -1;
  if ( !websTestVar(a1, (int)"viewidx") )
    return -1;
  Var = websGetVar(a1, (int)"viewidx", (int)&word_4A0308);
  v11 = atoi(Var);
  v12 = 0;
  v13 = -1;
  for ( i = 0; i < 32; ++i )
  {
    while ( 1 )
    {
      v19 = 8 * i;
      if ( v13 != -1 )
      {
        v15 = (int *)((char *)&liverec + v19);
        goto LABEL_6;
      }
      v15 = (int *)((char *)&liverec + v19);
      if ( !*(_DWORD *)((char *)&liverec + v19) )
        break;
LABEL_6:
      v16 = *v15;
      if ( *v15 == v11 )
        goto LABEL_16;
LABEL_7:
      if ( v16 )
      {
        v17 = v15[1];
        if ( v17 < v5 )
        {
          v18 = v5 - v17;
          goto LABEL_10;
        }
        if ( v5 < v17 )
        {
          v18 = 9999 - (v17 - v5);
LABEL_10:
          if ( v18 >= 10 )
          {
            v15[1] = 0;
            *v15 = 0;
          }
        }
      }
LABEL_12:
      if ( ++i >= 32 )
        goto LABEL_24;
    }
    v16 = *v15;
    v13 = i;
    if ( *v15 != v11 )
      goto LABEL_7;
LABEL_16:
    v20 = v15[1];
    v12 = 1;
    if ( v20 == v5 )
      v8 = v5 + 1;
    if ( v20 == v6 )
      v8 = v20 + 1;
    if ( v20 == v7 )
      v8 = v7 + 1;
    if ( v8 == -1 )
    {
      v15[1] = v7;
      goto LABEL_12;
    }
    v8 %= 9999;
    v15[1] = (v8 + 2) % 9999;
  }
LABEL_24:
  result = v8;
  if ( !v12 && v8 == -1 && v13 != -1 )
  {
    v21 = (int *)((char *)&liverec + 8 * v13);
    v21[1] = v7;
    *v21 = v11;
  }
  return result;
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);

//----- (0044C900) --------------------------------------------------------
int *  getHttpLiveStream(int a1)
{
  int v2; // $s4
  int v3; // $s1
  char v5[64]; // [sp+20h] [-A8h] BYREF
  __int16 v6; // [sp+60h] [-68h] BYREF
  char v7[32]; // [sp+62h] [-66h] BYREF
  char v8[32]; // [sp+82h] [-46h] BYREF
  char v9[38]; // [sp+A2h] [-26h] BYREF

  getSysInfoBuffer(92, (int)&v6, 98);
  snprintf(v5, 64, "%d", v6);
  websSetVar(a1, "LiveStreamingDuration", v5);
  v2 = checklivefile(a1, (int)&v6);
  if ( v2 == -1 )
  {
    websSetVar(a1, "LiveStreamingFile1", v7);
    websSetVar(a1, "LiveStreamingFile2", v8);
    return websSetVar(a1, "LiveStreamingFile3", v9);
  }
  else
  {
    v3 = (v2 + 2) % 9999;
    trace(1, (int)"New Live view = (%d, %d, %d\n", v2, (v2 + 1) % 9999, v3);
    snprintf(v5, 64, "%s%d%s", livefilestart, v2, ".ts");
    websSetVar(a1, "LiveStreamingFile1", v5);
    snprintf(v5, 64, "%s%d%s", livefilestart, (v2 + 1) % 9999, ".ts");
    websSetVar(a1, "LiveStreamingFile2", v5);
    snprintf(v5, 64, "%s%d%s", livefilestart, v3, ".ts");
    return websSetVar(a1, "LiveStreamingFile3", v5);
  }
}
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (0044CBB8) --------------------------------------------------------
int   sub_44CBB8(int a1)
{
  return websWriteFmt(a1, (int)&word_4A0308);
}
// 4A0308: using guessed type __int16 word_4A0308;

//----- (0044CBD8) --------------------------------------------------------
int   sub_44CBD8(int a1)
{
  return websWriteFmt(a1, (int)&word_4A0308);
}
// 4A0308: using guessed type __int16 word_4A0308;

//----- (0044CBF8) --------------------------------------------------------
int   sub_44CBF8(int a1)
{
  int SysInfoShort; // $v0

  SysInfoShort = getSysInfoShort(24);
  return websWriteFmt(a1, (int)"%s", (char *)(&ptz_status)[SysInfoShort]);
}
// 4E3920: using guessed type char (*ptz_status)[4];

//----- (0044CC58) --------------------------------------------------------
int   sub_44CC58(int a1)
{
  return websgetSysInfoLong(a1, 22);
}

//----- (0044CC74) --------------------------------------------------------
int   sub_44CC74(int a1)
{
  int v2; // $v0
  int v3; // $v0
  int v4; // $s1
  void *SelectString; // $v0
  int v6; // $s0
  _BYTE *v7; // $v0
  int v8; // $v0

  v2 = nvram_bufget(0, "VideoResolution");
  v4 = 0;
  v3 = atoi(v2);
  SelectString = (void *)websGetSelectString(resolution_select, v3);
  v6 = strdupWithoutNull(SelectString);
  if ( v6 )
  {
    v7 = (_BYTE *)strchr(v6, 120);
    if ( v7 )
    {
      *v7 = 0;
      v8 = websWriteFmt(a1, (int)"%s", v6);
    }
    else
    {
      v8 = websWriteFmt(a1, (int)"%s", "320");
    }
    v4 = v8;
    free2(v6);
  }
  return v4;
}
// 44CD4C: conditional instruction was optimized away because $s0.4!=0
// 4E378C: using guessed type char *resolution_select[3];
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0044CD94) --------------------------------------------------------
int   sub_44CD94(int a1)
{
  int v2; // $v0
  int v3; // $v0
  int v4; // $s1
  void *SelectString; // $v0
  int v6; // $s0
  _BYTE *v7; // $v0
  char *v8; // $s1
  int v9; // $v0
  int v10; // $a0
  char *v11; // $a2
  int v12; // $v0

  v2 = nvram_bufget(0, "VideoResolution");
  v4 = 0;
  v3 = atoi(v2);
  SelectString = (void *)websGetSelectString(resolution_select, v3);
  v6 = strdupWithoutNull(SelectString);
  if ( v6 )
  {
    v7 = (_BYTE *)strchr(v6, 120);
    v8 = v7 + 1;
    if ( v7 )
    {
      *v7 = 0;
      v9 = strcmp(v7 + 1, "120");
      v10 = a1;
      v11 = "112";
      if ( v9 )
      {
        v10 = a1;
        v11 = v8;
      }
      v12 = websWriteFmt(v10, (int)"%s", v11);
    }
    else
    {
      v12 = websWriteFmt(a1, (int)"%s", "240");
    }
    v4 = v12;
    free2(v6);
  }
  return v4;
}
// 44CEB0: conditional instruction was optimized away because $s0.4!=0
// 4E378C: using guessed type char *resolution_select[3];
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0044CF08) --------------------------------------------------------
int   sub_44CF08(int a1, int a2, _DWORD *a3)
{
  int v5; // $v0
  int v7; // $v0
  int v8; // $s1
  void *SelectString; // $v0
  int v10; // $s0
  _BYTE *v11; // $v0
  int v12; // $s1
  int v13; // $v0

  v5 = nvram_bufget(0, "VideoResolution");
  v8 = 0;
  v7 = atoi(v5);
  SelectString = (void *)websGetSelectString(resolution_select, v7);
  v10 = strdupWithoutNull(SelectString);
  if ( v10 )
  {
    v12 = 320;
    v11 = (_BYTE *)strchr(v10, 120);
    if ( v11 )
    {
      *v11 = 0;
      v12 = atoi(v10);
    }
    if ( a2 > 0 )
    {
      v13 = atoi(*a3);
      if ( v12 < v13 )
        v13 = v12;
      v12 = v13;
    }
    v8 = websWriteFmt(a1, (int)"%d", v12);
    free2(v10);
  }
  return v8;
}
// 44D030: conditional instruction was optimized away because $s0.4!=0
// 4E378C: using guessed type char *resolution_select[3];
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0044D070) --------------------------------------------------------
int   sub_44D070(int a1, int a2, _DWORD *a3)
{
  int v5; // $v0
  int v7; // $v0
  int v8; // $s0
  void *SelectString; // $v0
  int v10; // $v0
  int v11; // $s1
  _BYTE *v12; // $v0
  int v13; // $s0
  _BYTE *v14; // $s2
  int v15; // $v0

  v5 = nvram_bufget(0, "VideoResolution");
  v8 = 0;
  v7 = atoi(v5);
  SelectString = (void *)websGetSelectString(resolution_select, v7);
  v10 = strdupWithoutNull(SelectString);
  v11 = v10;
  if ( v10 )
  {
    v12 = (_BYTE *)strchr(v10, 120);
    v13 = 240;
    if ( v12 )
    {
      v14 = v12 + 1;
      *v12 = 0;
      v13 = 112;
      if ( strcmp(v12 + 1, "120") )
        v13 = atoi(v14);
    }
    if ( a2 > 0 )
    {
      v15 = atoi(*a3);
      if ( v13 < v15 )
        v15 = v13;
      v13 = v15;
    }
    v8 = websWriteFmt(a1, (int)"%d", v13);
    if ( v11 )
      free2(v11);
  }
  return v8;
}
// 4E378C: using guessed type char *resolution_select[3];
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0044D204) --------------------------------------------------------
int   sub_44D204(int a1)
{
  return getStringVar(a1, (int)"CheckFrameRate", (int)&word_4A0308);
}
// 4A0308: using guessed type __int16 word_4A0308;

//----- (0044D228) --------------------------------------------------------
int   sub_44D228(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FPSEnable", a2, a3);
}

//----- (0044D250) --------------------------------------------------------
int   sub_44D250(int a1)
{
  int Var; // $v0

  Var = websGetVar(a1, (int)"Profile", (int)"1");
  return websWriteFmt(a1, Var);
}

//----- (0044D2A8) --------------------------------------------------------
int   sub_44D2A8(int a1)
{
  int v2; // $v0
  int v3; // $s3
  int Var; // $v0
  int v5; // $s0
  int v6; // $v0
  void *SelectString; // $v0
  int v8; // $v0
  int v9; // $s0
  _BYTE *v10; // $v0
  int v11; // $v0
  int v13; // $v0
  int v14; // $v0
  int v15; // $v0

  v2 = nvram_bufget(0, "VideoResolution264");
  v3 = 0;
  v5 = atoi(v2);
  Var = websGetVar(a1, (int)"Profile", (int)"1");
  if ( atoi(Var) == 2 )
  {
    v13 = nvram_bufget(0, "VideoResolution264_2");
    v5 = atoi(v13);
    v14 = websGetVar(a1, (int)"Profile", (int)"1");
    if ( atoi(v14) != 3 )
      goto LABEL_3;
  }
  else
  {
    v6 = websGetVar(a1, (int)"Profile", (int)"1");
    if ( atoi(v6) != 3 )
      goto LABEL_3;
  }
  v15 = nvram_bufget(0, "VideoResolution264_3");
  v5 = atoi(v15);
LABEL_3:
  SelectString = (void *)websGetSelectString(resolution_select, v5);
  v8 = strdupWithoutNull(SelectString);
  v9 = v8;
  if ( v8 )
  {
    v10 = (_BYTE *)strchr(v8, 120);
    if ( v10 )
    {
      *v10 = 0;
      v11 = websWriteFmt(a1, (int)"%s", v9);
    }
    else
    {
      v11 = websWriteFmt(a1, (int)"%s", "320");
    }
    v3 = v11;
    if ( v9 )
      free2(v9);
  }
  return v3;
}
// 4E378C: using guessed type char *resolution_select[3];
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0044D4F8) --------------------------------------------------------
int   sub_44D4F8(int a1)
{
  int v2; // $v0
  int v3; // $s3
  int Var; // $v0
  int v5; // $s0
  int v6; // $v0
  void *SelectString; // $v0
  int v8; // $v0
  int v9; // $s0
  _BYTE *v10; // $v0
  _BYTE *v11; // $s1
  int v12; // $v0
  int v14; // $v0
  int v15; // $v0

  v2 = nvram_bufget(0, "VideoResolution264");
  v3 = 0;
  v5 = atoi(v2);
  Var = websGetVar(a1, (int)"Profile", (int)"1");
  if ( atoi(Var) == 2 )
  {
    v15 = nvram_bufget(0, "VideoResolution264_2");
    v5 = atoi(v15);
  }
  v6 = websGetVar(a1, (int)"Profile", (int)"1");
  if ( atoi(v6) == 3 )
  {
    v14 = nvram_bufget(0, "VideoResolution264_3");
    v5 = atoi(v14);
  }
  SelectString = (void *)websGetSelectString(resolution_select, v5);
  v8 = strdupWithoutNull(SelectString);
  v9 = v8;
  if ( v8 )
  {
    v10 = (_BYTE *)strchr(v8, 120);
    v11 = v10 + 1;
    if ( v10 )
    {
      *v10 = 0;
      if ( !strcmp(v10 + 1, "120") )
        v12 = websWriteFmt(a1, (int)"%s", "112");
      else
        v12 = websWriteFmt(a1, (int)"%s", v11);
    }
    else
    {
      v12 = websWriteFmt(a1, (int)"%s", "240");
    }
    v3 = v12;
    if ( v9 )
      free2(v9);
  }
  return v3;
}
// 4E378C: using guessed type char *resolution_select[3];
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0044D750) --------------------------------------------------------
int   sub_44D750(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"VideoResolution264", a2, a3);
}

//----- (0044D778) --------------------------------------------------------
int   sub_44D778(int a1, int a2, _DWORD *a3)
{
  int Var; // $v0
  int v7; // $v0
  int v8; // $v0
  char *v9; // $a1
  int v10; // $a0
  int v11; // $a2
  _DWORD *v12; // $a3

  Var = websGetVar(a1, (int)"Profile", (int)"1");
  if ( atoi(Var) == 2 )
    return getRadioConfig(a1, (int)"VideoResolution264_2", a2, a3);
  v7 = websGetVar(a1, (int)"Profile", (int)"1");
  v8 = atoi(v7);
  v9 = "VideoResolution264_3";
  v10 = a1;
  v11 = a2;
  v12 = a3;
  if ( v8 != 3 )
  {
    v10 = a1;
    v9 = "VideoResolution264";
    v11 = a2;
    v12 = a3;
  }
  return getRadioConfig(v10, (int)v9, v11, v12);
}
// 4E9F38: using guessed type int   atoi(_DWORD);

//----- (0044D8B0) --------------------------------------------------------
int   sub_44D8B0(int a1, int a2, _DWORD *a3)
{
  int Var; // $v0
  int v7; // $v0

  Var = websGetVar(a1, (int)"Profile", (int)"1");
  if ( atoi(Var) == 2 )
    return getStringOfValueSelect(a1, (int)"VideoResolution264_2", resolution_select, a2, a3);
  v7 = websGetVar(a1, (int)"Profile", (int)"1");
  if ( atoi(v7) == 3 )
    return getStringOfValueSelect(a1, (int)"VideoResolution264_3", resolution_select, a2, a3);
  else
    return getStringOfValueSelect(a1, (int)"VideoResolution264", resolution_select, a2, a3);
}
// 4E378C: using guessed type char *resolution_select[3];
// 4E9F38: using guessed type int   atoi(_DWORD);

//----- (0044DA2C) --------------------------------------------------------
int   sub_44DA2C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FrameRate264", a2, a3);
}

//----- (0044DA54) --------------------------------------------------------
int   sub_44DA54(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"FrameRate264", a2, a3);
}

//----- (0044DA7C) --------------------------------------------------------
int   sub_44DA7C(int a1, int a2, _DWORD *a3)
{
  return getStringOfMatchValue(a1, (int)"FrameRate264", (int)&framerate_select, (_BYTE **)&framerate_value, a2, a3);
}
// 4E379C: using guessed type char *framerate_select;
// 4E37C8: using guessed type __int16 *framerate_value;

//----- (0044DAC8) --------------------------------------------------------
int   sub_44DAC8(int a1, int a2, _DWORD *a3)
{
  int Var; // $v0
  int BitRateValue; // $v0

  if ( a2 > 0 && !strcmp(*a3, "2") && websTestVar(a1, (int)"BitRate264") )
    Var = websGetVar(a1, (int)"BitRate264", (int)&word_4A0308);
  else
    Var = nvram_bufget(0, "BitRate264");
  BitRateValue = getBitRateValue(Var);
  return websWriteFmt(a1, (int)"%d", BitRateValue);
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0044DBB0) --------------------------------------------------------
int   sub_44DBB0(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"BitRate264", a2, a3);
}

//----- (0044DBD8) --------------------------------------------------------
int   sub_44DBD8(int a1, int a2, _DWORD *a3)
{
  return getStringOfValueSelect(a1, (int)"BitRate264", bitrate_select, a2, a3);
}
// 4E365C: using guessed type char *bitrate_select[11];

//----- (0044DC20) --------------------------------------------------------
int   sub_44DC20(int a1)
{
  if ( !websTestVar(a1, (int)"LiveStreamingDuration") )
    getHttpLiveStream(a1);
  return getStringVar(a1, (int)"LiveStreamingDuration", (int)"2");
}

//----- (0044DCC4) --------------------------------------------------------
int   sub_44DCC4(int a1)
{
  if ( !websTestVar(a1, (int)"LiveStreamingDuration") )
    getHttpLiveStream(a1);
  return getStringVar(a1, (int)"LiveStreamingFile1", (int)byte_4A2DDC);
}

//----- (0044DD64) --------------------------------------------------------
int   sub_44DD64(int a1)
{
  if ( !websTestVar(a1, (int)"LiveStreamingDuration") )
    getHttpLiveStream(a1);
  return getStringVar(a1, (int)"LiveStreamingFile2", (int)byte_4A2DDC);
}

//----- (0044DE04) --------------------------------------------------------
int   sub_44DE04(int a1)
{
  if ( !websTestVar(a1, (int)"LiveStreamingDuration") )
    getHttpLiveStream(a1);
  return getStringVar(a1, (int)"LiveStreamingFile3", (int)byte_4A2DDC);
}

//----- (0044DEA4) --------------------------------------------------------
int   sub_44DEA4(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"ViewMode", a2, a3);
}

//----- (0044DECC) --------------------------------------------------------
int   sub_44DECC(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"VideoResolution", a2, a3);
}

//----- (0044DEF4) --------------------------------------------------------
int   sub_44DEF4(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"VideoResolution", a2, a3);
}

//----- (0044DF1C) --------------------------------------------------------
int   sub_44DF1C(int a1, int a2, _DWORD *a3)
{
  return getStringOfValueSelect(a1, (int)"VideoResolution", resolution_select, a2, a3);
}
// 4E378C: using guessed type char *resolution_select[3];

//----- (0044DF64) --------------------------------------------------------
int   sub_44DF64(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"CompressionRate", a2, a3);
}

//----- (0044DF8C) --------------------------------------------------------
int   sub_44DF8C(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"CompressionRate", a2, a3);
}

//----- (0044DFB4) --------------------------------------------------------
int   sub_44DFB4(int a1, int a2, _DWORD *a3)
{
  return getStringOfValueSelect(a1, (int)"CompressionRate", compress_select, a2, a3);
}
// 4E3750: using guessed type char *compress_select[5];

//----- (0044DFFC) --------------------------------------------------------
int   sub_44DFFC(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"FrameRate", a2, a3);
}

//----- (0044E024) --------------------------------------------------------
int   sub_44E024(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"FrameRate", a2, a3);
}

//----- (0044E04C) --------------------------------------------------------
int   sub_44E04C(int a1, int a2, _DWORD *a3)
{
  return getStringOfMatchValue(a1, (int)"FrameRate", (int)&framerate_select, (_BYTE **)&framerate_value, a2, a3);
}
// 4E379C: using guessed type char *framerate_select;
// 4E37C8: using guessed type __int16 *framerate_value;

//----- (0044E098) --------------------------------------------------------
int   sub_44E098(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"LightFrequency", a2, a3);
}

//----- (0044E0C0) --------------------------------------------------------
int   sub_44E0C0(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"LightFrequency", a2, a3);
}

//----- (0044E0E8) --------------------------------------------------------
int   sub_44E0E8(int a1, int a2, _DWORD *a3)
{
  return getStringOfValueSelect(a1, (int)"LightFrequency", lightfreq_select, a2, a3);
}
// 4E3740: using guessed type char *lightfreq_select[3];

//----- (0044E130) --------------------------------------------------------
int   sub_44E130(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"BrightnessControl", a2, a3);
}

//----- (0044E158) --------------------------------------------------------
int   sub_44E158(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"ContrastControl", a2, a3);
}

//----- (0044E180) --------------------------------------------------------
int   sub_44E180(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"SaturationControl", a2, a3);
}

//----- (0044E1A8) --------------------------------------------------------
int   sub_44E1A8(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"SharpnessControl", a2, a3);
}

//----- (0044E1D0) --------------------------------------------------------
int   sub_44E1D0(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"AntiFlickerEnable", a2, a3);
}

//----- (0044E1F8) --------------------------------------------------------
int   sub_44E1F8(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"Mirror", a2, a3);
}

//----- (0044E220) --------------------------------------------------------
int   sub_44E220(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"AudioEnable", a2, a3);
}

//----- (0044E248) --------------------------------------------------------
int   sub_44E248(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"AudioEnable", a2, a3);
}

//----- (0044E270) --------------------------------------------------------
int   sub_44E270(int a1, int a2, _DWORD *a3)
{
  return getStringOfValueSelect(a1, (int)"AudioEnable", (_BYTE **)&disableenable_select, a2, a3);
}
// 4E3998: using guessed type _UNKNOWN *disableenable_select;

//----- (0044E2B8) --------------------------------------------------------
int   sub_44E2B8(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"AudioVolume", a2, a3);
}

//----- (0044E2E0) --------------------------------------------------------
int   sub_44E2E0(int a1)
{
  int v1; // $v0
  int v3; // $a0
  int Var; // $s0
  int v5; // $v0
  char *v6; // $a2

  v1 = websTestVar(a1, (int)"profileid");
  v3 = a1;
  if ( !v1 )
  {
    v6 = "PCM, AAC";
    return websWriteFmt(v3, (int)"%s", v6);
  }
  Var = websGetVar(a1, (int)"profileid", (int)&word_4A0308);
  if ( strcmp(Var, "1") )
  {
    v5 = strcmp(Var, "2");
    v3 = a1;
    v6 = (char *)&off_49E60C;
    if ( v5 )
      return websWriteFmt(a1, (int)"%s", "PCM, AAC");
    return websWriteFmt(v3, (int)"%s", v6);
  }
  return websWriteFmt(a1, (int)"%s", "PCM");
}
// 49E60C: using guessed type _UNKNOWN *off_49E60C;
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (0044E420) --------------------------------------------------------
int   sub_44E420(int a1)
{
  return websWriteFmt(a1, (int)"%s", "11.025 kHz");
}

//----- (0044E444) --------------------------------------------------------
int   sub_44E444(int a1)
{
  int Var; // $v0
  int v3; // $v0
  int v5[2]; // [sp+18h] [-20h] BYREF
  int v6; // [sp+20h] [-18h]
  int v7; // [sp+24h] [-14h]
  char v8[16]; // [sp+28h] [-10h] BYREF

  if ( !websTestVar(a1, (int)"CurrentPanPosition") )
  {
    v5[0] = 4;
    v5[1] = 0;
    v6 = 0;
    v7 = 0;
    pantilt_cmd(v5);
    stritoa(v6, v8, 16);
    websSetVar(a1, "CurrentPanPosition", v8);
    stritoa(v7, v8, 16);
    websSetVar(a1, "CurrentTiltPosition", v8);
  }
  Var = websGetVar(a1, (int)"CurrentPanPosition", (int)&word_4A0308);
  v3 = atoi(Var);
  return websWriteFmt(a1, (int)"%d", v3);
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F38: using guessed type int   atoi(_DWORD);

//----- (0044E5E0) --------------------------------------------------------
int   sub_44E5E0(int a1)
{
  int Var; // $v0
  int v3; // $v0
  int v5[2]; // [sp+18h] [-20h] BYREF
  int v6; // [sp+20h] [-18h]
  int v7; // [sp+24h] [-14h]
  char v8[16]; // [sp+28h] [-10h] BYREF

  if ( !websTestVar(a1, (int)"CurrentTiltPosition") )
  {
    v5[0] = 4;
    v5[1] = 0;
    v6 = 0;
    v7 = 0;
    pantilt_cmd(v5);
    stritoa(v6, v8, 16);
    websSetVar(a1, "CurrentPanPosition", v8);
    stritoa(v7, v8, 16);
    websSetVar(a1, "CurrentTiltPosition", v8);
  }
  Var = websGetVar(a1, (int)"CurrentTiltPosition", (int)&word_4A0308);
  v3 = atoi(Var);
  return websWriteFmt(a1, (int)"%d", v3);
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9F38: using guessed type int   atoi(_DWORD);

//----- (0044E77C) --------------------------------------------------------
int   sub_44E77C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"PanSingleMoveDegree", a2, a3);
}

//----- (0044E7A4) --------------------------------------------------------
int   sub_44E7A4(int a1, int a2, _DWORD *a3)
{
  return getSelectString(a1, (int)"PanSingleMoveDegree", (_BYTE **)&degree_select, a2, a3);
}
// 4E36A4: using guessed type _UNKNOWN *degree_select;

//----- (0044E7EC) --------------------------------------------------------
int   sub_44E7EC(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"TiltSingleMoveDegree", a2, a3);
}

//----- (0044E814) --------------------------------------------------------
int   sub_44E814(int a1, int a2, _DWORD *a3)
{
  return getSelectString(a1, (int)"TiltSingleMoveDegree", (_BYTE **)&degree_select, a2, a3);
}
// 4E36A4: using guessed type _UNKNOWN *degree_select;

//----- (0044E85C) --------------------------------------------------------
int   sub_44E85C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"SwingTimeInterval", a2, a3);
}

//----- (0044E884) --------------------------------------------------------
int   sub_44E884(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"DwellingTime", a2, a3);
}

//----- (0044E8AC) --------------------------------------------------------
int   sub_44E8AC(int a1, int a2, _DWORD *a3)
{
  int v4; // $a3
  _BYTE *v6; // $v0
  _BYTE *v7; // $s1
  int v8; // $s0
  int v9; // $s0
  _BYTE v10[64]; // [sp+20h] [-60h] BYREF
  int v11[4]; // [sp+60h] [-20h] BYREF
  _BYTE *v12; // [sp+70h] [-10h] BYREF
  char *v13; // [sp+74h] [-Ch] BYREF
  char *v14; // [sp+78h] [-8h] BYREF

  if ( a2 <= 0 )
    return 0;
  v4 = atoi(*a3);
  if ( !v4 )
  {
    v11[0] = 2;
    pantilt_cmd(v11);
    return websWriteFmt(a1, (int)"Home (%d,%d)", v11[2], v11[3]);
  }
  if ( (unsigned int)(v4 - 1) >= 0x18 )
    return 0;
  snprintf(v10, 64, "SetPosition%d", v4);
  v6 = (_BYTE *)nvram_bufget(0, v10);
  v7 = v6;
  if ( !v6 || !*v6 )
    return 0;
  ParseSetPoition((int)v6, &v12, &v13, &v14, byte_4A2DDC);
  v8 = WritePrintableString(a1, v12);
  v9 = v8 + websWriteFmt(a1, (int)" (%s,%s)", v13, v14);
  free2(v7);
  return v9;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (0044EA48) --------------------------------------------------------
int   sub_44EA48(int a1, int a2, _DWORD *a3)
{
  int v4; // $s0
  int v5; // $s3
  int v6; // $s0
  int v7; // $s0
  int v8; // $s0
  int v9; // $s0
  int v10; // $s0
  int v11; // $s0
  int v12; // $s0
  int v13; // $s0
  int v14; // $s0
  int v15; // $s0
  int v16; // $s0
  int v17; // $v0
  int result; // $v0
  _BYTE *v19; // $s4
  void *v20; // $v0
  _BYTE *v21; // $v0
  int v22; // $s0
  int v23; // $s0
  int v24; // $v0
  _BYTE v25[64]; // [sp+20h] [-50h] BYREF
  _BYTE v26[16]; // [sp+60h] [-10h] BYREF
  _BYTE v27[16]; // [sp+70h] [+0h] BYREF
  char v28[8]; // [sp+80h] [+10h] BYREF
  int v29[4]; // [sp+88h] [+18h] BYREF
  char *v30; // [sp+98h] [+28h] BYREF
  char *v31; // [sp+9Ch] [+2Ch] BYREF
  char *v32; // [sp+A0h] [+30h] BYREF

  v4 = 0;
  v5 = 0;
  strcpy(v28, "Home");
  do
  {
    v19 = 0;
    if ( !v5 )
    {
      v29[0] = 2;
      pantilt_cmd(v29);
      stritoa(v29[2], v26, 16);
      stritoa(v29[3], v27, 16);
      v30 = v28;
      v31 = v26;
      v32 = v27;
LABEL_3:
      if ( atoi(*a3) != 1 )
        goto LABEL_4;
      goto LABEL_12;
    }
    memset(v25, 0, sizeof(v25));
    snprintf(v25, 64, "SetPosition%d", v5);
    v20 = (void *)nvram_bufget(0, v25);
    v21 = (_BYTE *)strdupWithoutNull(v20);
    v19 = v21;
    v32 = byte_4A2DDC;
    v31 = byte_4A2DDC;
    v30 = byte_4A2DDC;
    if ( !v21 || !*v21 )
      goto LABEL_3;
    ParseSetPoition((int)v21, &v30, &v31, &v32, byte_4A2DDC);
    if ( atoi(*a3) != 1 )
    {
LABEL_4:
      v6 = v4 + websWriteFmt(a1, (int)"%s", WebPanTiltPosition);
      v7 = v6 + websWriteFmt(a1, (int)"%d", v5);
      v8 = v7 + websWriteFmt(a1, (int)"%s", WebNewLine);
      v9 = v8 + websWriteFmt(a1, (int)"%s", WebPanTiltName);
      v10 = v9 + websWriteFmt(a1, (int)"%s", v30);
      v11 = v10 + websWriteFmt(a1, (int)"%s", WebNewLine);
      v12 = v11 + websWriteFmt(a1, (int)"%s", WebPanTiltHorizontal);
      v13 = v12 + websWriteFmt(a1, (int)"%s", v31);
      v14 = v13 + websWriteFmt(a1, (int)"%s", WebNewLine);
      v15 = v14 + websWriteFmt(a1, (int)"%s", WebPanTiltVertical);
      v16 = v15 + websWriteFmt(a1, (int)"%s", v32);
      v17 = websWriteFmt(a1, (int)"%s", WebNewLine);
      goto LABEL_5;
    }
LABEL_12:
    v22 = v4 + websWriteFmt(a1, (int)"%s", WebOptionStart);
    if ( !v5 || v31 && *v31 && v32 && *v32 )
    {
      v23 = v22 + websWriteFmt(a1, (int)"%d ", v5);
      v22 = v23 + WritePrintableString(a1, v30);
      v24 = websWriteFmt(a1, (int)" (%s,%s)", v31, v32);
    }
    else
    {
      v24 = websWriteFmt(a1, (int)"%d", v5);
    }
    v16 = v22 + v24;
    v17 = websWriteFmt(a1, (int)"%s", WebOptionEnd);
LABEL_5:
    v4 = v16 + v17;
    if ( v19 )
      free2(v19);
    ++v5;
    result = v4;
  }
  while ( v5 < 25 );
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (0044EEB8) --------------------------------------------------------
int   sub_44EEB8(int a1, int a2, _DWORD *a3)
{
  int v5; // $s0
  int i; // $s2
  int v7; // $s0
  int v8; // $v0
  int v9; // $s0
  char *v10; // $a2
  int result; // $v0
  void *v12; // $v0
  _BYTE *v13; // $v0
  _BYTE *v14; // $s1
  int v15; // $s0
  int v16; // $v0
  _BYTE v17[64]; // [sp+20h] [-50h] BYREF
  char *v18; // [sp+60h] [-10h] BYREF
  char *v19; // [sp+64h] [-Ch] BYREF
  char *v20; // [sp+68h] [-8h] BYREF

  v5 = 0;
  for ( i = 1; i < 25; ++i )
  {
    memset(v17, 0, sizeof(v17));
    snprintf(v17, 64, "SetPosition%d", i);
    v12 = (void *)nvram_bufget(0, v17);
    v13 = (_BYTE *)strdupWithoutNull(v12);
    v14 = v13;
    v20 = byte_4A2DDC;
    v19 = byte_4A2DDC;
    v18 = byte_4A2DDC;
    if ( v13 && *v13 )
      ParseSetPoition((int)v13, &v18, &v19, &v20, byte_4A2DDC);
    if ( atoi(*a3) == 1 )
    {
      v15 = v5 + websWriteFmt(a1, (int)"%s", WebOptionStart);
      if ( !i || v19 && *v19 && v20 && *v20 )
      {
        v15 += websWriteFmt(a1, (int)"%d ", i);
        v16 = WritePrintableString(a1, v18);
      }
      else
      {
        v16 = websWriteFmt(a1, (int)"%d", i);
      }
      v10 = WebOptionEnd;
      v9 = v15 + v16;
    }
    else
    {
      v7 = v5 + websWriteFmt(a1, (int)"%s", WebPanTiltPosition);
      if ( !i || v19 && *v19 && v20 && *v20 )
        v8 = websWriteFmt(a1, (int)"%d %s", i, v18);
      else
        v8 = websWriteFmt(a1, (int)"%d", i);
      v9 = v7 + v8;
      v10 = WebNewLine;
    }
    v5 = v9 + websWriteFmt(a1, (int)"%s", v10);
    if ( v14 )
      free2(v14);
    result = v5;
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F38: using guessed type int   atoi(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (0044F1C0) --------------------------------------------------------
int   sub_44F1C0(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"MotionDetectionEnable", a2, a3);
}

//----- (0044F1E8) --------------------------------------------------------
int   sub_44F1E8(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"MotionDetectionEnable", a2, a3);
}

//----- (0044F210) --------------------------------------------------------
int   sub_44F210(int a1, int a2, _DWORD *a3)
{
  char *Var; // $v0

  if ( a2 > 0 && !strcmp(*a3, "2") && websTestVar(a1, (int)"MotionDetectionBlockSet") )
    Var = (char *)websGetVar(a1, (int)"MotionDetectionBlockSet", (int)byte_4A2DDC);
  else
    Var = (char *)nvram_bufget(0, "MotionDetectionBlockSet");
  if ( Var && *Var )
    return websWriteFmt(a1, (int)"%s", Var);
  else
    return websWriteFmt(a1, (int)"%s", "0000000000000000000000000");
}
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4EA044: using guessed type int   nvram_bufget(_DWORD, _DWORD);

//----- (0044F324) --------------------------------------------------------
int   sub_44F324(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"MotionDetectionSensitivity", a2, a3);
}

//----- (0044F34C) --------------------------------------------------------
int   sub_44F34C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"MotionDetectionScheduleDay", a2, a3);
}

//----- (0044F374) --------------------------------------------------------
int   sub_44F374(int a1, int a2, _DWORD *a3)
{
  return getCheckConfig(a1, (int)"MotionDetectionScheduleDay", a2, a3);
}

//----- (0044F39C) --------------------------------------------------------
int   sub_44F39C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"MotionDetectionScheduleMode", a2, a3);
}

//----- (0044F3C4) --------------------------------------------------------
int   sub_44F3C4(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"MotionDetectionScheduleMode", a2, a3);
}

//----- (0044F3EC) --------------------------------------------------------
int   sub_44F3EC(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"MotionDetectionScheduleTimeStart", a2, a3);
}

//----- (0044F414) --------------------------------------------------------
int   sub_44F414(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"MotionDetectionScheduleTimeStop", a2, a3);
}

//----- (0044F43C) --------------------------------------------------------
int   sub_44F43C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"DayNightMode", a2, a3);
}

//----- (0044F464) --------------------------------------------------------
int   sub_44F464(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"DayNightMode", a2, a3);
}

//----- (0044F48C) --------------------------------------------------------
int   sub_44F48C(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"IRLedScheduleSunStart", a2, a3);
}

//----- (0044F4B4) --------------------------------------------------------
int   sub_44F4B4(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"IRLedScheduleSunEnd", a2, a3);
}

//----- (0044F4DC) --------------------------------------------------------
int   sub_44F4DC(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"IRLedScheduleMonStart", a2, a3);
}

//----- (0044F504) --------------------------------------------------------
int   sub_44F504(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"IRLedScheduleMonEnd", a2, a3);
}

//----- (0044F52C) --------------------------------------------------------
int   sub_44F52C(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"IRLedScheduleTueStart", a2, a3);
}

//----- (0044F554) --------------------------------------------------------
int   sub_44F554(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"IRLedScheduleTueEnd", a2, a3);
}

//----- (0044F57C) --------------------------------------------------------
int   sub_44F57C(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"IRLedScheduleWedStart", a2, a3);
}

//----- (0044F5A4) --------------------------------------------------------
int   sub_44F5A4(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"IRLedScheduleWedEnd", a2, a3);
}

//----- (0044F5CC) --------------------------------------------------------
int   sub_44F5CC(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"IRLedScheduleThuStart", a2, a3);
}

//----- (0044F5F4) --------------------------------------------------------
int   sub_44F5F4(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"IRLedScheduleThuEnd", a2, a3);
}

//----- (0044F61C) --------------------------------------------------------
int   sub_44F61C(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"IRLedScheduleFriStart", a2, a3);
}

//----- (0044F644) --------------------------------------------------------
int   sub_44F644(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"IRLedScheduleFriEnd", a2, a3);
}

//----- (0044F66C) --------------------------------------------------------
int   sub_44F66C(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"IRLedScheduleSatStart", a2, a3);
}

//----- (0044F694) --------------------------------------------------------
int   sub_44F694(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"IRLedScheduleSatEnd", a2, a3);
}

//----- (0044F6BC) --------------------------------------------------------
int   sub_44F6BC(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"SoundDetectionEnable", a2, a3);
}

//----- (0044F6E4) --------------------------------------------------------
int   sub_44F6E4(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"SoundDetectionEnable", a2, a3);
}

//----- (0044F70C) --------------------------------------------------------
int   sub_44F70C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"SoundDetectionDB", a2, a3);
}

//----- (0044F734) --------------------------------------------------------
int   sub_44F734(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"SoundDetectionScheduleDay", a2, a3);
}

//----- (0044F75C) --------------------------------------------------------
int   sub_44F75C(int a1, int a2, _DWORD *a3)
{
  return getCheckConfig(a1, (int)"SoundDetectionScheduleDay", a2, a3);
}

//----- (0044F784) --------------------------------------------------------
int   sub_44F784(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"SoundDetectionScheduleMode", a2, a3);
}

//----- (0044F7AC) --------------------------------------------------------
int   sub_44F7AC(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"SoundDetectionScheduleMode", a2, a3);
}

//----- (0044F7D4) --------------------------------------------------------
int   sub_44F7D4(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"SoundDetectionScheduleTimeStart", a2, a3);
}

//----- (0044F7FC) --------------------------------------------------------
int   sub_44F7FC(int a1, int a2, _DWORD *a3)
{
  return getStringConfig(a1, (int)"SoundDetectionScheduleTimeStop", a2, a3);
}

//----- (0044F824) --------------------------------------------------------
int   sub_44F824(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"OSDEnable", a2, a3);
}

//----- (0044F84C) --------------------------------------------------------
int   sub_44F84C(int a1, int a2, _DWORD *a3)
{
  return getRadioConfig(a1, (int)"OSDEnable", a2, a3);
}

//----- (0044F874) --------------------------------------------------------
int   sub_44F874(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"OSDColorY", a2, a3);
}

//----- (0044F89C) --------------------------------------------------------
int   sub_44F89C(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"OSDColorU", a2, a3);
}

//----- (0044F8C4) --------------------------------------------------------
int   sub_44F8C4(int a1, int a2, _DWORD *a3)
{
  return getIntConfig(a1, (int)"OSDColorV", a2, a3);
}

//----- (0044F8EC) --------------------------------------------------------
int   sub_44F8EC(int a1)
{
  return websWriteFmt(a1, (int)"%s", "no");
}

//----- (0044F910) --------------------------------------------------------
int formDefineMedia()
{
  websParaDefine("CMSDProject", (int)sub_44CBB8);
  websParaDefine("CMXJProject", (int)sub_44CBD8);
  websParaDefine("PTZSupport", (int)sub_44CBF8);
  websParaDefine("FrameSize", (int)sub_44CC58);
  websParaDefine("CurrentVideoWidth", (int)sub_44CC74);
  websParaDefine("CurrentVideoHeight", (int)sub_44CD94);
  websParaDefine("CurrentVideoLimitWidth", (int)sub_44CF08);
  websParaDefine("CurrentVideoLimitHeight", (int)sub_44D070);
  websParaDefine("CheckFrameRate", (int)sub_44D204);
  websParaDefine("FPSEnable", (int)sub_44D228);
  websParaDefine("Profile", (int)sub_44D250);
  websParaDefine("Current264VideoWidth", (int)sub_44D2A8);
  websParaDefine("Current264VideoHeight", (int)sub_44D4F8);
  websParaDefine("VideoResolution264", (int)sub_44D750);
  websParaDefine("RadioOfVideoResolution264", (int)sub_44D778);
  websParaDefine("StringOfVideoResolution264", (int)sub_44D8B0);
  websParaDefine("FrameRate264", (int)sub_44DA2C);
  websParaDefine("RadioOfFrameRate264", (int)sub_44DA54);
  websParaDefine("StringOfFrameRate264", (int)sub_44DA7C);
  websParaDefine("BitRate264", (int)sub_44DAC8);
  websParaDefine("RadioOfBitRate264", (int)sub_44DBB0);
  websParaDefine("StringOfBitRate264", (int)sub_44DBD8);
  websParaDefine("LiveStreamingDuration", (int)sub_44DC20);
  websParaDefine("LiveStreamingFile1", (int)sub_44DCC4);
  websParaDefine("LiveStreamingFile2", (int)sub_44DD64);
  websParaDefine("LiveStreamingFile3", (int)sub_44DE04);
  websParaDefine("ViewMode", (int)sub_44DEA4);
  websParaDefine("VideoResolution", (int)sub_44DECC);
  websParaDefine("RadioOfVideoResolution", (int)sub_44DEF4);
  websParaDefine("StringOfVideoResolution", (int)sub_44DF1C);
  websParaDefine("CompressionRate", (int)sub_44DF64);
  websParaDefine("RadioOfCompressionRate", (int)sub_44DF8C);
  websParaDefine("StringOfCompressionRate", (int)sub_44DFB4);
  websParaDefine("FrameRate", (int)sub_44DFFC);
  websParaDefine("RadioOfFrameRate", (int)sub_44E024);
  websParaDefine("StringOfFrameRate", (int)sub_44E04C);
  websParaDefine("LightFrequency", (int)sub_44E098);
  websParaDefine("RadioOfLightFrequency", (int)sub_44E0C0);
  websParaDefine("StringOfLightFrequency", (int)sub_44E0E8);
  websParaDefine("BrightnessControl", (int)sub_44E130);
  websParaDefine("ContrastControl", (int)sub_44E158);
  websParaDefine("SaturationControl", (int)sub_44E180);
  websParaDefine("SharpnessControl", (int)sub_44E1A8);
  websParaDefine("AntiFlickerEnable", (int)sub_44E1D0);
  websParaDefine("Mirror", (int)sub_44E1F8);
  websParaDefine("AudioEnable", (int)sub_44E220);
  websParaDefine("RadioOfAudioEnable", (int)sub_44E248);
  websParaDefine("StringOfAudioEnable", (int)sub_44E270);
  websParaDefine("AudioVolume", (int)sub_44E2B8);
  websParaDefine("AudioCodec", (int)sub_44E2E0);
  websParaDefine("AudioSampleRate", (int)sub_44E420);
  websParaDefine("p", (int)sub_44E444);
  websParaDefine("t", (int)sub_44E5E0);
  websParaDefine("PanSingleMoveDegree", (int)sub_44E77C);
  websParaDefine("SelectOfPanSingleMoveDegree", (int)sub_44E7A4);
  websParaDefine("TiltSingleMoveDegree", (int)sub_44E7EC);
  websParaDefine("SelectOfTiltSingleMoveDegree", (int)sub_44E814);
  websParaDefine("SwingTimeInterval", (int)sub_44E85C);
  websParaDefine("DwellingTime", (int)sub_44E884);
  websParaDefine("PresetPosition", (int)sub_44E8AC);
  websParaDefine("PresetList", (int)sub_44EA48);
  websParaDefine("PresetNameList", (int)sub_44EEB8);
  websParaDefine("MotionDetectionEnable", (int)sub_44F1C0);
  websParaDefine("RadioOfMotionDetectionEnable", (int)sub_44F1E8);
  websParaDefine("MotionDetectionBlockSet", (int)sub_44F210);
  websParaDefine("MotionDetectionSensitivity", (int)sub_44F324);
  websParaDefine("MotionDetectionScheduleDay", (int)sub_44F34C);
  websParaDefine("CheckOfMotionDetectionScheduleDay", (int)sub_44F374);
  websParaDefine("MotionDetectionScheduleMode", (int)sub_44F39C);
  websParaDefine("RadioOfMotionDetectionScheduleMode", (int)sub_44F3C4);
  websParaDefine("MotionDetectionScheduleTimeStart", (int)sub_44F3EC);
  websParaDefine("MotionDetectionScheduleTimeStop", (int)sub_44F414);
  websParaDefine("DayNightMode", (int)sub_44F43C);
  websParaDefine("RadioOfDayNightMode", (int)sub_44F464);
  websParaDefine("IRLedScheduleSunStart", (int)sub_44F48C);
  websParaDefine("IRLedScheduleSunEnd", (int)sub_44F4B4);
  websParaDefine("IRLedScheduleMonStart", (int)sub_44F4DC);
  websParaDefine("IRLedScheduleMonEnd", (int)sub_44F504);
  websParaDefine("IRLedScheduleTueStart", (int)sub_44F52C);
  websParaDefine("IRLedScheduleTueEnd", (int)sub_44F554);
  websParaDefine("IRLedScheduleWedStart", (int)sub_44F57C);
  websParaDefine("IRLedScheduleWedEnd", (int)sub_44F5A4);
  websParaDefine("IRLedScheduleThuStart", (int)sub_44F5CC);
  websParaDefine("IRLedScheduleThuEnd", (int)sub_44F5F4);
  websParaDefine("IRLedScheduleFriStart", (int)sub_44F61C);
  websParaDefine("IRLedScheduleFriEnd", (int)sub_44F644);
  websParaDefine("IRLedScheduleSatStart", (int)sub_44F66C);
  websParaDefine("IRLedScheduleSatEnd", (int)sub_44F694);
  websParaDefine("SoundDetectionEnable", (int)sub_44F6BC);
  websParaDefine("RadioOfSoundDetectionEnable", (int)sub_44F6E4);
  websParaDefine("SoundDetectionDB", (int)sub_44F70C);
  websParaDefine("SoundDetectionScheduleDay", (int)sub_44F734);
  websParaDefine("CheckOfSoundDetectionScheduleDay", (int)sub_44F75C);
  websParaDefine("SoundDetectionScheduleMode", (int)sub_44F784);
  websParaDefine("RadioOfSoundDetectionScheduleMode", (int)sub_44F7AC);
  websParaDefine("SoundDetectionScheduleTimeStart", (int)sub_44F7D4);
  websParaDefine("SoundDetectionScheduleTimeStop", (int)sub_44F7FC);
  websParaDefine("OSDEnable", (int)sub_44F824);
  websParaDefine("RadioOfOSDEnable", (int)sub_44F84C);
  websParaDefine("OSDColorY", (int)sub_44F874);
  websParaDefine("OSDColorU", (int)sub_44F89C);
  websParaDefine("OSDColorV", (int)sub_44F8C4);
  return websParaDefine("ThermalSupport", (int)sub_44F8EC);
}

//----- (00450604) --------------------------------------------------------
int   websGetAntiTblCount(int a1)
{
  int v2; // $s2
  int v3; // $s3
  int *v4; // $s1
  int v5; // $s0
  int v6; // $a1
  bool v7; // dc

  if ( !a1 )
    return 0;
  v2 = 0;
  if ( dword_4E6278 < 0 )
    return 0;
  v3 = dword_4E6278;
  v4 = (int *)dword_4E8E90;
  while ( 1 )
  {
    v5 = *v4;
    ++v2;
    v6 = *v4;
    v7 = *v4++ == 0;
    if ( !v7 && !strcmp(a1, v6) )
      break;
    if ( v3 < v2 )
      return 0;
  }
  return *(_DWORD *)(v5 + 32);
}
// 4E6278: using guessed type int dword_4E6278;
// 4E8E90: using guessed type int dword_4E8E90;
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (004506F8) --------------------------------------------------------
void   websAntiTblUnsched(int a1)
{
  int v2; // $s1
  int v3; // $s0

  if ( a1 )
  {
    v2 = 0;
    if ( dword_4E6278 >= 0 )
    {
      while ( 1 )
      {
        v3 = *(_DWORD *)(4 * v2 + dword_4E8E90);
        if ( v3 )
        {
          if ( !strcmp(a1, *(_DWORD *)(4 * v2 + dword_4E8E90)) )
            break;
        }
        if ( dword_4E6278 < ++v2 )
          return;
      }
      dword_4E6278 = FreeEntryId(&dword_4E8E90, v2);
      free2(v3);
    }
  }
}
// 4E6278: using guessed type int dword_4E6278;
// 4E8E90: using guessed type int dword_4E8E90;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);

//----- (00450800) --------------------------------------------------------
int   websAntiBruteProcessor(char **a1)
{
  int v2; // $s2
  char *v3; // $a0
  int v4; // $s6
  char *v5; // $v0
  _DWORD *SysInfoBuffer; // $s0
  int v7; // $s1
  int v8; // $a0
  bool v9; // dc
  int v10; // $v0
  int v11; // $a2
  int v12; // $s2
  int v13; // $a3
  int v14; // $s3
  int *v15; // $s0
  int v16; // $s1
  char **v17; // $a0
  int v18; // $a1
  int v19; // $a1
  int v20; // $s1
  int v21; // $v0
  int v22; // $s0
  int v23; // $v0
  char ***v24; // $a1
  int v26; // $v0
  _DWORD *v27; // $s0
  unsigned int v28; // $v0
  int v29; // $v0

  v2 = mmalloc(3584);
  trace(1, (int)"websAntiBruteProcessor=%s,%s\n", a1[34], a1[82]);
  v3 = a1[34];
  v4 = 0;
  if ( v3 )
    free2(v3);
  v5 = a1[82];
  a1[82] = 0;
  a1[34] = v5;
  if ( v2 )
  {
    SysInfoBuffer = (_DWORD *)getSysInfoBuffer(47, v2, 3584);
    v7 = 0;
    while ( 1 )
    {
      v8 = SysInfoBuffer[2];
      ++v7;
      v9 = *SysInfoBuffer == 0;
      SysInfoBuffer += 14;
      if ( !v9 )
      {
        v10 = inet_ntoa(v8);
        if ( !strcmp(a1 + 1, v10) )
          break;
      }
      if ( v7 >= 64 )
        goto LABEL_9;
    }
    v4 = 1;
LABEL_9:
    free2(v2);
  }
  if ( a1 == (char **)-4 )
    goto LABEL_25;
  v11 = 5111808;
  v12 = 0;
  if ( dword_4E6278 < 0 )
    goto LABEL_25;
  v13 = 5177344;
  v14 = dword_4E6278;
  v15 = (int *)dword_4E8E90;
  do
  {
    v16 = *v15;
    ++v12;
    v17 = a1 + 1;
    v18 = *v15;
    v9 = *v15++ == 0;
  }
  while ( (v9 || strcmp(v17, v18)) && v14 >= v12 );
  if ( !v16 )
  {
LABEL_25:
    v26 = AllocEntry(&dword_4E8E90, &dword_4E6278, 44);
    if ( v26 < 0 )
      goto LABEL_31;
    v27 = *(_DWORD **)(4 * v26 + dword_4E8E90);
    v28 = strlen(a1 + 1) + 1;
    if ( v28 >= 0x21 )
      v28 = 32;
    memcpy(v27, a1 + 1, v28);
    v27[8] = 1;
    v27[9] = time(0);
    v27[10] = time(0) + 600;
    if ( v27 )
      v20 = v27[8];
    else
LABEL_31:
      v20 = 20;
  }
  else
  {
    v19 = 1;
    if ( v4 != 1 )
      v19 = *(_DWORD *)(v16 + 32) + 1;
    *(_DWORD *)(v16 + 32) = v19;
    v20 = v19;
  }
  v21 = fork(v17, v19, v11, v13);
  v22 = v21;
  if ( !v21 )
  {
    v29 = getpid();
    trace(16, (int)"now in the antbrute child process(%d, %s).\n", v29, a1[36]);
    doSystem((int)"sleep %d", v20);
    websConnError((int)a1, 401, (int)"Authentication was requested");
    exit(0);
  }
  if ( v21 == -1 )
  {
    doSystem((int)"sleep %d", v20);
    websConnError((int)a1, 401, (int)"Authentication was requested");
  }
  else
  {
    v23 = AllocEntry(&dword_4E8E8C, &dword_4E6274, 8);
    if ( v23 >= 0 )
    {
      v24 = *(char ****)(4 * v23 + dword_4E8E8C);
      v24[1] = (char **)v22;
      *v24 = a1;
      websTimeoutCancel((int)a1);
    }
  }
  return 1;
}
// 450904: conditional instruction was optimized away because $s2.4!=0
// 4509B8: variable 'v17' is possibly undefined
// 4509B8: variable 'v19' is possibly undefined
// 4509B8: variable 'v11' is possibly undefined
// 4509B8: variable 'v13' is possibly undefined
// 4E6274: using guessed type int dword_4E6274;
// 4E6278: using guessed type int dword_4E6278;
// 4E8E8C: using guessed type int dword_4E8E8C;
// 4E8E90: using guessed type int dword_4E8E90;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F3C: using guessed type void   __noreturn exit(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9F90: using guessed type int   time(_DWORD);
// 4E9F94: using guessed type int   inet_ntoa(_DWORD);
// 4E9FC0: using guessed type int   fork(_DWORD, _DWORD, _DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);
// 4EA088: using guessed type int getpid(void);

//----- (00450BE8) --------------------------------------------------------
int websAntiBruteReapChildren()
{
  int result; // $v0
  int i; // $s1
  int v2; // $s0
  int j; // $s2
  int *v4; // $s1
  int v5; // $s0
  char *v6; // $a1
  int v7; // $a3
  int v8; // [sp+18h] [-8h] BYREF

  result = dword_4E6278;
  for ( i = 0; dword_4E6278 >= i; ++i )
  {
    v2 = *(_DWORD *)(4 * i + dword_4E8E90);
    if ( v2 )
    {
      result = time(0);
      if ( result < *(_DWORD *)(v2 + 36) || *(_DWORD *)(v2 + 40) < result )
      {
        dword_4E6278 = FreeEntryId(&dword_4E8E90, i);
        result = free2(v2);
      }
    }
  }
  for ( j = 0; dword_4E6274 >= j; ++j )
  {
    while ( 1 )
    {
      v4 = *(int **)(4 * j + dword_4E8E8C);
      if ( v4 )
      {
        v5 = *v4;
        result = websReapChildren(v4[1], (int)&v8);
        if ( !result )
          break;
      }
      if ( dword_4E6274 < ++j )
        return result;
    }
    websConnClose(v5, 200);
    v6 = "antbrute child(%d) exited, status=%d\n";
    v7 = (unsigned __int16)(v8 & 0xFF00) >> 8;
    if ( (v8 & 0x7F) != 0
      && (v7 = v8 & 0x7F, v6 = "antbrute child(%d) killed (signal %d)\n", (unsigned __int8)v8 == 127) )
    {
      trace(16, (int)"antbrute child(%d) stopped (signal %d)\n", v4[1], (unsigned __int16)(v8 & 0xFF00) >> 8);
    }
    else
    {
      trace(16, (int)v6, v4[1], v7);
    }
    dword_4E6274 = FreeEntryId(&dword_4E8E8C, j);
    result = free2(v4);
  }
  return result;
}
// 4E6274: using guessed type int dword_4E6274;
// 4E6278: using guessed type int dword_4E6278;
// 4E8E8C: using guessed type int dword_4E8E8C;
// 4E8E90: using guessed type int dword_4E8E90;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F90: using guessed type int   time(_DWORD);

//----- (00450E18) --------------------------------------------------------
int   aesencrypt(int a1, unsigned int a2, int a3, unsigned int a4, _DWORD *a5)
{
  int v9; // $a2
  int v10; // $a2
  int v11; // $a0
  unsigned __int8 *v12; // $t2
  int v13; // $a0
  unsigned __int8 *v14; // $t6
  int i; // $a2
  char *v16; // $a1
  char v17; // $a0
  int v18; // $t2
  _DWORD *v19; // $a3
  int j; // $a2
  _BYTE *v21; // $s4
  char v22; // $v1
  char v23; // $ra
  int k; // $a2
  _BYTE *v25; // $t3
  int v26; // $t6
  int v27; // $a0
  int v28; // $t7
  int v29; // $t0
  int m; // $a1
  _BYTE *v31; // $s3
  char v32; // $s4
  int n; // $a2
  _BYTE *v34; // $t9
  char v35; // $t5
  char v36; // $t4
  _DWORD *v38; // $a0
  int v39; // $t1
  int v40; // $a3
  int v41; // $s1
  _BYTE v43[64]; // [sp+18h] [-80h] BYREF
  _DWORD v44[4]; // [sp+58h] [-40h] BYREF
  _DWORD v45[8]; // [sp+68h] [-30h] BYREF
  _DWORD v46[4]; // [sp+88h] [-10h]

  memset(v43, 0, sizeof(v43));
  v9 = a2;
  memset(v44, 0, sizeof(v44));
  memset(v45, 0, 16);
  if ( a2 >= 0x21 )
    v9 = 32;
  memcpy(v44, a1, v9);
  v10 = a4;
  if ( a4 >= 0x41 )
    v10 = 64;
  memcpy(v43, a3, v10);
  v11 = 0;
  v12 = AES_Sbox;
  do
  {
    AES_Sbox_Inv[*v12] = v11++;
    v12 = &AES_Sbox[v11];
  }
  while ( v11 < 256 );
  v13 = 0;
  v14 = AES_ShiftRowTab;
  do
  {
    AES_ShiftRowTab_Inv[*v14] = v13++;
    v14 = &AES_ShiftRowTab[v13];
  }
  while ( v13 < 16 );
  for ( i = 0; i < 128; ++i )
  {
    v16 = (char *)&AES_xtime + i;
    v17 = 2 * i;
    v16[128] = v17 ^ 0x1B;
    *v16 = v17;
  }
  v18 = 0;
  v19 = v43;
  do
  {
    for ( j = 0; j < 16; ++j )
    {
      v21 = (char *)v19 + j;
      v22 = *((_BYTE *)v44 + j);
      v23 = *((_BYTE *)v19 + j);
      *v21 = v23 ^ v22;
    }
    for ( k = 0; k < 16; ++k )
    {
      v25 = (char *)v19 + k;
      v26 = *((unsigned __int8 *)v19 + k);
      *v25 = AES_Sbox[v26];
    }
    v27 = *v19;
    v28 = v19[2];
    v29 = v19[3];
    v46[1] = v19[1];
    v46[0] = v27;
    v46[2] = v28;
    v46[3] = v29;
    for ( m = 0; m < 16; ++m )
    {
      v31 = (char *)v19 + m;
      v32 = *((_BYTE *)v46 + AES_ShiftRowTab[m]);
      *v31 = v32;
    }
    for ( n = 0; n < 16; ++n )
    {
      v34 = (char *)v19 + n;
      v35 = *((_BYTE *)v45 + n);
      v36 = *((_BYTE *)v19 + n);
      *v34 = v36 ^ v35;
    }
    ++v18;
    v19 += 4;
  }
  while ( v18 < 4 );
  v38 = v43;
  do
  {
    v39 = v38[1];
    *a5 = *v38;
    a5[1] = v39;
    v40 = v38[2];
    a5[1] = v39;
    a5[2] = v40;
    v41 = v38[3];
    a5[2] = v40;
    a5[3] = v41;
    v38 += 4;
    a5[3] = v41;
    a5 += 4;
  }
  while ( v38 != v44 );
  return 1;
}
// 4E627C: using guessed type _BYTE AES_Sbox[256];
// 4E637C: using guessed type unsigned __int8 AES_ShiftRowTab[16];
// 4E8E94: using guessed type _BYTE AES_Sbox_Inv[256];
// 4E8F94: using guessed type _BYTE AES_ShiftRowTab_Inv[16];
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (004510C0) --------------------------------------------------------
int   aesdecrypt(int a1, unsigned int a2, int a3, unsigned int a4, _DWORD *a5)
{
  int v9; // $a2
  int v10; // $a2
  int v11; // $a0
  unsigned __int8 *v12; // $t2
  int v13; // $a0
  unsigned __int8 *v14; // $t6
  int i; // $a2
  char *v16; // $a1
  char v17; // $a0
  int v18; // $t2
  _DWORD *v19; // $a3
  int j; // $a2
  _BYTE *v21; // $s4
  char v22; // $v1
  char v23; // $ra
  int v24; // $t3
  int v25; // $t0
  int v26; // $t9
  int k; // $a1
  _BYTE *v28; // $t6
  char v29; // $t7
  int m; // $a2
  _BYTE *v31; // $a1
  int v32; // $v1
  int n; // $a2
  _BYTE *v34; // $t9
  char v35; // $t4
  char v36; // $t3
  _DWORD *v38; // $a0
  int v39; // $t1
  int v40; // $a3
  int v41; // $s1
  _BYTE v43[64]; // [sp+18h] [-80h] BYREF
  _DWORD v44[4]; // [sp+58h] [-40h] BYREF
  _DWORD v45[4]; // [sp+68h] [-30h] BYREF
  _DWORD v46[8]; // [sp+78h] [-20h]

  memset(v43, 0, sizeof(v43));
  v9 = a2;
  memset(v44, 0, sizeof(v44));
  memset(v45, 0, sizeof(v45));
  if ( a2 >= 0x21 )
    v9 = 32;
  memcpy(v44, a1, v9);
  v10 = a4;
  if ( a4 >= 0x41 )
    v10 = 64;
  memcpy(v43, a3, v10);
  v11 = 0;
  v12 = AES_Sbox;
  do
  {
    AES_Sbox_Inv[*v12] = v11++;
    v12 = &AES_Sbox[v11];
  }
  while ( v11 < 256 );
  v13 = 0;
  v14 = AES_ShiftRowTab;
  do
  {
    AES_ShiftRowTab_Inv[*v14] = v13++;
    v14 = &AES_ShiftRowTab[v13];
  }
  while ( v13 < 16 );
  for ( i = 0; i < 128; ++i )
  {
    v16 = (char *)&AES_xtime + i;
    v17 = 2 * i;
    v16[128] = v17 ^ 0x1B;
    *v16 = v17;
  }
  v18 = 0;
  v19 = v43;
  do
  {
    for ( j = 0; j < 16; ++j )
    {
      v21 = (char *)v19 + j;
      v22 = *((_BYTE *)v45 + j);
      v23 = *((_BYTE *)v19 + j);
      *v21 = v23 ^ v22;
    }
    v24 = v19[1];
    v25 = v19[2];
    v26 = v19[3];
    v46[0] = *v19;
    v46[1] = v24;
    v46[2] = v25;
    v46[3] = v26;
    for ( k = 0; k < 16; ++k )
    {
      v28 = (char *)v19 + k;
      v29 = *((_BYTE *)v46 + (unsigned __int8)AES_ShiftRowTab_Inv[k]);
      *v28 = v29;
    }
    for ( m = 0; m < 16; ++m )
    {
      v31 = (char *)v19 + m;
      v32 = *((unsigned __int8 *)v19 + m);
      *v31 = AES_Sbox_Inv[v32];
    }
    for ( n = 0; n < 16; ++n )
    {
      v34 = (char *)v19 + n;
      v35 = *((_BYTE *)v44 + n);
      v36 = *((_BYTE *)v19 + n);
      *v34 = v36 ^ v35;
    }
    ++v18;
    v19 += 4;
  }
  while ( v18 < 4 );
  v38 = v43;
  do
  {
    v39 = v38[1];
    *a5 = *v38;
    a5[1] = v39;
    v40 = v38[2];
    a5[1] = v39;
    a5[2] = v40;
    v41 = v38[3];
    a5[2] = v40;
    a5[3] = v41;
    v38 += 4;
    a5[3] = v41;
    a5 += 4;
  }
  while ( v38 != v44 );
  return 1;
}
// 4E627C: using guessed type _BYTE AES_Sbox[256];
// 4E637C: using guessed type unsigned __int8 AES_ShiftRowTab[16];
// 4E8E94: using guessed type _BYTE AES_Sbox_Inv[256];
// 4E8F94: using guessed type _BYTE AES_ShiftRowTab_Inv[16];
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00451368) --------------------------------------------------------
int   allocDecryptbyHexKey(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v8; // $a2
  unsigned int v9; // $s1
  int v10; // $a2
  unsigned int v11; // $s5
  _BYTE v13[512]; // [sp+20h] [-600h] BYREF
  _BYTE v14[512]; // [sp+220h] [-400h] BYREF
  _DWORD v15[128]; // [sp+420h] [-200h] BYREF

  memset(v15, 0, sizeof(v15));
  v8 = a4;
  if ( a4 >= 0x200 )
    v8 = 511;
  memcpy(v15, a3, v8);
  memset(v13, 0, sizeof(v13));
  v9 = hexstringtohexarray((char *)v15, (int)v13);
  memset(v15, 0, sizeof(v15));
  v10 = a2;
  if ( a2 >= 0x200 )
    v10 = 511;
  memcpy(v15, a1, v10);
  memset(v14, 0, sizeof(v14));
  v11 = hexstringtohexarray((char *)v15, (int)v14);
  memset(v15, 0, sizeof(v15));
  aesdecrypt((int)v13, v9, (int)v14, v11, v15);
  return strdupWithoutNull(v15);
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00451518) --------------------------------------------------------
int   allocEncryptbyHexKey(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v8; // $a2
  unsigned int v9; // $s1
  int v10; // $a2
  unsigned int v11; // $s5
  _BYTE v13[512]; // [sp+20h] [-600h] BYREF
  _BYTE v14[512]; // [sp+220h] [-400h] BYREF
  _DWORD v15[128]; // [sp+420h] [-200h] BYREF

  memset(v15, 0, sizeof(v15));
  v8 = a4;
  if ( a4 >= 0x200 )
    v8 = 511;
  memcpy(v15, a3, v8);
  memset(v13, 0, sizeof(v13));
  v9 = hexstringtohexarray((char *)v15, (int)v13);
  memset(v14, 0, sizeof(v14));
  v10 = a2;
  if ( a2 >= 0x200 )
    v10 = 511;
  memcpy(v14, a1, v10);
  v11 = strlen(v14);
  memset(v15, 0, sizeof(v15));
  aesencrypt((int)v13, v9, (int)v14, v11, v15);
  memset(v14, 0, sizeof(v14));
  hexarraytohexstring((unsigned __int8 *)v15, v14, 0x40u);
  return strdupWithoutNull(v14);
}
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (004516E0) --------------------------------------------------------
int   allocDecryptbyKey(int a1, unsigned __int8 *a2)
{
  unsigned int v3; // $v0
  unsigned int v5; // $v0
  _BYTE v7[512]; // [sp+18h] [-200h] BYREF

  v3 = strlen(a2);
  hexarraytohexstring(a2, v7, v3);
  v5 = strlen(a1);
  return allocDecryptbyHexKey(a1, v5, (int)v7, 0x200u);
}
// 4E9F24: using guessed type int   strlen(_DWORD);

//----- (00451778) --------------------------------------------------------
int   allocEncryptbyKey(int a1, unsigned __int8 *a2)
{
  unsigned int v3; // $v0
  unsigned int v5; // $v0
  _BYTE v7[512]; // [sp+18h] [-200h] BYREF

  v3 = strlen(a2);
  hexarraytohexstring(a2, v7, v3);
  v5 = strlen(a1);
  return allocEncryptbyHexKey(a1, v5, (int)v7, 0x200u);
}
// 4E9F24: using guessed type int   strlen(_DWORD);

//----- (00451810) --------------------------------------------------------
int   matrixSslOpenWithConfig(int a1)
{
  int Mutex; // $a0
  unsigned int v3; // $s1
  int v4; // $s2
  _DWORD *v5; // $t1
  char *v6; // $v1
  unsigned int v7; // $a2
  char v8; // $t2^2
  char v9; // $t0^3
  _DWORD *v10; // $s0
  _DWORD *v11; // $t1
  char *v12; // $v1
  unsigned int v13; // $a2
  char v14; // $t2^2
  char v15; // $t0^3

  Mutex = 0;
  if ( byte_4E638C != 89 )
  {
    strncpy(&byte_4E638C, "YNYYNNNNNYYNY", 31);
    if ( !strncmp(&byte_4E638C, a1, 2) )
    {
      if ( psCryptoOpen(a1 + 2) < 0 )
      {
        psTraceStr("psError %s", (int)"matrixssl.c");
        psTraceInt(":%d ", 122);
        psError((int)"pscrypto open failure\n");
        return -1;
      }
      else
      {
        memset(&unk_4E90D4, 0, 3456);
        v3 = 0;
        v4 = 0;
        dword_4E9E54 = (int)&dword_4E9E54;
        dword_4E9E58 = (int)&dword_4E9E54;
        do
        {
          while ( 1 )
          {
            v10 = (_DWORD *)((char *)&unk_4E9138 + v4);
            if ( (int *)((char *)&unk_4E9138 + v4) == &dword_4E9E54 )
              break;
            v5 = (_DWORD *)dword_4E9E58;
            v6 = (char *)&unk_4E90D4 + v4;
            *v10 = &dword_4E9E54;
            dword_4E9E58 = (int)&unk_4E9138 + v4;
            *v5 = v10;
            v10[1] = v5;
            v7 = v3 >> 8;
            v8 = BYTE2(v3);
            v9 = HIBYTE(v3);
            *v6 = v3++;
            v6[3] = v9;
            v6[1] = v7;
            v6[2] = v8;
            v4 += 108;
            if ( v3 >= 0x20 )
              goto LABEL_8;
          }
          psTraceStr("psAssert %s", (int)"matrixssl.c");
          psTraceInt(":%d ", 2305);
          psError((int)"(&g_sessionChronList) != (&g_sessionTable[i].chronList)");
          v11 = (_DWORD *)dword_4E9E58;
          v12 = (char *)&unk_4E90D4 + v4;
          *v10 = &dword_4E9E54;
          dword_4E9E58 = (int)&unk_4E9138 + v4;
          *v11 = v10;
          v10[1] = v11;
          v13 = v3 >> 8;
          v14 = BYTE2(v3);
          v15 = HIBYTE(v3);
          *v12 = v3++;
          v12[3] = v15;
          v12[1] = v13;
          v12[2] = v14;
          v4 += 108;
        }
        while ( v3 < 0x20 );
LABEL_8:
        Mutex = psCreateMutex((int)&unk_4E90A4, 0);
        if ( Mutex >= 0 )
        {
          Mutex = psCreateMutex((int)&unk_4E90BC, 0);
          if ( Mutex >= 0 )
          {
            Mutex = dtlsGenCookieSecret();
            if ( Mutex >= 0 )
            {
              matrixDtlsSetPmtu(-1);
              return 0;
            }
          }
        }
      }
    }
    else
    {
      psTraceStr("psError %s", (int)"matrixssl.c");
      psTraceInt(":%d ", 117);
      psErrorStr("MatrixSSL config mismatch.\nLibrary: YNYYNNNNNYYNY\nCurrent: %s\n", a1);
      return -1;
    }
  }
  return Mutex;
}
// 4E638C: using guessed type char byte_4E638C;
// 4E9E54: using guessed type int dword_4E9E54;
// 4E9E58: using guessed type int dword_4E9E58;
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FD8: using guessed type int   strncpy(_DWORD, _DWORD, _DWORD);
// 4E9FDC: using guessed type int   strncmp(_DWORD, _DWORD, _DWORD);

//----- (00451B64) --------------------------------------------------------
int matrixSslClose()
{
  int v0; // $v0
  int result; // $v0

  psLockMutex();
  v0 = 30;
  while ( v0-- >= 0 )
    ;
  memset(&unk_4E90D4, 0, 3456);
  psUnlockMutex();
  psDestroyMutex();
  psCryptoClose();
  result = 5111808;
  byte_4E638C = 78;
  return result;
}
// 4E638C: using guessed type char byte_4E638C;
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (00451C28) --------------------------------------------------------
int   matrixSslNewKeys(_DWORD *a1, int a2)
{
  _DWORD *v4; // $s0
  int result; // $v0
  int Mutex; // $s1

  v4 = (_DWORD *)malloc(444);
  result = -8;
  if ( v4 )
  {
    memset(v4, 0, 444);
    v4[36] = a2;
    *v4 = 0;
    Mutex = psCreateMutex((int)(v4 + 37), 0);
    if ( Mutex < 0 )
    {
      free2(v4);
      return Mutex;
    }
    else
    {
      *a1 = v4;
      return 0;
    }
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (00451D00) --------------------------------------------------------
int   psTestUserEcID(int a1, unsigned int a2)
{
  int v2; // $v1
  int v3; // $v0

  switch ( a1 )
  {
    case 19:
      v3 = a2 & 1;
      break;
    case 21:
      v3 = (a2 >> 1) & 1;
      break;
    case 23:
      v3 = (a2 >> 2) & 1;
      break;
    case 24:
      v3 = (a2 >> 3) & 1;
      break;
    case 25:
      v3 = (a2 >> 4) & 1;
      break;
    case 255:
      v3 = HIWORD(a2) & 1;
      break;
    case 26:
      v3 = (a2 >> 17) & 1;
      break;
    case 27:
      v3 = (a2 >> 18) & 1;
      break;
    default:
      v2 = -10;
      if ( a1 != 28 )
        return v2;
      v3 = (a2 >> 19) & 1;
      break;
  }
  v2 = -1;
  if ( v3 )
    return 0;
  return v2;
}

//----- (00451DC4) --------------------------------------------------------
int   curveIdToFlag(int a1)
{
  int v1; // $v1

  v1 = 1;
  if ( a1 != 19 )
  {
    v1 = 2;
    if ( a1 != 21 )
    {
      v1 = 4;
      if ( a1 != 23 )
      {
        v1 = 8;
        if ( a1 != 24 )
        {
          v1 = 16;
          if ( a1 != 25 )
          {
            v1 = 0x10000;
            if ( a1 != 255 )
            {
              v1 = 0x20000;
              if ( a1 != 26 )
              {
                v1 = 0x40000;
                if ( a1 != 27 )
                  return (a1 == 0x1C) << 19;
              }
            }
          }
        }
      }
    }
  }
  return v1;
}

//----- (00451E38) --------------------------------------------------------
int   matrixSslGenEphemeralEcKey(int a1, int a2, unsigned __int8 *a3)
{
  unsigned int v6; // $t6
  int v7; // $s2
  int v8; // $t7
  int v9; // $a0
  int v10; // $a1
  int v12; // [sp+20h] [-8h] BYREF
  int v13; // [sp+24h] [-4h]

  if ( !a1 || !a3 )
  {
    psTraceStr("psAssert %s", (int)"matrixssl.c");
    psTraceInt(":%d ", 856);
    psError((int)"keys && curve");
  }
  psGetTime((int)&v12);
  psLockMutex();
  if ( *(unsigned __int8 **)(a1 + 224) != a3 )
  {
LABEL_4:
    v6 = *(unsigned __int16 *)(a1 + 308);
    goto LABEL_5;
  }
  v6 = *(unsigned __int16 *)(a1 + 308);
  if ( v6 < 0x3E9 )
  {
    if ( psDiffMsecs(*(_DWORD *)(a1 + 300), *(_DWORD *)(a1 + 304), v12, v13) <= 7200000 )
    {
      v7 = 0;
      ++*(_WORD *)(a1 + 308);
      if ( !a2 )
        goto LABEL_11;
      v9 = a2;
      v10 = a1 + 172;
      goto LABEL_10;
    }
    goto LABEL_4;
  }
LABEL_5:
  if ( v6 )
  {
    psEccClearKey(a1 + 172);
    *(_WORD *)(a1 + 308) = 0;
  }
  v7 = psEccGenKey(*(_DWORD *)a1, a1 + 172, a3);
  if ( v7 >= 0 )
  {
    v8 = v13;
    *(_DWORD *)(a1 + 300) = v12;
    *(_WORD *)(a1 + 308) = 1;
    *(_DWORD *)(a1 + 304) = v8;
    v7 = 0;
    if ( a2 )
    {
      v9 = a2;
      v10 = a1 + 172;
LABEL_10:
      v7 = psEccCopyKey(v9, v10);
    }
  }
LABEL_11:
  psUnlockMutex();
  return v7;
}

//----- (00452054) --------------------------------------------------------
int   matrixSslDeleteKeys(int a1)
{
  int v2; // $a0
  int v3; // $a0
  _DWORD *v4; // $s1
  _DWORD *v5; // $s0
  int v6; // $a0
  int v7; // $s1
  int v8; // $a0
  int result; // $v0

  if ( !a1 )
    return result;
  v2 = *(_DWORD *)(a1 + 116);
  if ( v2 )
  {
    psX509FreeCert(v2);
    psClearPubKey(a1 + 4);
    v3 = *(_DWORD *)(a1 + 120);
    if ( !v3 )
      goto LABEL_4;
LABEL_13:
    psX509FreeCert(v3);
    goto LABEL_4;
  }
  psClearPubKey(a1 + 4);
  v3 = *(_DWORD *)(a1 + 120);
  if ( v3 )
    goto LABEL_13;
LABEL_4:
  if ( *(_DWORD *)(a1 + 124) )
  {
    v4 = *(_DWORD **)(a1 + 124);
    do
    {
      free2(*v4);
      free2(v4[2]);
      v5 = (_DWORD *)v4[4];
      free2(v4);
      v4 = v5;
    }
    while ( v5 );
  }
  v6 = *(_DWORD *)(a1 + 128);
  if ( v6 )
  {
    do
    {
      v7 = *(_DWORD *)(v6 + 88);
      free2(v6);
      v6 = v7;
    }
    while ( v7 );
  }
  psDestroyMutex();
  if ( *(_WORD *)(a1 + 308) )
  {
    psEccClearKey(a1 + 172);
    psEccClearKey(a1 + 236);
    v8 = *(_DWORD *)(a1 + 136);
    if ( !v8 )
      goto LABEL_11;
  }
  else
  {
    v8 = *(_DWORD *)(a1 + 136);
    if ( !v8 )
    {
LABEL_11:
      memset_s((unsigned __int8 *)a1, 0x1BCu, 0, 0x1BCu);
      return free2(a1);
    }
  }
  free2(v8);
  *(_WORD *)(a1 + 140) = 0;
  memset_s((unsigned __int8 *)a1, 0x1BCu, 0, 0x1BCu);
  return free2(a1);
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (004522A0) --------------------------------------------------------
int   sub_4522A0(int a1, char *a2, int a3, int a4, char *a5, int a6)
{
  int v9; // $v1
  int v10; // $s0
  int v11; // $a0
  int v12; // $v1
  int v13; // $a1
  unsigned __int8 v14; // $v1
  int v15; // $t3
  int v16; // $s0
  int v17; // $a0
  int v18; // $v1
  int v19; // $a0
  int v21; // $a0
  int v22; // $v1
  int v23; // $t7
  int v24; // $v0
  int v25; // $s5
  int v26; // $v0
  int v27; // $s3
  int v28; // $v1
  int i; // $a0
  int v30; // $t5
  int v31; // $a0
  int v32; // $a0
  int v33; // [sp+20h] [-8h] BYREF

  v9 = -6;
  if ( !a1 )
    return v9;
  v10 = *(_DWORD *)a1;
  if ( a2 )
  {
    v9 = -10;
    if ( *(_DWORD *)(a1 + 116) )
      return v9;
    v9 = psX509ParseCertFile(*(_DWORD *)a1, a2, (_DWORD *)(a1 + 116), 3u);
    if ( v9 < 0 )
      return v9;
    v11 = *(_DWORD *)(a1 + 116);
    v12 = *(_DWORD *)(v11 + 692);
    if ( v12 )
    {
      if ( v12 != 8 )
      {
        psTraceStr("psAssert %s", (int)"matrixssl.c");
        psTraceInt(":%d ", 666);
        psError((int)"keys->cert->authFailFlags == PS_CERT_AUTH_FAIL_DATE_FLAG");
        v11 = *(_DWORD *)(a1 + 116);
      }
      psX509FreeCert(v11);
      v22 = -37;
      *(_DWORD *)(a1 + 116) = 0;
      return v22;
    }
  }
  if ( a3 )
  {
    if ( *(_WORD *)(a1 + 112) )
    {
      v21 = *(_DWORD *)(a1 + 116);
      if ( v21 )
      {
        psX509FreeCert(v21);
        v22 = -10;
        *(_DWORD *)(a1 + 116) = 0;
        return v22;
      }
    }
    if ( a6 == 1 )
    {
      psInitPubKey(v10, a1 + 4, 1);
      v24 = psPkcs1ParsePrivFile(v10, a3, a4, a1 + 4);
      v25 = v24;
      if ( v24 < 0 )
      {
        v31 = *(_DWORD *)(a1 + 116);
        if ( !v31 )
          return v24;
        psX509FreeCert(v31);
        v9 = v25;
        *(_DWORD *)(a1 + 116) = 0;
        return v9;
      }
      *(_WORD *)(a1 + 112) = psRsaSize(a1 + 4);
    }
    if ( a6 == 3 )
    {
      psInitPubKey(v10, a1 + 4, 3);
      v26 = psEccParsePrivFile(v10, a3, a4, a1 + 4);
      v27 = v26;
      if ( v26 < 0 )
      {
        v32 = *(_DWORD *)(a1 + 116);
        if ( !v32 )
          return v26;
        psX509FreeCert(v32);
        v9 = v27;
        *(_DWORD *)(a1 + 116) = 0;
        return v9;
      }
      *(_WORD *)(a1 + 112) = psEccSize(a1 + 4);
    }
  }
  v13 = *(_DWORD *)(a1 + 116);
  if ( v13 )
  {
    v14 = *(_BYTE *)(a1 + 114);
    v15 = v14;
    if ( !v14 )
      goto LABEL_33;
  }
  else
  {
    v14 = *(_BYTE *)(a1 + 114);
    v15 = v14;
    if ( !v14 )
      goto LABEL_12;
  }
  if ( !v15 )
  {
    v23 = v14;
    if ( !v13 )
      goto LABEL_31;
    goto LABEL_29;
  }
  if ( !v13 )
  {
LABEL_33:
    psX509FreeCert(*(_DWORD *)(a1 + 116));
    psClearPubKey(a1 + 4);
    v22 = -36;
    *(_DWORD *)(a1 + 116) = 0;
    return v22;
  }
LABEL_29:
  if ( *(_DWORD *)(v13 + 796) )
  {
    v33 = 0;
    psX509AuthenticateCert(v10, v13, 0, &v33);
    v13 = *(_DWORD *)(a1 + 116);
    v28 = *(_DWORD *)(v13 + 796);
    for ( i = v13; v28; v28 = *(_DWORD *)(v28 + 796) )
    {
      v30 = *(_DWORD *)(i + 688);
      i = v28;
      if ( v30 != 1 )
        goto LABEL_33;
    }
    v23 = *(unsigned __int8 *)(a1 + 114);
  }
  else
  {
    v23 = v14;
  }
LABEL_31:
  if ( v23 == 1 && psRsaCmpPubKey((_DWORD *)(a1 + 4), (_DWORD *)(v13 + 40)) < 0 )
    goto LABEL_33;
LABEL_12:
  if ( !a5 )
    return 0;
  v9 = -10;
  if ( *(_DWORD *)(a1 + 120) )
    return v9;
  v16 = psX509ParseCertFile(v10, a5, (_DWORD *)(a1 + 120), 2u);
  if ( v16 < 0 )
  {
LABEL_19:
    v19 = *(_DWORD *)(a1 + 116);
    if ( v19 )
    {
      psX509FreeCert(v19);
      *(_DWORD *)(a1 + 116) = 0;
    }
    psClearPubKey(a1 + 4);
    return v16;
  }
  v17 = *(_DWORD *)(a1 + 120);
  v18 = *(_DWORD *)(v17 + 692);
  if ( v18 )
  {
    if ( v18 != 8 )
    {
      psTraceStr("psAssert %s", (int)"matrixssl.c");
      psTraceInt(":%d ", 778);
      psError((int)"keys->CAcerts->authFailFlags == PS_CERT_AUTH_FAIL_DATE_FLAG");
      v17 = *(_DWORD *)(a1 + 120);
    }
    v16 = -37;
    psX509FreeCert(v17);
    *(_DWORD *)(a1 + 120) = 0;
    goto LABEL_19;
  }
  return 0;
}

//----- (0045280C) --------------------------------------------------------
int   matrixSslLoadRsaKeys(int a1, char *a2, int a3, int a4, char *a5)
{
  return sub_4522A0(a1, a2, a3, a4, a5, 1);
}

//----- (0045282C) --------------------------------------------------------
int   matrixUpdateSession(int a1)
{
  int v2; // $v1
  unsigned int v3; // $s1
  int v4; // $a1
  char *v5; // $a0
  int v6; // $v0
  _DWORD *v7; // $s0
  _DWORD *v8; // $t2
  _DWORD *v9; // $a2
  _DWORD *v10; // $a3
  int v11; // $v1
  int v12; // $t2
  int v13; // $t1

  v2 = -6;
  if ( (*(_DWORD *)(a1 + 3372) & 1) != 0 )
  {
    v2 = -9;
    if ( *(_BYTE *)(a1 + 3224) )
    {
      v3 = (*(unsigned __int8 *)(a1 + 3228) << 24)
         + (*(unsigned __int8 *)(a1 + 3227) << 16)
         + (*(unsigned __int8 *)(a1 + 3226) << 8)
         + *(unsigned __int8 *)(a1 + 3225);
      v2 = -9;
      if ( v3 < 0x20 )
      {
        psLockMutex();
        v4 = 108 * v3;
        v5 = (char *)&unk_4E90D4 + 108 * v3;
        v6 = *((_DWORD *)v5 + 24);
        if ( ((*(_DWORD *)(a1 + 3372) >> 4) & 1) != 0 )
          --v6;
        *((_DWORD *)v5 + 24) = v6;
        if ( !v6 )
        {
          v7 = (_DWORD *)((char *)&unk_4E9138 + v4);
          if ( (int *)((char *)&unk_4E9138 + v4) == &dword_4E9E54 )
          {
            psTraceStr("psAssert %s", (int)"matrixssl.c");
            psTraceInt(":%d ", 2570);
            psError((int)"(&g_sessionChronList) != (&g_sessionTable[i].chronList)");
          }
          v8 = (_DWORD *)dword_4E9E58;
          *v7 = &dword_4E9E54;
          dword_4E9E58 = (int)v7;
          *v8 = v7;
          v7[1] = v8;
        }
        if ( ((*(_DWORD *)(a1 + 3372) >> 6) & 1) != 0 )
        {
          memset((char *)&unk_4E90F4 + 108 * v3, 0, 48);
          *((_DWORD *)&unk_4E90D4 + 27 * v3 + 20) = 0;
          psUnlockMutex();
          return -1;
        }
        else
        {
          v9 = (_DWORD *)((char *)&unk_4E90F4 + 108 * v3);
          v10 = (_DWORD *)(a1 + 80);
          do
          {
            v11 = v10[1];
            v12 = v10[2];
            v13 = v10[3];
            *v9 = *v10;
            v9[1] = v11;
            v9[2] = v12;
            v9[3] = v13;
            v10 += 4;
            v9[3] = v13;
            v9 += 4;
          }
          while ( v10 != (_DWORD *)(a1 + 128) );
          *((_DWORD *)&unk_4E90D4 + 27 * v3 + 20) = *(_DWORD *)(a1 + 3344);
          psUnlockMutex();
          return 0;
        }
      }
    }
  }
  return v2;
}
// 4E9E54: using guessed type int dword_4E9E54;
// 4E9E58: using guessed type int dword_4E9E58;
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (00452AD4) --------------------------------------------------------
int   matrixSslDeleteSession(int a1)
{
  int v2; // $v1
  int v3; // $a1
  int v4; // $a0
  int v5; // $a0
  int v6; // $a0
  int v7; // $a0
  int v8; // $a0
  int v9; // $a0
  int v10; // $a0
  int v11; // $a0
  int v12; // $a0
  int v13; // $a0
  int v14; // $a0
  int result; // $v0

  if ( a1 )
  {
    v2 = *(unsigned __int8 *)(a1 + 3224);
    v3 = *(_DWORD *)(a1 + 3372) | 0x10;
    *(_DWORD *)(a1 + 3372) = v3;
    if ( v2 && (v3 & 1) != 0 )
    {
      matrixUpdateSession(a1);
      v4 = *(_DWORD *)(a1 + 3372) & 1;
    }
    else
    {
      v4 = v3 & 1;
    }
    if ( v4 )
    {
      v5 = *(_DWORD *)(a1 + 3260);
      if ( v5 )
      {
        free2(v5);
        *(_DWORD *)(a1 + 3260) = 0;
      }
    }
    v6 = *(_DWORD *)(a1 + 3264);
    *(_BYTE *)(a1 + 3224) = 0;
    if ( v6 )
      free2(v6);
    v7 = *(_DWORD *)(a1 + 600);
    if ( v7 )
    {
      psX509FreeCert(v7);
      *(_DWORD *)(a1 + 600) = 0;
    }
    if ( *(_DWORD *)(a1 + 3128) )
      psEccDeleteKey((int *)(a1 + 3128));
    if ( *(_DWORD *)(a1 + 3124) )
      psEccDeleteKey((int *)(a1 + 3124));
    v8 = *(_DWORD *)(a1 + 128);
    if ( v8 )
      free2(v8);
    v9 = *(_DWORD *)(a1 + 3332);
    if ( v9 )
      free2(v9);
    v10 = *(_DWORD *)(a1 + 3424);
    if ( v10 )
      free2(v10);
    v11 = *(_DWORD *)(a1 + 3436);
    if ( v11 )
      free2(v11);
    dtlsInitFrag(a1);
    v12 = *(_DWORD *)(a1 + 4640);
    if ( v12 )
      free2(v12);
    v13 = *(_DWORD *)(a1 + 4644);
    if ( v13 )
    {
      free2(v13);
      v14 = *(_DWORD *)(a1 + 3116);
      if ( !v14 )
        goto LABEL_27;
    }
    else
    {
      v14 = *(_DWORD *)(a1 + 3116);
      if ( !v14 )
      {
LABEL_27:
        memset(*(_DWORD *)(a1 + 3300), 0, *(_DWORD *)(a1 + 3316));
        memset(*(_DWORD *)(a1 + 3304), 0, *(_DWORD *)(a1 + 3320));
        free2(*(_DWORD *)(a1 + 3304));
        free2(*(_DWORD *)(a1 + 3300));
        freePkaAfter(a1);
        clearFlightList(a1);
        memset(a1, 0, 4696);
        return free2(a1);
      }
    }
    free2(v14);
    goto LABEL_27;
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (00452E38) --------------------------------------------------------
int   matrixSslNewSession(int *a1, int a2, _DWORD *a3, _DWORD *a4)
{
  unsigned int v4; // $s2
  int v7; // $v1
  int v8; // $v0
  int v9; // $s0
  int v10; // $a0
  int v11; // $v0
  int v12; // $v0
  unsigned int v13; // $t3
  int v14; // $t2
  int v15; // $v0
  int i; // $t2
  int v18; // $v0
  int v19; // $t5
  int Pmtu; // $v0
  int v21; // $s1
  int v22; // $v0
  int v23; // $v0
  int v24; // $v0
  __int16 *CipherSpec; // $v0
  int v26; // $a0
  unsigned int v27; // $a0
  char v28; // $v0
  int v29; // $a0
  int v30; // $t3
  int v31; // $a3
  int v32; // $t5
  BOOL v33; // $s7
  _DWORD *v34; // $v0
  __int16 *v35; // $v0
  _DWORD *v36; // $a3
  int *v37; // $a2
  int v38; // $v1
  int v39; // $a1
  int v40; // $t1
  int v41; // $ra
  int v42; // $s5
  int v43; // $t7
  int v44; // $t6
  int v45; // $s4
  int v46; // $t5
  int v47; // $a2
  int v48; // $a3
  int v49; // $t0
  unsigned int v50; // $a0
  int v52; // $a0
  int v53; // $v0
  int v54; // $a0
  char v55; // $v0

  v4 = a4[5];
  v7 = -6;
  if ( ((v4 >> 30) & 1) != 0 )
    return v7;
  v8 = malloc(4696);
  v9 = v8;
  v7 = -8;
  if ( !v8 )
    return v7;
  memset(v8, 0, 4696);
  v10 = a4[10];
  *(_DWORD *)(v9 + 4684) = a4[8];
  if ( v10 )
    *(_DWORD *)(v9 + 3324) |= 0x10u;
  if ( a4[11] )
    *(_DWORD *)(v9 + 3324) |= 8u;
  v11 = a4[15];
  if ( v11 >= 0 )
    *(_DWORD *)(v9 + 4680) = v11;
  v12 = a4[16];
  if ( v12 )
    *(_DWORD *)(v9 + 4692) = v12;
  v13 = a4[4];
  if ( !v13 )
  {
    *(_DWORD *)(v9 + 3400) = *(_DWORD *)(v9 + 3400) & 0xFF000000 | compiledInEcFlags() & 0xFFFFFF;
    goto LABEL_48;
  }
  if ( *(_BYTE *)(a2 + 114) == 3 )
  {
    v52 = *(unsigned __int16 *)(*(_DWORD *)(a2 + 56) + 2);
    v53 = a4[4] & 1;
    if ( v52 != 19 )
    {
      switch ( v52 )
      {
        case 21:
          v53 = (v13 >> 1) & 1;
          break;
        case 23:
          v53 = (v13 >> 2) & 1;
          break;
        case 24:
          v53 = (v13 >> 3) & 1;
          break;
        case 25:
          v53 = (v13 >> 4) & 1;
          break;
        case 255:
          v53 = HIWORD(v13) & 1;
          break;
        case 26:
          v53 = (v13 >> 17) & 1;
          break;
        case 27:
          v53 = (v13 >> 18) & 1;
          break;
        case 28:
          v53 = (v13 >> 19) & 1;
          break;
        default:
          goto LABEL_27;
      }
    }
    if ( v53 )
      goto LABEL_13;
LABEL_27:
    free2(v9);
    return -6;
  }
LABEL_13:
  v14 = *(_DWORD *)(a2 + 116);
  if ( v14 )
  {
    while ( 1 )
    {
      if ( *(_BYTE *)(v14 + 150) != 3 )
        goto LABEL_15;
      v15 = *(unsigned __int16 *)(*(_DWORD *)(v14 + 92) + 2);
      if ( v15 == 19 )
      {
        if ( (v13 & 1) == 0 )
          goto LABEL_27;
        v14 = *(_DWORD *)(v14 + 796);
        if ( !v14 )
          break;
      }
      else
      {
        switch ( v15 )
        {
          case 21:
            if ( ((v13 >> 1) & 1) == 0 )
              goto LABEL_27;
            break;
          case 23:
            if ( ((v13 >> 2) & 1) == 0 )
              goto LABEL_27;
            break;
          case 24:
            if ( ((v13 >> 3) & 1) == 0 )
              goto LABEL_27;
            break;
          case 25:
            if ( ((v13 >> 4) & 1) == 0 )
              goto LABEL_27;
            break;
          case 255:
            if ( (v13 & 0x10000) == 0 )
              goto LABEL_27;
            break;
          case 26:
            if ( ((v13 >> 17) & 1) == 0 )
              goto LABEL_27;
            break;
          case 27:
            if ( ((v13 >> 18) & 1) == 0 )
              goto LABEL_27;
            break;
          default:
            if ( v15 != 28 || ((v13 >> 19) & 1) == 0 )
              goto LABEL_27;
            break;
        }
LABEL_15:
        v14 = *(_DWORD *)(v14 + 796);
        if ( !v14 )
          break;
      }
    }
  }
  for ( i = *(_DWORD *)(a2 + 120); i; i = *(_DWORD *)(i + 796) )
  {
    if ( *(_BYTE *)(i + 150) == 3 )
    {
      v18 = *(unsigned __int16 *)(*(_DWORD *)(i + 92) + 2);
      switch ( v18 )
      {
        case 19:
          if ( (v13 & 1) == 0 )
            goto LABEL_27;
          break;
        case 21:
          if ( ((v13 >> 1) & 1) == 0 )
            goto LABEL_27;
          break;
        case 23:
          if ( ((v13 >> 2) & 1) == 0 )
            goto LABEL_27;
          break;
        case 24:
          if ( ((v13 >> 3) & 1) == 0 )
            goto LABEL_27;
          break;
        case 25:
          if ( ((v13 >> 4) & 1) == 0 )
            goto LABEL_27;
          break;
        case 255:
          if ( (v13 & 0x10000) == 0 )
            goto LABEL_27;
          break;
        case 26:
          if ( ((v13 >> 17) & 1) == 0 )
            goto LABEL_27;
          break;
        case 27:
          if ( ((v13 >> 18) & 1) == 0 )
            goto LABEL_27;
          break;
        default:
          if ( v18 != 28 || ((v13 >> 19) & 1) == 0 )
            goto LABEL_27;
          break;
      }
    }
  }
  *(_DWORD *)(v9 + 3400) = *(_DWORD *)(v9 + 3400) & 0xFF000000 | v13 & 0xFFFFFF;
LABEL_48:
  v19 = a4[9];
  Pmtu = 1500;
  v21 = (v4 >> 14) & 1;
  *(_DWORD *)(v9 + 3208) = v19;
  *(_DWORD *)(v9 + 3320) = 1500;
  if ( v21 )
  {
    Pmtu = matrixDtlsGetPmtu();
    *(_DWORD *)(v9 + 3320) = Pmtu;
  }
  v22 = malloc(Pmtu);
  *(_DWORD *)(v9 + 3304) = v22;
  if ( !v22 )
  {
    free2(v9);
    return -8;
  }
  v23 = 1500;
  *(_DWORD *)(v9 + 3316) = 1500;
  if ( v21 )
  {
    v23 = matrixDtlsGetPmtu();
    *(_DWORD *)(v9 + 3316) = v23;
  }
  v24 = malloc(v23);
  *(_DWORD *)(v9 + 3300) = v24;
  if ( !v24
    || (*(_DWORD *)(v9 + 3144) = a2,
        *(_DWORD *)(v9 + 3212) = 0,
        CipherSpec = sslGetCipherSpec(v9, 0),
        (*(_DWORD *)(v9 + 3344) = CipherSpec) == 0) )
  {
    free2(*(_DWORD *)(v9 + 3304));
    free2(v9);
    return -8;
  }
  sslActivateReadCipher(v9);
  sslActivateWriteCipher(v9);
  if ( v21 )
  {
    *(_DWORD *)(v9 + 3372) |= 0x4000u;
    *(_DWORD *)(v9 + 4660) = 13;
    *(_DWORD *)(v9 + 4664) = 12;
    *(_DWORD *)(v9 + 3576) = matrixDtlsGetPmtu();
    *(_DWORD *)(v9 + 3572) = -1;
    *(_DWORD *)(v9 + 3432) = 0;
    *(_WORD *)(v9 + 3584) = 0;
    *(_WORD *)(v9 + 3586) = 0;
    dtlsInitFrag(v9);
  }
  else
  {
    *(_DWORD *)(v9 + 4664) = 4;
    *(_DWORD *)(v9 + 4660) = 5;
  }
  if ( (v4 & 1) == 0 )
  {
    v29 = 0;
    if ( ((v4 >> 10) & 1) != 0 )
      v29 = 2;
    if ( ((v4 >> 11) & 1) != 0 )
    {
      v30 = *(_DWORD *)(v9 + 3372) | 0x800;
      *(_BYTE *)(v9 + 3389) = 3;
      *(_BYTE *)(v9 + 3390) = 1;
      *(_DWORD *)(v9 + 3372) = v30;
      v29 = 1;
    }
    if ( ((v4 >> 12) & 1) != 0 )
    {
      v31 = *(_DWORD *)(v9 + 3372) | 0x1800;
      *(_BYTE *)(v9 + 3389) = 3;
      *(_BYTE *)(v9 + 3390) = 2;
      *(_DWORD *)(v9 + 3372) = v31;
      v29 = 1;
    }
    if ( ((v4 >> 13) & 1) != 0 )
    {
      v32 = *(_DWORD *)(v9 + 3372) | 0x3800;
      *(_BYTE *)(v9 + 3390) = 3;
      *(_DWORD *)(v9 + 3372) = v32;
      *(_BYTE *)(v9 + 3389) = 3;
      v29 = 1;
    }
    if ( v29 != 2 )
    {
      v33 = (v4 & 0x4000) != 0;
      if ( !v29 )
      {
        *(_DWORD *)(v9 + 3372) |= 0x3800u;
        if ( (v4 & 0x4000) != 0 )
        {
          *(_BYTE *)(v9 + 3389) = -2;
          *(_BYTE *)(v9 + 3390) = -3;
        }
        else
        {
          *(_BYTE *)(v9 + 3389) = 3;
          *(_BYTE *)(v9 + 3390) = 3;
        }
        v33 = (v4 & 0x4000) != 0;
      }
      if ( !v33 || v29 != 1 )
        goto LABEL_88;
      v54 = *(unsigned __int8 *)(v9 + 3390);
      *(_BYTE *)(v9 + 3389) = -2;
      v55 = -3;
      if ( v54 == 3 || (v55 = -1, v54 == 2) )
      {
        *(_BYTE *)(v9 + 3390) = v55;
LABEL_88:
        *(_BYTE *)(v9 + 3384) = 2;
        v34 = a3;
        if ( a3 )
        {
          if ( a3[21] )
          {
            v35 = sslGetCipherSpec(v9, a3[21]);
            *(_DWORD *)(v9 + 3344) = v35;
            if ( v35 )
            {
              v36 = (_DWORD *)(v9 + 80);
              v37 = a3 + 9;
              do
              {
                v38 = *v37;
                v39 = v37[1];
                v40 = v37[2];
                v41 = v37[3];
                v37 += 4;
                *v36 = v38;
                v36[1] = v39;
                v36[2] = v40;
                v36[3] = v41;
                v36 += 4;
              }
              while ( v37 != a3 + 21 );
              v42 = a3[1];
              *(_BYTE *)(v9 + 3224) = 32;
              *(_BYTE *)(v9 + 3228) = HIBYTE(v42);
              v43 = a3[2];
              *(_WORD *)(v9 + 3225) = v42;
              *(_BYTE *)(v9 + 3227) = BYTE2(v42);
              *(_BYTE *)(v9 + 3232) = HIBYTE(v43);
              v44 = a3[3];
              *(_WORD *)(v9 + 3229) = v43;
              *(_BYTE *)(v9 + 3231) = BYTE2(v43);
              *(_BYTE *)(v9 + 3236) = HIBYTE(v44);
              v45 = a3[4];
              *(_WORD *)(v9 + 3233) = v44;
              *(_BYTE *)(v9 + 3235) = BYTE2(v44);
              *(_BYTE *)(v9 + 3240) = HIBYTE(v45);
              v46 = a3[5];
              *(_WORD *)(v9 + 3237) = v45;
              *(_BYTE *)(v9 + 3239) = BYTE2(v45);
              v47 = a3[6];
              *(_BYTE *)(v9 + 3244) = HIBYTE(v46);
              v48 = a3[7];
              *(_WORD *)(v9 + 3241) = v46;
              *(_BYTE *)(v9 + 3243) = BYTE2(v46);
              v49 = a3[8];
              *(_DWORD *)(v9 + 3245) = v47;
              *(_DWORD *)(v9 + 3249) = v48;
              *(_DWORD *)(v9 + 3253) = v49;
              v50 = 0;
              do
              {
                if ( *((unsigned __int8 *)a3 + v50++ + 4) )
                {
                  *(_BYTE *)(v9 + 3224) = 32;
                  goto LABEL_90;
                }
              }
              while ( v50 < 0x20 );
              *(_BYTE *)(v9 + 3224) = 0;
            }
          }
LABEL_90:
          v34 = a3;
        }
        *(_DWORD *)(v9 + 3260) = v34;
        goto LABEL_92;
      }
    }
LABEL_154:
    matrixSslDeleteSession(v9);
    return -6;
  }
  v26 = *(_DWORD *)(v9 + 3372);
  if ( ((v4 >> 7) & 1) != 0 )
    *(_DWORD *)(v9 + 3372) = v26 | 0x81;
  else
    *(_DWORD *)(v9 + 3372) = v26 | 1;
  *(_BYTE *)(v9 + 3384) = 1;
  if ( ((v4 >> 11) & 1) != 0 )
  {
    *(_BYTE *)(v9 + 3389) = 3;
    *(_BYTE *)(v9 + 3390) = 1;
  }
  if ( ((v4 >> 12) & 1) != 0 )
  {
    *(_BYTE *)(v9 + 3389) = 3;
    *(_BYTE *)(v9 + 3390) = 2;
  }
  if ( ((v4 >> 13) & 1) != 0 )
  {
    *(_BYTE *)(v9 + 3390) = 3;
    *(_BYTE *)(v9 + 3389) = 3;
  }
  if ( ((v4 >> 10) & 1) != 0 )
    goto LABEL_154;
  if ( (v4 & 0x4000) == 0 || !*(_BYTE *)(v9 + 3389) )
    goto LABEL_92;
  v27 = *(unsigned __int8 *)(v9 + 3390);
  if ( v27 < 2 )
    goto LABEL_154;
  *(_BYTE *)(v9 + 3389) = -2;
  v28 = -3;
  if ( v27 != 3 )
  {
    v28 = -1;
    if ( v27 != 2 )
      goto LABEL_154;
  }
  *(_BYTE *)(v9 + 3390) = v28;
LABEL_92:
  memset(*(_DWORD *)(v9 + 3300), 0, *(_DWORD *)(v9 + 3316));
  memset(*(_DWORD *)(v9 + 3304), 0, *(_DWORD *)(v9 + 3320));
  *a1 = v9;
  *(_DWORD *)(v9 + 3376) = 255;
  *(_BYTE *)(v9 + 3385) = -2;
  *(_BYTE *)(v9 + 3386) = -2;
  return 0;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (00453944) --------------------------------------------------------
int   matrixClearSession(int a1, int a2)
{
  int v3; // $s2
  int v5; // $v1
  unsigned int v6; // $s1
  char *v7; // $t6
  int *v8; // $s0
  int v10; // $a0
  int **v12; // $t2
  char *v13; // $s1

  v3 = a1 + 3225;
  v5 = -6;
  if ( *(_BYTE *)(a1 + 3224) )
  {
    v6 = (*(unsigned __int8 *)(a1 + 3228) << 24)
       + (*(unsigned __int8 *)(a1 + 3227) << 16)
       + (*(unsigned __int8 *)(a1 + 3226) << 8)
       + *(unsigned __int8 *)(a1 + 3225);
    v5 = -9;
    if ( v6 < 0x20 )
    {
      psLockMutex();
      v7 = (char *)&unk_4E90D4 + 108 * v6;
      v8 = (int *)((char *)&unk_4E9138 + 108 * v6);
      if ( (*((_DWORD *)v7 + 24))-- == 1 )
      {
        if ( v8 == &dword_4E9E54 )
        {
          psTraceStr("psAssert %s", (int)"matrixssl.c");
          psTraceInt(":%d ", 2440);
          psError((int)"(&g_sessionChronList) != (&g_sessionTable[i].chronList)");
        }
        v12 = (int **)dword_4E9E58;
        *v8 = (int)&dword_4E9E54;
        dword_4E9E58 = (int)&unk_4E9138 + 108 * v6;
        *v12 = v8;
        v8[1] = (int)v12;
        v10 = v3;
        if ( !a2 )
          goto LABEL_5;
      }
      else
      {
        v10 = v3;
        if ( !a2 )
        {
LABEL_5:
          psUnlockMutex();
          return 0;
        }
      }
      memset(v10, 0, 32);
      *(_DWORD *)(a1 + 3372) &= ~8u;
      *(_BYTE *)(a1 + 3224) = 0;
      memset((char *)&unk_4E90D8 + 108 * v6, 0, 28);
      memset((char *)&unk_4E90F4 + 108 * v6, 0, 48);
      v13 = (char *)&unk_4E90D4 + 108 * v6;
      *((_DWORD *)v13 + 20) = 0;
      *((_WORD *)v13 + 43) = 0;
      goto LABEL_5;
    }
  }
  return v5;
}
// 4E9E54: using guessed type int dword_4E9E54;
// 4E9E58: using guessed type int dword_4E9E58;
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (00453B98) --------------------------------------------------------
BOOL   matrixSslHandshakeIsComplete(int a1)
{
  return *(unsigned __int8 *)(a1 + 3384) == 0xFF;
}

//----- (00453BAC) --------------------------------------------------------
void   matrixSslSetCertValidator(int a1, int a2)
{
  if ( a1 )
  {
    if ( a2 )
      *(_DWORD *)(a1 + 604) = a2;
  }
}

//----- (00453BC8) --------------------------------------------------------
int   matrixRegisterSession(int a1)
{
  unsigned int v1; // $a1
  int v3; // $a0
  int v4; // $v0
  int v5; // $a2
  unsigned __int8 *v6; // $t8
  unsigned int v7; // $s2
  _DWORD *v8; // $a3
  _DWORD *v9; // $t0
  int v10; // $t4
  int v11; // $t3
  int v12; // $t2
  char *v13; // $s0
  int v14; // $a1
  _DWORD *v15; // $t5
  int v16; // $t1
  int v17; // $t6
  int v18; // $t9
  int v19; // $t2
  int v20; // $ra
  int v21; // $t7
  int v22; // $a3
  int v23; // $t0
  int v24; // $t3
  int v25; // $t2
  int v26; // $a1
  int v27; // $v1
  int v28; // $v0

  v1 = *(_DWORD *)(a1 + 3372);
  v3 = -1;
  if ( (v1 & 1) == 0 )
    return v3;
  v4 = *(_DWORD *)(a1 + 3260);
  if ( !v4 || *(_WORD *)(v4 + 92) != 3 )
  {
    if ( ((v1 >> 14) & 1) == 0 || (v3 = 0, !*(_BYTE *)(a1 + 3224)) )
    {
      psLockMutex();
      v5 = dword_4E9E54;
      v6 = (unsigned __int8 *)(dword_4E9E54 - 100);
      if ( (int *)dword_4E9E54 == &dword_4E9E54
        || (dword_4E9E54 = *(_DWORD *)dword_4E9E54,
            *(_DWORD *)(dword_4E9E54 + 4) = &dword_4E9E54,
            v7 = (v6[3] << 24) + (v6[2] << 16) + (v6[1] << 8) + *(unsigned __int8 *)(v5 - 100),
            v7 >= 0x20) )
      {
        psUnlockMutex();
        return -9;
      }
      else
      {
        v8 = (_DWORD *)((char *)&unk_4E90F4 + 108 * v7);
        v9 = (_DWORD *)(a1 + 80);
        do
        {
          v10 = v9[1];
          v11 = v9[2];
          v12 = v9[3];
          *v8 = *v9;
          v8[1] = v10;
          v8[2] = v11;
          v8[3] = v12;
          v9 += 4;
          v8[3] = v12;
          v8 += 4;
        }
        while ( v9 != (_DWORD *)(a1 + 128) );
        v13 = (char *)&unk_4E90D4 + 108 * v7;
        v14 = *((_DWORD *)v13 + 24) + 1;
        *((_DWORD *)v13 + 20) = *(_DWORD *)(a1 + 3344);
        *((_DWORD *)v13 + 24) = v14;
        v15 = (_DWORD *)((char *)&unk_4E90D8 + 108 * v7);
        v16 = *(_DWORD *)(a1 + 68);
        v17 = *(_DWORD *)(a1 + 72);
        v18 = *(_DWORD *)(a1 + 64);
        v19 = *(_DWORD *)(a1 + 52);
        v20 = *(_DWORD *)(a1 + 56);
        v21 = *(_DWORD *)(a1 + 60);
        *v15 = *(_DWORD *)(a1 + 48);
        v15[1] = v19;
        v15[2] = v20;
        v15[3] = v21;
        v15[4] = v18;
        v15[5] = v16;
        v15[6] = v17;
        v15[6] = v17;
        *(_BYTE *)(a1 + 3224) = 32;
        v22 = *((_DWORD *)v13 + 4);
        v23 = *((_DWORD *)v13 + 5);
        v24 = *((_DWORD *)v13 + 6);
        v25 = *((_DWORD *)v13 + 7);
        v26 = *((_DWORD *)v13 + 3);
        v27 = *((_DWORD *)v13 + 2);
        v28 = *((_DWORD *)v13 + 1);
        *(_DWORD *)(a1 + 3225) = *(_DWORD *)v13;
        *(_DWORD *)(a1 + 3229) = v28;
        *(_DWORD *)(a1 + 3233) = v27;
        *(_DWORD *)(a1 + 3237) = v26;
        *(_DWORD *)(a1 + 3241) = v22;
        *(_DWORD *)(a1 + 3245) = v23;
        *(_DWORD *)(a1 + 3249) = v24;
        *(_DWORD *)(a1 + 3253) = v25;
        psGetTime((int)&unk_4E912C + 108 * v7);
        v13[84] = *(_BYTE *)(a1 + 3389);
        v13[85] = *(_BYTE *)(a1 + 3390);
        *((_WORD *)v13 + 43) = (*(_DWORD *)(a1 + 4656) >> 17) & 1;
        psUnlockMutex();
        return v7;
      }
    }
    return v3;
  }
  return 0;
}
// 4E9E54: using guessed type int dword_4E9E54;

//----- (00453EC0) --------------------------------------------------------
int   matrixResumeSession(int a1)
{
  int v2; // $v1
  unsigned int v3; // $s1
  char *v4; // $s2
  unsigned int v6; // $v1
  char *v7; // $s0
  int *v8; // $a2
  _DWORD *v9; // $a3
  int *v10; // $t0
  int v11; // $v0
  int v12; // $v1
  int v13; // $a0
  int v14; // $a1
  int v15; // $a1
  char *v16; // $s5
  int v17; // $t0
  int v18; // $t3
  int v19[2]; // [sp+20h] [-8h] BYREF

  v2 = -6;
  if ( (*(_DWORD *)(a1 + 3372) & 1) == 0 || !*(_BYTE *)(a1 + 3224) )
    return v2;
  v3 = (*(unsigned __int8 *)(a1 + 3228) << 24)
     + (*(unsigned __int8 *)(a1 + 3227) << 16)
     + (*(unsigned __int8 *)(a1 + 3226) << 8)
     + *(unsigned __int8 *)(a1 + 3225);
  psLockMutex();
  if ( v3 >= 0x20 || (v4 = (char *)&unk_4E90D4 + 108 * v3, !*((_DWORD *)v4 + 20)) )
  {
    psUnlockMutex();
    return -9;
  }
  psGetTime((int)v19);
  v6 = *(unsigned __int8 *)(a1 + 3224);
  if ( v6 >= 0x20 )
    v6 = 32;
  if ( !memcmp(v4, a1 + 3225, v6) )
  {
    v7 = (char *)&unk_4E90D4 + 108 * v3;
    if ( psDiffMsecs(*((_DWORD *)v7 + 22), *((_DWORD *)v7 + 23), v19[0], v19[1]) <= 86400000
      && v7[84] == *(_BYTE *)(a1 + 3389)
      && v7[85] == *(_BYTE *)(a1 + 3390)
      && (*((_WORD *)v7 + 43) || ((*(_DWORD *)(a1 + 4656) >> 17) & 1) != 1)
      && (*((_WORD *)&unk_4E90D4 + 54 * v3 + 43) != 1 || ((*(_DWORD *)(a1 + 4656) >> 17) & 1) != 0) )
    {
      v8 = (int *)((char *)&unk_4E90F4 + 108 * v3);
      v9 = (_DWORD *)(a1 + 80);
      v10 = v8 + 12;
      do
      {
        v11 = *v8;
        v12 = v8[1];
        v13 = v8[2];
        v14 = v8[3];
        v8 += 4;
        *v9 = v11;
        v9[1] = v12;
        v9[2] = v13;
        v9[3] = v14;
        v9 += 4;
      }
      while ( v8 != v10 );
      v15 = 108 * v3;
      v16 = (char *)&unk_4E90D4 + 108 * v3;
      v17 = *((_DWORD *)v16 + 24);
      *(_DWORD *)(a1 + 3344) = *((_DWORD *)v16 + 20);
      *((_DWORD *)v16 + 24) = v17 + 1;
      if ( !v17 )
      {
        v18 = *(_DWORD *)((char *)&unk_4E9138 + v15);
        *(_DWORD *)(v18 + 4) = *(_DWORD *)((char *)&unk_4E9138 + v15 + 4);
        **(_DWORD **)((char *)&unk_4E9138 + v15 + 4) = v18;
      }
      psUnlockMutex();
      return 0;
    }
  }
  psUnlockMutex();
  return -1;
}
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);

//----- (0045421C) --------------------------------------------------------
int matrixSessionTicketLen()
{
  return 128;
}

//----- (00454224) --------------------------------------------------------
int   matrixCreateSessionTicket(int a1, int a2, int *a3)
{
  int v6; // $v1
  int Time; // $s3
  int v8; // $s2
  int v9; // $t8
  int v10; // $a0
  int v11; // $v1
  int v12; // $ra
  int v13; // $s5
  int v14; // $s4
  int v15; // $t7
  _DWORD *v16; // $t1
  _DWORD *v17; // $a3
  _DWORD *v18; // $a2
  int v19; // $t4
  int v20; // $t3
  int v21; // $s0
  int v22; // $s4
  int inited; // $s0
  _BYTE v25[8]; // [sp+20h] [-1E0h] BYREF
  unsigned __int8 v26[280]; // [sp+28h] [-1D8h] BYREF
  _BYTE v27[176]; // [sp+140h] [-C0h] BYREF
  _DWORD v28[4]; // [sp+1F0h] [-10h] BYREF

  v6 = -9;
  if ( *a3 >= 134 )
  {
    *(_BYTE *)(a2 + 1) = 1;
    *(_BYTE *)(a2 + 2) = 81;
    *(_BYTE *)(a2 + 3) = 0x80;
    *(_BYTE *)(a2 + 5) = 0x80;
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 4) = 0;
    Time = psGetTime((int)v25);
    psGetPrngLocked((int)v28, 0x10u);
    psLockMutex();
    v8 = *(_DWORD *)(*(_DWORD *)(a1 + 3144) + 128);
    v9 = v28[0];
    v10 = *(_DWORD *)(v8 + 4);
    v11 = *(_DWORD *)(v8 + 8);
    v12 = *(_DWORD *)(v8 + 12);
    *(_DWORD *)(a2 + 6) = *(_DWORD *)v8;
    *(_DWORD *)(a2 + 10) = v10;
    *(_DWORD *)(a2 + 14) = v11;
    *(_DWORD *)(a2 + 18) = v12;
    *(_DWORD *)(a2 + 18) = v12;
    v13 = v28[1];
    *(_DWORD *)(a2 + 22) = v9;
    v14 = v28[2];
    *(_DWORD *)(a2 + 22) = v9;
    v15 = v28[3];
    *(_DWORD *)(a2 + 26) = v13;
    *(_DWORD *)(a2 + 30) = v14;
    *(_DWORD *)(a2 + 34) = v15;
    *(_BYTE *)(a2 + 38) = *(_BYTE *)(a1 + 3389);
    v16 = (_DWORD *)(a1 + 128);
    *(_BYTE *)(a2 + 39) = *(_BYTE *)(a1 + 3390);
    v17 = (_DWORD *)(a1 + 80);
    *(_BYTE *)(a2 + 40) = HIBYTE(**(_WORD **)(a1 + 3344));
    v18 = (_DWORD *)(a2 + 43);
    *(_BYTE *)(a2 + 41) = **(_WORD **)(a1 + 3344);
    *(_BYTE *)(a2 + 42) = (*(_DWORD *)(a1 + 4656) & 0x20000) != 0;
    do
    {
      v19 = v17[1];
      v20 = v17[2];
      v21 = v17[3];
      *v18 = *v17;
      v18[1] = v19;
      v18[2] = v20;
      v18[3] = v21;
      v17 += 4;
      v18[3] = v21;
      v18 += 4;
    }
    while ( v17 != v16 );
    *(_BYTE *)(a2 + 93) = BYTE1(Time);
    *(_BYTE *)(a2 + 94) = Time;
    *(_BYTE *)(a2 + 91) = HIBYTE(Time);
    *(_BYTE *)(a2 + 92) = BYTE2(Time);
    v22 = a2 + 95 + sslWritePad((_BYTE *)(a2 + 95), 7u);
    inited = psAesInitCBC((int)v26, a2 + 22, (unsigned int *)(v8 + 16), *(_BYTE *)(v8 + 82), 1);
    if ( inited >= 0 )
    {
      psAesEncryptCBC((int)v26, a2 + 38, (_BYTE *)(a2 + 38), 0x40u);
      psAesClearCBC(v26);
      inited = psHmacSha256Init((int)v27, v8 + 48, *(_WORD *)(v8 + 84));
      if ( inited >= 0 )
      {
        psHmacSha256Update((int)v27, a2 + 6, 0x60u);
        psHmacSha256Final((int)v27, v22);
        inited = 0;
        *a3 = 134;
      }
    }
    memset_s((unsigned __int8 *)v28, 0x10u, 0, 0x10u);
    psUnlockMutex();
    return inited;
  }
  return v6;
}

//----- (00454560) --------------------------------------------------------
int   matrixUnlockSessionTicket(int a1, int a2, int a3)
{
  int v5; // $a3
  int v6; // $a2
  int v7; // $v1
  int v8; // $a0
  int v9; // $a1
  int v10; // $s3
  int v11; // $s1
  int v12; // $s4
  int v13; // $s0
  int v14; // $s0
  int v15; // $v0
  int v17; // $a3
  int v18; // $a2
  int v19; // $s1
  __int16 *CipherSpec; // $v0
  int v21; // $t3
  unsigned __int8 *v22; // $t0
  _DWORD *v23; // $a3
  unsigned __int8 *v24; // $a2
  int v25; // $ra
  int v26; // $s0
  int v27; // $t8
  int v28; // $s7
  int Time; // $v0
  int v30; // $s2
  _BYTE v31[176]; // [sp+30h] [-208h] BYREF
  _BYTE v32[32]; // [sp+E0h] [-158h] BYREF
  unsigned __int8 v33[280]; // [sp+100h] [-138h] BYREF
  _BYTE v34[8]; // [sp+218h] [-20h] BYREF
  _DWORD v35[4]; // [sp+220h] [-18h] BYREF
  int v36; // [sp+230h] [-8h]

  v5 = -1;
  if ( a3 != 128 )
    return v5;
  psLockMutex();
  v6 = *(_DWORD *)a2;
  v7 = *(_DWORD *)(a2 + 4);
  v8 = *(_DWORD *)(a2 + 8);
  v9 = *(_DWORD *)(a2 + 12);
  v10 = *(_DWORD *)(a1 + 3144);
  v36 = 0;
  v35[0] = v6;
  v35[1] = v7;
  v35[2] = v8;
  v35[3] = v9;
  v11 = *(_DWORD *)(v10 + 128);
  v12 = 0;
  if ( !v11 )
    goto LABEL_5;
  while ( memcmp(v11, v35, 16) )
  {
    v11 = *(_DWORD *)(v11 + 88);
    if ( !v11 )
      goto LABEL_5;
  }
  v17 = *(_DWORD *)(v10 + 132);
  *(_WORD *)(v11 + 86) = 1;
  v36 = v11;
  v12 = 1;
  if ( v17 )
  {
LABEL_5:
    if ( *(_DWORD *)(v10 + 132) )
    {
      psUnlockMutex();
      v13 = (*(int (  **)(_DWORD, _DWORD *, int))(*(_DWORD *)(a1 + 3144) + 132))(
              *(_DWORD *)(a1 + 3144),
              v35,
              v12);
      psLockMutex();
      if ( v13 < 0 )
      {
        if ( v11 )
          *(_WORD *)(v11 + 86) = 0;
      }
      else
      {
        if ( v12 )
          goto LABEL_14;
        v14 = *(_DWORD *)(*(_DWORD *)(a1 + 3144) + 128);
        if ( v14 )
        {
          while ( *(_DWORD *)(v14 + 88) )
            v14 = *(_DWORD *)(v14 + 88);
          if ( !memcmp(v14, a2, 16) )
          {
            v36 = v14;
            *(_WORD *)(v14 + 86) = 1;
            goto LABEL_14;
          }
        }
      }
    }
    psUnlockMutex();
    return -1;
  }
LABEL_14:
  psHmacSha256Init((int)v31, v36 + 48, *(_WORD *)(v36 + 84));
  psHmacSha256Update((int)v31, a2, 0x60u);
  psHmacSha256Final((int)v31, (int)v32);
  psAesInitCBC((int)v33, a2 + 16, (unsigned int *)(v36 + 16), *(_BYTE *)(v36 + 82), 2);
  psAesDecryptCBC((int)v33, (unsigned int *)(a2 + 32), a2 + 32, 0x40u);
  psAesClearCBC(v33);
  *(_WORD *)(v36 + 86) = 0;
  psUnlockMutex();
  v15 = memcmp(v32, a2 + 96, 32);
  v5 = -1;
  if ( !v15
    && *(unsigned __int8 *)(a1 + 3389) == *(unsigned __int8 *)(a2 + 32)
    && *(unsigned __int8 *)(a1 + 3390) == *(unsigned __int8 *)(a2 + 33) )
  {
    v18 = *(unsigned __int8 *)(a2 + 34);
    v19 = (v18 << 8) + *(unsigned __int8 *)(a2 + 35);
    CipherSpec = sslGetCipherSpec(a1, ((_WORD)v18 << 8) + *(unsigned __int8 *)(a2 + 35));
    *(_DWORD *)(a1 + 3344) = CipherSpec;
    v5 = -1;
    if ( CipherSpec )
    {
      if ( *(_BYTE *)(a2 + 36) || ((*(_DWORD *)(a1 + 4656) >> 22) & 1) != 1 )
      {
        v21 = *(_DWORD *)(a1 + 3260);
        *(_DWORD *)(a1 + 4656) = *(_DWORD *)(a1 + 4656) & 0xFFBFFFFF | ((*(_BYTE *)(a2 + 36) & 1) << 22);
        v22 = (unsigned __int8 *)(a2 + 85);
        v23 = (_DWORD *)(v21 + 36);
        v24 = (unsigned __int8 *)(a2 + 37);
        do
        {
          v25 = *(_DWORD *)v24;
          v26 = *((_DWORD *)v24 + 1);
          v27 = *((_DWORD *)v24 + 2);
          v28 = *((_DWORD *)v24 + 3);
          v24 += 16;
          *v23 = v25;
          v23[1] = v26;
          v23[2] = v27;
          v23[3] = v28;
          v23 += 4;
        }
        while ( v24 != v22 );
        v30 = (*v22 << 24)
            + (*(unsigned __int8 *)(a2 + 86) << 16)
            + (*(unsigned __int8 *)(a2 + 87) << 8)
            + *(unsigned __int8 *)(a2 + 88);
        Time = psGetTime((int)v34);
        v5 = -1;
        if ( (unsigned int)(Time - v30) <= 0x15180 )
        {
          v5 = 0;
          *(_DWORD *)(*(_DWORD *)(a1 + 3260) + 84) = v19;
        }
      }
    }
  }
  return v5;
}
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);

//----- (004549DC) --------------------------------------------------------
int   matrixSslGetSessionId(int a1, int a2)
{
  _WORD *v4; // $a0
  _DWORD *v5; // $a3
  int *v6; // $t0
  int *v7; // $a2
  int v8; // $ra
  int v9; // $t8
  int v10; // $s1
  int v11; // $s0
  int v12; // $v1
  _DWORD *v14; // $a3
  int *v15; // $a2
  int v16; // $t5
  int v17; // $t4
  int v18; // $a0
  int v19; // $t3

  if ( !a1 || (*(_DWORD *)(a1 + 3372) & 1) != 0 || !a2 )
    return -6;
  v4 = *(_WORD **)(a1 + 3344);
  if ( v4 )
  {
    if ( *v4 && *(_BYTE *)(a1 + 3224) == 32 )
    {
      if ( !*(_DWORD *)(a2 + 88) || (v12 = 0, !*(_WORD *)(a2 + 94)) )
      {
        *(_DWORD *)(a2 + 84) = (unsigned __int16)*v4;
        memcpy(a2 + 4, a1 + 3225, *(unsigned __int8 *)(a1 + 3224));
        v14 = (_DWORD *)(a2 + 36);
        v15 = (int *)(a1 + 80);
        do
        {
          v16 = *v15;
          v17 = v15[1];
          v18 = v15[2];
          v19 = v15[3];
          v15 += 4;
          *v14 = v16;
          v14[1] = v17;
          v14[2] = v18;
          v14[3] = v19;
          v14 += 4;
        }
        while ( v15 != (int *)(a1 + 128) );
        return 0;
      }
      return v12;
    }
    if ( *v4 )
    {
      if ( *(_DWORD *)(a2 + 88) )
      {
        v5 = (_DWORD *)(a2 + 36);
        if ( *(_WORD *)(a2 + 94) )
        {
          *(_DWORD *)(a2 + 84) = (unsigned __int16)*v4;
          v6 = (int *)(a1 + 128);
          v7 = (int *)(a1 + 80);
          do
          {
            v8 = *v7;
            v9 = v7[1];
            v10 = v7[2];
            v11 = v7[3];
            v7 += 4;
            *v5 = v8;
            v5[1] = v9;
            v5[2] = v10;
            v5[3] = v11;
            v5 += 4;
          }
          while ( v7 != v6 );
          return 0;
        }
      }
    }
  }
  return -1;
}
// 454A44: conditional instruction was optimized away because $a0.4!=0
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00454B84) --------------------------------------------------------
int   matrixServerSetKeysSNI(int a1)
{
  void (*v1)(void); // $t9
  int result; // $v0

  v1 = *(void (**)(void))(a1 + 3284);
  result = 0;
  if ( v1 )
  {
    *(_DWORD *)(a1 + 4656) |= 0x8000u;
    v1();
    return -10;
  }
  return result;
}

//----- (00454BF4) --------------------------------------------------------
int   sslResetContext(int a1)
{
  int v1; // $a2
  int v3; // $v1
  int result; // $v0

  v1 = *(_DWORD *)(a1 + 3372);
  if ( (v1 & 1) == 0 )
  {
    v3 = *(_DWORD *)(a1 + 3324);
    *(_DWORD *)(a1 + 3288) = *(_DWORD *)(a1 + 3136);
    *(_DWORD *)(a1 + 3296) = v3;
    *(_DWORD *)(a1 + 3292) = v1;
  }
  *(_DWORD *)(a1 + 3136) = 0;
  if ( (v1 & 1) != 0 )
  {
    matrixClearSession(a1, 0);
    v1 = *(_DWORD *)(a1 + 3372);
  }
  result = -131073;
  *(_DWORD *)(a1 + 3372) = v1 & 0xFFF07FFF;
  if ( (((v1 & 0xFFF07FFF) >> 14) & 1) != 0 )
    *(_WORD *)(a1 + 3586) = 0;
  *(_DWORD *)(a1 + 3324) = 0;
  return result;
}

//----- (00454CC4) --------------------------------------------------------
int   matrixValidateCertsExt(
        int a1,
        _DWORD *a2,
        int a3,
        unsigned __int8 *a4,
        int *a5,
        int a6,
        int a7,
        unsigned int *a8)
{
  int v10; // $s2
  int v11; // $a0
  int v12; // $s0
  int v13; // $s1
  int v14; // $a0
  int v15; // $t3
  BOOL v16; // $v1
  int v17; // $v0
  int v18; // $s0
  int v19; // $v0
  int v20; // $s3
  bool v21; // dc
  int result; // $v0
  int v23; // $v0
  int v24; // $s4
  int v25; // $a2
  BOOL v26; // $s0
  int v27; // $s1
  int v28; // $s6
  unsigned int v29; // $s2
  unsigned int v30; // $v1
  char *v31; // $a0
  int v32; // $v1
  int v33; // $v0
  int v34; // $v1
  int v35; // $v0
  char *v36; // $a0
  int v37; // $v1
  int v38; // $v0
  char *v39; // $s0
  int v40; // $v0
  int v41; // $ra
  int v42; // $s4
  int v43; // $s5
  int v44; // $s0
  _BYTE *v45; // $a1
  char *v46; // $s0
  int v47; // $v0
  _BYTE v48[16]; // [sp+28h] [-10h] BYREF

  v10 = 0;
  if ( (a8[2] & 1) != 0 )
  {
    v11 = -6;
    if ( *a8 >= 3 )
      return v11;
  }
  if ( (a8[1] & 1) != 0 )
  {
    if ( a4 )
    {
      v23 = psX509ValidateGeneralName(a4);
      v11 = -6;
      if ( v23 < 0 )
        return v11;
    }
  }
  *a5 = 0;
  if ( a3 )
  {
    v12 = a2[199];
    v13 = (int)a2;
    if ( v12 )
    {
      for ( ; *(_DWORD *)(v12 + 796); v12 = *(_DWORD *)(v13 + 796) )
      {
        v14 = psX509AuthenticateCert(a1, v13, v12, a5);
        if ( v14 < 0 )
          return v14;
        v15 = *(_DWORD *)(v12 + 468);
        v16 = v15 < v10++;
        if ( v15 >= 0 && v16 )
          goto LABEL_24;
        v13 = *(_DWORD *)(v13 + 796);
      }
      v11 = psX509AuthenticateCert(a1, v13, v12, a5);
      if ( v11 < 0 )
        return v11;
      v17 = *(_DWORD *)(v12 + 468);
      if ( v17 >= 0 && v17 < v10 )
        goto LABEL_24;
      v13 = *(_DWORD *)(v13 + 796);
      ++v10;
    }
    v18 = a3;
    *a5 = 0;
    while ( 1 )
    {
      *(_DWORD *)(v13 + 688) = 0;
      v19 = psX509AuthenticateCert(a1, v13, v18, a5);
      v20 = v19;
      if ( !v19 )
        break;
      v21 = v19 == -8;
      result = -8;
      if ( v21 )
        return result;
      v18 = *(_DWORD *)(v18 + 796);
      if ( !v18 )
        return -36;
    }
    v24 = *(_DWORD *)(v18 + 468);
    if ( v24 < 0 )
      goto LABEL_32;
    v25 = *(unsigned __int16 *)(v18 + 20);
    if ( v25 != *(unsigned __int16 *)(v13 + 20)
      || (v35 = memcmp(*(_DWORD *)(v18 + 16), *(_DWORD *)(v13 + 16), v25), v26 = v24 < v10, !v35)
      && (v21 = v10 <= 0, --v10, !v21) )
    {
      v26 = v24 < v10;
    }
    if ( !v26 )
    {
LABEL_32:
      if ( ((a2[120] >> 12) & 1) != 0 && (a2[122] & 6) == 0 )
      {
        psTrace((int)"End-entity certificate not for TLS usage!\n");
        v41 = a2[173] | 2;
        a2[172] = -37;
        v20 = -37;
        a2[173] = v41;
      }
      v11 = v20;
      if ( !a4 || ((a8[1] >> 1) & 1) != 0 )
        return v11;
      v27 = a2[118];
      v28 = 0;
      if ( v27 )
      {
        v29 = *a8;
        while ( 1 )
        {
          v30 = *(_DWORD *)(v27 + 4);
          if ( v30 == 2 )
          {
            v28 = 1;
            if ( v29 >= 2 && v29 != 3 )
              goto LABEL_39;
            v31 = *(char **)(v27 + 56);
            v32 = *v31;
            if ( v32 == 42 )
            {
              v39 = v31 + 1;
              if ( v31[1] != 46 )
                goto LABEL_39;
              if ( strchr(a4, 64) )
                goto LABEL_39;
              v40 = strchr(a4, 46);
              if ( !v40 )
                goto LABEL_39;
              v33 = strcasecmp(v39, v40);
            }
            else
            {
              if ( v32 == 46 )
                goto LABEL_39;
              v33 = strcasecmp(v31, a4);
            }
          }
          else
          {
            if ( v30 >= 3 )
            {
              if ( v30 == 7 )
              {
                v28 = 1;
                if ( !v29 || v29 == 5 )
                {
                  snprintf(
                    v48,
                    15,
                    "%u.%u.%u.%u",
                    **(unsigned __int8 **)(v27 + 56),
                    *(unsigned __int8 *)(*(_DWORD *)(v27 + 56) + 1),
                    *(unsigned __int8 *)(*(_DWORD *)(v27 + 56) + 2),
                    *(unsigned __int8 *)(*(_DWORD *)(v27 + 56) + 3));
                  v48[15] = 0;
                  if ( !strcmp(v48, a4) )
                    return v20;
                  v29 = *a8;
                }
              }
              goto LABEL_39;
            }
            if ( v30 != 1 )
              goto LABEL_39;
            v28 = 1;
            if ( v29 )
            {
              if ( v29 != 4 )
                goto LABEL_39;
            }
            if ( ((a8[2] >> 1) & 1) != 0 )
            {
              if ( strlen(a4) != *(unsigned __int16 *)(v27 + 62) )
                goto LABEL_39;
              v33 = strcasecmp(*(_DWORD *)(v27 + 56), a4);
            }
            else
            {
              v42 = *(unsigned __int16 *)(v27 + 62);
              v43 = *(_DWORD *)(v27 + 56);
              if ( strlen(a4) != v42 )
                goto LABEL_39;
              v44 = 0;
              if ( *(_WORD *)(v27 + 62) )
              {
                v45 = *(_BYTE **)(v27 + 56);
                do
                {
                  if ( *v45 == 64 )
                    break;
                  ++v44;
                  v45 = (_BYTE *)(v43 + v44);
                }
                while ( v44 < v42 );
              }
              if ( strncmp(v43, a4, v44) )
                goto LABEL_39;
              v33 = strcasecmp(v43 + v44, &a4[v44]);
            }
          }
          if ( !v33 )
            return v20;
LABEL_39:
          v27 = *(_DWORD *)(v27 + 64);
          if ( !v27 )
            goto LABEL_56;
        }
      }
      v29 = *a8;
LABEL_56:
      if ( v29 && v29 != 2 && v29 != 1 || v28 && (a8[2] & 1) == 0 )
        goto LABEL_59;
      v36 = (char *)a2[80];
      v37 = *v36;
      if ( v37 == 42 )
      {
        v46 = v36 + 1;
        if ( v36[1] != 46 )
          goto LABEL_59;
        if ( strchr(a4, 64) )
          goto LABEL_59;
        v47 = strchr(a4, 46);
        if ( !v47 )
          goto LABEL_59;
        v38 = strcasecmp(v46, v47);
      }
      else
      {
        if ( v37 == 46 )
          goto LABEL_59;
        v38 = strcasecmp(v36, a4);
      }
      if ( !v38 )
        return v20;
LABEL_59:
      v34 = a2[173] | 4;
      v11 = -37;
      a2[172] = -37;
      a2[173] = v34;
      return v11;
    }
LABEL_24:
    *(_DWORD *)(v13 + 688) = -38;
    return -38;
  }
  return psX509AuthenticateCert(a1, (int)a2, 0, a5);
}
// 454E48: conditional instruction was optimized away because $s3.4!=0
// 4E9F14: using guessed type int   strchr(_DWORD, _DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9F84: using guessed type int   strcmp(_DWORD, _DWORD);
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);
// 4E9FD4: using guessed type int   strcasecmp(_DWORD, _DWORD);
// 4E9FDC: using guessed type int   strncmp(_DWORD, _DWORD, _DWORD);
// 4EA0A4: using guessed type int snprintf(_DWORD, _DWORD, char *, ...);

//----- (00455498) --------------------------------------------------------
int   matrixUserCertValidator(int a1, int a2, int a3, int (  *a4)(int, int, int))
{
  int v6; // $a2

  if ( !a4 )
    return 0;
  v6 = 0;
  if ( a2 != 255 )
    v6 = a2;
  return a4(a1, a3, v6);
}

//----- (004554C8) --------------------------------------------------------
int   matrixSslNewServerSession(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // $v0
  int v8; // $v0
  _DWORD *v9; // $a1
  int v10; // $a2
  int v11; // $a0
  int v12; // $t2
  int v13; // $t2
  int v14[2]; // [sp+18h] [-8h] BYREF

  result = -6;
  if ( !a1 || !a4 )
    return result;
  v8 = *(_DWORD *)(a4 + 20);
  *a1 = 0;
  v14[0] = 0;
  if ( a3 )
  {
    *(_DWORD *)(a4 + 20) = v8 | 0x81;
    if ( matrixSslNewSession(v14, a2, 0, (_DWORD *)a4) >= 0 )
    {
      matrixSslSetCertValidator(v14[0], a3);
      goto LABEL_6;
    }
  }
  else
  {
    *(_DWORD *)(a4 + 20) = v8 | 1;
    if ( matrixSslNewSession(v14, a2, 0, (_DWORD *)a4) >= 0 )
    {
LABEL_6:
      v9 = (_DWORD *)v14[0];
      v10 = *(_DWORD *)(a4 + 28);
      v11 = *(__int16 *)(a4 + 2);
      *(_DWORD *)(v14[0] + 4672) |= 2u;
      v9[1172] = v10;
      if ( v11 < 0 )
      {
        v9[1164] |= 0x2000u;
        v13 = *(__int16 *)(a4 + 4);
        v9[832] = 0x4000;
        if ( v13 >= 0 )
          goto LABEL_8;
      }
      else
      {
        v12 = *(__int16 *)(a4 + 4);
        v9[832] = 0x4000;
        if ( v12 >= 0 )
        {
LABEL_8:
          if ( *(__int16 *)(a4 + 6) > 0 )
          {
            v9[1164] |= 0x400000u;
            v9 = (_DWORD *)v14[0];
          }
          result = 0;
          *a1 = v9;
          return result;
        }
      }
      v9[1164] |= 0x1000u;
      v9 = (_DWORD *)v14[0];
      goto LABEL_8;
    }
  }
  if ( v14[0] )
    matrixSslDeleteSession(v14[0]);
  return -1;
}

//----- (00455668) --------------------------------------------------------
int   matrixSslGetReadbuf(_DWORD *a1, _DWORD *a2)
{
  int result; // $v0
  int v5; // $a2
  int v6; // $v0
  int v7; // $a3

  result = -6;
  if ( a1 && a2 )
  {
    v5 = a1[829];
    if ( v5 <= 0 || (v6 = a1[825]) == 0 )
    {
      psTraceStr("psAssert %s", (int)"matrixsslApi.c");
      psTraceInt(":%d ", 639);
      psError((int)"ssl && ssl->insize > 0 && ssl->inbuf != NULL");
      v6 = a1[825];
      v5 = a1[829];
    }
    v7 = a1[827];
    *a2 = v6 + v7;
    return v5 - v7;
  }
  return result;
}

//----- (00455748) --------------------------------------------------------
int   matrixSslGetOutdata(_DWORD *a1, _DWORD *a2)
{
  int result; // $v0

  result = -6;
  if ( a1 )
  {
    if ( (int)a1[830] <= 0 || !a1[826] )
    {
      psTraceStr("psAssert %s", (int)"matrixsslApi.c");
      psTraceInt(":%d ", 717);
      psError((int)"ssl->outsize > 0 && ssl->outbuf != NULL");
    }
    if ( a2 )
      *a2 = a1[826];
    return a1[828];
  }
  return result;
}

//----- (0045581C) --------------------------------------------------------
int   matrixSslGetWritebuf(int a1, int *a2, unsigned int a3)
{
  unsigned int v6; // $a1
  unsigned int EncodedSize; // $s1
  int v8; // $s3
  int v9; // $a1
  int v10; // $a2
  int v11; // $v1
  int v12; // $a0
  bool v13; // dc
  unsigned int v14; // $s1
  int v15; // $a3
  unsigned int v16; // $v1
  unsigned int v17; // $v1
  BOOL v18; // $t1
  unsigned int v19; // $a0
  int v20; // $v0
  int v21; // $t1
  unsigned int Pmtu; // $s4
  int v24; // $v0
  signed int v25; // $t7
  unsigned int v26; // $v1

  if ( a1 && a2 )
  {
    if ( *(int *)(a1 + 3320) <= 0 || !*(_DWORD *)(a1 + 3304) )
    {
      psTraceStr("psAssert %s", (int)"matrixsslApi.c");
      psTraceInt(":%d ", 756);
      psError((int)"ssl->outsize > 0 && ssl->outbuf != NULL");
    }
    if ( (*(_DWORD *)(a1 + 3372) & 1) != 0 || *(_BYTE *)(a1 + 3389) != 3 || *(unsigned __int8 *)(a1 + 3390) >= 2u )
    {
      LOBYTE(v6) = *(_BYTE *)(a1 + 3367);
    }
    else
    {
      v6 = *(unsigned __int8 *)(a1 + 3367);
      if ( v6 >= 2 && a3 >= 2 )
      {
        v26 = *(_DWORD *)(a1 + 3324);
        if ( ((v26 >> 2) & 1) == 0 )
          *(_DWORD *)(a1 + 3324) = v26 | 4;
      }
    }
    if ( *(_DWORD *)(a1 + 3328) < a3 )
      a3 = *(_DWORD *)(a1 + 3328);
    EncodedSize = matrixSslGetEncodedSize(a1, (unsigned __int8)v6 + a3);
    if ( EncodedSize < a3 )
    {
      psTraceStr("psAssert %s", (int)"matrixsslApi.c");
      psTraceInt(":%d ", 796);
      psError((int)"requiredLen >= requestedLen");
    }
    v8 = EncodedSize - a3;
    if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
    {
      Pmtu = matrixDtlsGetPmtu();
      if ( Pmtu < EncodedSize )
      {
        v8 = matrixSslGetEncodedSize(a1, 0) + *(unsigned __int8 *)(a1 + 3367);
        EncodedSize = matrixSslGetEncodedSize(a1, Pmtu - v8);
      }
    }
    v9 = *(_DWORD *)(a1 + 3320);
    v10 = *(_DWORD *)(a1 + 3312);
    v11 = -1;
    if ( v9 < v10 )
      return v11;
    v12 = v9 - v10;
    v13 = v9 - v10 < EncodedSize;
    v14 = EncodedSize - (v9 - v10);
    if ( v13 )
    {
      v24 = realloc(*(_DWORD *)(a1 + 3304), v9 + v14);
      v11 = -8;
      if ( !v24 )
        return v11;
      v10 = *(_DWORD *)(a1 + 3312);
      v25 = *(_DWORD *)(a1 + 3320) + v14;
      v15 = v24;
      *(_DWORD *)(a1 + 3304) = v24;
      *(_DWORD *)(a1 + 3320) = v25;
      v11 = -1;
      v12 = v25 - v10;
      if ( v25 < v10 )
        return v11;
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 3304);
    }
    v16 = *(_DWORD *)(a1 + 3328);
    if ( v16 >= a3 )
    {
      a3 = v12 - v8;
      if ( v16 < v12 - v8 )
        a3 = *(_DWORD *)(a1 + 3328);
    }
    v17 = *(_DWORD *)(a1 + 3372);
    if ( ((v17 >> 2) & 1) != 0 )
    {
      v18 = (v17 & 0x100000) != 0;
      if ( ((v17 >> 12) & 1) != 0 )
      {
        v19 = *(unsigned __int8 *)(a1 + 3367);
        if ( v19 >= 2 )
        {
          v20 = v15 + v10 + *(_DWORD *)(a1 + 4660) + v19;
LABEL_23:
          v11 = a3;
          *a2 = v20;
          return v11;
        }
      }
    }
    else
    {
      v18 = (v17 & 0x100000) != 0;
    }
    if ( !v18 )
    {
      if ( ((*(_DWORD *)(a1 + 3324) >> 2) & 1) != 0 )
      {
        if ( !*(_BYTE *)(a1 + 3367) )
          _break(7u, 0);
        v21 = *(unsigned __int8 *)(a1 + 3367);
        if ( !((*(unsigned __int8 *)(a1 + 3364) + 1) % v21) )
          v21 = 0;
        if ( !*(_BYTE *)(a1 + 3367) )
          _break(7u, 0);
        v11 = a3;
        *a2 = v15
            + v10
            + 2 * *(_DWORD *)(a1 + 4660)
            + v21
            + *(unsigned __int8 *)(a1 + 3367)
            * ((*(unsigned __int8 *)(a1 + 3364) + 1)
             / *(unsigned __int8 *)(a1 + 3367))
            - 1;
      }
      else
      {
        v11 = a3;
        *a2 = v15 + v10 + *(_DWORD *)(a1 + 4660);
      }
      return v11;
    }
    v20 = v15 + v10 + *(_DWORD *)(a1 + 4660);
    if ( ((v17 >> 22) & 1) != 0 )
      v20 += 8;
    goto LABEL_23;
  }
  return -6;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);

//----- (00455CB0) --------------------------------------------------------
int   matrixSslEncodeWritebuf(int a1, int a2)
{
  int v3; // $v1
  int v4; // $v0
  int v5; // $t0
  int v6; // $a1
  int v7; // $a2
  int v8; // $a3
  int v9; // $v0
  unsigned int v10; // $v1
  unsigned int v11; // $t9
  int v12; // $v0
  unsigned int v13; // $a0
  int v14; // $v0
  int v15; // $t3
  int v17; // [sp+2Ch] [+Ch] BYREF

  v17 = a2;
  if ( !a1 || a2 < 0 )
    return -6;
  v3 = -12;
  if ( (*(_DWORD *)(a1 + 3324) & 1) != 0 )
    return v3;
  if ( *(int *)(a1 + 3320) <= 0 || (v4 = *(_DWORD *)(a1 + 3304)) == 0 )
  {
    psTraceStr("psAssert %s", (int)"matrixsslApi.c");
    psTraceInt(":%d ", 948);
    psError((int)"ssl->outsize > 0 && ssl->outbuf != NULL");
    v4 = *(_DWORD *)(a1 + 3304);
  }
  v5 = *(_DWORD *)(a1 + 3312);
  v6 = v4 + v5;
  if ( v4 )
  {
    v7 = *(_DWORD *)(a1 + 3320);
    if ( v7 - v5 >= v17 )
    {
      v8 = *(_DWORD *)(a1 + 4660);
      if ( ((*(_DWORD *)(a1 + 3324) >> 2) & 1) != 0 )
      {
        v9 = *(unsigned __int8 *)(a1 + 3367);
        if ( !*(_BYTE *)(a1 + 3367) )
          _break(7u, 0);
        if ( !((*(unsigned __int8 *)(a1 + 3364) + 1) % v9) )
          v9 = 0;
        if ( !*(_BYTE *)(a1 + 3367) )
          _break(7u, 0);
        v8 = v8
           + v9
           + *(unsigned __int8 *)(a1 + 3367) * ((*(unsigned __int8 *)(a1 + 3364) + 1) / *(unsigned __int8 *)(a1 + 3367))
           + v8
           - 1;
      }
      v10 = *(_DWORD *)(a1 + 3372);
      v11 = v10 >> 20;
      if ( ((v10 >> 2) & 1) != 0 )
      {
        v12 = (v10 & 0x100000) != 0;
        if ( ((v10 >> 12) & 1) == 0 )
          goto LABEL_22;
        v13 = *(unsigned __int8 *)(a1 + 3367);
        if ( v13 >= 2 )
          v8 += v13;
        v11 = v10 >> 20;
      }
      v12 = v11 & 1;
LABEL_22:
      if ( v12 && ((v10 >> 22) & 1) != 0 )
        v8 += 8;
      v14 = matrixSslEncode(a1, v6, v7 - v5, v6 + v8, &v17);
      if ( v14 >= 0 )
      {
        v15 = *(_DWORD *)(a1 + 3312) + v17;
        *(_DWORD *)(a1 + 3312) = v15;
        return v15;
      }
      if ( v14 == -50 )
      {
        psTraceStr("psAssert %s", (int)"matrixsslApi.c");
        psTraceInt(":%d ", 988);
        psError((int)"rc != SSL_FULL");
      }
    }
  }
  return -1;
}

//----- (00455F68) --------------------------------------------------------
int   matrixSslReceivedData(int a1, int a2, char **a3, int *a4)
{
  int v8; // $t7
  int v9; // $v1
  int v10; // $a1
  int v11; // $v1
  int v12; // $v0
  char *v13; // $s1
  int v14; // $t0
  char *v15; // $a2
  int v16; // $v0
  char *v17; // $a1
  int v18; // $s7
  char *v19; // $s3
  int v20; // $s2
  int v21; // $s4
  unsigned int v22; // $v1
  unsigned int v23; // $v1
  int v24; // $v1
  int v25; // $t8
  int v27; // $a1
  int Pmtu; // $s1
  int v29; // $v1
  int v30; // $s1
  unsigned int v31; // $a0
  unsigned int v32; // $a1
  unsigned int v33; // $v1
  int v34; // $a0
  int v35; // $v0
  bool v36; // dc
  int v37; // $v1
  int v38; // $a2
  int v39; // $a0
  int v40; // $ra
  unsigned int v41; // $v1
  unsigned int v42; // $v1
  unsigned int v43; // $t7
  int v44; // $v1
  int v45; // $a1
  int v46; // $v0
  int v47; // $a1
  char *v48; // $v0
  int v49; // $v0
  char *v50; // $s6
  char *v51; // $a2
  int v52; // $a0
  int v53; // $t0
  unsigned __int8 v54; // [sp+30h] [-18h] BYREF
  char v55[3]; // [sp+31h] [-17h] BYREF
  int v56; // [sp+34h] [-14h] BYREF
  unsigned int v57; // [sp+38h] [-10h] BYREF
  int v58; // [sp+3Ch] [-Ch] BYREF
  char *v59; // [sp+40h] [-8h] BYREF
  int v60; // [sp+44h] [-4h] BYREF

  if ( !a1 || !a3 || !a4 )
    return -6;
  if ( *(int *)(a1 + 3320) <= 0 || !*(_DWORD *)(a1 + 3304) )
  {
    psTraceStr("psAssert %s", (int)"matrixsslApi.c");
    psTraceInt(":%d ", 1158);
    psError((int)"ssl->outsize > 0 && ssl->outbuf != NULL");
  }
  if ( *(int *)(a1 + 3316) <= 0 || !*(_DWORD *)(a1 + 3300) )
  {
    psTraceStr("psAssert %s", (int)"matrixsslApi.c");
    psTraceInt(":%d ", 1159);
    psError((int)"ssl->insize > 0 && ssl->inbuf != NULL");
  }
  *a4 = 0;
  v8 = *(_DWORD *)(a1 + 3308);
  *a3 = 0;
  *(_DWORD *)(a1 + 3308) = v8 + a2;
  v9 = 0;
  if ( !(v8 + a2) )
    return v9;
  v59 = *(char **)(a1 + 3300);
  while ( 2 )
  {
    if ( matrixSslHandshakeIsComplete(a1) )
    {
      v10 = *(_DWORD *)(a1 + 3308);
      v11 = v10 >> 31;
      v12 = (int)((unsigned __int64)(818089009LL * v10) >> 32) >> 2;
    }
    else
    {
      v10 = *(_DWORD *)(a1 + 3308);
      v11 = v10 >> 31;
      v12 = (int)((unsigned __int64)(954437177LL * v10) >> 32) >> 1;
    }
    if ( v12 - v11 < 0 )
      return -12;
    v13 = v59;
    v14 = *(_DWORD *)(a1 + 3316);
    v15 = &v59[-*(_DWORD *)(a1 + 3300)];
    v60 = v10;
    v16 = matrixSslDecode(
            (unsigned __int16 *)a1,
            (int *)&v59,
            (char **)&v60,
            v14 - (_DWORD)v15,
            &v56,
            (int *)&v57,
            &v58,
            &v54,
            v55);
    v17 = v59;
    v18 = v16;
    v19 = v13;
    v20 = v59 - v13;
    v21 = -12;
    switch ( v16 )
    {
      case -61:
        v44 = *(_DWORD *)(a1 + 3308) - v20;
        *(_DWORD *)(a1 + 3308) = v44;
        if ( v44 <= 0 )
          return 1;
        v31 = *(_DWORD *)(a1 + 3300);
        if ( v31 < (unsigned int)v17 )
          goto LABEL_41;
        psTraceStr("psAssert %s", (int)"matrixsslApi.c");
        v45 = 1250;
        goto LABEL_85;
      case -54:
        v22 = *(_DWORD *)(a1 + 3372);
        if ( ((v22 >> 1) & 1) != 0 && ((v22 >> 12) & 1) != 0 )
        {
          v23 = *(unsigned __int8 *)(a1 + 3367);
          if ( v23 >= 2 )
            v19 = &v13[v23];
        }
        v24 = v60;
        if ( v60 != 2 )
        {
          psTraceStr("psAssert %s", (int)"matrixsslApi.c");
          psTraceInt(":%d ", 1370);
          psError((int)"len == 2");
          v24 = v60;
        }
        *a4 = v24;
        v9 = 6;
        v25 = *(_DWORD *)(a1 + 3308) - v20;
        *a3 = v19;
        *(_DWORD *)(a1 + 3308) = v25;
        return v9;
      case -53:
        if ( ((*(_DWORD *)(a1 + 3324) >> 1) & 1) == 0 && matrixSslHandshakeIsComplete(a1) )
        {
          v47 = *(_DWORD *)(a1 + 3260);
          *(_DWORD *)(a1 + 3324) |= 2u;
          matrixSslGetSessionId(a1, v47);
        }
        v40 = *(_DWORD *)(a1 + 3308) - v20;
        *(_DWORD *)(a1 + 3308) = v40;
        if ( v40 != v56 )
        {
          psTraceStr("psAssert %s", (int)"matrixsslApi.c");
          psTraceInt(":%d ", 1459);
          psError((int)"(uint32) ssl->inlen == start");
        }
        if ( *(unsigned __int8 *)(a1 + 3367) != *(unsigned __int8 *)(a1 + 3371) )
        {
          psTraceStr("psAssert %s", (int)"matrixsslApi.c");
          psTraceInt(":%d ", 1467);
          psError((int)"ssl->enBlockSize == ssl->deBlockSize");
        }
        v41 = *(_DWORD *)(a1 + 3372);
        if ( ((v41 >> 1) & 1) != 0 && ((v41 >> 12) & 1) != 0 && (v42 = *(unsigned __int8 *)(a1 + 3371), v42 >= 2) )
        {
          v19 = &v13[v42];
          v60 -= v42;
          *a4 = v60;
        }
        else
        {
          *a4 = v60;
        }
        v43 = *(_DWORD *)(a1 + 3372);
        *a3 = v19;
        if ( ((v43 >> 14) & 1) != 0 )
          *(_WORD *)(a1 + 3586) = 1;
        return 4;
      case -52:
        v36 = (unsigned __int8)v55[0] == 255;
        *(_DWORD *)(a1 + 3308) = 0;
        if ( !v36 )
          *(_DWORD *)(a1 + 3324) |= 1u;
        if ( v13 != v17 )
        {
          psTraceStr("psAssert %s", (int)"matrixsslApi.c");
          psTraceInt(":%d ", 1302);
          psError((int)"prevBuf == buf");
        }
        if ( *(_DWORD *)(a1 + 3316) < v60 )
        {
          psTraceStr("psAssert %s", (int)"matrixsslApi.c");
          psTraceInt(":%d ", 1303);
          psError((int)"ssl->insize >= (int32) len");
        }
        if ( v56 )
        {
          psTraceStr("psAssert %s", (int)"matrixsslApi.c");
          psTraceInt(":%d ", 1304);
          psError((int)"start == 0");
        }
        if ( *(char **)(a1 + 3300) != v59 )
        {
          psTraceStr("psAssert %s", (int)"matrixsslApi.c");
          psTraceInt(":%d ", 1305);
          psError((int)"buf == ssl->inbuf");
        }
        v37 = *(_DWORD *)(a1 + 3312);
        v21 = 1;
        if ( v37 > 0 )
        {
          v38 = v60;
          if ( *(_DWORD *)(a1 + 3320) < v37 + v60 )
          {
            v49 = realloc(*(_DWORD *)(a1 + 3304), v37 + v60);
            v9 = -8;
            if ( !v49 )
              return v9;
            v38 = v60;
            v37 = *(_DWORD *)(a1 + 3312);
            v39 = v49;
            *(_DWORD *)(a1 + 3320) = v37 + v60;
            *(_DWORD *)(a1 + 3304) = v49;
          }
          else
          {
            v39 = *(_DWORD *)(a1 + 3304);
          }
          memcpy(v39 + v37, *(_DWORD *)(a1 + 3300), v38);
          *(_DWORD *)(a1 + 3312) += v60;
          v21 = 1;
          goto LABEL_29;
        }
        v50 = (char *)v60;
        v51 = *(char **)(a1 + 3304);
        v52 = *(_DWORD *)(a1 + 3320);
        v53 = *(_DWORD *)(a1 + 3316);
        *(_DWORD *)(a1 + 3304) = *(_DWORD *)(a1 + 3300);
        *(_DWORD *)(a1 + 3320) = v53;
        *(_DWORD *)(a1 + 3316) = v52;
        v59 = v51;
        v60 = (int)v50;
        *(_DWORD *)(a1 + 3300) = v51;
        *(_DWORD *)(a1 + 3312) = v50;
        goto LABEL_29;
      case -51:
        v9 = -8;
        if ( v57 >= 0x4806 )
          return v9;
        v21 = 2;
        if ( *(_DWORD *)(a1 + 3316) >= v57 )
          goto LABEL_29;
        v48 = (char *)realloc(*(_DWORD *)(a1 + 3300), v57);
        v9 = -8;
        if ( !v48 )
          return v9;
        v59 = v48;
        *(_DWORD *)(a1 + 3316) = v57;
        v21 = 2;
        *(_DWORD *)(a1 + 3300) = v48;
        goto LABEL_29;
      case -50:
        v32 = v57;
        if ( v57 >= 0x4806 )
          return -8;
        if ( v57 < 0x4001 )
          goto LABEL_45;
        if ( matrixSslHandshakeIsComplete(a1) )
        {
          v32 = v57;
        }
        else
        {
          v32 = v57;
          if ( v57 >= 0x4001 )
            return -8;
        }
LABEL_45:
        v33 = *(_DWORD *)(a1 + 3316);
        *(_DWORD *)(a1 + 3308) = 0;
        if ( v33 >= v32 )
          return -12;
        v34 = *(_DWORD *)(a1 + 3300);
        v60 = v34 - (_DWORD)v59;
        v35 = realloc(v34, v32);
        v9 = -8;
        if ( !v35 )
          return v9;
        v59 = (char *)(v35 + v60);
        *(_DWORD *)(a1 + 3316) = v57;
        *(_DWORD *)(a1 + 3300) = v35;
        continue;
      case -12:
        return v58;
      case 0:
        v30 = *(_DWORD *)(a1 + 3308) - v20;
        *(_DWORD *)(a1 + 3308) = v30;
        if ( v30 > 0 )
        {
          v31 = *(_DWORD *)(a1 + 3300);
          if ( v31 >= (unsigned int)v17 )
          {
            psTraceStr("psAssert %s", (int)"matrixsslApi.c");
            v45 = 1205;
LABEL_85:
            psTraceInt(":%d ", v45);
            psError((int)"buf > ssl->inbuf");
            v31 = *(_DWORD *)(a1 + 3300);
          }
LABEL_41:
          memmove(v31);
          v59 = *(char **)(a1 + 3300);
          continue;
        }
        v21 = 2;
        if ( ((*(_DWORD *)(a1 + 3324) >> 1) & 1) == 0 && matrixSslHandshakeIsComplete(a1) )
        {
          v27 = *(_DWORD *)(a1 + 3260);
          *(_DWORD *)(a1 + 3324) |= 2u;
          matrixSslGetSessionId(a1, v27);
          v21 = 5;
        }
LABEL_29:
        if ( *(int *)(a1 + 3308) > 0 && *(char **)(a1 + 3300) != v59 )
        {
          psTraceStr("psAssert %s", (int)"matrixsslApi.c");
          psTraceInt(":%d ", 1502);
          psError((int)&word_4A0308);
        }
        if ( v18 == -51 )
          return v21;
        Pmtu = 1500;
        if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
          Pmtu = matrixDtlsGetPmtu();
        v29 = v21;
        if ( Pmtu < *(_DWORD *)(a1 + 3316) )
        {
          if ( *(_DWORD *)(a1 + 3308) < Pmtu )
          {
            v46 = realloc(*(_DWORD *)(a1 + 3300), Pmtu);
            v29 = v21;
            if ( v46 )
            {
              *(_DWORD *)(a1 + 3316) = Pmtu;
              *(_DWORD *)(a1 + 3300) = v46;
              return v29;
            }
          }
          return v21;
        }
        return v29;
      default:
        goto LABEL_29;
    }
  }
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);
// 4EA0A8: using guessed type int   memmove(_DWORD);

//----- (00456B08) --------------------------------------------------------
int   matrixSslProcessedData(_DWORD *a1, char **a2, int *a3)
{
  int v6; // $v0
  int Pmtu; // $s1
  int v8; // $v1
  int v10; // $v0

  if ( !a1 || !a2 || !a3 )
    return -6;
  *a3 = 0;
  v6 = a1[829];
  *a2 = 0;
  if ( v6 <= 0 || !a1[825] )
  {
    psTraceStr("psAssert %s", (int)"matrixsslApi.c");
    psTraceInt(":%d ", 1542);
    psError((int)"ssl->insize > 0 && ssl->inbuf != NULL");
  }
  if ( (int)a1[827] > 0 )
    memmove(a1[825]);
  Pmtu = 1500;
  if ( ((a1[843] >> 14) & 1) != 0 )
    Pmtu = matrixDtlsGetPmtu();
  if ( Pmtu < a1[829] )
  {
    v8 = a1[827];
    if ( v8 >= Pmtu )
      goto LABEL_12;
    v10 = realloc(a1[825], Pmtu);
    if ( v10 )
    {
      v8 = a1[827];
      a1[825] = v10;
      a1[829] = Pmtu;
LABEL_12:
      if ( v8 > 0 )
        return matrixSslReceivedData((int)a1, 0, a2, a3);
      return 0;
    }
  }
  if ( (int)a1[827] > 0 )
    return matrixSslReceivedData((int)a1, 0, a2, a3);
  return 0;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);
// 4EA0A8: using guessed type int   memmove(_DWORD);

//----- (00456D60) --------------------------------------------------------
int   matrixSslEncodeClosureAlert(_DWORD *a1)
{
  int result; // $v0
  int v3; // $v1
  int v4; // $s1
  int v5; // $t1
  int v6; // $a0
  int v7; // $v1
  int v8; // $v0
  int v9; // $t5
  int v10; // [sp+18h] [-18h] BYREF
  int v11; // [sp+1Ch] [-14h]
  int v12; // [sp+20h] [-10h]
  int v13; // [sp+24h] [-Ch]
  int v14; // [sp+28h] [-8h] BYREF

  result = -6;
  if ( a1 )
  {
    if ( (int)a1[830] <= 0 || !a1[826] )
    {
      psTraceStr("psAssert %s", (int)"matrixsslApi.c");
      psTraceInt(":%d ", 1584);
      psError((int)"ssl->outsize > 0 && ssl->outbuf != NULL");
    }
    v3 = a1[831];
    v4 = 0;
    if ( (v3 & 1) == 0 )
    {
      v5 = v3 | 1;
      v6 = a1[826];
      v7 = a1[830];
      a1[831] = v5;
      while ( 1 )
      {
        v9 = a1[828];
        v10 = v6 + v9;
        v13 = v7 - v9;
        v12 = v6 + v9;
        v11 = v6 + v9;
        result = sslEncodeClosureAlert((int)a1, &v10, &v14);
        if ( result != -50 || v4 )
          break;
        v4 = a1[828] + v14;
        v8 = realloc(a1[826], v4);
        v6 = v8;
        v7 = v4;
        if ( !v8 )
          return -8;
        a1[826] = v8;
        a1[830] = v4;
      }
      if ( result )
        return result;
      a1[828] += v12 - v11;
    }
    return 0;
  }
  return result;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);

//----- (00456EFC) --------------------------------------------------------
int   matrixSslSentData(_DWORD *a1, int a2)
{
  int result; // $v0
  int v5; // $s2
  int v6; // $a2
  unsigned int v7; // $v1
  int Pmtu; // $s1
  int v9; // $a1
  int v10; // $v0

  result = -6;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( (int)a1[830] <= 0 || !a1[826] )
      {
        psTraceStr("psAssert %s", (int)"matrixsslApi.c");
        psTraceInt(":%d ", 1908);
        psError((int)"ssl->outsize > 0 && ssl->outbuf != NULL");
      }
      v5 = 0;
      v6 = a1[828] - a2;
      a1[828] = v6;
      if ( v6 <= 0 )
      {
        if ( !v6 && (v7 = a1[831], (v7 & 1) != 0) )
        {
          v5 = 3;
        }
        else
        {
          Pmtu = 1500;
          if ( ((a1[843] >> 14) & 1) != 0 )
            Pmtu = matrixDtlsGetPmtu();
          if ( Pmtu < a1[830] && a1[828] < Pmtu && (v10 = realloc(a1[826], Pmtu)) != 0 )
          {
            v7 = a1[831];
            a1[826] = v10;
            a1[830] = Pmtu;
          }
          else
          {
            v7 = a1[831];
          }
        }
        if ( ((v7 >> 1) & 1) != 0 || !matrixSslHandshakeIsComplete((int)a1) )
        {
          return v5;
        }
        else
        {
          v9 = a1[815];
          a1[831] |= 2u;
          matrixSslGetSessionId((int)a1, v9);
          return 5;
        }
      }
      else
      {
        memmove(a1[826]);
        return 1;
      }
    }
    else
    {
      return a1[828] > 0;
    }
  }
  return result;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);
// 4EA0A8: using guessed type int   memmove(_DWORD);

//----- (0045713C) --------------------------------------------------------
int   matrixSslDecode(
        unsigned __int16 *a1,
        int *a2,
        char **a3,
        int a4,
        _DWORD *a5,
        int *a6,
        int *a7,
        unsigned __int8 *a8,
        _BYTE *a9)
{
  unsigned int v10; // $v1
  int v11; // $s7
  char *v12; // $s0
  unsigned int v13; // $s2
  char *v14; // $s3
  char *v15; // $s6
  int v16; // $v1
  int v17; // $a3
  int v18; // $t0
  int v19; // $a3
  unsigned __int8 v20; // $a3
  unsigned int v21; // $a2
  unsigned __int8 v22; // $v1
  unsigned int v23; // $a0
  unsigned __int8 *v24; // $a1
  __int16 v25; // $ra
  unsigned __int8 *v26; // $s0
  unsigned __int16 v27; // $a3
  unsigned int v28; // $a0
  unsigned int v29; // $a0
  unsigned int v30; // $a2
  unsigned __int16 v31; // $a3
  int v32; // $a1
  unsigned __int16 v33; // $a0
  unsigned __int8 v34; // $t0
  int v35; // $s0
  unsigned __int8 v36; // $t1
  int v37; // $s4
  int v38; // $s4
  unsigned int v39; // $fp
  unsigned int v40; // $a0
  int v41; // $v1
  int v42; // $t0
  int v43; // $a3
  int v44; // $a0
  int v45; // $a1
  BOOL v46; // $v0
  int v47; // $s5
  int v48; // $v1
  bool v49; // dc
  BOOL v50; // $t1
  int v51; // $s5
  int v52; // $v1
  BOOL v53; // $t2
  int v55; // $v1
  int v56; // $a0
  int v57; // $a0
  int v58; // $t7
  char v59; // $v1
  unsigned int v60; // $a0
  int v61; // $v1
  int v62; // $v1
  unsigned int v63; // $a1
  int v64; // $s0
  int v65; // $v1
  char v66; // $t9
  char v67; // $t6
  unsigned __int8 *i; // $v1
  BOOL v69; // $v0
  BOOL v70; // $v0
  BOOL v71; // $v0
  int v72; // $v0
  int v73; // $s0
  int v74; // $a1
  int v75; // $v1
  int v76; // $a0
  char *v77; // $v0
  BOOL v78; // $v0
  int v79; // $v0
  int j; // $v1
  int v81; // $v1
  unsigned int v82; // $a0
  int v83; // $v0
  char v84; // $v0
  int *v85; // $a0
  int v86; // $v0
  int v87; // $v1
  unsigned __int8 *v88; // $t2
  unsigned __int8 *v89; // $s2
  int v90; // $s5
  unsigned int v91; // $a2
  unsigned __int8 *v92; // $a1
  int v93; // $s6
  unsigned __int8 *v94; // $fp
  int v95; // $a0
  int v96; // $t2
  int v97; // $a1
  unsigned int v98; // $s0
  int v99; // $fp
  unsigned int v100; // $v1
  unsigned __int8 *v101; // $v0
  int v102; // $s0
  int v103; // $s2
  int v104; // $s0
  int v105; // $a0
  unsigned __int8 *v106; // $t3
  unsigned int v107; // $s2
  unsigned __int16 v108; // $a2
  int v109; // $a1
  int v110; // $a0
  int v111; // $t4
  char *v112; // $s0
  int v113; // $a2
  int v114; // $s2
  int v115; // $s7
  unsigned __int8 *v116; // $a3
  int v117; // $s0
  unsigned int v118; // $t5
  int v119; // $a1
  int v120; // $v1
  int v121; // $t7
  int v122; // $v1
  unsigned int v123; // $s2
  int v124; // $v1
  unsigned __int8 v125; // $a0
  int v126; // $v1
  int v127; // $t0
  unsigned int v128; // $v1
  unsigned __int8 *v129; // $t4
  unsigned __int8 *v130; // $t1
  int v131; // $t7
  int v132; // $t6
  unsigned int v133; // $a3
  int v134; // $s0
  int v135; // $t5
  int v136; // $t6
  int v137; // $a3
  int v138; // $t9
  int v139; // $v1
  int v140; // $t1
  int v141; // $s4
  int v142; // $a0
  int v143; // $v0
  int v144; // $v0
  int v145; // $v0
  int v146; // $v0
  unsigned __int16 *v147; // $fp
  int v148; // $t6
  int v149; // $a0
  int v150; // $t5
  unsigned __int16 *v151; // $t2
  unsigned __int8 *v152; // $a1
  int v153; // $a0
  int v154; // $v0
  unsigned int v155; // $a0
  int v156; // $a0
  int v157; // $s6
  int v158; // $a2
  unsigned __int8 *v159; // $a1
  int v160; // $t8
  int v161; // $v0
  int v162; // $s2
  int v163; // $a1
  int v164; // $v1
  int v165; // $v0
  int Cipher; // $v0
  int (  *v167)(int, signed int, unsigned __int8 **, int); // $t9
  int v168; // $a0
  _BYTE *v169; // $a1
  int v170; // $v0
  unsigned __int8 *v171; // $v1
  int v172; // $s0
  unsigned __int8 *v173; // $t7
  int v174; // $a0
  int v175; // $a2
  int v176; // $t5
  int v177; // $t0
  int v178; // $t8
  unsigned int v179; // $s2
  unsigned __int8 *v180; // $s4
  int v181; // $v0
  int v182; // $a0
  unsigned int v183; // $a0
  int v184; // $v0
  int v185; // $v1
  unsigned __int8 *v186; // $v1
  int v187; // $a2
  int v188; // $v0
  int v189; // $v0
  char *v190; // $s2
  _BYTE v191[72]; // [sp+28h] [-200h] BYREF
  int v192[2]; // [sp+70h] [-1B8h] BYREF
  int v193; // [sp+78h] [-1B0h]
  int v194; // [sp+7Ch] [-1ACh]
  __int64 v195[26]; // [sp+80h] [-1A8h] BYREF
  _DWORD v196[32]; // [sp+150h] [-D8h] BYREF
  _BYTE v197[64]; // [sp+1D0h] [-58h] BYREF
  int v198; // [sp+210h] [-18h] BYREF
  unsigned __int8 *v199; // [sp+214h] [-14h] BYREF
  unsigned __int8 *v200; // [sp+218h] [-10h]
  int v201; // [sp+21Ch] [-Ch]
  int v202; // [sp+220h] [-8h]

  *a7 = 0;
  v10 = *((_DWORD *)a1 + 843);
  if ( ((v10 >> 6) & 1) != 0 || ((v10 >> 4) & 1) != 0 )
  {
LABEL_58:
    v19 = -12;
    *a7 = -12;
    return v19;
  }
  v11 = *a2;
  v12 = (char *)*a2;
  v13 = 0;
  if ( ((v10 >> 5) & 1) != 0 )
  {
    *((_DWORD *)a1 + 843) = v10 & 0xFFFFFFDF;
    goto LABEL_149;
  }
  *a6 = 0;
  v14 = (char *)v11;
  v15 = &(*a3)[v11];
  while ( 1 )
  {
    while ( 1 )
    {
      v16 = v15 - v14;
      if ( v15 == v14 )
        return 0;
      v17 = -51;
      if ( v16 < 5 )
      {
        v85 = a6;
        v79 = 5;
        goto LABEL_207;
      }
      if ( !*((_BYTE *)a1 + 3389) && *v14 < 0 )
        goto LABEL_174;
      v18 = *((_DWORD *)a1 + 1165);
      v19 = -51;
      if ( v16 < v18 )
      {
        *a6 = v18;
        return v19;
      }
      v20 = *v14;
      v21 = *((_DWORD *)a1 + 843);
      *((_BYTE *)a1 + 12) = *v14;
      v22 = v14[1];
      *((_BYTE *)a1 + 2) = v22;
      v23 = (unsigned __int8)v14[2];
      *((_BYTE *)a1 + 3) = v23;
      v24 = (unsigned __int8 *)(v14 + 3);
      if ( ((v21 >> 14) & 1) != 0 )
      {
        if ( v22 != 254 )
          goto LABEL_58;
        v24 = (unsigned __int8 *)(v14 + 11);
        if ( v23 < 0xFD )
          goto LABEL_58;
        *((_BYTE *)a1 + 4) = v14[3];
        *((_BYTE *)a1 + 5) = v14[4];
        *((_BYTE *)a1 + 6) = v14[5];
        *((_BYTE *)a1 + 7) = v14[6];
        *((_BYTE *)a1 + 8) = v14[7];
        *((_BYTE *)a1 + 9) = v14[8];
        *((_BYTE *)a1 + 10) = v14[9];
        *((_BYTE *)a1 + 11) = v14[10];
      }
      else if ( v22 != 3 )
      {
        v19 = -12;
        *((_DWORD *)a1 + 844) = 70;
        return v19;
      }
      v25 = *v24;
      *a1 = v25 << 8;
      *a1 = (v25 << 8) + v24[1];
      v26 = v24 + 2;
      if ( (unsigned int)v20 - 20 >= 4 )
      {
        v12 = (char *)*a2;
LABEL_192:
        *((_DWORD *)a1 + 844) = 10;
        goto LABEL_149;
      }
      if ( (unsigned __int8)(*((_BYTE *)a1 + 3384) - 1) >= 2u && a1[1] != (unsigned __int16)(*((_DWORD *)a1 + 847) >> 8) )
      {
        v12 = (char *)*a2;
        goto LABEL_174;
      }
      v27 = *a1;
      if ( (unsigned __int16)(*a1 - 1) >= 0x4800u )
        goto LABEL_186;
      if ( v15 - (char *)v26 < *a1 )
      {
        v79 = *a1 + v18;
        if ( ((v21 >> 14) & 1) != 0 )
        {
          v12 = (char *)*a2;
LABEL_174:
          *((_DWORD *)a1 + 844) = 47;
          goto LABEL_149;
        }
        v85 = a6;
        v17 = -51;
LABEL_207:
        *v85 = v79;
        return v17;
      }
      if ( ((v21 >> 14) & 1) == 0 )
        break;
      v57 = dtlsCompareEpoch((int)(a1 + 2), (int)a1 + 3533);
      if ( v57 == 1 && *((_BYTE *)a1 + 12) == 22 && *((_BYTE *)a1 + 3384) == 20 )
      {
        v19 = 0;
        if ( !*((_DWORD *)a1 + 890) )
        {
          *a2 = (int)&v26[*a1];
          return v19;
        }
        v59 = *((_BYTE *)a1 + 5);
        *((_BYTE *)a1 + 3533) = *((_BYTE *)a1 + 4);
        *((_BYTE *)a1 + 3534) = v59;
LABEL_88:
        if ( dtlsChkReplayWindow((int)a1, (int)(a1 + 3)) == 1 )
        {
          v21 = *((_DWORD *)a1 + 843);
          v27 = *a1;
          v28 = v21 >> 1;
          goto LABEL_21;
        }
        v12 = (char *)&v26[*a1];
        *a2 = (int)v12;
        v14 = v12;
        if ( v15 - v12 <= 0 )
          return 0;
      }
      else
      {
        if ( !v57 )
          goto LABEL_88;
        if ( v57 == 1 && *((_BYTE *)a1 + 12) == 22 && *((unsigned __int8 *)a1 + 3384) == 255 )
        {
          v67 = *((_BYTE *)a1 + 5);
          *((_BYTE *)a1 + 3533) = *((_BYTE *)a1 + 4);
          *((_BYTE *)a1 + 3534) = v67;
        }
        if ( v57 == 1 && *((_BYTE *)a1 + 12) == 23 && *((unsigned __int8 *)a1 + 3384) == 255 )
        {
          v66 = *((_BYTE *)a1 + 5);
          v21 = *((_DWORD *)a1 + 843);
          v27 = *a1;
          *((_BYTE *)a1 + 3533) = *((_BYTE *)a1 + 4);
          *((_BYTE *)a1 + 3534) = v66;
          break;
        }
        v12 = (char *)&v26[*a1];
        *a2 = (int)v12;
        v14 = v12;
        if ( *((_BYTE *)a1 + 12) == 20 )
        {
          v58 = v15 - v12;
          if ( !a1[1793] )
          {
            if ( v15 != v12 )
            {
              if ( *v12 != 22 )
              {
                psTraceStr("psAssert %s", (int)"sslDecode.c");
                psTraceInt(":%d ", 596);
                psError((int)"*c == SSL_RECORD_TYPE_HANDSHAKE");
              }
              *a2 = (int)&v12[256 * (unsigned __int8)v12[11] + 13 + (unsigned __int8)v12[12]];
            }
            return -61;
          }
        }
        else
        {
          v58 = v15 - v12;
        }
        if ( v58 <= 0 )
        {
          if ( v57 == 1 && (*((_DWORD *)a1 + 843) & 1) != 0 )
          {
            v12 = (char *)v11;
            if ( *((_BYTE *)a1 + 3384) == 1 )
            {
              *a2 = v11;
              goto LABEL_192;
            }
          }
          v19 = -61;
          if ( v57 != -1 )
            return 0;
          return v19;
        }
      }
    }
    v28 = v21 >> 1;
LABEL_21:
    v200 = (unsigned __int8 *)v11;
    if ( (v28 & 1) != 0 )
    {
      v29 = *((unsigned __int8 *)a1 + 3371);
      if ( v29 >= 2 && ((v21 >> 21) & 1) == 0 )
      {
        if ( ((v21 >> 12) & 1) != 0 )
        {
          if ( v27 < (int)(*((unsigned __int8 *)a1 + 3368) + v29 + 1) )
            goto LABEL_224;
        }
        else if ( v27 < *((unsigned __int8 *)a1 + 3368) + 1 )
        {
          v12 = (char *)*a2;
          goto LABEL_109;
        }
      }
    }
    if ( (*((int (  **)(unsigned __int16 *, unsigned __int8 *, int, _DWORD))a1 + 838))(a1, v26, v11, v27) < 0 )
    {
      v12 = (char *)*a2;
      *((_DWORD *)a1 + 844) = 51;
      goto LABEL_149;
    }
    v30 = *((_DWORD *)a1 + 843);
    v31 = *a1;
    v32 = *a1;
    v14 = (char *)&v26[v32];
    if ( ((v30 >> 21) & 1) != 0 )
    {
      v33 = v32 - 8;
      if ( ((*(_DWORD *)(*((_DWORD *)a1 + 836) + 4) >> 13) & 1) == 0 )
        v33 = v32 - 16;
      v31 = v33;
      if ( ((v30 >> 23) & 1) != 0 )
      {
        v31 = v33 - 8;
        *a1 = v33 - 8;
      }
      else
      {
        *a1 = v33;
      }
    }
    if ( ((v30 >> 1) & 1) != 0 && ((v30 >> 21) & 1) == 0 )
    {
      v34 = *((_BYTE *)a1 + 3371);
      v35 = 0;
      if ( v34 < 2u )
      {
        v36 = *((_BYTE *)a1 + 3368);
        goto LABEL_36;
      }
      v60 = v31 + v11;
      v13 = *(unsigned __int8 *)(v60 - 1);
      if ( (*((_DWORD *)a1 + 847) & 0xFFFF00) == 0x300 )
        v35 = v13 >= v34;
      if ( ((v30 >> 12) & 1) != 0 )
      {
        v36 = *((_BYTE *)a1 + 3368);
        if ( v31 < (int)(v36 + v13 + *((unsigned __int8 *)a1 + 3371) + 1) )
        {
          v35 = 2;
LABEL_96:
          v61 = 255;
          goto LABEL_98;
        }
      }
      else
      {
        v36 = *((_BYTE *)a1 + 3368);
        if ( v31 < (int)(v36 + v13 + 1) )
        {
          v35 = 3;
          goto LABEL_96;
        }
      }
      v61 = 255;
      if ( v35 )
      {
        do
        {
LABEL_98:
          while ( (unsigned __int8)v61 != v13 )
          {
            if ( --v61 < 0 )
              goto LABEL_100;
          }
          --v61;
          v35 = 1;
        }
        while ( v61 >= 0 );
LABEL_100:
        v37 = v31;
        goto LABEL_37;
      }
      if ( *((_BYTE *)a1 + 3389) != 3 )
        goto LABEL_101;
      v63 = v60 - v13;
      if ( !*((_BYTE *)a1 + 3390) )
        goto LABEL_101;
      for ( i = (unsigned __int8 *)(v63 - 1); (unsigned int)i < v60; ++i )
      {
        if ( *i != v13 )
          v35 = 1;
      }
      v62 = v36;
      if ( v35 )
      {
        for ( j = 255 - v13; j > 0; --j )
        {
          if ( (unsigned __int8)j == v13 )
            v35 = 2;
        }
LABEL_101:
        v62 = v36;
        if ( !v35 )
        {
          v63 = v60 - v13;
          goto LABEL_103;
        }
LABEL_36:
        v37 = v31;
LABEL_37:
        v38 = v37 + v11 - v36;
        v39 = v30 >> 12;
      }
      else
      {
LABEL_103:
        v64 = v63 - v62;
        v65 = 255 - v13;
        v38 = v64 - 1;
        while ( 1 )
        {
          v35 = 0;
          if ( v65 <= 0 )
            break;
          --v65;
        }
        v39 = v30 >> 12;
      }
      v40 = *((unsigned __int8 *)a1 + 3371);
      if ( (v39 & 1) != 0 && *((unsigned __int8 *)a1 + 3371) >= 2u )
      {
        v200 = (unsigned __int8 *)(v11 + *((unsigned __int8 *)a1 + 3371));
        v40 = v34;
      }
      if ( v40 >= 2 )
      {
        v41 = v31;
        v42 = 0;
        v43 = 0;
        if ( ((v30 >> 12) & 1) != 0 )
          v41 -= v40;
        v44 = v41 - v36 + 13;
        v45 = v41 - v13 - v36 + 12;
        if ( v36 == 20 || v36 == 32 )
        {
          v69 = v44 < 65;
          while ( !v69 )
          {
            v44 -= 64;
            v69 = v44 < 65;
            ++v43;
          }
          if ( v44 >= 57 )
            ++v43;
          v70 = v45 < 65;
          while ( 1 )
          {
            v49 = !v70;
            v71 = v45 < 57;
            if ( !v49 )
              break;
            v45 -= 64;
            v70 = v45 < 65;
            ++v42;
          }
        }
        else
        {
          v46 = v44 < 129;
          if ( v36 != 48 )
            goto LABEL_47;
          while ( !v46 )
          {
            v44 -= 128;
            v46 = v44 < 129;
            ++v43;
          }
          if ( v44 >= 113 )
            ++v43;
          v78 = v45 < 129;
          while ( 1 )
          {
            v49 = !v78;
            v71 = v45 < 113;
            if ( !v49 )
              break;
            v45 -= 128;
            v78 = v45 < 129;
            ++v42;
          }
        }
        if ( !v71 )
          ++v42;
LABEL_47:
        v47 = v43 - v42;
        if ( !v35 )
        {
          v48 = v36;
          v49 = v36 == 32;
          v50 = v36 < 0x21u;
          if ( v49 )
          {
            psSha256Init(v195);
            while ( v47 > 0 )
            {
              --v47;
              psSha256Update((int *)v195, (int)v196, 0x40u);
            }
            psSha256Final((int)v195, (int)v196);
          }
          else if ( v50 )
          {
            if ( v48 == 20 )
            {
              psSha1Init(v195);
              while ( v47 > 0 )
              {
                --v47;
                psSha1Update((int *)v195, (int)v196, 0x40u);
              }
              psSha1Final(v195, (int)v196);
            }
            else
            {
LABEL_51:
              psTraceStr("psAssert %s", (int)"sslDecode.c");
              psTraceInt(":%d ", 956);
              psError((int)&word_4A0308);
            }
          }
          else
          {
            if ( v48 != 48 )
              goto LABEL_51;
            psSha384Init(v195);
            while ( v47 > 0 )
            {
              --v47;
              psSha384Update((int *)v195, (int)v196, 0x80u);
            }
            psSha384Final((int)v195, v196);
          }
        }
      }
      v51 = v38 - (_DWORD)v200;
      if ( (*((int (  **)(unsigned __int16 *, _DWORD, unsigned __int8 *, int, int))a1 + 840))(
             a1,
             *((unsigned __int8 *)a1 + 12),
             v200,
             v38 - (_DWORD)v200,
             v38) >= 0
        && !v35 )
      {
        memset(v38, 0, *((unsigned __int8 *)a1 + 3368));
        v52 = *((_DWORD *)a1 + 832);
        v53 = v52 < v51;
        if ( v52 == 255 )
          goto LABEL_55;
        goto LABEL_62;
      }
LABEL_224:
      v12 = (char *)*a2;
LABEL_109:
      *((_DWORD *)a1 + 844) = 20;
      goto LABEL_149;
    }
    v55 = *((_DWORD *)a1 + 832);
    v38 = v31 + v11;
    v51 = v31;
    if ( v55 == 255 )
    {
LABEL_55:
      if ( v51 >= 16385 )
      {
        v12 = (char *)*a2;
LABEL_57:
        *((_DWORD *)a1 + 844) = 22;
        goto LABEL_149;
      }
      goto LABEL_63;
    }
    v53 = v55 < v31;
LABEL_62:
    if ( v53 )
    {
      v12 = (char *)*a2;
      goto LABEL_57;
    }
LABEL_63:
    v56 = *((unsigned __int8 *)a1 + 12);
    if ( v56 == 21 )
    {
      if ( v51 < 2 )
      {
        v12 = (char *)*a2;
        *((_DWORD *)a1 + 844) = 50;
        goto LABEL_149;
      }
      v88 = v200;
      *a8 = *v200;
      *a9 = v88[1];
      *a3 = (char *)2;
      if ( *a8 == 2 )
        *((_DWORD *)a1 + 843) |= 0x40u;
      if ( !*a9 )
        *((_DWORD *)a1 + 843) |= 0x10u;
      v19 = -54;
      v84 = -4;
      *a2 = (int)v14;
      goto LABEL_199;
    }
    if ( *((unsigned __int8 *)a1 + 12) >= 0x16u )
      break;
    if ( v56 != 20 )
      goto LABEL_200;
    if ( v51 <= 0 || *v200 != 1 )
    {
LABEL_186:
      v12 = (char *)*a2;
      goto LABEL_174;
    }
    if ( ((*((_DWORD *)a1 + 843) >> 14) & 1) == 0 )
      goto LABEL_188;
    if ( *((_BYTE *)a1 + 3384) == 20 )
    {
      *((_DWORD *)a1 + 890) = 1;
LABEL_188:
      incrTwoByte((int)a1, (_BYTE *)a1 + 3533, 0);
      *a5 = *a3 - &v14[-v11];
      *a2 = (int)v14;
      v81 = *((unsigned __int8 *)a1 + 3384);
      v12 = v14;
      if ( v81 == 20 )
      {
        Cipher = sslActivateReadCipher((int)a1);
        v19 = 0;
        if ( Cipher >= 0 )
          goto LABEL_198;
      }
      else
      {
        if ( v81 == 11 )
        {
          v86 = *((_DWORD *)a1 + 815);
          if ( v86 )
          {
            if ( *(_WORD *)(v86 + 92) == 4 )
            {
              *((_DWORD *)a1 + 843) |= 8u;
              if ( sslCreateKeys((int)a1) >= 0 )
              {
                *((_BYTE *)a1 + 3384) = 20;
                if ( sslActivateReadCipher((int)a1) < 0 )
                {
                  v12 = (char *)*a2;
LABEL_215:
                  *((_DWORD *)a1 + 844) = 80;
                  goto LABEL_149;
                }
LABEL_197:
                *(_WORD *)(*((_DWORD *)a1 + 815) + 92) = 0;
                v19 = 0;
LABEL_198:
                v84 = -3;
LABEL_199:
                *((_BYTE *)a1 + 3385) = v84;
                return v19;
              }
LABEL_395:
              v12 = (char *)*a2;
              goto LABEL_215;
            }
          }
        }
        v82 = *((_DWORD *)a1 + 843);
        if ( ((v82 >> 18) & 1) == 0 )
          goto LABEL_192;
        if ( *((_BYTE *)a1 + 3384) != 12 )
          goto LABEL_192;
        v83 = *((_DWORD *)a1 + 815);
        if ( !v83 || *(_WORD *)(v83 + 92) != 4 )
          goto LABEL_192;
        *((_DWORD *)a1 + 843) = v82 | 8;
        if ( sslCreateKeys((int)a1) < 0 )
        {
          v12 = (char *)*a2;
          goto LABEL_215;
        }
        *((_BYTE *)a1 + 3384) = 20;
        if ( sslActivateReadCipher((int)a1) >= 0 )
          goto LABEL_197;
      }
LABEL_389:
      v12 = (char *)*a2;
      goto LABEL_215;
    }
    v12 = v14;
    *a2 = (int)v14;
  }
  if ( v56 != 22 )
  {
    if ( v56 != 23 )
    {
LABEL_200:
      v19 = -12;
      *a7 = -12;
      return v19;
    }
    v87 = *((unsigned __int8 *)a1 + 3384);
    if ( v87 != 255 && v87 != 2 || ((*((_DWORD *)a1 + 843) >> 1) & 1) == 0 )
    {
      v12 = (char *)*a2;
      goto LABEL_192;
    }
    v89 = v200;
    v12 = v14;
    *a5 = *a3 - &v14[-v11];
    *a2 = (int)v14;
    *a3 = (char *)(v38 - v11);
    if ( v89 == (unsigned __int8 *)v38 )
    {
      v90 = *((_DWORD *)a1 + 845);
      *((_DWORD *)a1 + 845) = v90 + 1;
      if ( v90 >= 1024 )
        goto LABEL_192;
    }
    else
    {
      v165 = *((_DWORD *)a1 + 845);
      if ( v165 > 0 )
        *((_DWORD *)a1 + 845) = v165 - 1;
    }
    v19 = -53;
    v84 = -1;
    goto LABEL_199;
  }
  v91 = *((_DWORD *)a1 + 843);
  v92 = v200;
  v199 = v200;
  v93 = 0;
  v94 = &v200[v51];
  v201 = 0;
  if ( ((v91 >> 14) & 1) != 0 )
  {
    v96 = v51;
    goto LABEL_276;
  }
  v95 = *((_DWORD *)a1 + 833);
  v96 = v51;
  if ( !v95 )
    goto LABEL_276;
  v97 = *((_DWORD *)a1 + 834);
  v98 = *((_DWORD *)a1 + 835) - v97;
  if ( v51 < v98 )
    v98 = v51;
  memcpy(v95 + v97, v200, v98);
  v99 = *((_DWORD *)a1 + 835);
  v100 = *((_DWORD *)a1 + 834) + v98;
  v101 = &v199[v98];
  *((_DWORD *)a1 + 834) = v100;
  if ( v100 != v99 )
  {
    v102 = *((_DWORD *)a1 + 833);
    v103 = 0;
    v199 = v101;
    goto LABEL_241;
  }
  v104 = *((_DWORD *)a1 + 833);
  v105 = *((_DWORD *)a1 + 1166);
  v94 = (unsigned __int8 *)(v104 + v100);
  v106 = (unsigned __int8 *)(v104 + v105);
  v107 = v100 - v105;
  v199 = (unsigned __int8 *)(v104 + v105);
LABEL_251:
  v108 = v105 + v107;
  v109 = (int)&v106[-v105];
LABEL_252:
  v110 = (int)a1;
  while ( 2 )
  {
    sslUpdateHSHash(v110, v109, v108);
LABEL_254:
    switch ( *((_BYTE *)a1 + 3384) )
    {
      case 0:
        v92 = v199;
        if ( v94 != v199 )
          goto LABEL_351;
        v93 = -53;
        *((_BYTE *)a1 + 3385) = 0;
        goto LABEL_406;
      case 1:
        if ( v93 )
        {
          psTraceStr("psAssert %s", (int)"sslDecode.c");
          psTraceInt(":%d ", 2455);
          psError((int)"rc == 0");
        }
        if ( &v199[v107] != v94 )
          goto LABEL_385;
        v189 = parseClientHello((unsigned int)a1, &v199, v94);
        goto LABEL_446;
      case 2:
        if ( v93 )
        {
          psTraceStr("psAssert %s", (int)"sslDecode.c");
          psTraceInt(":%d ", 2529);
          psError((int)"rc == 0");
        }
        v167 = (int (  *)(int, signed int, unsigned __int8 **, int))parseServerHello;
        v169 = (_BYTE *)v107;
        goto LABEL_439;
      case 3:
        v186 = v199;
        if ( v94 - v199 < 3 )
          goto LABEL_385;
        v199 += 2;
        v187 = v186[2];
        v92 = v186 + 3;
        *((_DWORD *)a1 + 857) = v187;
        v199 = v186 + 3;
        if ( v187 <= 0 )
          goto LABEL_433;
        if ( v94 - v92 < v187 )
          goto LABEL_385;
        if ( *((_DWORD *)a1 + 858) )
        {
          if ( memcmpct(*((_DWORD *)a1 + 856), (int)v92, v187) )
            goto LABEL_351;
        }
        else
        {
          v188 = malloc(v187);
          *((_DWORD *)a1 + 856) = v188;
          if ( !v188 )
            goto LABEL_326;
          memcpy(v188, v199, *((_DWORD *)a1 + 857));
        }
        v92 = &v199[*((_DWORD *)a1 + 857)];
        v199 = v92;
LABEL_433:
        v93 = -53;
        ++*((_DWORD *)a1 + 858);
        *((_BYTE *)a1 + 3384) = 2;
        *((_BYTE *)a1 + 3385) = 3;
        goto LABEL_406;
      case 4:
        if ( v107 < 6 )
          goto LABEL_351;
        v171 = v199;
        v172 = *((_DWORD *)a1 + 815);
        v174 = *v199++ << 24;
        v173 = v199;
        *(_DWORD *)(v172 + 96) = v174;
        v175 = *v173 << 16;
        v199 = v171 + 2;
        *(_DWORD *)(v172 + 96) = v174 | v175;
        v176 = v174 | v175 | (v171[2] << 8);
        v199 = v171 + 3;
        *(_DWORD *)(v172 + 96) = v176;
        v177 = v176 | v171[3];
        v199 = v171 + 4;
        *(_DWORD *)(v172 + 96) = v177;
        v178 = v171[4];
        v199 = v171 + 5;
        v179 = (v178 << 8) | v171[5];
        v199 = v171 + 6;
        if ( v94 - (v171 + 6) < v179 )
          goto LABEL_385;
        if ( !*(_WORD *)(v172 + 94) )
        {
          v183 = v179;
          *(_WORD *)(v172 + 94) = v179;
          goto LABEL_421;
        }
        if ( !*(_DWORD *)(v172 + 88) )
        {
          psTraceStr("psAssert %s", (int)"sslDecode.c");
          psTraceInt(":%d ", 2626);
          psError((int)"ssl->sid->sessionTicket");
          v172 = *((_DWORD *)a1 + 815);
        }
        if ( *(unsigned __int16 *)(v172 + 94) != v179
          || (v180 = v199, v181 = memcmp(v199, *(_DWORD *)(v172 + 88), v179), v92 = &v180[v179], v181) )
        {
          v182 = *(_DWORD *)(v172 + 88);
          *(_WORD *)(v172 + 94) = v179;
          free2(v182);
          v172 = *((_DWORD *)a1 + 815);
          v183 = *(unsigned __int16 *)(v172 + 94);
LABEL_421:
          v184 = malloc(v183);
          *(_DWORD *)(v172 + 88) = v184;
          if ( v184 )
          {
            memcpy(*(_DWORD *)(*((_DWORD *)a1 + 815) + 88), v199, *(unsigned __int16 *)(*((_DWORD *)a1 + 815) + 94));
            v172 = *((_DWORD *)a1 + 815);
            v185 = *(unsigned __int16 *)(v172 + 94);
          }
          else
          {
            v172 = *((_DWORD *)a1 + 815);
            v185 = *(unsigned __int16 *)(v172 + 94);
            *(_WORD *)(v172 + 94) = 0;
          }
          v92 = &v199[v185];
        }
        v199 = v92;
        *(_WORD *)(v172 + 92) = 0;
        *((_BYTE *)a1 + 3384) = 20;
        *((_BYTE *)a1 + 3385) = 4;
LABEL_406:
        v91 = *((_DWORD *)a1 + 843);
        if ( ((v91 >> 14) & 1) != 0 )
          *((_DWORD *)a1 + 893) = v201;
        v96 = v94 - v92;
        if ( v92 >= v94 )
        {
LABEL_409:
          v102 = *((_DWORD *)a1 + 833);
          v103 = v93;
          goto LABEL_241;
        }
LABEL_276:
        v116 = v92 + 1;
        if ( v96 <= 0 )
          goto LABEL_385;
        v117 = *v92;
        v199 = v92 + 1;
        if ( (v91 & 1) != 0 )
        {
          v118 = v91 >> 14;
          if ( v117 != 1 )
            goto LABEL_279;
        }
        else
        {
          v118 = v91 >> 14;
          if ( v117 )
            goto LABEL_279;
        }
        v118 = v91 >> 14;
        if ( *((unsigned __int8 *)a1 + 3384) == 255 )
        {
          v102 = *((_DWORD *)a1 + 833);
          v103 = -12;
          v154 = 100;
          goto LABEL_334;
        }
LABEL_279:
        if ( (v118 & 1) != 0 )
        {
          if ( v94 - v116 < 5 )
            goto LABEL_385;
          v119 = *((_DWORD *)a1 + 893);
          v201 = (v116[3] << 8) + v116[4];
          if ( v119 + 1 < v201 )
            goto LABEL_321;
          if ( v201 && v119 >= v201 )
            goto LABEL_301;
        }
        v120 = *((unsigned __int8 *)a1 + 3384);
        if ( v120 == v117 || v117 == 1 && v120 == 255 )
          goto LABEL_305;
        if ( v117 == 13 && v120 == 14 )
        {
          *((_DWORD *)a1 + 843) = v91 | 0x80;
          goto LABEL_304;
        }
        if ( v117 )
          goto LABEL_291;
        if ( *((unsigned __int8 *)a1 + 3384) == 255 )
        {
          v121 = *((unsigned __int8 *)a1 + 3384);
          if ( (v91 & 1) == 0 )
          {
            sslResetContext((int)a1);
            *((_BYTE *)a1 + 3384) = 0;
LABEL_305:
            if ( v117 == 1 )
            {
              sslInitHSHash(a1);
              v125 = *((_BYTE *)a1 + 3384);
              v126 = v125;
              if ( v125 != 255 )
                goto LABEL_308;
              sslResetContext((int)a1);
              v125 = 1;
              *((_BYTE *)a1 + 3384) = 1;
            }
            else
            {
              v125 = *((_BYTE *)a1 + 3384);
            }
            v126 = v125;
LABEL_308:
            v127 = v125;
            if ( v126 == 20 )
            {
              if ( sslSnapshotHSHash((int *)a1, (int)v197, !(*((_DWORD *)a1 + 843) & 1)) <= 0 )
                goto LABEL_345;
              v127 = *((unsigned __int8 *)a1 + 3384);
            }
            if ( v127 == 15 && sslSnapshotHSHash((int *)a1, (int)v197, -1) <= 0 )
            {
LABEL_345:
              v102 = *((_DWORD *)a1 + 833);
              goto LABEL_346;
            }
            v128 = *((unsigned __int8 *)a1 + 2);
            if ( v128 < 3 )
            {
              if ( v128 != 2 )
              {
LABEL_351:
                v102 = *((_DWORD *)a1 + 833);
                v103 = -12;
                goto LABEL_338;
              }
              v109 = (int)v200;
              v110 = (int)a1;
              v108 = v51;
              v107 = v51 - 1;
              continue;
            }
            v129 = v199;
            v130 = v199 + 2;
            if ( v94 - v199 < 3 )
              goto LABEL_385;
            v131 = *v199++;
            v132 = v129[1];
            v133 = *((_DWORD *)a1 + 843);
            v199 = v130;
            v106 = v129 + 3;
            v107 = (v131 << 16) + (v132 << 8) + v129[2];
            v199 = v129 + 3;
            if ( ((v133 >> 14) & 1) != 0 )
            {
              if ( v94 - v106 < 8 )
                goto LABEL_385;
              v134 = v129[3];
              v199 = v129 + 4;
              v135 = v129[4];
              v199 = v129 + 5;
              v136 = v129[5];
              v199 = v129 + 6;
              v137 = v129[6];
              v199 = v129 + 7;
              v138 = v129[7];
              v199 = v129 + 8;
              v139 = v129[8];
              v199 = v129 + 9;
              v140 = v129[9];
              v199 = v129 + 10;
              v141 = (v139 << 16) + (v140 << 8) + v129[10];
              v106 = v129 + 11;
              v201 = (v134 << 8) + v135;
              v202 = (v136 << 16) + (v137 << 8) + v138;
              v199 = v129 + 11;
              if ( v141 != v107 )
              {
                if ( *((_DWORD *)a1 + 835) )
                {
                  v144 = *((_DWORD *)a1 + 897);
                }
                else
                {
                  v142 = *((_DWORD *)a1 + 833);
                  if ( v142 )
                  {
                    free2(v142);
                    *((_DWORD *)a1 + 833) = 0;
                  }
                  v143 = malloc(v107);
                  *((_DWORD *)a1 + 833) = v143;
                  if ( !v143 )
                  {
                    v103 = -8;
                    v102 = 0;
                    goto LABEL_241;
                  }
                  v144 = v201;
                  *((_DWORD *)a1 + 897) = v201;
                }
                if ( v144 != v201 )
                  goto LABEL_321;
                v145 = dtlsSeenFrag((int)a1, v202, &v198);
                v93 = v145;
                if ( v145 == 1 )
                  goto LABEL_321;
                if ( v145 == -1 )
                {
                  dtlsInitFrag((int)a1);
                  v102 = *((_DWORD *)a1 + 833);
                  if ( v102 )
                  {
                    free2(*((_DWORD *)a1 + 833));
                    *((_DWORD *)a1 + 833) = 0;
                    v102 = 0;
                  }
                  v103 = -9;
LABEL_338:
                  v154 = 47;
LABEL_334:
                  *((_DWORD *)a1 + 844) = v154;
                  goto LABEL_241;
                }
                v147 = &a1[6 * v198];
                v146 = malloc(*((_DWORD *)a1 + 1166));
                v148 = v198;
                *((_DWORD *)v147 + 900) = v146;
                v149 = *(_DWORD *)&a1[6 * v148 + 1800];
                if ( !v149 )
                {
                  dtlsInitFrag((int)a1);
LABEL_326:
                  v102 = *((_DWORD *)a1 + 833);
                  v103 = -8;
                  goto LABEL_241;
                }
                memcpy(v149, &v199[-*((_DWORD *)a1 + 1166)], *((_DWORD *)a1 + 1166));
                v150 = v202;
                v151 = &a1[6 * v198];
                *((_DWORD *)v151 + 899) = v141;
                *((_DWORD *)v151 + 898) = v150;
                v152 = v199;
                v153 = *((_DWORD *)a1 + 833) + v202;
                *((_DWORD *)a1 + 835) += v141;
                memcpy(v153, v152, v141);
                if ( *((_DWORD *)a1 + 835) != v107 )
                  goto LABEL_321;
                v106 = (unsigned __int8 *)*((_DWORD *)a1 + 833);
                v199 = v106;
                v94 = &v106[v107];
              }
            }
            if ( v94 - v106 < v107 )
            {
              v102 = *((_DWORD *)a1 + 833);
              if ( v102 )
              {
                v103 = -12;
LABEL_333:
                v154 = 50;
                goto LABEL_334;
              }
              v155 = *((_DWORD *)a1 + 1166) + v107;
              *((_DWORD *)a1 + 835) = v155;
              v156 = malloc(v155);
              *((_DWORD *)a1 + 833) = v156;
              if ( v156 )
              {
                v157 = *((_DWORD *)a1 + 1166);
                v158 = v94 - v199 + v157;
                v159 = &v199[-v157];
                *((_DWORD *)a1 + 834) = v158;
                memcpy(v156, v159, v158);
                goto LABEL_321;
              }
LABEL_346:
              v103 = -12;
              v154 = 80;
              goto LABEL_334;
            }
            if ( ((*((_DWORD *)a1 + 843) >> 14) & 1) == 0 )
            {
              v105 = *((_DWORD *)a1 + 1166);
              goto LABEL_251;
            }
            if ( !*((_DWORD *)a1 + 835) )
            {
              v160 = *((_DWORD *)a1 + 1166);
              v108 = v160 + v107;
              v109 = (int)&v106[-v160];
              goto LABEL_252;
            }
            dtlsHsHashFragMsg((int)a1);
            dtlsInitFrag((int)a1);
            goto LABEL_254;
          }
        }
        else
        {
          v121 = *((unsigned __int8 *)a1 + 3384);
        }
        if ( v121 == 2 && ((v91 >> 1) & 1) != 0 && ((v91 >> 2) & 1) != 0 && (v91 & 1) == 0 )
        {
          if ( v94 - v116 < 3 )
          {
LABEL_385:
            v102 = *((_DWORD *)a1 + 833);
            v103 = -12;
            goto LABEL_333;
          }
          v162 = *v116;
          v199 = v116 + 1;
          v163 = v116[1];
          v199 = v116 + 2;
          v164 = (v162 << 16) + (v163 << 8) + v116[2];
          if ( ((v91 >> 14) & 1) != 0 )
          {
            if ( v94 - (v116 + 3) < 8 )
            {
              v102 = *((_DWORD *)a1 + 833);
              v103 = -12;
              v199 = v116 + 3;
              goto LABEL_333;
            }
            v199 = v116 + 11;
          }
          else
          {
            v199 = v116 + 3;
          }
          if ( v164 )
          {
            v102 = *((_DWORD *)a1 + 833);
            v103 = -12;
            goto LABEL_241;
          }
LABEL_321:
          v102 = *((_DWORD *)a1 + 833);
          v103 = 0;
          goto LABEL_241;
        }
LABEL_291:
        if ( v117 != 4 )
        {
          v122 = *((unsigned __int8 *)a1 + 3384);
          goto LABEL_293;
        }
        v122 = *((unsigned __int8 *)a1 + 3384);
        if ( v122 == 20 )
        {
          v161 = *((_DWORD *)a1 + 815);
          if ( v161 )
          {
            v122 = *((unsigned __int8 *)a1 + 3384);
            if ( *(_WORD *)(v161 + 92) == 3 && (v91 & 1) == 0 )
            {
              *((_BYTE *)a1 + 3384) = 4;
              goto LABEL_305;
            }
          }
        }
LABEL_293:
        if ( v122 == 22 )
          goto LABEL_384;
        v123 = v91 >> 14;
        if ( ((v91 >> 18) & 1) != 0 )
        {
          if ( v117 == 14 )
          {
            v123 = v91 >> 14;
            if ( v122 == 12 )
            {
              if ( ((v91 >> 17) & 1) != 0 )
                goto LABEL_384;
              goto LABEL_304;
            }
          }
          else
          {
            v123 = v91 >> 14;
          }
        }
        if ( (v123 & 1) == 0 )
          goto LABEL_384;
        if ( v117 == 3 && *((_BYTE *)a1 + 3384) == 2 && !*((_DWORD *)a1 + 858) )
        {
LABEL_304:
          *((_BYTE *)a1 + 3384) = v117;
          goto LABEL_305;
        }
        v124 = *((_DWORD *)a1 + 893);
        if ( v124 + 1 == v201 || v124 < v201 )
        {
LABEL_384:
          v102 = *((_DWORD *)a1 + 833);
          v103 = -12;
          v154 = 10;
          goto LABEL_334;
        }
LABEL_301:
        v102 = *((_DWORD *)a1 + 833);
        v103 = -61;
LABEL_241:
        if ( v102 && *((_DWORD *)a1 + 834) == *((_DWORD *)a1 + 835) )
        {
          free2(v102);
          *((_DWORD *)a1 + 833) = 0;
          *((_DWORD *)a1 + 835) = 0;
          *((_DWORD *)a1 + 834) = 0;
        }
        if ( v103 == -12 )
        {
LABEL_273:
          if ( *((_DWORD *)a1 + 844) != 255 )
          {
            v12 = (char *)*a2;
            goto LABEL_149;
          }
          goto LABEL_389;
        }
        if ( v103 >= -11 )
        {
          if ( v103 != -8 )
          {
            v19 = 0;
            if ( !v103 )
            {
              *a5 = *a3 - &v14[-v11];
              *a2 = (int)v14;
              return v19;
            }
LABEL_248:
            if ( *((_DWORD *)a1 + 844) != 255 )
            {
              v12 = (char *)*a2;
              goto LABEL_149;
            }
            goto LABEL_395;
          }
          goto LABEL_273;
        }
        if ( v103 == -61 )
        {
          v190 = *a3;
          *a2 = (int)v14;
          *a5 = v190 - &v14[-v11];
          v19 = -61;
          if ( v190 != &v14[-v11] )
            return 0;
          return v19;
        }
        if ( v103 != -53 )
          goto LABEL_248;
        if ( *v14 != 23 )
        {
          v111 = (unsigned __int8)*v14;
          goto LABEL_257;
        }
        v111 = (unsigned __int8)*v14;
        if ( *((unsigned __int8 *)a1 + 3384) != 255 || (*((_DWORD *)a1 + 843) & 1) == 0 )
        {
LABEL_257:
          if ( v111 == 23 )
          {
            if ( *((_BYTE *)a1 + 3384) )
            {
              v112 = &(*a3)[v11];
            }
            else
            {
              v112 = &(*a3)[v11];
              if ( v14 < v112 )
              {
                v113 = *((_DWORD *)a1 + 822);
                v114 = *((_DWORD *)a1 + 823);
                v115 = *((_DWORD *)a1 + 824);
                *a2 = (int)v14;
                v19 = 0;
                *((_BYTE *)a1 + 3384) = -1;
                *((_DWORD *)a1 + 784) = v113;
                *((_DWORD *)a1 + 843) = v114;
                *((_DWORD *)a1 + 831) = v115;
                return v19;
              }
            }
          }
          else
          {
            v112 = &(*a3)[v11];
          }
          if ( v112 != v14 )
          {
            psTraceStr("psAssert %s", (int)"sslDecode.c");
            psTraceInt(":%d ", 1487);
            psError((int)"origbuf + *len == c");
          }
          v12 = (char *)v11;
          *a2 = v11;
          goto LABEL_149;
        }
        if ( &(*a3)[v11] != v14 )
        {
          psTraceStr("psAssert %s", (int)"sslDecode.c");
          psTraceInt(":%d ", 1460);
          psError((int)"origbuf + *len == c");
        }
        v12 = (char *)v11;
        *a2 = v11;
LABEL_149:
        if ( v12 != (char *)v11 )
        {
          psTraceStr("psAssert %s", (int)"sslDecode.c");
          psTraceInt(":%d ", 1626);
          psError((int)"origbuf == *buf");
        }
        v192[1] = v11;
        v193 = v11;
        v192[0] = v11;
        v194 = a4;
        memset(v11, 0, a4);
        if ( *((_BYTE *)a1 + 3384) )
        {
          v72 = sslEncodeResponse((int)a1, v192, a6);
        }
        else
        {
          memset(v191, 0, 68);
          v72 = matrixSslEncodeClientHello((int)a1, v192, 0, 0, a6, 0, (int)v191);
        }
        v73 = v72;
        *a9 = -1;
        if ( v72 )
        {
          v19 = -50;
          if ( v72 != -50 )
          {
            if ( v72 >= 0 )
            {
              psTraceStr("psAssert %s", (int)"sslDecode.c");
              psTraceInt(":%d ", 1721);
              psError((int)"rc < 0");
            }
            *a7 = v73;
            return -12;
          }
          *((_DWORD *)a1 + 843) |= 0x20u;
          *a3 = 0;
          return v19;
        }
        v74 = *((_DWORD *)a1 + 844);
        if ( v74 == 255 )
        {
          v77 = (char *)(v193 - v192[0]);
LABEL_157:
          *a5 = 0;
          v17 = -52;
          *a3 = v77;
        }
        else
        {
          v75 = v192[0];
          v76 = v193;
          v49 = v192[0] == v193;
          *((_DWORD *)a1 + 843) |= 0x40u;
          if ( !v49 )
          {
            *a9 = v74;
            *a8 = 2;
            v77 = (char *)(v76 - v75);
            goto LABEL_157;
          }
          v17 = -12;
          *a7 = -12;
        }
        return v17;
      case 0xB:
        if ( v93 )
        {
          psTraceStr("psAssert %s", (int)"sslDecode.c");
          psTraceInt(":%d ", 2545);
          psError((int)"rc == 0");
        }
        v170 = parseCertificate((int)a1, &v199, (int)v94);
        goto LABEL_404;
      case 0xC:
        if ( v93 )
        {
          psTraceStr("psAssert %s", (int)"sslDecode.c");
          psTraceInt(":%d ", 2708);
          psError((int)"rc == 0");
        }
        v167 = (int (  *)(int, signed int, unsigned __int8 **, int))parseServerKeyExchange;
        v168 = (int)a1;
        goto LABEL_402;
      case 0xD:
        if ( v93 )
        {
          psTraceStr("psAssert %s", (int)"sslDecode.c");
          psTraceInt(":%d ", 2677);
          psError((int)"rc == 0");
        }
        v167 = parseCertificateRequest;
        v169 = (_BYTE *)v107;
        goto LABEL_439;
      case 0xE:
        if ( v93 )
        {
          psTraceStr("psAssert %s", (int)"sslDecode.c");
          psTraceInt(":%d ", 2663);
          psError((int)"rc == 0");
        }
        v189 = parseServerHelloDone((int)a1, v107, (int *)&v199);
        goto LABEL_446;
      case 0xF:
        if ( v93 )
        {
          psTraceStr("psAssert %s", (int)"sslDecode.c");
          psTraceInt(":%d ", 2693);
          psError((int)"rc == 0");
        }
        v167 = parseCertificateVerify;
        v168 = (int)a1;
LABEL_402:
        v169 = v197;
        goto LABEL_403;
      case 0x10:
        if ( v93 )
        {
          psTraceStr("psAssert %s", (int)"sslDecode.c");
          psTraceInt(":%d ", 2473);
          psError((int)"rc == 0");
        }
        v167 = parseClientKeyExchange;
        v169 = (_BYTE *)v107;
        goto LABEL_439;
      case 0x14:
        if ( v93 )
        {
          psTraceStr("psAssert %s", (int)"sslDecode.c");
          psTraceInt(":%d ", 2485);
          psError((int)"rc == 0");
        }
        v189 = parseFinished((int)a1, v107, (int)v197, (int *)&v199, (int)v94);
LABEL_446:
        v93 = v189;
        if ( v189 >= 0 || v189 == -53 )
          goto LABEL_405;
        goto LABEL_409;
      case 0x16:
        v167 = (int (  *)(int, signed int, unsigned __int8 **, int))parseCertificateStatus;
        v169 = (_BYTE *)v107;
LABEL_439:
        v168 = (int)a1;
LABEL_403:
        v170 = v167(v168, (signed int)v169, &v199, (int)v94);
LABEL_404:
        v93 = v170;
        if ( v170 < 0 )
          goto LABEL_409;
LABEL_405:
        v92 = v199;
        goto LABEL_406;
      default:
        goto LABEL_384;
    }
  }
}
// 4578A4: conditional instruction was optimized away because $s0.4 is in (1..3)
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (004596DC) --------------------------------------------------------
int   matrixSslGetEncodedSize(int a1, int a2)
{
  unsigned int v2; // $a2
  int v3; // $t0
  int v4; // $a1
  unsigned __int8 v5; // $a3
  unsigned int v6; // $t6
  int v7; // $t2
  char v8; // $v0

  v2 = *(_DWORD *)(a1 + 3372);
  v3 = *(_DWORD *)(a1 + 4660);
  v4 = a2 + v3;
  if ( ((v2 >> 2) & 1) == 0 )
    return v4;
  v4 += *(unsigned __int8 *)(a1 + 3364);
  if ( ((v2 >> 12) & 1) != 0 )
  {
    v5 = *(_BYTE *)(a1 + 3367);
    v6 = v2 >> 20;
    if ( v5 >= 2u )
      v4 += v5;
  }
  else
  {
    v5 = *(_BYTE *)(a1 + 3367);
    v6 = v2 >> 20;
  }
  if ( (v6 & 1) != 0 )
  {
    v7 = 8;
    if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
      v7 = 16;
    v4 += v7;
    if ( ((v2 >> 22) & 1) != 0 )
      v4 += 8;
  }
  if ( ((*(_DWORD *)(a1 + 3324) >> 2) & 1) == 0 )
  {
    if ( v5 >= 2u )
    {
      v8 = v4 - v3;
      return v4 + (unsigned __int8)(v5 - (v8 & (v5 - 1)));
    }
    return v4;
  }
  if ( v5 >= 2u )
    v4 += (unsigned __int8)(v5 - ((v4 - v3 - 1) & (v5 - 1)));
  v4 += v3 + *(unsigned __int8 *)(a1 + 3364);
  v8 = *(_BYTE *)(a1 + 3364) + 1;
  if ( v5 < 2u )
    return v4;
  return v4 + (unsigned __int8)(v5 - (v8 & (v5 - 1)));
}

//----- (00459804) --------------------------------------------------------
int   sub_459804(int a1, int a2, int a3, int a4, _DWORD *a5, int a6)
{
  unsigned __int16 v6; // $t0
  int v10; // $s1
  int v11; // $s7
  unsigned int v12; // $v1
  int v13; // $a2
  _DWORD *i; // $s0
  int v15; // $s2
  unsigned int v16; // $a0
  int v17; // $a1
  int v18; // $a0
  int v19; // $a1
  int v20; // $a0
  int v21; // $v1
  int v22; // $v0
  int v23; // $a0
  int v24; // $a0
  unsigned int v25; // $a1
  int v26; // $a0
  _BYTE *v27; // $v1
  int v28; // $t8
  unsigned int v29; // $a2
  int v30; // $s3
  _BYTE *v31; // $s1
  unsigned int v32; // $t1
  int v33; // $v1
  int v34; // $v0
  _DWORD *v35; // $a1
  int v36; // $s0
  int v38; // $v1
  int v39; // $a2
  int v40; // $v0
  int v41; // $a1
  int v42; // $v1
  int v43; // $v0
  unsigned int v44; // $v1

  v6 = *(_WORD *)(a2 + 16);
  if ( v6 >= a3 )
  {
    v10 = v6 - a3;
    v11 = 0;
  }
  else
  {
    v10 = a3 - v6;
    v11 = 1;
  }
  v12 = *(_DWORD *)(a1 + 3372);
  if ( ((v12 >> 14) & 1) != 0 )
    *(_DWORD *)(a1 + 4652) = a3 - *(unsigned __int16 *)(a2 + 16);
  v13 = -12;
  if ( v10 < 13 )
  {
    for ( i = *(_DWORD **)(a1 + 3196); ; i = (_DWORD *)i[8] )
    {
      if ( !i )
        return -12;
      if ( i[6] == a6 )
        break;
    }
    v15 = v10;
    if ( ((v12 >> 2) & 1) != 0 )
    {
      v16 = *(unsigned __int8 *)(a1 + 3367);
      if ( v16 >= 2 )
      {
        v39 = i[4];
        v40 = v39 - *(_DWORD *)(a1 + 4660) - i[5];
        v41 = v40 + v10;
        if ( !v11 )
          v41 = v40 - v10;
        v42 = (unsigned __int8)(v16 - ((v16 - 1) & v41));
        i[5] = v42;
        v43 = v41 + *(_DWORD *)(a1 + 4660) + v42;
        v15 = v39 - v43;
        if ( v39 < v43 )
          v15 = v43 - v39;
      }
    }
    v17 = *(_DWORD *)(a2 + 4);
    if ( a5[2] - (v17 + v6) <= 0 )
    {
      psTraceStr("psAssert %s", (int)"sslEncode.c");
      psTraceInt(":%d ", 417);
      psError((int)"howMuchToMove > 0");
      v17 = *(_DWORD *)(a2 + 4);
      v18 = *(unsigned __int16 *)(a2 + 16);
    }
    else
    {
      v18 = v6;
    }
    v19 = v17 + v18;
    v20 = v19 - v15;
    if ( !v11 || (v20 = v19 + v15, v13 = -12, a5[1] + a5[3] - a5[2] >= v15) )
    {
      memmove(v20);
      if ( v11 )
      {
        v21 = i[2] + v10;
        v22 = a5[2] + v15;
        v23 = i[4] + v15;
      }
      else
      {
        v21 = i[2] - v10;
        v22 = a5[2] - v15;
        v23 = i[4] - v15;
      }
      a5[2] = v22;
      i[4] = v23;
      v24 = *(_DWORD *)(a2 + 4);
      i[2] = v21;
      memcpy(v24, a4, a3);
      v25 = *(_DWORD *)(a1 + 3372);
      v26 = i[4] - *(_DWORD *)(a1 + 4660);
      v27 = (_BYTE *)(*i - 2);
      if ( ((v25 >> 2) & 1) != 0 )
      {
        v28 = v26 >> 8;
        if ( ((v25 >> 20) & 1) == 0 || ((v25 >> 22) & 1) == 0 )
          goto LABEL_23;
        v27 = (_BYTE *)(*i - 10);
      }
      v28 = v26 >> 8;
LABEL_23:
      v27[1] = v26;
      *v27 = v28;
      v29 = *(_DWORD *)(a1 + 3372);
      v30 = i[2] - *(_DWORD *)(a1 + 4664);
      v31 = (_BYTE *)(*i + 1);
      if ( ((v29 >> 2) & 1) != 0 && ((v29 >> 12) & 1) != 0 )
      {
        v44 = *(unsigned __int8 *)(a1 + 3367);
        v32 = v29 >> 14;
        if ( v44 >= 2 )
        {
          v31 += v44;
          v30 -= v44;
        }
      }
      else
      {
        v32 = v29 >> 14;
      }
      v33 = v30 >> 16;
      if ( (v32 & 1) != 0 )
      {
        v34 = memcmp(v31, v31 + 8, 3);
        v13 = -12;
        if ( v34 )
          return v13;
        v33 = v30 >> 16;
      }
      *v31 = v33;
      v31[1] = BYTE1(v30);
      v31[2] = v30;
      if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
      {
        v31[10] = v30;
        v31[8] = v33;
        v31[9] = BYTE1(v30);
      }
      v35 = (_DWORD *)i[8];
      v13 = 0;
      if ( v35 )
      {
        if ( v11 )
        {
          do
          {
            v38 = v35[1];
            *v35 += v15;
            if ( v38 )
              v35[1] = v38 + v15;
            if ( v35[6] == 20 )
              *(_DWORD *)(a1 + 3200) += v15;
            v35 = (_DWORD *)v35[8];
          }
          while ( v35 );
        }
        else
        {
          do
          {
            while ( 1 )
            {
              v36 = v35[1];
              *v35 -= v15;
              if ( v36 )
                v35[1] = v36 - v15;
              if ( v35[6] == 20 )
                break;
              v35 = (_DWORD *)v35[8];
              if ( !v35 )
                return 0;
            }
            *(_DWORD *)(a1 + 3200) -= v15;
            v35 = (_DWORD *)v35[8];
          }
          while ( v35 );
        }
        return 0;
      }
    }
  }
  return v13;
}
// 4598C8: conditional instruction was optimized away because $s0.4!=0
// 459AE4: conditional instruction was optimized away because $s7.4==0
// 459B50: conditional instruction was optimized away because $s7.4==1
// 459C48: conditional instruction was optimized away because $a0.4 is in (2..FF)
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);
// 4EA0A8: using guessed type int   memmove(_DWORD);

//----- (00459D0C) --------------------------------------------------------
int   sub_459D0C(int a1, _DWORD *a2)
{
  unsigned int v2; // $v1
  int v5; // $s2
  int v6; // $a1
  _BYTE **v7; // $s1
  int v8; // $a3
  int (  *v9)(int, int, int, unsigned __int16, unsigned __int8 *, unsigned __int16); // $t9
  int v10; // $v0
  int v11; // $a0
  int v12; // $a1
  int v13; // $v0
  __int16 v14; // $a0
  __int16 v15; // $ra
  unsigned __int16 v16; // $a2
  _BYTE *v18; // $v0
  int v19; // $s3
  int v20; // $t1
  unsigned __int16 v21; // $a3
  _BYTE *v22; // $a2
  int v23; // $v0
  int v24; // $a0
  int v25; // $v0
  int v26; // $t1
  __int16 v27; // $t0
  __int16 v28; // $a3
  __int16 v29; // $a2
  int v30; // $a0
  int v31; // $v0
  int v32; // $a0
  int v33; // $v0
  int v34; // $a0
  int v35; // $t8
  int v36; // $t7
  __int16 v37; // $s2
  __int16 v38; // $s1
  _WORD v39[4]; // [sp+28h] [-8h] BYREF

  v2 = *(_DWORD *)(a1 + 3372);
  v5 = 0;
  if ( ((v2 >> 14) & 1) == 0 || (v6 = 0, !*(_DWORD *)(a1 + 3580)) )
  {
    v7 = (_BYTE **)(a1 + 3148);
    v8 = *(unsigned __int16 *)(a1 + 3162);
    if ( (unsigned __int16)(*(_WORD *)(a1 + 3162) - 1) >= 2u )
      goto LABEL_13;
    if ( ((v2 >> 13) & 1) != 0 )
      v9 = privRsaEncryptSignedElement;
    else
      v9 = psRsaEncryptPriv;
    v10 = v9(
            0,
            *(_DWORD *)(a1 + 3144) + 4,
            *(_DWORD *)(a1 + 3148),
            *(_WORD *)(a1 + 3160),
            *(unsigned __int8 **)(a1 + 3152),
            *(_WORD *)(*(_DWORD *)(a1 + 3144) + 112));
    v5 = v10;
    if ( v10 >= 0 )
    {
      if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 && !*(_DWORD *)(a1 + 3580) )
      {
        v30 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 3144) + 112);
        *(_DWORD *)(a1 + 4636) = v30;
        v31 = malloc(v30);
        *(_DWORD *)(a1 + 4640) = v31;
        v6 = -8;
        if ( !v31 )
          return v6;
        memcpy(v31, *(_DWORD *)(a1 + 3152), *(_DWORD *)(a1 + 4636));
      }
      v11 = *(_DWORD *)(a1 + 3148);
      if ( v11 )
      {
        free2(v11);
        *(_DWORD *)(a1 + 3148) = 0;
      }
      if ( !*(_WORD *)(a1 + 3186) )
      {
        *(_WORD *)(a1 + 3162) = 0;
        v29 = *(_WORD *)(a1 + 3162);
        *(_DWORD *)(a1 + 3152) = 0;
        *(_DWORD *)(a1 + 3156) = 0;
        *(_WORD *)(a1 + 3160) = 0;
        *(_WORD *)(a1 + 3164) = 0;
        if ( v29 != 3 )
          return v5;
        goto LABEL_17;
      }
      *(_WORD *)(a1 + 3162) = *(_WORD *)(a1 + 3186);
      v12 = *(_DWORD *)(a1 + 3180);
      v13 = *(_DWORD *)(a1 + 3176);
      v14 = *(_WORD *)(a1 + 3184);
      v15 = *(_WORD *)(a1 + 3188);
      *(_WORD *)(a1 + 3186) = 0;
      v16 = *(_WORD *)(a1 + 3162);
      *(_DWORD *)(a1 + 3152) = v13;
      *(_DWORD *)(a1 + 3156) = v12;
      *(_WORD *)(a1 + 3160) = v14;
      *(_WORD *)(a1 + 3164) = v15;
      *(_DWORD *)(a1 + 3176) = 0;
      *(_DWORD *)(a1 + 3180) = 0;
      *(_WORD *)(a1 + 3184) = 0;
      *(_WORD *)(a1 + 3188) = 0;
      v8 = v16;
LABEL_13:
      if ( v8 != 3 )
        return v5;
LABEL_17:
      v18 = (_BYTE *)malloc(*(unsigned __int16 *)(a1 + 3164) + 1);
      v19 = (int)v18;
      v6 = -8;
      if ( !v18 )
        return v6;
      v20 = *(_DWORD *)(a1 + 3144);
      v21 = *(_WORD *)(a1 + 3160);
      v22 = *v7;
      v39[0] = *(_WORD *)(a1 + 3164) + 1;
      *(_DWORD *)(a1 + 4652) = 0;
      v23 = psEccDsaSign(0, v20 + 4, v22, v21, v18, v39, 1u);
      if ( v23 )
      {
        if ( v23 == -15 )
        {
          free2(v19);
          return -15;
        }
      }
      else
      {
        if ( *(unsigned __int16 *)(a1 + 3164) == v39[0] )
        {
          memcpy(*(_DWORD *)(a1 + 3152), v19, *(unsigned __int16 *)(a1 + 3164));
LABEL_21:
          free2(v19);
          if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 && !*(_DWORD *)(a1 + 3580) )
          {
            v32 = v39[0];
            *(_DWORD *)(a1 + 4636) = v39[0];
            v33 = malloc(v32);
            *(_DWORD *)(a1 + 4640) = v33;
            v6 = -8;
            if ( !v33 )
              return v6;
            memcpy(v33, *(_DWORD *)(a1 + 3152), *(_DWORD *)(a1 + 4636));
          }
          v24 = *(_DWORD *)(a1 + 3148);
          if ( v24 )
          {
            free2(v24);
            *(_DWORD *)(a1 + 3148) = 0;
          }
          if ( *(_WORD *)(a1 + 3186) )
          {
            v25 = *(_DWORD *)(a1 + 3176);
            v26 = *(_DWORD *)(a1 + 3180);
            v27 = *(_WORD *)(a1 + 3184);
            v28 = *(_WORD *)(a1 + 3188);
            *(_WORD *)(a1 + 3162) = *(_WORD *)(a1 + 3186);
            *(_DWORD *)(a1 + 3152) = v25;
            *(_DWORD *)(a1 + 3156) = v26;
            *(_WORD *)(a1 + 3160) = v27;
            *(_WORD *)(a1 + 3164) = v28;
            *(_WORD *)(a1 + 3188) = 0;
            *(_WORD *)(a1 + 3186) = 0;
            *(_DWORD *)(a1 + 3176) = 0;
            *(_DWORD *)(a1 + 3180) = 0;
            *(_WORD *)(a1 + 3184) = 0;
          }
          else
          {
            *(_WORD *)(a1 + 3162) = 0;
            *(_WORD *)(a1 + 3164) = 0;
            *(_WORD *)(a1 + 3160) = 0;
            *(_DWORD *)(a1 + 3156) = 0;
            *(_DWORD *)(a1 + 3152) = 0;
          }
          return v5;
        }
        if ( sub_459804(a1, a1 + 3148, v39[0], v19, a2, 12) >= 0 )
          goto LABEL_21;
        v34 = *(_DWORD *)(a1 + 3148);
        if ( v34 )
        {
          free2(v34);
          *(_DWORD *)(a1 + 3148) = 0;
        }
        if ( *(_WORD *)(a1 + 3186) )
        {
          v35 = *(_DWORD *)(a1 + 3176);
          v36 = *(_DWORD *)(a1 + 3180);
          v37 = *(_WORD *)(a1 + 3184);
          v38 = *(_WORD *)(a1 + 3188);
          *(_WORD *)(a1 + 3162) = *(_WORD *)(a1 + 3186);
          *(_DWORD *)(a1 + 3152) = v35;
          *(_DWORD *)(a1 + 3156) = v36;
          *(_WORD *)(a1 + 3160) = v37;
          *(_WORD *)(a1 + 3164) = v38;
          *(_WORD *)(a1 + 3188) = 0;
          *(_WORD *)(a1 + 3186) = 0;
          *(_DWORD *)(a1 + 3176) = 0;
          *(_DWORD *)(a1 + 3180) = 0;
          *(_WORD *)(a1 + 3184) = 0;
        }
        else
        {
          *(_WORD *)(a1 + 3162) = 0;
          *(_WORD *)(a1 + 3164) = 0;
          *(_WORD *)(a1 + 3160) = 0;
          *(_DWORD *)(a1 + 3156) = 0;
          *(_DWORD *)(a1 + 3152) = 0;
        }
      }
      free2(v19);
      return -12;
    }
    v6 = -12;
    if ( v10 == -15 )
    {
      free2(*(_DWORD *)(a1 + 3148));
      v6 = -15;
      *(_DWORD *)(a1 + 3148) = 0;
      *(_WORD *)(a1 + 3162) = 0;
    }
  }
  return v6;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0045A220) --------------------------------------------------------
int   sub_45A220(int a1)
{
  unsigned int v1; // $v1
  int Keys; // $s2
  int v4; // $s1
  int v5; // $a0
  int v6; // $t0
  int v7; // $a3
  __int16 v8; // $a1
  __int16 v9; // $s1
  int v10; // $v1
  int v11; // $a0
  __int16 v13; // $a0
  int v14; // $a0
  int v15; // $v1
  int v16; // $s3
  __int16 v17; // $ra
  __int16 v18; // $t8
  int v19; // $a0
  int v20; // $v0
  int v21; // $v0
  int v22; // $a2
  int v23; // $a1
  int v24; // $v0
  int v25; // $v0
  int v26; // $v0
  int v27; // $a0
  _BYTE *v28; // $v0
  int v29; // $t5
  int v30; // $a1

  v1 = *(_DWORD *)(a1 + 3372);
  Keys = -1;
  if ( ((v1 >> 14) & 1) == 0 || !*(_DWORD *)(a1 + 3580) )
  {
    v4 = a1 + 3148;
    if ( ((v1 >> 17) & 1) != 0 )
    {
      if ( ((v1 >> 19) & 1) != 0 )
      {
        if ( *(_DWORD *)(a1 + 3152) != *(_DWORD *)(a1 + 128) )
        {
          psTraceStr("psAssert %s", (int)"sslEncode.c");
          psTraceInt(":%d ", 800);
          psError((int)"pka->outbuf == ssl->sec.premaster");
        }
        if ( *(_WORD *)(a1 + 3162) == 6 )
        {
          Keys = psEccGenSharedSecret(
                   *(_DWORD *)(a1 + 3132),
                   *(_DWORD *)(a1 + 3124),
                   *(_DWORD *)(a1 + 3128),
                   *(_DWORD *)(a1 + 128),
                   (_WORD *)(a1 + 132));
          if ( Keys < 0 )
            goto LABEL_37;
        }
        v5 = *(_DWORD *)(a1 + 3148);
        if ( v5 )
        {
          free2(v5);
          *(_DWORD *)(a1 + 3148) = 0;
        }
        if ( *(_WORD *)(a1 + 3186) )
        {
          v6 = *(_DWORD *)(a1 + 3176);
          v7 = *(_DWORD *)(a1 + 3180);
          v8 = *(_WORD *)(a1 + 3184);
          v9 = *(_WORD *)(a1 + 3188);
          *(_WORD *)(a1 + 3162) = *(_WORD *)(a1 + 3186);
          *(_DWORD *)(a1 + 3152) = v6;
          *(_DWORD *)(a1 + 3156) = v7;
          *(_WORD *)(a1 + 3160) = v8;
          *(_WORD *)(a1 + 3164) = v9;
          *(_WORD *)(a1 + 3186) = 0;
          *(_DWORD *)(a1 + 3176) = 0;
          *(_DWORD *)(a1 + 3180) = 0;
          *(_WORD *)(a1 + 3184) = 0;
          *(_WORD *)(a1 + 3188) = 0;
        }
        else
        {
          *(_WORD *)(a1 + 3164) = 0;
          *(_WORD *)(a1 + 3160) = 0;
          *(_DWORD *)(a1 + 3156) = 0;
          *(_DWORD *)(a1 + 3152) = 0;
          *(_WORD *)(a1 + 3162) = 0;
        }
        psEccDeleteKey((int *)(a1 + 3128));
        psEccDeleteKey((int *)(a1 + 3124));
      }
    }
    else
    {
      if ( (unsigned __int16)(*(_WORD *)(*(_DWORD *)(a1 + 3344) + 2) - 8) >= 2u )
      {
        if ( *(_WORD *)(a1 + 3162) != 4 )
        {
          psTraceStr("psAssert %s", (int)"sslEncode.c");
          psTraceInt(":%d ", 1026);
          psError((int)"pka->type == PKA_AFTER_RSA_ENCRYPT");
        }
        v20 = psRsaEncryptPub(
                *(_DWORD *)(a1 + 3168),
                *(_DWORD *)(a1 + 600) + 40,
                *(_DWORD *)(a1 + 128),
                *(_WORD *)(a1 + 132),
                *(_BYTE **)(a1 + 3152),
                *(_WORD *)(a1 + 3164));
        Keys = v20;
        if ( v20 < 0 )
        {
          v10 = -15;
          if ( v20 != -15 )
            return -12;
          return v10;
        }
        if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
        {
          v21 = malloc(*(unsigned __int16 *)(a1 + 3164));
          *(_DWORD *)(a1 + 4640) = v21;
          v10 = -8;
          if ( !v21 )
            return v10;
          v22 = *(unsigned __int16 *)(a1 + 3164);
          v23 = *(_DWORD *)(a1 + 3152);
          *(_DWORD *)(a1 + 4636) = v22;
          memcpy(v21, v23, v22);
        }
      }
      else
      {
        v13 = *(_WORD *)(a1 + 3162);
        if ( *(_WORD *)(a1 + 3162) == 5 )
        {
          v24 = psEccNewKey(*(_DWORD *)(a1 + 3168), (int *)(a1 + 3124), *(_DWORD *)(*(_DWORD *)(a1 + 600) + 92));
          v10 = -8;
          if ( v24 < 0 )
            return v10;
          v25 = matrixSslGenEphemeralEcKey(
                  *(_DWORD *)(a1 + 3144),
                  *(_DWORD *)(a1 + 3124),
                  *(unsigned __int8 **)(*(_DWORD *)(a1 + 600) + 92));
          Keys = v25;
          if ( v25 < 0 )
          {
            v10 = -15;
            if ( v25 != -15 )
            {
              psEccDeleteKey((int *)(a1 + 3124));
              v10 = -12;
              *(_DWORD *)(a1 + 3376) = 80;
            }
            return v10;
          }
          v26 = psEccX963ExportKey(
                  *(_DWORD *)(a1 + 3216),
                  *(_DWORD *)(a1 + 3124),
                  *(_BYTE **)(a1 + 3152),
                  (_WORD *)(a1 + 3164));
          v10 = -12;
          if ( v26 < 0 )
            return v10;
          if ( *(_WORD *)(a1 + 3164) != *(unsigned __int8 *)(*(_DWORD *)(a1 + 3152) - 1) )
          {
            psTraceStr("psAssert %s", (int)"sslEncode.c");
            psTraceInt(":%d ", 970);
            psError((int)"pka->user == (int32) * (pka->outbuf - 1)");
          }
          v13 = 6;
          if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
          {
            v27 = *(unsigned __int16 *)(a1 + 3164) + 1;
            *(_DWORD *)(a1 + 4636) = v27;
            v28 = (_BYTE *)malloc(v27);
            *(_DWORD *)(a1 + 4640) = v28;
            v10 = -8;
            if ( !v28 )
              return v10;
            v29 = *(_DWORD *)(a1 + 4636);
            v30 = *(_DWORD *)(a1 + 3152);
            *v28 = *(_WORD *)(a1 + 3164);
            memcpy(v28 + 1, v30, v29 - 1);
            v13 = 6;
            *(_WORD *)(a1 + 3162) = 6;
          }
          else
          {
            *(_WORD *)(a1 + 3162) = 6;
          }
        }
        if ( v13 == 6 )
        {
          Keys = psEccGenSharedSecret(
                   *(_DWORD *)(a1 + 3168),
                   *(_DWORD *)(a1 + 3124),
                   *(_DWORD *)(a1 + 600) + 40,
                   *(_DWORD *)(a1 + 128),
                   (_WORD *)(a1 + 132));
          if ( Keys < 0 )
          {
LABEL_37:
            if ( Keys == -15 )
            {
              v10 = -15;
              *(_WORD *)(v4 + 14) = 7;
            }
            else
            {
              free2(*(_DWORD *)(a1 + 128));
              v10 = -12;
              *(_DWORD *)(a1 + 128) = 0;
            }
            return v10;
          }
        }
        psEccDeleteKey((int *)(a1 + 3124));
      }
      v14 = *(_DWORD *)(a1 + 3148);
      if ( v14 )
      {
        free2(v14);
        *(_DWORD *)(a1 + 3148) = 0;
      }
      if ( *(_WORD *)(a1 + 3186) )
      {
        v15 = *(_DWORD *)(a1 + 3176);
        v16 = *(_DWORD *)(a1 + 3180);
        v17 = *(_WORD *)(a1 + 3184);
        v18 = *(_WORD *)(a1 + 3188);
        v19 = (*(_DWORD *)(a1 + 4656) >> 17) & 1;
        *(_WORD *)(a1 + 3162) = *(_WORD *)(a1 + 3186);
        *(_DWORD *)(a1 + 3152) = v15;
        *(_DWORD *)(a1 + 3156) = v16;
        *(_WORD *)(a1 + 3160) = v17;
        *(_WORD *)(a1 + 3164) = v18;
        *(_WORD *)(a1 + 3186) = 0;
        *(_DWORD *)(a1 + 3176) = 0;
        *(_DWORD *)(a1 + 3180) = 0;
        *(_WORD *)(a1 + 3184) = 0;
        *(_WORD *)(a1 + 3188) = 0;
        if ( v19 )
          goto LABEL_14;
LABEL_27:
        Keys = sslCreateKeys(a1);
        v10 = Keys;
        if ( Keys >= 0 )
          goto LABEL_14;
        return v10;
      }
      *(_WORD *)(a1 + 3164) = 0;
      *(_WORD *)(a1 + 3160) = 0;
      *(_DWORD *)(a1 + 3156) = 0;
      *(_DWORD *)(a1 + 3152) = 0;
      *(_WORD *)(a1 + 3162) = 0;
    }
    if ( ((*(_DWORD *)(a1 + 4656) >> 17) & 1) != 0 )
    {
LABEL_14:
      v10 = Keys;
      if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) == 0 && ((*(_DWORD *)(a1 + 3324) >> 3) & 1) == 0 )
      {
        v11 = *(_DWORD *)(a1 + 600);
        if ( v11 )
        {
          psX509FreeCert(v11);
          *(_DWORD *)(a1 + 600) = 0;
          return Keys;
        }
      }
      return v10;
    }
    goto LABEL_27;
  }
  psTraceStr("psAssert %s", (int)"sslEncode.c");
  psTraceInt(":%d ", 781);
  psError((int)&word_4A0308);
  return 0;
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0045A920) --------------------------------------------------------
int   clearFlightList(int a1)
{
  int v2; // $a0
  int v3; // $s0
  int result; // $v0

  v2 = *(_DWORD *)(a1 + 3196);
  if ( v2 )
  {
    do
    {
      v3 = *(_DWORD *)(v2 + 32);
      result = free2(v2);
      v2 = v3;
    }
    while ( v3 );
  }
  *(_DWORD *)(a1 + 3196) = 0;
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (0045A988) --------------------------------------------------------
int   freePkaAfter(int a1)
{
  int v2; // $a0
  int result; // $v0
  __int16 v4; // $t0
  int v5; // $a3
  int v6; // $a2
  __int16 v7; // $a1
  __int16 v8; // $v1
  int v9; // $a0
  int v10; // $v1
  __int16 v11; // $a0
  __int16 v12; // $a1

  v2 = *(_DWORD *)(a1 + 3148);
  if ( v2 )
  {
    free2(v2);
    *(_DWORD *)(a1 + 3148) = 0;
  }
  result = *(unsigned __int16 *)(a1 + 3186);
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  if ( *(_WORD *)(a1 + 3186) )
  {
    v5 = *(_DWORD *)(a1 + 3176);
    v6 = *(_DWORD *)(a1 + 3180);
    v7 = *(_WORD *)(a1 + 3184);
    v8 = *(_WORD *)(a1 + 3188);
    v4 = *(_WORD *)(a1 + 3186);
    *(_WORD *)(a1 + 3186) = 0;
    *(_DWORD *)(a1 + 3176) = 0;
    *(_DWORD *)(a1 + 3180) = 0;
    *(_WORD *)(a1 + 3184) = 0;
    *(_WORD *)(a1 + 3188) = 0;
  }
  v9 = *(_DWORD *)(a1 + 3148);
  if ( v9 )
  {
    *(_WORD *)(a1 + 3162) = v4;
    *(_DWORD *)(a1 + 3152) = v5;
    *(_DWORD *)(a1 + 3156) = v6;
    *(_WORD *)(a1 + 3160) = v7;
    *(_WORD *)(a1 + 3164) = v8;
    result = free2(v9);
    *(_DWORD *)(a1 + 3148) = 0;
  }
  if ( *(_WORD *)(a1 + 3186) )
  {
    result = *(_DWORD *)(a1 + 3176);
    v10 = *(_DWORD *)(a1 + 3180);
    v11 = *(_WORD *)(a1 + 3184);
    v12 = *(_WORD *)(a1 + 3188);
    *(_WORD *)(a1 + 3162) = *(_WORD *)(a1 + 3186);
    *(_DWORD *)(a1 + 3152) = result;
    *(_DWORD *)(a1 + 3156) = v10;
    *(_WORD *)(a1 + 3160) = v11;
    *(_WORD *)(a1 + 3164) = v12;
    *(_WORD *)(a1 + 3188) = 0;
    *(_WORD *)(a1 + 3186) = 0;
    *(_DWORD *)(a1 + 3176) = 0;
    *(_DWORD *)(a1 + 3180) = 0;
    *(_WORD *)(a1 + 3184) = 0;
  }
  else
  {
    *(_WORD *)(a1 + 3162) = 0;
    *(_WORD *)(a1 + 3164) = 0;
    *(_WORD *)(a1 + 3160) = 0;
    *(_DWORD *)(a1 + 3156) = 0;
    *(_DWORD *)(a1 + 3152) = 0;
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (0045AAC4) --------------------------------------------------------
int   psWriteRecordInfo(int a1, char a2, __int16 a3, char *a4, int a5)
{
  _BYTE *v5; // $a1
  char v6; // $v1
  _BYTE *v7; // $a1
  int v8; // $v0
  char v10; // $t9

  if ( a2 == 91 )
    a2 = 22;
  *a4 = a2;
  a4[1] = *(_BYTE *)(a1 + 3389);
  a4[2] = *(_BYTE *)(a1 + 3390);
  v5 = a4 + 3;
  if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
  {
    v6 = *(_BYTE *)(a1 + 3529);
    *(_DWORD *)(a1 + 3204) = v5;
    a4[3] = v6;
    v5 = a4 + 11;
    a4[4] = *(_BYTE *)(a1 + 3530);
    a4[5] = *(_BYTE *)(a1 + 3537);
    a4[6] = *(_BYTE *)(a1 + 3538);
    a4[7] = *(_BYTE *)(a1 + 3539);
    a4[8] = *(_BYTE *)(a1 + 3540);
    a4[9] = *(_BYTE *)(a1 + 3541);
    a4[10] = *(_BYTE *)(a1 + 3542);
  }
  v5[1] = a3;
  *v5 = HIBYTE(a3);
  v7 = v5 + 1;
  if ( a5 == 20 )
    v8 = *(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) & 0x1800;
  else
    v8 = (*(_DWORD *)(a1 + 3372) >> 22) & 1;
  if ( !v8 )
    return *(_DWORD *)(a1 + 4660);
  if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
  {
    v7[1] = *(_BYTE *)(a1 + 3529);
    v7[2] = *(_BYTE *)(a1 + 3530);
    v7[3] = *(_BYTE *)(a1 + 3537);
    v7[4] = *(_BYTE *)(a1 + 3538);
    v7[5] = *(_BYTE *)(a1 + 3539);
    v7[6] = *(_BYTE *)(a1 + 3540);
    v7[7] = *(_BYTE *)(a1 + 3541);
    v7[8] = *(_BYTE *)(a1 + 3542);
  }
  else
  {
    v10 = *(_BYTE *)(a1 + 576);
    *(_DWORD *)(a1 + 3204) = v7 + 1;
    v7[1] = v10;
    v7[2] = *(_BYTE *)(a1 + 577);
    v7[3] = *(_BYTE *)(a1 + 578);
    v7[4] = *(_BYTE *)(a1 + 579);
    v7[5] = *(_BYTE *)(a1 + 580);
    v7[6] = *(_BYTE *)(a1 + 581);
    v7[7] = *(_BYTE *)(a1 + 582);
    v7[8] = *(_BYTE *)(a1 + 583);
  }
  return *(_DWORD *)(a1 + 4660) + 8;
}

//----- (0045ACB8) --------------------------------------------------------
int   psWriteHandshakeHeader(int a1, char a2, int a3, __int16 a4, int a5, int a6, _BYTE *a7)
{
  int result; // $v0

  a7[1] = (a3 & 0xFF0000u) >> 16;
  a7[2] = BYTE1(a3);
  *a7 = a2;
  if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
  {
    a7[11] = a6;
    a7[3] = a3;
    a7[4] = HIBYTE(a4);
    a7[5] = a4;
    a7[6] = (a5 & 0xFF0000u) >> 16;
    a7[7] = BYTE1(a5);
    a7[8] = a5;
    a7[9] = (a6 & 0xFF0000u) >> 16;
    a7[10] = BYTE1(a6);
  }
  else
  {
    a7[3] = a3;
  }
  result = *(_DWORD *)(a1 + 4664);
  *(_BYTE *)(a1 + 3386) = a2;
  return result;
}

//----- (0045AD54) --------------------------------------------------------
int   sub_45AD54(
        int a1,
        unsigned __int8 a2,
        unsigned __int8 a3,
        _WORD *a4,
        _BYTE *a5,
        int *a6,
        int a7,
        int *a8)
{
  int v9; // $a0
  int v10; // $s2
  int v11; // $s1
  int v12; // $s3
  unsigned int v13; // $a0
  unsigned int v14; // $t8
  unsigned int v15; // $t8
  __int16 v16; // $a1
  __int16 v17; // $v1
  unsigned int v18; // $v1
  char *v19; // $a0
  int v20; // $a2
  int v21; // $a1
  int v22; // $a3
  char v23; // $v1
  _BYTE *v24; // $a1
  char v25; // $a2
  _BYTE *v26; // $a1
  unsigned int v27; // $a0
  int v28; // $s4
  int v29; // $t9
  unsigned int v30; // $s4
  unsigned int v31; // $a1
  unsigned int v33; // $a0
  __int16 v34; // $v1
  int v35; // $a0
  unsigned int v36; // $a1
  unsigned int v37; // $v1
  _BYTE *v38; // $a0
  char v39; // $a1
  int v40; // $v1
  unsigned int v41; // $t3
  int v42; // $t9
  unsigned int v43; // $a1
  char v44; // $t7
  int v45; // $t3
  int v46; // $t4
  unsigned int v47; // $a0
  unsigned int v48; // $a1

  v9 = *(_DWORD *)(a1 + 4660);
  v10 = a2;
  v11 = a3;
  v12 = (unsigned __int16)*a4 - v9;
  if ( a2 == 22 )
    v12 -= *(_DWORD *)(a1 + 4664);
  if ( a2 == 90 )
  {
    v12 -= *(_DWORD *)(a1 + 4664);
    v10 = 22;
    *a4 = *(_DWORD *)(a1 + 3328) + v9;
  }
  if ( a3 != 20 )
  {
    v13 = *(_DWORD *)(a1 + 3372);
    v14 = v13 >> 2;
LABEL_7:
    if ( (v14 & 1) != 0 && ((v13 >> 12) & 1) != 0 && *(unsigned __int8 *)(a1 + 3367) >= 2u )
    {
      *a4 += *(unsigned __int8 *)(a1 + 3367);
      goto LABEL_40;
    }
    goto LABEL_8;
  }
  v13 = *(_DWORD *)(a1 + 3372);
  v14 = v13 >> 2;
  if ( ((v13 >> 12) & 1) == 0 )
    goto LABEL_7;
  if ( *(unsigned __int8 *)(*(_DWORD *)(a1 + 3344) + 11) >= 2u )
  {
    *a4 += *(unsigned __int8 *)(*(_DWORD *)(a1 + 3344) + 11);
LABEL_40:
    v15 = v13 >> 20;
    if ( a3 == 20 )
      goto LABEL_41;
LABEL_9:
    if ( (v15 & 1) != 0 )
    {
      v16 = 8;
      if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
        v16 = 16;
      v17 = v16;
      if ( ((v13 >> 22) & 1) != 0 )
        v17 = v16 + 8;
      *a4 += v17;
    }
    goto LABEL_15;
  }
LABEL_8:
  v15 = v13 >> 20;
  if ( a3 != 20 )
    goto LABEL_9;
LABEL_41:
  v33 = *(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4);
  if ( (v33 & 0x1800) != 0 )
  {
    v34 = *a4 + 16;
    if ( ((v33 >> 13) & 1) == 0 )
      v34 = *a4 + 24;
    goto LABEL_44;
  }
  if ( ((v33 >> 6) & 1) != 0 )
  {
    v34 = *a4 + 8;
    if ( ((v33 >> 13) & 1) == 0 )
    {
      *a4 += 16;
      goto LABEL_45;
    }
LABEL_44:
    *a4 = v34;
LABEL_45:
    *a5 = 0;
    goto LABEL_46;
  }
LABEL_15:
  *a5 = 0;
  if ( a3 == 20 )
  {
LABEL_46:
    v35 = *(_DWORD *)(a1 + 3344);
    if ( *(_BYTE *)(v35 + 8) )
    {
      if ( (*(_WORD *)(a1 + 4658) & 1) != 0 )
        *a4 += 10;
      else
        *a4 += *(unsigned __int8 *)(v35 + 8);
    }
    v36 = *(unsigned __int8 *)(v35 + 11);
    LOBYTE(v37) = 0;
    if ( v36 >= 2 )
      v37 = v36 - ((*(unsigned __int8 *)a4 - *(_DWORD *)(a1 + 4660)) & (v36 - 1));
    *a5 = v37;
    *a4 += (unsigned __int8)v37;
    goto LABEL_18;
  }
  v18 = *(_DWORD *)(a1 + 3372);
  if ( ((v18 >> 2) & 1) != 0 && ((v18 >> 20) & 1) == 0 )
  {
    v45 = *(unsigned __int8 *)(a1 + 3364);
    v46 = (unsigned __int16)*a4;
    *a4 = v46 + v45;
    v47 = *(unsigned __int8 *)(a1 + 3367);
    LOBYTE(v48) = 0;
    if ( v47 >= 2 )
      v48 = v47 - ((v46 + v45 - *(_DWORD *)(a1 + 4660)) & (v47 - 1));
    *a5 = v48;
    *a4 += (unsigned __int8)v48;
  }
LABEL_18:
  v19 = (char *)*a8;
  v20 = (unsigned __int16)*a4;
  v21 = -50;
  if ( a7 - *a8 >= v20 )
  {
    if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) == 0 || (v21 = -60, *(_DWORD *)(a1 + 3576) >= v20) )
    {
      v22 = (unsigned __int16)*a4 - *(_DWORD *)(a1 + 4660);
      v23 = v10;
      if ( v10 == 91 )
        v23 = 22;
      *v19 = v23;
      v19[1] = *(_BYTE *)(a1 + 3389);
      v19[2] = *(_BYTE *)(a1 + 3390);
      v24 = v19 + 3;
      if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
      {
        v25 = *(_BYTE *)(a1 + 3529);
        *(_DWORD *)(a1 + 3204) = v24;
        v19[3] = v25;
        v24 = v19 + 11;
        v19[4] = *(_BYTE *)(a1 + 3530);
        v19[5] = *(_BYTE *)(a1 + 3537);
        v19[6] = *(_BYTE *)(a1 + 3538);
        v19[7] = *(_BYTE *)(a1 + 3539);
        v19[8] = *(_BYTE *)(a1 + 3540);
        v19[9] = *(_BYTE *)(a1 + 3541);
        v19[10] = *(_BYTE *)(a1 + 3542);
      }
      v24[1] = v22;
      *v24 = BYTE1(v22);
      v26 = v24 + 1;
      if ( v11 == 20 )
      {
        if ( (*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) & 0x1800) != 0 )
        {
          v28 = *(_DWORD *)(a1 + 3372) >> 14;
LABEL_27:
          if ( (v28 & 1) != 0 )
          {
            v26[1] = *(_BYTE *)(a1 + 3529);
            v26[2] = *(_BYTE *)(a1 + 3530);
            v26[3] = *(_BYTE *)(a1 + 3537);
            v26[4] = *(_BYTE *)(a1 + 3538);
            v26[5] = *(_BYTE *)(a1 + 3539);
            v26[6] = *(_BYTE *)(a1 + 3540);
            v26[7] = *(_BYTE *)(a1 + 3541);
            v26[8] = *(_BYTE *)(a1 + 3542);
          }
          else
          {
            v44 = *(_BYTE *)(a1 + 576);
            *(_DWORD *)(a1 + 3204) = v26 + 1;
            v26[1] = v44;
            v26[2] = *(_BYTE *)(a1 + 577);
            v26[3] = *(_BYTE *)(a1 + 578);
            v26[4] = *(_BYTE *)(a1 + 579);
            v26[5] = *(_BYTE *)(a1 + 580);
            v26[6] = *(_BYTE *)(a1 + 581);
            v26[7] = *(_BYTE *)(a1 + 582);
            v26[8] = *(_BYTE *)(a1 + 583);
          }
          v29 = *a8 + *(_DWORD *)(a1 + 4660) + 8;
          *a8 = v29;
          v27 = *(_DWORD *)(a1 + 3372);
          *a6 = v29;
          LOBYTE(v30) = 0;
          if ( v11 != 20 )
            goto LABEL_30;
          goto LABEL_59;
        }
        v27 = *(_DWORD *)(a1 + 3372);
      }
      else
      {
        v27 = *(_DWORD *)(a1 + 3372);
        v28 = v27 >> 14;
        if ( ((v27 >> 22) & 1) != 0 )
          goto LABEL_27;
      }
      v42 = *a8 + *(_DWORD *)(a1 + 4660);
      *a8 = v42;
      LOBYTE(v30) = 0;
      *a6 = v42;
      if ( v11 != 20 )
      {
LABEL_30:
        if ( ((v27 >> 2) & 1) != 0 && ((v27 >> 12) & 1) != 0 )
        {
          v31 = *(unsigned __int8 *)(a1 + 3367);
          if ( v31 >= 2 )
          {
            psGetPrngLocked(*a8, v31);
            *a8 += *(unsigned __int8 *)(a1 + 3367);
          }
        }
        goto LABEL_34;
      }
LABEL_59:
      if ( ((v27 >> 12) & 1) != 0 )
      {
        v43 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 3344) + 11);
        if ( v43 >= 2 )
        {
          psGetPrngLocked(*a8, v43);
          *a8 += *(unsigned __int8 *)(*(_DWORD *)(a1 + 3344) + 11);
        }
      }
LABEL_34:
      if ( v10 != 22 )
        return 0;
      if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
      {
        v30 = *(_DWORD *)(a1 + 3564);
        v38 = (_BYTE *)*a8;
        v39 = BYTE2(v12);
        v40 = (v12 & 0xFF00) >> 8;
        *(_DWORD *)(a1 + 3564) = v30 + 1;
        *v38 = v11;
        v38[1] = BYTE2(v12);
        v38[2] = v40;
        v41 = v30 >> 8;
        if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
          goto LABEL_54;
      }
      else
      {
        v38 = (_BYTE *)*a8;
        v39 = BYTE2(v12);
        v40 = (v12 & 0xFF00) >> 8;
        *v38 = v11;
        v38[1] = BYTE2(v12);
        v38[2] = v40;
        LOBYTE(v41) = 0;
        if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
        {
LABEL_54:
          v38[11] = v12;
          v38[4] = v41;
          v38[5] = v30;
          v38[9] = v39;
          v38[10] = v40;
          v38[3] = v12;
          v38[6] = 0;
          v38[7] = 0;
          v38[8] = 0;
LABEL_55:
          *(_BYTE *)(a1 + 3386) = v11;
          *a8 += *(_DWORD *)(a1 + 4664);
          return 0;
        }
      }
      v38[3] = v12;
      goto LABEL_55;
    }
  }
  return v21;
}
// 45B134: conditional instruction was optimized away because $s1.4==14

//----- (0045B4B0) --------------------------------------------------------
int   sub_45B4B0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int *a8)
{
  _DWORD *v12; // $a1
  int v13; // $v1
  int v14; // $v0
  int v15; // $v0
  int v16; // $v1
  int v17; // $a2
  int v18; // $v0
  int v19; // $v1
  unsigned int v20; // $v1
  int v21; // $a3
  int v22; // $v1
  int v23; // $a1
  int v24; // $a0
  unsigned int v26; // $v0
  int v27; // $v1
  int v28; // $a0

  v12 = (_DWORD *)malloc(36);
  v13 = -8;
  if ( !v12 )
    return v13;
  v14 = *(_DWORD *)(a1 + 3196);
  *v12 = 0;
  v12[1] = 0;
  v12[2] = 0;
  v12[3] = 0;
  v12[4] = 0;
  v12[5] = 0;
  v12[6] = 0;
  v12[7] = 0;
  v12[8] = 0;
  if ( v14 )
  {
    do
    {
      v19 = v14;
      v14 = *(_DWORD *)(v14 + 32);
    }
    while ( v14 );
    *(_DWORD *)(v19 + 32) = v12;
    v17 = *(_DWORD *)(a7 + 8) + *(_DWORD *)(a1 + 4660);
    if ( a3 == 20 )
      goto LABEL_4;
  }
  else
  {
    v15 = *(_DWORD *)(a7 + 8);
    v16 = *(_DWORD *)(a1 + 4660);
    *(_DWORD *)(a1 + 3196) = v12;
    v17 = v15 + v16;
    if ( a3 == 20 )
    {
LABEL_4:
      v18 = *(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) & 0x1800;
      goto LABEL_9;
    }
  }
  v20 = *(_DWORD *)(a1 + 3372);
  if ( ((v20 >> 20) & 1) != 0 )
  {
    v18 = (v20 >> 22) & 1;
LABEL_9:
    if ( v18 )
      v17 += 8;
  }
  v21 = *a8;
  v12[1] = *(_DWORD *)(a1 + 3204);
  v12[2] = v21 - v17;
  *v12 = a6;
  v12[3] = a2;
  v12[5] = a5;
  v12[4] = a4;
  v12[6] = a3;
  if ( a3 == 20 )
  {
    v28 = *(_DWORD *)(a1 + 3344);
    if ( (*(_DWORD *)(v28 + 4) & 0x1840) != 0 || (v22 = v21 + 10, (*(_WORD *)(a1 + 4658) & 1) == 0) )
      v22 = v21 + *(unsigned __int8 *)(v28 + 8);
  }
  else
  {
    v22 = v21 + *(unsigned __int8 *)(a1 + 3364);
  }
  v23 = v22 + a5;
  if ( a3 == 20 )
  {
    v26 = *(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4);
    if ( (v26 & 0x1840) != 0 )
    {
      v27 = v23 + 8;
      if ( ((v26 >> 13) & 1) == 0 )
        v27 = v23 + 16;
      v23 = v27;
    }
  }
  else if ( ((*(_DWORD *)(a1 + 3372) >> 20) & 1) != 0 )
  {
    v24 = v23 + 8;
    if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
      v24 = v23 + 16;
    v23 = v24;
  }
  *a8 = v23;
  v13 = -12;
  if ( v23 - *(_DWORD *)(a7 + 8) == a4 )
    return 0;
  return v13;
}
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (0045B710) --------------------------------------------------------
int   sub_45B710(int a1, _DWORD *a2)
{
  int v3; // $s3
  int v5; // $t1
  int v6; // $a1
  int v7; // $v1
  int v8; // $v0
  int v9; // $s1
  int v10; // $v1
  int v11; // $t6
  int v12; // $a2
  int v13; // $v1
  unsigned int v14; // $a0
  unsigned int v15; // $t4
  int v16; // $a0
  int v17; // $a1
  _DWORD *v18; // $a2
  __int16 v19; // $a3
  int v20; // $a0
  _BYTE *v21; // $v1
  int v22; // $a1
  __int16 v23; // $t7
  int v24; // $a0
  int v25; // $t4
  int v26; // $a1
  int v27; // $a2
  int v28; // $v0
  unsigned int v30; // $a0
  __int16 v31; // $t7
  int v32; // $t4
  int v33; // $a1
  int v34; // $a2
  unsigned int v35; // $v1
  __int16 v36; // $a1
  int v37; // $t0
  int v38; // $a1
  int v39; // $v1
  int v40; // $a0
  int v41; // $a0
  char v42[2]; // [sp+28h] [-10h] BYREF
  unsigned __int16 v43; // [sp+2Ah] [-Eh] BYREF
  int v44; // [sp+2Ch] [-Ch] BYREF
  int v45[2]; // [sp+30h] [-8h] BYREF

  v3 = *(_DWORD *)(a1 + 4688);
  v5 = *a2 + a2[3];
  v45[0] = a2[2];
  v6 = 0;
  v7 = a1 + 3148;
  while ( 1 )
  {
    v8 = *(unsigned __int16 *)(v7 + 14);
    ++v6;
    if ( v8 == 1 )
      break;
    v9 = v7;
    if ( v8 == 3 || v8 == 2 )
      goto LABEL_8;
    v7 += 24;
    if ( v6 >= 2 )
    {
      v7 = a1 + 3148;
      if ( *(_WORD *)(a1 + 3162) )
      {
        v7 = a1 + 3172;
        if ( *(_WORD *)(a1 + 3186) )
          v7 = 0;
      }
      break;
    }
  }
  v9 = v7;
LABEL_8:
  v10 = -12;
  if ( !v9 )
    return v10;
  v11 = *(_DWORD *)(a1 + 3144);
  v12 = *(unsigned __int16 *)(v11 + 112);
  v13 = *(_DWORD *)(a1 + 4660) + *(_DWORD *)(a1 + 4664) + v12;
  if ( *(_DWORD *)(*(_DWORD *)(v11 + 116) + 444) != 518 )
  {
    v14 = *(_DWORD *)(a1 + 3372);
    v43 = v13 + 2;
    v15 = v14 >> 13;
LABEL_11:
    v16 = v15 & 1;
    goto LABEL_12;
  }
  if ( *(_WORD *)(v11 + 112) == 132 )
    v43 = v13 + 8;
  else
    v43 = v13 + 9;
  if ( (unsigned __int16)v12 + 4 >= 128 )
    ++v43;
  v30 = *(_DWORD *)(a1 + 3372);
  v15 = v30 >> 13;
  if ( ((v30 >> 14) & 1) == 0 )
    goto LABEL_11;
  v16 = (v30 & 0x2000) != 0;
  if ( *(_DWORD *)(a1 + 3580) == 1 )
    v43 += *(_DWORD *)(a1 + 4652);
LABEL_12:
  if ( v16 )
    v43 += 2;
  v10 = sub_45AD54(a1, 0x16u, 0xFu, &v43, v42, &v44, v5, v45);
  if ( v10 >= 0 )
  {
    v17 = *(_DWORD *)(a1 + 3144);
    v18 = *(_DWORD **)(v17 + 116);
    if ( v18[111] == 518 )
    {
      v35 = *(_DWORD *)(a1 + 3372);
      v36 = 36;
      if ( ((v35 >> 13) & 1) != 0 )
      {
        v40 = v18[2];
        switch ( v40 )
        {
          case 520:
          case 1673:
            *(_BYTE *)v45[0]++ = 2;
            *(_BYTE *)v45[0] = 3;
            v35 = *(_DWORD *)(a1 + 3372);
            v24 = v45[0] + 1;
            v36 = 20;
            ++v45[0];
            break;
          case 524:
          case 1679:
            *(_BYTE *)v45[0]++ = 4;
            *(_BYTE *)v45[0] = 3;
            v35 = *(_DWORD *)(a1 + 3372);
            v24 = v45[0] + 1;
            v36 = 32;
            ++v45[0];
            break;
          case 525:
          case 1680:
            *(_BYTE *)v45[0]++ = 5;
            *(_BYTE *)v45[0] = 3;
            v35 = *(_DWORD *)(a1 + 3372);
            v24 = v45[0] + 1;
            v36 = 48;
            ++v45[0];
            break;
          default:
            if ( v40 != 526 )
            {
              v10 = -12;
              if ( v40 != 1681 )
                return v10;
            }
            *(_BYTE *)v45[0]++ = 6;
            *(_BYTE *)v45[0] = 3;
            v35 = *(_DWORD *)(a1 + 3372);
            v24 = v45[0] + 1;
            v36 = 64;
            ++v45[0];
            break;
        }
      }
      else
      {
        v24 = v45[0];
      }
      if ( ((v35 >> 14) & 1) == 0 || !*(_DWORD *)(a1 + 3580) )
      {
        *(_WORD *)(v9 + 12) = v36;
        v37 = *(_DWORD *)(a1 + 3144);
        *(_WORD *)(v9 + 14) = 3;
        v38 = *(unsigned __int16 *)(v37 + 112);
        *(_DWORD *)(v9 + 8) = v3;
        *(_DWORD *)(v9 + 4) = v24;
        v39 = v38 + 8;
        if ( v38 != 132 )
          v39 = v38 + 9;
        if ( v39 - 3 >= 128 )
          ++v39;
        v28 = v24 + v39;
        *(_WORD *)(v9 + 16) = v39;
        goto LABEL_32;
      }
      v33 = *(_DWORD *)(a1 + 4644);
      v34 = *(_DWORD *)(a1 + 4648);
      goto LABEL_48;
    }
    v19 = 36;
    if ( ((*(_DWORD *)(a1 + 3372) >> 13) & 1) == 0 )
    {
      *(_WORD *)(v9 + 14) = 2;
      *(_BYTE *)v45[0] = HIBYTE(*(_WORD *)(v17 + 112));
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 3144) + 112);
      *(_BYTE *)++v45[0] = v31;
      v24 = v45[0] + 1;
      v32 = (*(_DWORD *)(a1 + 3372) >> 14) & 1;
      ++v45[0];
      if ( !v32 )
        goto LABEL_31;
LABEL_46:
      if ( !*(_DWORD *)(a1 + 3580) )
        goto LABEL_31;
      v33 = *(_DWORD *)(a1 + 4644);
      v34 = *(_DWORD *)(a1 + 4648);
      *(_WORD *)(v9 + 14) = 0;
LABEL_48:
      memcpy(v24, v33, v34);
      v45[0] += *(_DWORD *)(a1 + 4648);
LABEL_33:
      v10 = sub_45B4B0(a1, 22, 15, v43, (unsigned __int8)v42[0], v44, (int)a2, v45);
      if ( v10 >= 0 )
      {
        v10 = 0;
        a2[2] = v45[0];
      }
      return v10;
    }
    v20 = v18[2];
    switch ( v20 )
    {
      case 1673:
      case 648:
      case 520:
        *(_BYTE *)v45[0]++ = 2;
        *(_BYTE *)v45[0] = 1;
        v19 = 20;
        v21 = (_BYTE *)(v45[0] + 1);
        break;
      case 1679:
      case 524:
        *(_BYTE *)v45[0]++ = 4;
        *(_BYTE *)v45[0] = 1;
        v19 = 32;
        v21 = (_BYTE *)(v45[0] + 1);
        break;
      case 1680:
      case 525:
        *(_BYTE *)v45[0]++ = 5;
        *(_BYTE *)v45[0] = 1;
        v19 = 48;
        v21 = (_BYTE *)(v45[0] + 1);
        break;
      case 1681:
      case 526:
        *(_BYTE *)v45[0]++ = 6;
        *(_BYTE *)v45[0] = 1;
        v19 = 64;
        v21 = (_BYTE *)(v45[0] + 1);
        break;
      default:
        v10 = -12;
        if ( v20 != 1678 )
          return v10;
        if ( v18[6] >= 2u )
        {
          v41 = *(_DWORD *)(*(_DWORD *)(v17 + 116) + 24);
          if ( v41 == 2 )
          {
            v19 = 32;
            *(_BYTE *)v45[0] = 4;
          }
          else if ( v41 == 3 )
          {
            v19 = 48;
            *(_BYTE *)v45[0] = 5;
          }
          else
          {
            v10 = -12;
            if ( v41 != 4 )
              return v10;
            v19 = 64;
            *(_BYTE *)v45[0] = 6;
          }
        }
        else
        {
          *(_BYTE *)v45[0] = 2;
          v19 = 20;
        }
        *(_BYTE *)++v45[0] = 1;
        v21 = (_BYTE *)(v45[0] + 1);
        v22 = *(_DWORD *)(a1 + 3144);
        ++v45[0];
LABEL_30:
        *(_WORD *)(v9 + 14) = 1;
        *v21 = HIBYTE(*(_WORD *)(v22 + 112));
        v23 = *(_WORD *)(*(_DWORD *)(a1 + 3144) + 112);
        *(_BYTE *)++v45[0] = v23;
        v24 = v45[0] + 1;
        v25 = (*(_DWORD *)(a1 + 3372) >> 14) & 1;
        ++v45[0];
        if ( !v25 )
        {
LABEL_31:
          v26 = *(_DWORD *)(a1 + 3144);
          *(_WORD *)(v9 + 12) = v19;
          v27 = *(unsigned __int16 *)(v26 + 112);
          *(_DWORD *)(v9 + 4) = v24;
          v28 = v27 + v24;
          *(_DWORD *)(v9 + 8) = v3;
LABEL_32:
          v45[0] = v28;
          goto LABEL_33;
        }
        goto LABEL_46;
    }
    v22 = *(_DWORD *)(a1 + 3144);
    v45[0] = (int)v21;
    goto LABEL_30;
  }
  return v10;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0045BE2C) --------------------------------------------------------
int   sslWritePad(_BYTE *a1, unsigned __int8 a2)
{
  int v2; // $v0

  LOBYTE(v2) = a2;
  if ( a2 )
  {
    do
    {
      v2 = (unsigned __int8)(v2 - 1);
      *a1++ = a2 - 1;
    }
    while ( v2 );
  }
  return a2;
}

//----- (0045BE58) --------------------------------------------------------
int   sub_45BE58(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int *a8)
{
  unsigned int v8; // $t1
  int v10; // $s4
  int v13; // $s5
  int v15; // $t0
  int v16; // $s0
  int (  *v17)(int, _DWORD, int, int, int); // $t9
  _BYTE *v18; // $a0
  int v19; // $v0
  unsigned int v20; // $a0
  int v21; // $a3
  int v22; // $a1
  int v23; // $a1
  unsigned int v24; // $v1
  int v25; // $s2
  int v26; // $s1
  int v27; // $v0
  int updated; // $v1
  int v29; // $v0
  int v30; // $v1
  unsigned __int8 v32; // $a2
  int v33; // $v0
  int v34; // $s3
  int v35; // $v0
  int v36; // $v0
  int v37; // $a2
  int v38; // $v0

  v8 = *(_DWORD *)(a1 + 3372);
  v10 = *(_DWORD *)(a7 + 8) + *(_DWORD *)(a1 + 4660);
  v13 = a6;
  if ( ((v8 >> 20) & 1) != 0 )
  {
    if ( ((v8 >> 22) & 1) != 0 )
      v10 += 8;
    *(_BYTE *)(a1 + 3392) = a2;
  }
  v15 = *a8;
  v16 = *a8 - v10;
  if ( ((v8 >> 2) & 1) != 0 && ((v8 >> 12) & 1) != 0 && (v32 = *(_BYTE *)(a1 + 3367), v32 >= 2u) )
  {
    if ( a2 == 22 )
    {
      sslUpdateHSHash(a1, v32 + a6, v16 - *(unsigned __int8 *)(a1 + 3367));
      if ( a3 == 16 && ((*(_DWORD *)(a1 + 4656) >> 17) & 1) == 1 )
      {
        v38 = tlsExtendedDeriveKeys(a1);
        updated = -12;
        if ( v38 < 0 )
          return updated;
        v15 = *a8;
        v32 = *(_BYTE *)(a1 + 3367);
      }
      else
      {
        v15 = *a8;
        v32 = *(_BYTE *)(a1 + 3367);
      }
    }
    if ( a2 != 23 )
    {
      v33 = (*(int (  **)(int, _DWORD, int, int, int))(a1 + 3356))(
              a1,
              (unsigned __int8)a2,
              v32 + a6,
              v16 - v32,
              v15);
LABEL_43:
      v15 = *a8 + v33;
      *a8 = v15;
      goto LABEL_9;
    }
    v15 = *a8 + (*(int (  **)(int, int, int, int, int))(a1 + 3356))(a1, 23, a6, v16 - v32, v15);
    *a8 = v15;
    if ( *(unsigned __int8 *)(a1 + 3367) + v10 == a6 )
    {
      v13 = v10;
    }
    else
    {
      v36 = (*(int (  **)(int, int, int))(a1 + 3348))(a1, v10, v10);
      updated = -12;
      if ( v36 < 0 )
        return updated;
      v37 = *(unsigned __int8 *)(a1 + 3367);
      v15 = *a8;
      v16 -= v37;
      v10 += v37;
    }
  }
  else
  {
    if ( a2 == 22 )
    {
      updated = sslUpdateHSHash(a1, a6, v16);
      if ( updated < 0 )
        return updated;
      if ( a3 == 16 && ((*(_DWORD *)(a1 + 4656) >> 17) & 1) == 1 )
      {
        v35 = tlsExtendedDeriveKeys(a1);
        updated = -12;
        if ( v35 < 0 )
          return updated;
        v15 = *a8;
      }
      else
      {
        v15 = *a8;
      }
    }
    v17 = *(int (  **)(int, _DWORD, int, int, int))(a1 + 3356);
    if ( v17 )
    {
      v33 = v17(a1, (unsigned __int8)a2, a6, v16, v15);
      goto LABEL_43;
    }
  }
LABEL_9:
  v18 = (_BYTE *)v15;
  LOBYTE(v19) = a5;
  if ( (_BYTE)a5 )
  {
    do
    {
      v19 = (unsigned __int8)(v19 - 1);
      *v18++ = a5 - 1;
    }
    while ( v19 );
    v15 = *a8;
  }
  v20 = *(_DWORD *)(a1 + 3372);
  v21 = v15 + (unsigned __int8)a5;
  if ( ((v20 >> 20) & 1) != 0 )
  {
    v22 = v21 + 8;
    if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
      v22 = v21 + 16;
    v21 = v22;
  }
  *a8 = v21;
  if ( v13 == v10 )
  {
    v29 = (*(int (  **)(int, int, int, int))(a1 + 3348))(a1, v10, v10, v21 - v10);
  }
  else if ( ((v20 >> 2) & 1) != 0 )
  {
    v23 = *(_DWORD *)(a1 + 3344);
    v24 = *(unsigned __int8 *)(v23 + 11);
    if ( v24 < 2 )
    {
      v26 = v16;
      if ( ((v20 >> 20) & 1) != 0 )
      {
        v26 = v16 + 8;
        if ( ((*(_DWORD *)(v23 + 4) >> 13) & 1) == 0 )
          v26 = v16 + 16;
      }
      v25 = 0;
    }
    else
    {
      v25 = (v24 - 1) & v16;
      v26 = ~(v24 - 1) & v16;
    }
    if ( v26 > 0 )
    {
      v27 = (*(int (  **)(int, int, int, int))(a1 + 3348))(a1, v13, v10, v26);
      updated = -12;
      if ( v27 < 0 )
        return updated;
    }
    if ( v25 > 0 )
      memcpy(v10 + v26, v13 + v26, v25);
    v29 = (*(int (  **)(int, int, int, int))(a1 + 3348))(
            a1,
            v10 + v26,
            v10 + v26,
            *(unsigned __int8 *)(a1 + 3364) + v25 + a5);
  }
  else
  {
    v29 = (*(int (  **)(int, int, int, int))(a1 + 3348))(a1, v13, v10, v21 - v10);
  }
  updated = -12;
  if ( v29 < 0 )
    return updated;
  v30 = *(_DWORD *)(a7 + 8);
  if ( *a8 - v30 != a4 )
    return -12;
  if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
  {
    dtlsIncrRsn(a1);
    v34 = *a8 - *(_DWORD *)(a7 + 8);
  }
  else
  {
    v34 = *a8 - v30;
  }
  updated = -12;
  if ( v34 != a4 )
    return updated;
  return 0;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0045C358) --------------------------------------------------------
int   sslEncodeClosureAlert(int a1, _DWORD *a2, _DWORD *a3)
{
  int v6; // $v1
  int v7; // $t7
  int v8; // $t3
  int v9; // $v1
  _BYTE v11[2]; // [sp+28h] [-10h] BYREF
  unsigned __int16 v12; // [sp+2Ah] [-Eh] BYREF
  int v13; // [sp+2Ch] [-Ch] BYREF
  int v14[2]; // [sp+30h] [-8h] BYREF

  v6 = -12;
  if ( ((*(_DWORD *)(a1 + 3372) >> 6) & 1) != 0 )
    return v6;
  v7 = *(_DWORD *)(a1 + 4660);
  v8 = *a2 + a2[3];
  v14[0] = a2[2];
  v12 = v7 + 2;
  v9 = sub_45AD54(a1, 0x15u, 0, &v12, v11, &v13, v8, v14);
  if ( v9 >= 0 )
  {
    *(_BYTE *)v14[0]++ = 1;
    *(_BYTE *)v14[0]++ = 0;
    v9 = sub_45BE58(a1, 21, 0, v12, v11[0], v13, (int)a2, v14);
    if ( v9 >= 0 )
    {
      v6 = 0;
      a2[2] = v14[0];
      return v6;
    }
  }
  *a3 = v12;
  return v9;
}

//----- (0045C4BC) --------------------------------------------------------
int   matrixSslEncode(int a1, int a2, int a3, int a4, _WORD *a5)
{
  unsigned int v5; // $t0
  int v10; // $a1
  unsigned int v12; // $t3
  int v13; // $v1
  unsigned int v14; // $a1
  int v15; // $t2
  int v16; // $t3
  int v17; // $a3
  _BYTE v18[2]; // [sp+28h] [-20h] BYREF
  _WORD v19[3]; // [sp+2Ah] [-1Eh] BYREF
  int v20; // [sp+30h] [-18h] BYREF
  int v21; // [sp+34h] [-14h]
  int v22; // [sp+38h] [-10h]
  int v23; // [sp+3Ch] [-Ch]
  int v24; // [sp+40h] [-8h] BYREF
  int v25; // [sp+44h] [-4h] BYREF

  v5 = *(_DWORD *)(a1 + 3372);
  if ( ((v5 >> 6) & 1) != 0 || *(unsigned __int8 *)(a1 + 3384) != 255 )
    return -12;
  v10 = -12;
  if ( ((v5 >> 4) & 1) != 0 )
    return v10;
  v12 = *(_DWORD *)(a1 + 3324);
  v25 = a2;
  if ( ((v12 >> 2) & 1) == 0 )
  {
LABEL_7:
    v10 = -8;
    v19[0] = *(_DWORD *)(a1 + 4660) + *a5;
    if ( v19[0] >= 0x4806u )
      return v10;
    v13 = sub_45AD54(a1, 0x17u, 0, v19, v18, &v24, a2 + a3, &v25);
    if ( v13 >= 0 )
    {
      v14 = *(_DWORD *)(a1 + 3324);
      v25 += *(_DWORD *)a5;
      if ( ((v14 >> 2) & 1) != 0 )
      {
        *(_DWORD *)(a1 + 3324) = v14 & 0xFFFFFFFB;
      }
      else
      {
        v23 = a3;
        v22 = a2;
        v21 = a2;
        v20 = a2;
      }
      v10 = sub_45BE58(a1, 23, 0, v19[0], v18[0], a4, (int)&v20, &v25);
      if ( v10 >= 0 )
      {
        v10 = v25 - a2;
        *(_DWORD *)a5 = v25 - a2;
      }
      return v10;
    }
LABEL_19:
    if ( v13 != -50 )
      return v13;
    v10 = -50;
    *(_DWORD *)a5 = v19[0];
    return v10;
  }
  v19[0] = *(_WORD *)(a1 + 4660) + 1;
  v13 = sub_45AD54(a1, 0x17u, 0, v19, v18, &v24, a2 + a3, &v25);
  if ( v13 < 0 )
    goto LABEL_19;
  if ( *(_DWORD *)(a1 + 4660) + a2 != v24 )
  {
    psTraceStr("psAssert %s", (int)"sslEncode.c");
    psTraceInt(":%d ", 157);
    psError((int)"encryptStart == buf + ssl->recordHeadLen");
  }
  v15 = v18[0];
  v16 = v25 + 1;
  v17 = v19[0];
  --*(_DWORD *)a5;
  v25 = v16;
  v22 = a2;
  v21 = a2;
  v20 = a2;
  v23 = a3;
  v10 = sub_45BE58(a1, 23, 0, v17, v15, a4, (int)&v20, &v25);
  if ( v10 >= 0 )
  {
    ++a4;
    v22 += v25 - a2;
    goto LABEL_7;
  }
  return v10;
}

//----- (0045C7D0) --------------------------------------------------------
int   sub_45C7D0(int a1, int *a2)
{
  int v2; // $t2
  int v3; // $t3
  unsigned int v4; // $a3
  int v6; // $a2
  int v8; // $a0
  int v9; // $s2
  int v10; // $s1
  bool v11; // dc
  unsigned int v12; // $a0
  unsigned int v13; // $t8
  int v14; // $v0
  unsigned int v15; // $v1
  unsigned int v16; // $a2
  int v17; // $t5
  int PrngLocked; // $v0
  int Keys; // $v1
  char v20; // $t8
  int v21; // $a3
  _DWORD *v22; // $t4
  int v23; // $t0
  int v24; // $t1
  int v25; // $t2
  int v26; // $t3
  int v27; // $s2
  int v28; // $t9
  int v29; // $t5
  char v30; // $a0
  int v31; // $a2
  _BYTE *v32; // $a0
  __int16 v33; // $t1
  int v34; // $v1
  int v35; // $v1
  int v36; // $t7
  _BYTE *v37; // $a1
  unsigned int v38; // $a0
  unsigned int v39; // $t5
  unsigned int v40; // $a0
  int v41; // $v0
  unsigned int v42; // $a0
  unsigned int v43; // $t9
  unsigned int v44; // $a0
  int v46; // $v1
  int v47; // $a0
  unsigned __int16 v48; // [sp+28h] [-10h] BYREF
  _BYTE v49[2]; // [sp+2Ah] [-Eh] BYREF
  int v50; // [sp+2Ch] [-Ch] BYREF
  int v51[2]; // [sp+30h] [-8h] BYREF

  v2 = *(_DWORD *)(a1 + 4660);
  v3 = *(_DWORD *)(a1 + 4664);
  v4 = *(_DWORD *)(a1 + 3372);
  v6 = *a2;
  v8 = a2[3];
  v51[0] = a2[2];
  v9 = v6 + v8;
  v48 = v2 + v3 + 70;
  v10 = 0;
  if ( ((v4 >> 19) & 1) != 0 )
    v10 = 8;
  if ( *(int *)(a1 + 3328) < 0x4000 )
  {
    v11 = v10 != 0;
    v10 += 5;
    if ( !v11 )
      v10 = 7;
  }
  v12 = *(_DWORD *)(a1 + 4656);
  v13 = v12 >> 17;
  if ( (v12 & 0x10000) != 0 )
  {
    v11 = v10 != 0;
    v10 += 4;
    if ( !v11 )
    {
      v10 = 6;
      v13 = v12 >> 17;
    }
  }
  if ( (v13 & 1) != 0 )
  {
    v11 = v10 != 0;
    v10 += 4;
    if ( !v11 )
      v10 = 6;
  }
  v14 = *(_DWORD *)(a1 + 3260);
  v15 = v12 >> 15;
  if ( v14 )
  {
    if ( *(_WORD *)(v14 + 92) == 3 )
    {
      if ( !v10 )
        v10 = 2;
      v10 += 4;
    }
    v15 = v12 >> 15;
  }
  v16 = v12 >> 20;
  if ( (v15 & 1) != 0 )
  {
    v11 = v10 != 0;
    v10 += 4;
    if ( !v11 )
    {
      v10 = 6;
      v16 = v12 >> 20;
    }
  }
  if ( (v16 & 1) != 0 )
  {
    v11 = v10 != 0;
    v10 += 4;
    if ( !v11 )
      v10 = 6;
  }
  v48 += v10;
  if ( ((v4 >> 14) & 1) == 0 || (v17 = v4 >> 3, *(_DWORD *)(a1 + 3580) != 1) )
  {
    PrngLocked = psGetPrngLocked(a1 + 48, 0x20u);
    Keys = -12;
    if ( PrngLocked < 0 )
      return Keys;
    v17 = *(_DWORD *)(a1 + 3372) >> 3;
  }
  if ( (v17 & 1) == 0 )
    matrixRegisterSession(a1);
  v48 = *(unsigned __int8 *)(a1 + 3224) + v48 - 32;
  Keys = sub_45AD54(a1, 0x16u, 2u, &v48, v49, &v50, v9, v51);
  if ( Keys >= 0 )
  {
    *(_BYTE *)v51[0] = *(_BYTE *)(a1 + 3389);
    v20 = *(_BYTE *)(a1 + 3390);
    *(_BYTE *)++v51[0] = v20;
    v21 = *(_DWORD *)(a1 + 48);
    v22 = (_DWORD *)(v51[0] + 1);
    v51[0] = (int)v22;
    v23 = *(_DWORD *)(a1 + 64);
    v24 = *(_DWORD *)(a1 + 68);
    v25 = *(_DWORD *)(a1 + 72);
    v26 = *(_DWORD *)(a1 + 76);
    v27 = *(_DWORD *)(a1 + 52);
    v28 = *(_DWORD *)(a1 + 56);
    v29 = *(_DWORD *)(a1 + 60);
    *v22 = v21;
    v22[1] = v27;
    v22[2] = v28;
    v22[3] = v29;
    v22[4] = v23;
    v22[5] = v24;
    v22[6] = v25;
    v22[7] = v26;
    v30 = *(_BYTE *)(a1 + 3224);
    v51[0] += 32;
    *(_BYTE *)v51[0] = v30;
    v31 = *(unsigned __int8 *)(a1 + 3224);
    v32 = (_BYTE *)++v51[0];
    if ( v31 )
    {
      memcpy(v32, a1 + 3225, v31);
      v32 = (_BYTE *)(*(unsigned __int8 *)(a1 + 3224) + v51[0]);
      v51[0] = (int)v32;
    }
    *v32 = HIBYTE(**(_WORD **)(a1 + 3344));
    v33 = **(_WORD **)(a1 + 3344);
    *(_BYTE *)++v51[0] = v33;
    *(_BYTE *)++v51[0] = 0;
    v34 = v51[0]++;
    if ( v10 )
    {
      *(_BYTE *)(v34 + 1) = (unsigned __int16)(v10 - 2) >> 8;
      *(_BYTE *)++v51[0] = v10 - 2;
      v35 = v51[0];
      v36 = *(_DWORD *)(a1 + 3328);
      v37 = (_BYTE *)++v51[0];
      if ( v36 < 0x4000 )
      {
        *(_BYTE *)(v35 + 1) = 0;
        *(_BYTE *)++v51[0] = 1;
        *(_BYTE *)++v51[0] = 0;
        *(_BYTE *)++v51[0] = 1;
        v46 = v51[0];
        v47 = *(_DWORD *)(a1 + 3328);
        v37 = (_BYTE *)++v51[0];
        if ( v47 == 512 )
        {
          *(_BYTE *)(v46 + 1) = 1;
          v47 = *(_DWORD *)(a1 + 3328);
          v37 = (_BYTE *)++v51[0];
        }
        if ( v47 == 1024 )
        {
          *v37 = 2;
          v47 = *(_DWORD *)(a1 + 3328);
          v37 = (_BYTE *)++v51[0];
        }
        if ( v47 == 2048 )
        {
          *v37 = 3;
          v47 = *(_DWORD *)(a1 + 3328);
          v37 = (_BYTE *)++v51[0];
        }
        if ( v47 == 4096 )
        {
          *v37 = 4;
          v37 = (_BYTE *)++v51[0];
        }
      }
      v38 = *(_DWORD *)(a1 + 4656);
      v39 = v38 >> 17;
      if ( (v38 & 0x10000) != 0 )
      {
        *v37 = 0;
        *(_BYTE *)++v51[0] = 4;
        *(_BYTE *)++v51[0] = 0;
        *(_BYTE *)++v51[0] = 0;
        v40 = *(_DWORD *)(a1 + 4656);
        v37 = (_BYTE *)++v51[0];
        v39 = v40 >> 17;
      }
      if ( (v39 & 1) != 0 )
      {
        *v37 = 0;
        *(_BYTE *)++v51[0] = 23;
        *(_BYTE *)++v51[0] = 0;
        *(_BYTE *)++v51[0] = 0;
        v37 = (_BYTE *)++v51[0];
      }
      v41 = *(_DWORD *)(a1 + 3260);
      if ( v41 && *(_WORD *)(v41 + 92) == 3 )
      {
        *v37 = 0;
        *(_BYTE *)++v51[0] = 35;
        *(_BYTE *)++v51[0] = 0;
        *(_BYTE *)++v51[0] = 0;
        v37 = (_BYTE *)++v51[0];
      }
      v42 = *(_DWORD *)(a1 + 4656);
      v43 = v42 >> 20;
      if ( ((v42 >> 15) & 1) != 0 )
      {
        *v37 = 0;
        *(_BYTE *)++v51[0] = 0;
        *(_BYTE *)++v51[0] = 0;
        *(_BYTE *)++v51[0] = 0;
        v44 = *(_DWORD *)(a1 + 4656);
        v37 = (_BYTE *)++v51[0];
        v43 = v44 >> 20;
      }
      if ( (v43 & 1) != 0 )
      {
        *v37 = 0;
        *(_BYTE *)++v51[0] = 5;
        *(_BYTE *)++v51[0] = 0;
        *(_BYTE *)++v51[0] = 0;
        v37 = (_BYTE *)++v51[0];
      }
      if ( ((*(_DWORD *)(a1 + 3372) >> 19) & 1) != 0 )
      {
        *v37 = 0;
        *(_BYTE *)++v51[0] = 11;
        *(_BYTE *)++v51[0] = 0;
        *(_BYTE *)++v51[0] = 2;
        *(_BYTE *)++v51[0] = 1;
        *(_BYTE *)++v51[0] = 0;
        ++v51[0];
      }
    }
    Keys = sub_45B4B0(a1, 22, 2, v48, v49[0], v50, (int)a2, v51);
    if ( Keys >= 0 )
    {
      if ( ((*(_DWORD *)(a1 + 3372) >> 3) & 1) == 0 || (Keys = sslCreateKeys(a1), Keys >= 0) )
      {
        Keys = 0;
        a2[2] = v51[0];
      }
    }
  }
  return Keys;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0045CF80) --------------------------------------------------------
int   sub_45CF80(int a1, int *a2)
{
  unsigned int v2; // $a3
  int v5; // $v1
  _BYTE *v6; // $a0
  int v7; // $a1
  int v8; // $s5
  int v9; // $t1
  int v10; // $t3
  int v11; // $v1
  unsigned int v12; // $a1
  int v13; // $s3
  _DWORD *v14; // $s2
  unsigned int v15; // $a1
  unsigned int v16; // $t2
  unsigned int v17; // $v1
  unsigned __int16 v19; // $t0
  int v20; // $a0
  __int16 v21; // $v0
  __int16 v22; // $ra
  __int16 v23; // $t6
  int v24; // $a0
  int v25; // $a1
  int v26; // $v0
  int v27; // $v1
  char *v28; // $a0
  __int16 v29; // $s0
  _BYTE *v30; // $a1
  char v31; // $v0
  __int16 v32; // $a1
  int v33; // $a2
  __int16 v34; // $v0
  int v35; // $t7
  _BYTE *v36; // $t5
  int v37; // $t6
  char *v38; // $a0
  __int16 v39; // $s0
  char v40; // $v0
  unsigned int v41; // $v1
  _BYTE *v42; // $t5
  int v43; // $a0
  int v44; // $s3
  _BYTE *v45; // $a2
  int v46; // $a1
  int v47; // $v1
  _BYTE *v48; // $t3
  _BYTE v49[2]; // [sp+28h] [-E8h] BYREF
  _WORD v50[3]; // [sp+2Ah] [-E6h] BYREF
  __int64 v51[26]; // [sp+30h] [-E0h] BYREF
  unsigned __int16 v52; // [sp+100h] [-10h] BYREF
  int v53; // [sp+104h] [-Ch] BYREF
  _BYTE *v54[2]; // [sp+108h] [-8h] BYREF

  v2 = *(_DWORD *)(a1 + 3372);
  v5 = a2[3];
  v6 = (_BYTE *)a2[2];
  v7 = *a2;
  v54[0] = v6;
  v50[0] = 0;
  v8 = *(_DWORD *)(a1 + 4688);
  v9 = v7 + v5;
  if ( ((v2 >> 19) & 1) != 0 )
  {
    v10 = **(unsigned __int8 **)(*(_DWORD *)(a1 + 3124) + 52);
    v52 = 2 * v10 + 1;
    if ( ((v2 >> 15) & 1) != 0 )
    {
      v50[0] = 2 * v10 + 7 + *(_WORD *)(a1 + 4660) + *(_WORD *)(a1 + 4664) + *(_WORD *)(*(_DWORD *)(a1 + 3144) + 112);
    }
    else if ( (v2 & 0x10000) != 0 )
    {
      v19 = *(_WORD *)(*(_DWORD *)(a1 + 3144) + 112);
      v20 = 2 * v10 + 1 + *(_DWORD *)(a1 + 4660) + *(_DWORD *)(a1 + 4664);
      v50[0] = 2 * v10 + 7 + *(_WORD *)(a1 + 4660) + *(_WORD *)(a1 + 4664);
      if ( v19 != 132 )
        v50[0] = v20 + 7;
      v21 = v19 + v50[0];
      if ( v19 + 4 < 128 )
        v50[0] = v21 + 6;
      else
        v50[0] = v21 + 7;
      if ( ((v2 >> 14) & 1) != 0 && *(_DWORD *)(a1 + 3580) == 1 )
        v50[0] += *(_DWORD *)(a1 + 4652);
    }
  }
  v11 = -12;
  if ( !v50[0] )
    return v11;
  if ( ((v2 >> 13) & 1) != 0 )
    v50[0] += 2;
  v11 = sub_45AD54(a1, 0x16u, 0xCu, v50, v49, &v53, v9, (int *)v54);
  if ( v11 < 0 )
    return v11;
  v12 = *(_DWORD *)(a1 + 3372);
  v13 = (int)v54[0];
  if ( ((v12 >> 19) & 1) != 0 )
  {
    *v54[0] = 3;
    v22 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 3124) + 52) + 2);
    *++v54[0] = HIBYTE(v22);
    v23 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 3124) + 52) + 2);
    *++v54[0] = v23;
    *++v54[0] = v52;
    v24 = *(_DWORD *)(a1 + 3216);
    v25 = *(_DWORD *)(a1 + 3124);
    v26 = psEccX963ExportKey(v24, v25, ++v54[0], &v52);
    v11 = -12;
    if ( v26 )
      return v11;
    v12 = *(_DWORD *)(a1 + 3372);
    v54[0] += v52;
    if ( ((v12 >> 15) & 1) == 0 )
      goto LABEL_10;
  }
  else if ( ((v12 >> 15) & 1) == 0 )
  {
    goto LABEL_10;
  }
  v14 = (_DWORD *)malloc(48);
  v11 = -8;
  if ( !v14 )
    return v11;
  if ( ((*(_DWORD *)(a1 + 3372) >> 13) & 1) != 0 )
  {
    v27 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 3144) + 116) + 8);
    switch ( v27 )
    {
      case 1679:
        psSha256Init(v51);
        psSha256Update((int *)v51, a1 + 16, 0x20u);
        psSha256Update((int *)v51, a1 + 48, 0x20u);
        psSha256Update((int *)v51, v13, (unsigned int)&v54[0][-v13]);
        psSha256Final((int)v51, (int)v14);
        v28 = v54[0];
        v29 = 32;
        v30 = v54[0] + 2;
        v31 = 4;
        break;
      case 1680:
        psSha384Init(v51);
        psSha384Update((int *)v51, a1 + 16, 0x20u);
        psSha384Update((int *)v51, a1 + 48, 0x20u);
        psSha384Update((int *)v51, v13, (unsigned int)&v54[0][-v13]);
        psSha384Final((int)v51, v14);
        v28 = v54[0];
        v29 = 48;
        v30 = v54[0] + 2;
        v31 = 5;
        break;
      case 1673:
      case 648:
        psSha1Init(v51);
        psSha1Update((int *)v51, a1 + 16, 0x20u);
        psSha1Update((int *)v51, a1 + 48, 0x20u);
        psSha1Update((int *)v51, v13, (unsigned int)&v54[0][-v13]);
        psSha1Final(v51, (int)v14);
        v28 = v54[0];
        v29 = 20;
        v30 = v54[0] + 2;
        v31 = 2;
        break;
      default:
        goto LABEL_20;
    }
    *v28 = v31;
    v28[1] = 1;
    v54[0] = v30;
  }
  else
  {
    psMd5Sha1Init(v51);
    psMd5Sha1Update((int *)v51, a1 + 16, 0x20u);
    psMd5Sha1Update((int *)v51, a1 + 48, 0x20u);
    psMd5Sha1Update((int *)v51, v13, (unsigned int)&v54[0][-v13]);
    psMd5Sha1Final(v51, (int)v14);
    v30 = v54[0];
    v29 = 36;
  }
  *v30 = HIBYTE(*(_WORD *)(*(_DWORD *)(a1 + 3144) + 112));
  v32 = *(_WORD *)(*(_DWORD *)(a1 + 3144) + 112);
  *++v54[0] = v32;
  v12 = *(_DWORD *)(a1 + 3372);
  ++v54[0];
  if ( ((v12 >> 14) & 1) != 0 && *(_DWORD *)(a1 + 3580) == 1 )
  {
    free2(v14);
    memcpy(v54[0], *(_DWORD *)(a1 + 4640), *(_DWORD *)(a1 + 4636));
    v12 = *(_DWORD *)(a1 + 3372);
    v54[0] += *(_DWORD *)(a1 + 4636);
  }
  else
  {
    v33 = a1 + 3148;
    if ( *(_WORD *)(a1 + 3162) )
    {
      v33 = a1 + 3172;
      if ( *(_WORD *)(a1 + 3186) )
        v33 = 0;
    }
    v34 = 2;
    if ( ((v12 >> 13) & 1) != 0 )
      v34 = 1;
    v35 = *(_DWORD *)(a1 + 3144);
    *(_WORD *)(v33 + 12) = v29;
    *(_WORD *)(v33 + 14) = v34;
    v36 = v54[0];
    v37 = *(unsigned __int16 *)(v35 + 112);
    *(_DWORD *)v33 = v14;
    *(_DWORD *)(v33 + 4) = v36;
    *(_DWORD *)(v33 + 8) = v8;
    v54[0] = &v36[v37];
  }
LABEL_10:
  if ( (v12 & 0x10000) == 0 )
    goto LABEL_31;
  v14 = (_DWORD *)malloc(48);
  v11 = -8;
  if ( !v14 )
    return v11;
  v15 = *(_DWORD *)(a1 + 3372);
  if ( ((v15 >> 13) & 1) != 0 )
  {
    v16 = v15 >> 13;
    if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 3144) + 116) + 8) == 524 )
    {
      psSha256Init(v51);
      psSha256Update((int *)v51, a1 + 16, 0x20u);
      psSha256Update((int *)v51, a1 + 48, 0x20u);
      psSha256Update((int *)v51, v13, (unsigned int)&v54[0][-v13]);
      psSha256Final((int)v51, (int)v14);
      v38 = v54[0];
      v39 = 32;
      v40 = 4;
      goto LABEL_53;
    }
  }
  else
  {
    v16 = v15 >> 13;
  }
  if ( (v16 & 1) == 0 || *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 3144) + 116) + 8) != 525 )
  {
    v17 = *(unsigned __int8 *)(a1 + 3390);
    if ( v17 >= 3
      && v17 != 255
      && (((v15 >> 13) & 1) == 0 || *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 3144) + 116) + 8) != 520) )
    {
LABEL_20:
      free2(v14);
      return -10;
    }
    psSha1Init(v51);
    psSha1Update((int *)v51, a1 + 16, 0x20u);
    psSha1Update((int *)v51, a1 + 48, 0x20u);
    psSha1Update((int *)v51, v13, (unsigned int)&v54[0][-v13]);
    psSha1Final(v51, (int)v14);
    v41 = *(_DWORD *)(a1 + 3372);
    v39 = 20;
    if ( ((v41 >> 13) & 1) != 0 )
    {
      v42 = v54[0];
      *v54[0] = 2;
      v42[1] = 3;
      v41 = *(_DWORD *)(a1 + 3372);
      v54[0] = v42 + 2;
    }
    goto LABEL_57;
  }
  psSha384Init(v51);
  psSha384Update((int *)v51, a1 + 16, 0x20u);
  psSha384Update((int *)v51, a1 + 48, 0x20u);
  psSha384Update((int *)v51, v13, (unsigned int)&v54[0][-v13]);
  psSha384Final((int)v51, v14);
  v38 = v54[0];
  v39 = 48;
  v40 = 5;
LABEL_53:
  *v38 = v40;
  v38[1] = 3;
  v41 = *(_DWORD *)(a1 + 3372);
  v54[0] = v38 + 2;
LABEL_57:
  if ( ((v41 >> 14) & 1) != 0 && *(_DWORD *)(a1 + 3580) == 1 )
  {
    free2(v14);
    memcpy(v54[0], *(_DWORD *)(a1 + 4640), *(_DWORD *)(a1 + 4636));
    v54[0] += *(_DWORD *)(a1 + 4636);
  }
  else
  {
    v43 = a1 + 3148;
    if ( *(_WORD *)(a1 + 3162) )
    {
      v11 = -7;
      if ( *(_WORD *)(a1 + 3186) )
        return v11;
      v43 = a1 + 3172;
    }
    if ( !v43 )
      return -7;
    v44 = *(_DWORD *)(a1 + 3144);
    *(_WORD *)(v43 + 14) = 3;
    *(_WORD *)(v43 + 12) = v39;
    v45 = v54[0];
    v46 = *(unsigned __int16 *)(v44 + 112);
    *(_DWORD *)v43 = v14;
    *(_DWORD *)(v43 + 8) = v8;
    *(_DWORD *)(v43 + 4) = v45;
    v47 = v46 + 8;
    if ( v46 != 132 )
      v47 = v46 + 9;
    v48 = &v45[v47];
    if ( v47 - 3 >= 128 )
      v48 = &v45[++v47];
    *(_WORD *)(v43 + 16) = v47;
    v54[0] = v48;
  }
LABEL_31:
  v11 = sub_45B4B0(a1, 22, 12, v50[0], v49[0], v53, (int)a2, (int *)v54);
  if ( v11 < 0 )
    return v11;
  a2[2] = (int)v54[0];
  return 0;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0045DA18) --------------------------------------------------------
int   sub_45DA18(int a1, int *a2, int a3)
{
  int v4; // $v1
  int v5; // $a3
  int v6; // $a2
  int v7; // $fp
  int v8; // $s1
  int v9; // $s2
  int i; // $s0
  int v11; // $t4
  int v12; // $t4
  int v13; // $s0
  int v14; // $a0
  int v15; // $s3
  int v16; // $s6
  unsigned int v17; // $fp
  _BYTE *v18; // $a1
  int v19; // $s7
  unsigned int v20; // $s1
  int v21; // $s4
  int v22; // $a0
  int v23; // $s0
  BOOL v24; // $t6
  int v25; // $s0
  int v26; // $a0
  int v27; // $v0
  char *v28; // $s2
  _BYTE *v30; // $a0
  int v31; // $a0
  unsigned int v32; // $a3
  unsigned int v33; // $v0
  unsigned __int16 v34; // $t0
  unsigned int v35; // $s0
  _BYTE *v36; // $a0
  BOOL v37; // $ra
  _BYTE *v38; // $v0
  int v39; // $v0
  int v40; // $v0
  int v41; // $s1
  unsigned int v42; // $s0
  unsigned int v43; // $a0
  unsigned int v44; // $a2
  int v45; // $a1
  int v46; // $a2
  _BYTE *v47; // $v1
  bool v48; // dc
  int v49; // $a0
  unsigned int v50; // $s0
  int v51; // $a0
  int v52; // $a1
  unsigned __int16 v53; // $a2
  unsigned int v54; // $t7
  int v55; // $a0
  int v56; // $a0
  _BYTE v57[2]; // [sp+28h] [-20h] BYREF
  unsigned __int16 v58; // [sp+2Ah] [-1Eh] BYREF
  _BYTE v59[2]; // [sp+2Ch] [-1Ch] BYREF
  unsigned __int16 v60; // [sp+2Eh] [-1Ah] BYREF
  int v61; // [sp+30h] [-18h] BYREF
  _BYTE *v62; // [sp+34h] [-14h] BYREF
  int v63; // [sp+38h] [-10h] BYREF
  char *v64; // [sp+3Ch] [-Ch] BYREF
  int v65; // [sp+40h] [-8h]
  int v66; // [sp+44h] [-4h]

  v4 = 0;
  if ( ((*(_DWORD *)(a1 + 3372) >> 18) & 1) != 0 )
    return v4;
  v5 = *a2;
  v6 = a2[3];
  v64 = (char *)a2[2];
  v7 = v5 + v6;
  v8 = 0;
  v9 = 0;
  if ( a3 )
  {
    for ( i = *(_DWORD *)(*(_DWORD *)(a1 + 3144) + 116); i; v9 += v12 )
    {
      while ( 1 )
      {
        ++v8;
        if ( !*(_DWORD *)(i + 784) )
          break;
        v11 = *(unsigned __int16 *)(i + 788);
        i = *(_DWORD *)(i + 796);
        v9 += v11;
        if ( !i )
          goto LABEL_8;
      }
      psTraceStr("psAssert %s", (int)"sslEncode.c");
      psTraceInt(":%d ", 5199);
      psError((int)"cert->unparsedBin != NULL");
      v12 = *(unsigned __int16 *)(i + 788);
      i = *(_DWORD *)(i + 796);
    }
  }
LABEL_8:
  v13 = 3 * v8 + 3;
  v14 = *(_DWORD *)(a1 + 4664);
  v15 = v9 + v13;
  v16 = *(_DWORD *)(a1 + 3328);
  if ( v16 >= v9 + v13 + v14 )
  {
    v58 = *(_WORD *)(a1 + 4660) + v14 + v13 + v9;
    v40 = sub_45AD54(a1, 0x16u, 0xBu, &v58, v57, &v63, v7, (int *)&v64);
    v4 = v40;
    if ( v40 < 0 )
    {
      if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 && v40 == -60 )
      {
        v27 = dtlsWriteCertificate(a1, v9, v13, v64);
        v4 = v27;
        if ( v27 >= 0 )
        {
          v28 = &v64[v27];
          a2[2] = (int)&v64[v27];
          v4 = 0;
          v64 = v28;
        }
      }
      return v4;
    }
    *v64++ = (unsigned int)(v15 - 3) >> 16;
    *v64++ = (unsigned __int16)(v15 - 3) >> 8;
    *v64++ = v15 - 3;
    if ( !a3 || (v41 = *(_DWORD *)(*(_DWORD *)(a1 + 3144) + 116)) == 0 )
    {
LABEL_56:
      v4 = sub_45B4B0(a1, 22, 11, v58, v57[0], v63, (int)a2, (int *)&v64);
      if ( v4 >= 0 )
      {
        v4 = 0;
        a2[2] = (int)v64;
      }
      return v4;
    }
    while ( 1 )
    {
      if ( *(_DWORD *)(v41 + 784) )
      {
        v42 = *(unsigned __int16 *)(v41 + 788);
        v43 = v42 >> 8;
        v44 = v42;
        if ( *(_WORD *)(v41 + 788) )
          goto LABEL_55;
      }
      else
      {
        psTraceStr("psAssert %s", (int)"sslEncode.c");
        psTraceInt(":%d ", 5269);
        psError((int)"cert->unparsedBin != NULL");
        v42 = *(unsigned __int16 *)(v41 + 788);
        v43 = v42 >> 8;
        v44 = v42;
        if ( *(_WORD *)(v41 + 788) )
        {
LABEL_55:
          *v64++ = 0;
          *v64++ = v43;
          *v64 = v42;
          v45 = *(_DWORD *)(v41 + 784);
          memcpy(++v64, v45, v44);
          v64 += v42;
        }
      }
      v41 = *(_DWORD *)(v41 + 796);
      if ( !v41 )
        goto LABEL_56;
    }
  }
  v17 = 0;
  v18 = (_BYTE *)a2[2];
  v65 = *a2 + a2[3];
  v62 = v18;
  v19 = v9;
  v20 = 0;
  v66 = 0;
  v21 = 0;
  if ( v9 <= 0 )
    goto LABEL_58;
  v60 = v15 + *(_WORD *)(a1 + 4660) + v14;
  v4 = sub_45AD54(a1, 0x5Au, 0xBu, &v60, v59, &v61, v65, (int *)&v62);
  if ( v4 < 0 )
    return v4;
  *v62++ = (unsigned int)(v15 - 3) >> 16;
  *v62++ = (unsigned __int16)(v15 - 3) >> 8;
  *v62 = v15 - 3;
  v22 = v16 - *(_DWORD *)(a1 + 4664);
  ++v62;
  v23 = v22 - 3;
  if ( !a3 )
    goto LABEL_30;
  v21 = *(_DWORD *)(*(_DWORD *)(a1 + 3144) + 116);
  if ( !v21 )
    goto LABEL_30;
  while ( 1 )
  {
    v17 = 0;
    if ( !*(_DWORD *)(v21 + 784) )
    {
      psTraceStr("psAssert %s", (int)"sslEncode.c");
      psTraceInt(":%d ", 4878);
      psError((int)"cert->unparsedBin != NULL");
    }
    v20 = *(unsigned __int16 *)(v21 + 788);
    if ( !*(_WORD *)(v21 + 788) )
      goto LABEL_19;
    if ( v23 < 4 )
      break;
    v17 = v23 - 3;
    *v62 = (v20 & 0xFF0000) >> 16;
    v24 = v20 < v23 - 3;
    *++v62 = BYTE1(v20);
    v25 = v23 - 3;
    *++v62 = v20;
    v26 = (int)++v62;
    if ( v24 )
      v17 = v20;
    memcpy(v26, *(_DWORD *)(v21 + 784), v17);
    v23 = v25 - v17;
    v62 += v17;
    v20 -= v17;
    v19 -= v17;
    if ( !v23 )
      goto LABEL_30;
LABEL_19:
    v21 = *(_DWORD *)(v21 + 796);
    if ( !v21 )
      goto LABEL_30;
  }
  *v62 = 0;
  v30 = v62;
  v66 = 2;
  ++v62;
  if ( v23 != 1 )
  {
    v30[1] = BYTE1(v20);
    v31 = (int)v62++;
    v66 = 1;
    if ( v23 != 2 )
    {
      *(_BYTE *)(v31 + 1) = v20;
      v66 = 0;
      ++v62;
    }
  }
LABEL_30:
  v4 = sub_45B4B0(a1, 22, 11, v60, v59[0], v61, (int)a2, (int *)&v62);
  if ( v4 >= 0 )
  {
    while ( 1 )
    {
      v18 = v62;
      if ( v19 <= 0 )
        break;
      a2[2] = (int)v62;
      if ( !v21 )
        return -1;
      if ( v66 <= 0 )
        v60 = 0;
      else
        v60 = v66;
      v32 = *(_DWORD *)(a1 + 3328);
      v33 = v20 + v60;
      if ( v32 >= v33 )
      {
        v51 = *(_DWORD *)(v21 + 796);
        v60 = v33;
        if ( v51 )
        {
          v52 = v51;
          v53 = v33;
          while ( 1 )
          {
            v54 = v53 + *(unsigned __int16 *)(v52 + 788) + 3;
            v53 += *(_WORD *)(v52 + 788) + 3;
            if ( v32 < v54 )
              break;
            v52 = *(_DWORD *)(v52 + 796);
            if ( !v52 )
            {
              v60 = v53;
              goto LABEL_37;
            }
          }
          v60 = v32;
        }
      }
      else
      {
        v60 += v32;
      }
LABEL_37:
      v34 = v60;
      v60 += *(_WORD *)(a1 + 4660);
      v35 = v34;
      v4 = sub_45AD54(a1, 0x5Bu, 0xBu, &v60, v59, &v61, v65, (int *)&v62);
      if ( v4 < 0 )
        return v4;
      if ( v66 <= 0 )
      {
        v36 = v62;
        v37 = v35 < v20;
      }
      else
      {
        if ( v66 == 2 )
        {
          *v62 = BYTE1(v20);
          v35 -= 2;
          ++v62;
        }
        else
        {
          --v35;
        }
        *v62 = v20;
        v36 = ++v62;
        v66 = 0;
        v37 = v35 < v20;
      }
      if ( v37 )
      {
        memcpy(v36, *(_DWORD *)(v21 + 784) + v17, v35);
        v17 += v35;
        v38 = &v62[v35];
        v20 -= v35;
        v19 -= v35;
LABEL_44:
        v62 = v38;
      }
      else
      {
        memcpy(v36, *(_DWORD *)(v21 + 784) + v17, v20);
        v46 = v35 - v20;
        v47 = &v62[v20];
        v19 -= v20;
        v62 += v20;
        v48 = (int)(v35 - v20) <= 0;
        v20 = 0;
        if ( !v48 )
        {
          do
          {
            v21 = *(_DWORD *)(v21 + 796);
            v50 = v46 - 3;
            if ( !v21 )
              return -1;
            v20 = *(unsigned __int16 *)(v21 + 788);
            v17 = 0;
            if ( v46 < 4 )
            {
              *v47 = 0;
              v55 = (int)v62++;
              v66 = 2;
              if ( v46 != 1 )
              {
                *(_BYTE *)(v55 + 1) = BYTE1(v20);
                v56 = (int)v62++;
                v66 = 1;
                if ( v46 != 2 )
                {
                  *(_BYTE *)(v56 + 1) = v20;
                  v66 = 0;
                  v38 = v62 + 1;
                  goto LABEL_44;
                }
              }
              break;
            }
            *v47 = (v20 & 0xFF0000) >> 16;
            v17 = v46 - 3;
            *++v62 = BYTE1(v20);
            *++v62 = v20;
            v49 = (int)++v62;
            if ( v20 < v50 )
              v17 = v20;
            memcpy(v49, *(_DWORD *)(v21 + 784), v17);
            v46 = v50 - v17;
            v47 = &v62[v17];
            v62 += v17;
            v20 -= v17;
            v19 -= v17;
          }
          while ( v50 != v17 && v46 > 0 );
        }
      }
      v39 = sub_45B4B0(a1, 22, 11, v60, v59[0], v61, (int)a2, (int *)&v62);
      if ( v39 < 0 )
        return v39;
    }
LABEL_58:
    v4 = 0;
    a2[2] = (int)v18;
  }
  return v4;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0045E42C) --------------------------------------------------------
int   matrixSslEncodeClientHello(
        int a1,
        _DWORD *a2,
        unsigned __int16 *a3,
        unsigned __int8 a4,
        _DWORD *a5,
        int a6,
        int a7)
{
  int v10; // $s3
  unsigned int v11; // $v1
  int v12; // $v1
  unsigned int v13; // $a3
  int v14; // $t5
  int v15; // $v1
  unsigned __int8 v16; // $a0
  int v17; // $a1
  int v18; // $a2
  int v19; // $v1
  unsigned __int16 v20; // $a0
  int CipherSpecListLen; // $s6
  int PrngLocked; // $a3
  char v23; // $a1
  unsigned __int8 v24; // $a0
  int v25; // $s0
  __int16 v26; // $a1
  bool v27; // dc
  unsigned int v28; // $a2
  int v29; // $a2
  int v30; // $v1
  int v31; // $s1
  int v32; // $t9
  _BYTE *v33; // $t5
  int v34; // $s0
  unsigned int v35; // $v1
  int v36; // $a0
  unsigned int v37; // $a2
  char v38; // $t0
  int v39; // $a3
  _DWORD *v40; // $t4
  int v41; // $t8
  int v42; // $t7
  int v43; // $t6
  int v44; // $t5
  int v45; // $a1
  int v46; // $ra
  int v47; // $fp
  char v48; // $a0
  int v49; // $a2
  _BYTE *v50; // $a0
  int CipherSpecList; // $v0
  _BYTE *v52; // $a0
  unsigned int v53; // $v1
  _BYTE *v54; // $a0
  _BYTE *v55; // $a3
  _BYTE *v56; // $a1
  _BYTE *v57; // $v1
  int v58; // $s0
  unsigned int v59; // $s6
  int v60; // $a0
  char v61; // $a1
  int v62; // $t8
  _BYTE *v63; // $v0
  int v64; // $a2
  int v65; // $a0
  int v66; // $a1
  int v67; // $a2
  _BYTE *v69; // $a1
  int v70; // $a0
  _BYTE *v71; // $a0
  int v72; // $v1
  int v73; // $s4
  int v74; // $s6
  int v75; // $t3
  int v76; // $v0
  int v77; // $v0
  int v78; // $a0
  int v79; // $a2
  int v80; // $a0
  int v81; // $v0
  unsigned int v82; // $t4
  unsigned int v83; // $v0
  int v84; // $s1
  unsigned __int16 *v85; // $s0
  __int16 *CipherSpec; // $v0
  int v87; // $v0
  int v88; // $a1
  unsigned __int16 *v89; // $a2
  unsigned __int16 v90; // $t7
  int v91; // $a1
  int v92; // $a2
  _BYTE *v93; // $t6
  int v94; // $a1
  __int16 v95; // $t7
  __int16 v96; // $s4
  int v97; // $s0
  int v98; // $a1
  int v99; // $a2
  int v100; // $a2
  char v101[2]; // [sp+28h] [-58h] BYREF
  unsigned __int16 v102[3]; // [sp+2Ah] [-56h] BYREF
  _BYTE v103[18]; // [sp+30h] [-50h] BYREF
  _BYTE v104[32]; // [sp+48h] [-38h] BYREF
  unsigned __int8 v105[4]; // [sp+68h] [-18h] BYREF
  int v106; // [sp+6Ch] [-14h] BYREF
  _BYTE *v107; // [sp+70h] [-10h] BYREF
  int v108; // [sp+74h] [-Ch]
  int v109; // [sp+78h] [-8h]
  _BYTE *v110; // [sp+7Ch] [-4h]

  v10 = a4;
  *a5 = 0;
  v110 = 0;
  if ( !a2 || !*a2 || !a1 || !a7 )
    return -6;
  if ( a4 )
  {
    PrngLocked = -6;
    if ( !a3 )
      return PrngLocked;
    if ( !*a3 )
      return -6;
  }
  v11 = *(_DWORD *)(a1 + 3372);
  if ( ((v11 >> 6) & 1) == 0 && ((v11 >> 4) & 1) == 0 && (v11 & 1) == 0 )
  {
    v12 = *(unsigned __int8 *)(a1 + 3384);
    if ( v12 == 2 || v12 == 255 || !*(_BYTE *)(a1 + 3384) )
    {
      sslInitHSHash((_DWORD *)a1);
      v13 = *(_DWORD *)(a1 + 3372);
      v108 = 0;
      if ( ((v13 >> 14) & 1) != 0 )
      {
        v14 = *(_DWORD *)(a1 + 3432);
        v108 = 1;
        if ( v14 )
          v108 = (unsigned __int16)(*(_DWORD *)(a1 + 3428) + 1);
        v15 = (unsigned __int8)v10;
        v16 = v10;
        if ( (unsigned __int8)v10 >= 9u )
        {
          v16 = 8;
          v15 = 8;
        }
        *(_BYTE *)(a1 + 3528) = v16;
        v17 = 0;
        if ( v15 )
        {
          v18 = v16;
          do
          {
            v19 = 2 * v17;
            v20 = a3[v17++];
            *(_WORD *)(v19 + a1 + 3512) = v20;
          }
          while ( v17 < v18 );
        }
      }
      if ( !*(_BYTE *)(a1 + 3224) )
        *(_DWORD *)(a1 + 3372) = v13 & 0xFFFFFFF7;
      if ( v10 )
      {
        if ( a3 )
        {
          LOWORD(CipherSpecListLen) = 2;
          if ( *a3 )
          {
            LOWORD(v84) = 0;
            v85 = a3;
            while ( 1 )
            {
              CipherSpec = sslGetCipherSpec(a1, *v85);
              v84 = (__int16)(v84 + 1);
              CipherSpecListLen = (unsigned __int16)(CipherSpecListLen + 2);
              ++v85;
              if ( !CipherSpec )
                return -10;
              if ( v84 >= v10 )
                goto LABEL_26;
            }
          }
        }
      }
      CipherSpecListLen = (unsigned __int16)sslGetCipherSpecListLen(a1);
      PrngLocked = -12;
      if ( CipherSpecListLen == 2 )
        return PrngLocked;
LABEL_26:
      if ( *(_WORD *)(a7 + 10) )
      {
        v23 = *(_BYTE *)(a1 + 3390);
        PrngLocked = -12;
        if ( v23 == 3 )
          return PrngLocked;
        v24 = *(_BYTE *)(a1 + 3224);
        if ( v24 )
          return PrngLocked;
        CipherSpecListLen = (unsigned __int16)(CipherSpecListLen + 2);
        *(_DWORD *)(a1 + 4656) |= 0x400u;
      }
      else
      {
        v24 = *(_BYTE *)(a1 + 3224);
        v23 = *(_BYTE *)(a1 + 3390);
      }
      v102[0] = *(_WORD *)(a1 + 4660) + *(_WORD *)(a1 + 4664) + v24 + CipherSpecListLen + v108 + 37;
      v25 = 0;
      if ( v23 && (v26 = *(_WORD *)(a7 + 2), v26 > 0) && v26 < 0x4000 )
      {
        if ( v26 != 512 && v26 != 1024 && v26 != 2048 )
        {
          PrngLocked = -6;
          if ( v26 != 4096 )
          {
            *(_DWORD *)(a1 + 3328) = 0x4000;
            return PrngLocked;
          }
        }
        v25 = 7;
        *(_DWORD *)(a1 + 3328) = v26 | 0x10000;
      }
      else
      {
        *(_DWORD *)(a1 + 3328) = 0x4000;
      }
      if ( *(_WORD *)(a7 + 4) )
      {
        v27 = v25 != 0;
        v25 += 4;
        if ( !v27 )
          v25 = 6;
      }
      if ( *(__int16 *)(a7 + 6) >= 0 )
      {
        v27 = v25 != 0;
        v25 += 4;
        if ( !v27 )
          v25 = 6;
      }
      v105[0] = 0;
      if ( eccSuitesSupported(a1, a3, v10) )
      {
        v28 = *(_DWORD *)(a7 + 16);
        v105[0] = 32;
        if ( v28 )
          userSuppliedEccList(v104, v105, v28);
        else
          psGetEccCurveIdList((int)v104, v105);
        if ( v105[0] )
        {
          v29 = v105[0] + v25;
          if ( !v25 )
            v29 = v105[0] + 2;
          v25 = v29 + 12;
        }
      }
      v109 = 0;
      if ( *(_WORD *)a7 == 1 )
      {
        v87 = *(_DWORD *)(a1 + 3260);
        v109 = 1;
        if ( v87 )
        {
          if ( !v25 )
            v25 = 2;
          v25 += 4;
          if ( *(_WORD *)(v87 + 94) && *(_WORD *)(v87 + 92) == 5 )
            v25 += *(unsigned __int16 *)(v87 + 94);
        }
      }
      if ( *(_WORD *)(a7 + 12) == 1 )
      {
        if ( !v25 )
          v25 = 2;
        v25 += 9;
      }
      v103[9] = 3;
      v103[10] = 4;
      v103[12] = 6;
      v103[14] = 5;
      v103[16] = 2;
      v103[17] = 1;
      v103[1] = 16;
      v103[2] = 4;
      v103[3] = 3;
      v103[4] = 6;
      v103[5] = 3;
      v103[6] = 5;
      v103[7] = 3;
      v103[8] = 2;
      v103[11] = 1;
      v103[13] = 1;
      v103[15] = 1;
      v103[0] = 0;
      if ( !v25 )
        v25 = 2;
      v30 = a6;
      *(_WORD *)(a1 + 3404) = 29812;
      v31 = v25 + 22;
      if ( a6 )
      {
        if ( v25 == -22 )
          v31 = 2;
        do
        {
          v32 = *(_DWORD *)(v30 + 8);
          v30 = *(_DWORD *)(v30 + 16);
          v31 += v32 + 4;
        }
        while ( v30 );
      }
      if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 && *(int *)(a1 + 3440) > 0 )
        v31 = *(_DWORD *)(a1 + 3440);
      v33 = (_BYTE *)a2[2];
      v34 = *a2 + a2[3];
      v102[0] += v31;
      v107 = v33;
      PrngLocked = sub_45AD54(a1, 0x16u, 1u, v102, v101, &v106, v34, (int *)&v107);
      if ( PrngLocked < 0 )
      {
        *a5 = v102[0];
        return PrngLocked;
      }
      v35 = *(_DWORD *)(a1 + 3372);
      v36 = 1;
      if ( ((v35 >> 14) & 1) != 0 )
      {
        v37 = v35 >> 14;
        if ( !*(_DWORD *)(a1 + 3432) )
          goto LABEL_68;
        v36 = 0;
      }
      v37 = v35 >> 14;
LABEL_68:
      if ( (v37 & 1) == 0 || *(_DWORD *)(a1 + 3580) != 1 )
      {
        if ( v36 )
        {
          PrngLocked = psGetPrngLocked(a1 + 16, 0x20u);
          if ( PrngLocked < 0 )
            return PrngLocked;
        }
      }
      *v107 = *(_BYTE *)(a1 + 3389);
      v38 = *(_BYTE *)(a1 + 3390);
      *++v107 = v38;
      v39 = *(_DWORD *)(a1 + 16);
      v40 = v107 + 1;
      v107 = v40;
      v41 = *(_DWORD *)(a1 + 32);
      v42 = *(_DWORD *)(a1 + 36);
      v43 = *(_DWORD *)(a1 + 40);
      v44 = *(_DWORD *)(a1 + 44);
      v45 = *(_DWORD *)(a1 + 20);
      v46 = *(_DWORD *)(a1 + 24);
      v47 = *(_DWORD *)(a1 + 28);
      *v40 = v39;
      v40[1] = v45;
      v40[2] = v46;
      v40[3] = v47;
      v40[4] = v41;
      v40[5] = v42;
      v40[6] = v43;
      v40[7] = v44;
      v48 = *(_BYTE *)(a1 + 3224);
      v107 += 32;
      *v107 = v48;
      v49 = *(unsigned __int8 *)(a1 + 3224);
      v50 = ++v107;
      if ( v49 )
      {
        memcpy(v50, a1 + 3225, v49);
        v50 = &v107[*(unsigned __int8 *)(a1 + 3224)];
        v107 = v50;
      }
      if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
      {
        if ( *(_DWORD *)(a1 + 3432) )
        {
          *v50 = *(_DWORD *)(a1 + 3428);
          v91 = *(_DWORD *)(a1 + 3424);
          v92 = *(_DWORD *)(a1 + 3428);
          memcpy(++v107, v91, v92);
          v50 = &v107[*(_DWORD *)(a1 + 3428)];
        }
        else
        {
          *v50 = 0;
          v50 = v107 + 1;
        }
        v107 = v50;
      }
      if ( v10 && a3 && *a3 )
      {
        PrngLocked = -50;
        if ( v34 - (int)v50 < CipherSpecListLen )
          return PrngLocked;
        *v50 = (unsigned __int16)(CipherSpecListLen - 2) >> 8;
        LOWORD(v88) = 0;
        *++v107 = CipherSpecListLen - 2;
        v52 = ++v107;
        v89 = a3;
        do
        {
          *v52 = HIBYTE(*v89);
          v90 = *v89;
          *++v107 = v90;
          v88 = (__int16)(v88 + 1);
          v52 = ++v107;
          ++v89;
        }
        while ( v88 < v10 );
        if ( ((*(_DWORD *)(a1 + 4656) >> 10) & 1) == 0 )
        {
LABEL_83:
          *v52 = 1;
          *++v107 = 0;
          v53 = *(_DWORD *)(a1 + 3372);
          v54 = v107;
          v55 = v107 + 1;
          v56 = v107 + 1;
          if ( ((v53 >> 14) & 1) != 0 )
            v110 = v107 + 1;
          if ( !v31 )
            goto LABEL_125;
          v31 -= 2;
          ++v107;
          v54[1] = BYTE1(v31);
          *++v107 = v31;
          v57 = ++v107;
          if ( a6 )
          {
            v58 = a6;
            do
            {
              v83 = *(_DWORD *)(v58 + 4);
              if ( v83 )
              {
                if ( v83 == 16 )
                {
                  *(_DWORD *)(a1 + 4656) |= 0x80u;
                  v83 = *(_DWORD *)(v58 + 4);
                }
                v59 = v83 >> 8;
              }
              else
              {
                *(_DWORD *)(a1 + 4656) |= 1u;
                v59 = *(_DWORD *)(v58 + 4) >> 8;
              }
              *v57 = v59;
              v60 = *(_DWORD *)(v58 + 4);
              *++v107 = v60;
              v61 = *(_BYTE *)(v58 + 9);
              *++v107 = v61;
              v62 = *(_DWORD *)(v58 + 8);
              *++v107 = v62;
              v63 = v107;
              v64 = *(_DWORD *)(v58 + 8);
              v65 = (int)++v107;
              if ( v64 == 1 )
              {
                v66 = *(_DWORD *)(v58 + 12);
                if ( !v66 )
                {
                  v63[1] = 0;
                  goto LABEL_94;
                }
              }
              else
              {
                v66 = *(_DWORD *)(v58 + 12);
              }
              memcpy(v65, v66, v64);
LABEL_94:
              v67 = *(_DWORD *)(v58 + 8);
              v58 = *(_DWORD *)(v58 + 16);
              v57 = &v107[v67];
              v107 += v67;
            }
            while ( v58 );
          }
          if ( (*(_WORD *)(a1 + 3330) & 1) != 0 )
          {
            *(_DWORD *)(a1 + 4656) |= 2u;
            *v57 = 0;
            *++v107 = 1;
            *++v107 = 0;
            *++v107 = 1;
            v69 = v107;
            v70 = *(__int16 *)(a7 + 2);
            v57 = ++v107;
            switch ( v70 )
            {
              case 512:
                v69[1] = 1;
                v57 = ++v107;
                goto LABEL_110;
              case 1024:
                v69[1] = 2;
                v57 = v107 + 1;
                break;
              case 2048:
                v69[1] = 3;
                v57 = v107 + 1;
                break;
              case 4096:
                v69[1] = 4;
                v57 = v107 + 1;
                break;
              default:
                goto LABEL_110;
            }
            v107 = v57;
          }
LABEL_110:
          if ( v105[0] )
          {
            *(_DWORD *)(a1 + 4656) |= 0x10u;
            *v57 = 0;
            *++v107 = 10;
            *++v107 = (unsigned __int16)(v105[0] + 2) >> 8;
            *++v107 = v105[0] + 2;
            *++v107 = 0;
            *++v107 = v105[0];
            memcpy(++v107, v104, v105[0]);
            v93 = &v107[v105[0]];
            *(_DWORD *)(a1 + 4656) |= 0x20u;
            v107 = v93;
            *v93 = 0;
            *++v107 = 11;
            *++v107 = 0;
            *++v107 = 2;
            *++v107 = 1;
            *++v107 = 0;
            v57 = ++v107;
          }
          *(_DWORD *)(a1 + 4656) |= 0x40u;
          *v57 = 0;
          *++v107 = 13;
          *++v107 = 0;
          *++v107 = 18;
          memcpy(++v107, v103, 18);
          v71 = v107;
          v55 = v107 + 18;
          v56 = v107 + 18;
          if ( v109 )
          {
            v72 = *(_DWORD *)(a1 + 3260);
            if ( v72 )
            {
              v73 = *(unsigned __int16 *)(v72 + 94);
              v107 += 18;
              if ( v73 && *(_WORD *)(v72 + 92) == 5 )
              {
                *(_DWORD *)(a1 + 4656) |= 0x100u;
                v71[18] = 0;
                *++v107 = 35;
                v95 = *(_WORD *)(*(_DWORD *)(a1 + 3260) + 94);
                *++v107 = HIBYTE(v95);
                v96 = *(_WORD *)(*(_DWORD *)(a1 + 3260) + 94);
                *++v107 = v96;
                v97 = *(_DWORD *)(a1 + 3260);
                v98 = *(_DWORD *)(v97 + 88);
                v99 = *(unsigned __int16 *)(v97 + 94);
                memcpy(++v107, v98, v99);
                v100 = *(_DWORD *)(a1 + 3260);
                v55 = &v107[*(unsigned __int16 *)(v100 + 94)];
                v56 = v55;
                *(_WORD *)(v100 + 92) = 2;
              }
              else
              {
                *(_DWORD *)(a1 + 4656) |= 0x100u;
                v71[18] = 0;
                *++v107 = 35;
                *++v107 = 0;
                *++v107 = 0;
                v55 = v107 + 1;
                v56 = v107 + 1;
                *(_WORD *)(*(_DWORD *)(a1 + 3260) + 92) = 1;
              }
            }
          }
          if ( *(_WORD *)(a7 + 12) )
          {
            v74 = *(_DWORD *)(a1 + 4656);
            v107 = v55;
            *(_DWORD *)(a1 + 4656) = v74 | 0x800;
            *v56 = 0;
            *++v107 = 5;
            *++v107 = 0;
            *++v107 = 5;
            *++v107 = 1;
            *++v107 = 0;
            *++v107 = 0;
            *++v107 = 0;
            *++v107 = 0;
            v55 = v107 + 1;
            v56 = v107 + 1;
          }
          if ( *(_WORD *)(a7 + 4) )
          {
            v75 = *(_DWORD *)(a1 + 4656);
            v107 = v55;
            *(_DWORD *)(a1 + 4656) = v75 | 4;
            *v56 = 0;
            *++v107 = 4;
            *++v107 = 0;
            *++v107 = 0;
            v55 = v107 + 1;
            v56 = v107 + 1;
          }
          v76 = *(__int16 *)(a7 + 6);
          if ( v76 < 0 )
          {
            v78 = *(_DWORD *)(a1 + 3372) >> 14;
            goto LABEL_126;
          }
          v107 = v55;
          if ( v76 <= 0 )
            v77 = *(_DWORD *)(a1 + 4656) | 8;
          else
            v77 = *(_DWORD *)(a1 + 4656) | 0x400008;
          *(_DWORD *)(a1 + 4656) = v77;
          *v56 = 0;
          *++v107 = 23;
          *++v107 = 0;
          *++v107 = 0;
          v53 = *(_DWORD *)(a1 + 3372);
          v55 = v107 + 1;
          v56 = v107 + 1;
LABEL_125:
          v78 = v53 >> 14;
LABEL_126:
          if ( (v78 & 1) != 0 && v31 )
          {
            v79 = *(_DWORD *)(a1 + 3440);
            if ( !v79 )
            {
              v80 = v56 - v110;
              v107 = v55;
              *(_DWORD *)(a1 + 3440) = v56 - v110;
              v81 = malloc(v80);
              *(_DWORD *)(a1 + 3436) = v81;
              PrngLocked = -8;
              if ( v81 )
              {
                memcpy(v81, v110, *(_DWORD *)(a1 + 3440));
                goto LABEL_131;
              }
              return PrngLocked;
            }
            v94 = *(_DWORD *)(a1 + 3436);
            v107 = v110;
            memcpy(v110, v94, v79);
            v107 += *(_DWORD *)(a1 + 3440);
          }
          else
          {
            v107 = v55;
          }
LABEL_131:
          PrngLocked = sub_45BE58(a1, 22, 0, v102[0], (unsigned __int8)v101[0], v106, (int)a2, (int *)&v107);
          if ( PrngLocked >= 0 )
          {
            a2[2] = v107;
            if ( *(unsigned __int8 *)(a1 + 3384) == 255 )
              sslResetContext(a1);
            v82 = *(_DWORD *)(a1 + 3372) & 0xFFFFFF7F;
            PrngLocked = 0;
            *(_BYTE *)(a1 + 3384) = 2;
            *(_DWORD *)(a1 + 3372) = v82;
          }
          return PrngLocked;
        }
        *v52 = 86;
        *++v107 = 0;
        v52 = v107 + 1;
      }
      else
      {
        CipherSpecList = sslGetCipherSpecList(a1, v50, v34 - (_DWORD)v50);
        PrngLocked = -50;
        if ( CipherSpecList < 0 )
          return PrngLocked;
        v52 = &v107[CipherSpecList];
      }
      v107 = v52;
      goto LABEL_83;
    }
  }
  return -12;
}
// 45E788: conditional instruction was optimized away because $s7.4!=0
// 45F0F0: conditional instruction was optimized away because $s3.4 is in (1..FF)
// 45F204: conditional instruction was optimized away because $s3.4 is in (1..FF)
// 45E770: conditional instruction was optimized away because %arg_18.4!=0
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0045F5A0) --------------------------------------------------------
int   sub_45F5A0(int a1, int *a2)
{
  _BYTE *v3; // $v1
  int v4; // $a0
  int v5; // $v0
  int v7; // $a1
  int v8; // $s3
  int v9; // $s5
  int v10; // $s2
  int Keys; // $v1
  unsigned int v13; // $a1
  unsigned int v14; // $t5
  unsigned int v15; // $v0
  unsigned int v16; // $t2
  unsigned __int16 v17; // $v0
  int v18; // $v0
  int v19; // $s0
  unsigned int v20; // $v1
  unsigned int v21; // $t0
  int v22; // $a1
  unsigned int v23; // $a0
  int v24; // $ra
  _BYTE *v25; // $a2
  int v26; // $a0
  __int16 v27; // $s2
  int v28; // $v0
  _BYTE *v29; // $v0
  char v30; // $t3
  int PrngLocked; // $v0
  unsigned __int16 v32; // $t6
  _BYTE *v33; // $t4
  int v34; // $t6
  int v35; // $v0
  int v36; // $a0
  int v37; // $a1
  int v38; // $v0
  unsigned __int16 v39; // $a2
  int v40; // $v0
  int v41; // $t0
  __int16 v42; // $a2
  int v43; // $v0
  int v44; // $t3
  _BYTE v45[2]; // [sp+28h] [-18h] BYREF
  unsigned __int16 v46; // [sp+2Ah] [-16h] BYREF
  unsigned __int16 v47; // [sp+2Ch] [-14h] BYREF
  unsigned __int8 v48[2]; // [sp+2Eh] [-12h] BYREF
  int v49; // [sp+30h] [-10h] BYREF
  int v50; // [sp+34h] [-Ch] BYREF
  _BYTE *v51; // [sp+38h] [-8h] BYREF
  int v52; // [sp+3Ch] [-4h] BYREF

  v3 = (_BYTE *)a2[2];
  v4 = *a2;
  v5 = a2[3];
  v7 = *(unsigned __int16 *)(a1 + 3162);
  v51 = v3;
  v8 = v4 + v5;
  v46 = 0;
  v47 = 0;
  v9 = *(_DWORD *)(a1 + 4688);
  v10 = a1 + 3148;
  if ( v7 )
  {
    v10 = a1 + 3172;
    if ( *(_WORD *)(a1 + 3186) )
      return -7;
  }
  Keys = -7;
  if ( !v10 )
    return Keys;
  v13 = *(_DWORD *)(a1 + 3372);
  if ( ((v13 >> 18) & 1) == 0 )
    goto LABEL_7;
  if ( matrixSslPskGetKeyId(a1, &v49, v48) < 0 )
  {
    free2(*(_DWORD *)(a1 + 3116));
    Keys = -12;
    *(_DWORD *)(a1 + 3116) = 0;
    return Keys;
  }
  v13 = *(_DWORD *)(a1 + 3372);
  v14 = v13 >> 17;
  if ( ((v13 >> 14) & 1) == 0 )
  {
    free2(*(_DWORD *)(a1 + 3116));
    v13 = *(_DWORD *)(a1 + 3372);
    *(_DWORD *)(a1 + 3116) = 0;
LABEL_7:
    v14 = v13 >> 17;
  }
  if ( (v14 & 1) != 0 )
  {
    if ( ((v13 >> 14) & 1) != 0 )
    {
      v15 = v13 >> 19;
      if ( *(_DWORD *)(a1 + 3580) == 1 )
      {
        v46 = *(_DWORD *)(a1 + 4636);
        goto LABEL_13;
      }
    }
    else
    {
      v15 = v13 >> 19;
    }
    v16 = v13 >> 18;
    if ( (v15 & 1) == 0 )
    {
LABEL_14:
      if ( (v16 & 1) == 0 )
        goto LABEL_17;
      v17 = v48[0] + v47 + 2;
      goto LABEL_16;
    }
    v46 = 2 * **(unsigned __int8 **)(*(_DWORD *)(a1 + 3124) + 52) + 2;
LABEL_13:
    v16 = v13 >> 18;
    goto LABEL_14;
  }
  if ( ((v13 >> 18) & 1) != 0 )
  {
    v17 = v48[0] + v47;
LABEL_16:
    v47 = v17;
    goto LABEL_17;
  }
  if ( (unsigned __int16)(*(_WORD *)(*(_DWORD *)(a1 + 3344) + 2) - 8) >= 2u )
    v46 = *(_WORD *)(*(_DWORD *)(a1 + 600) + 148);
  else
    v46 = 2 * **(unsigned __int8 **)(*(_DWORD *)(a1 + 600) + 92) + 2;
LABEL_17:
  v18 = *(_DWORD *)(a1 + 4660) + *(_DWORD *)(a1 + 4664) + v46 + v47;
  v19 = 0;
  if ( ((v13 >> 11) & 1) != 0 )
  {
    LOWORD(v18) = v18 + 2;
    v19 = 1;
  }
  v47 = v18;
  if ( ((v13 >> 17) & 1) != 0 )
  {
    v20 = v13 >> 18;
    if ( v19 )
      goto LABEL_23;
    v19 = 1;
    v47 += 2;
  }
  v20 = v13 >> 18;
LABEL_23:
  v21 = v13 >> 19;
  if ( (v20 & 1) == 0 )
  {
LABEL_26:
    v22 = v21 & 1;
    goto LABEL_27;
  }
  v22 = (v13 & 0x80000) != 0;
  if ( !v19 )
  {
    v19 = 1;
    v47 += 2;
    goto LABEL_26;
  }
LABEL_27:
  if ( v22 && v19 == 1 )
  {
    v19 = 0;
    v47 -= 2;
  }
  Keys = sub_45AD54(a1, 0x16u, 0x10u, &v47, v45, &v50, v8, (int *)&v51);
  if ( Keys < 0 )
    return Keys;
  if ( v19 == 1 )
  {
    if ( ((*(_DWORD *)(a1 + 3372) >> 18) & 1) != 0 )
    {
      *v51++ = 0;
      *v51++ = v48[0];
      memcpy(v51, v49, v48[0]);
      v51 += v48[0];
    }
    if ( v46 )
    {
      *v51++ = HIBYTE(v46);
      *v51++ = v46;
    }
  }
  v23 = *(_DWORD *)(a1 + 3372);
  if ( ((v23 >> 14) & 1) != 0 && *(_DWORD *)(a1 + 3580) == 1 )
  {
    memcpy(v51, *(_DWORD *)(a1 + 4640), *(_DWORD *)(a1 + 4636));
    v51 += *(_DWORD *)(a1 + 4636);
  }
  else if ( ((v23 >> 17) & 1) != 0 )
  {
    if ( ((v23 >> 19) & 1) != 0 )
    {
      *v51 = --v46;
      v36 = *(_DWORD *)(a1 + 3216);
      v37 = *(_DWORD *)(a1 + 3124);
      v38 = psEccX963ExportKey(v36, v37, ++v51, &v46);
      Keys = -12;
      if ( v38 < 0 )
        return Keys;
      v39 = v46;
      if ( (unsigned __int8)*(v51 - 1) != v46 )
      {
        psTraceStr("psAssert %s", (int)"sslEncode.c");
        psTraceInt(":%d ", 6621);
        psError((int)"keyLen == (uint32) * (c - 1)");
        v39 = v46;
      }
      if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
      {
        *(_DWORD *)(a1 + 4636) = v39 + 1;
        v40 = malloc(v39 + 1);
        *(_DWORD *)(a1 + 4640) = v40;
        Keys = -8;
        if ( !v40 )
          return Keys;
        memcpy(v40, v51 - 1, *(_DWORD *)(a1 + 4636));
        v39 = v46;
      }
      v41 = v39;
      v42 = **(unsigned __int8 **)(*(_DWORD *)(a1 + 3124) + 52);
      v51 += v41;
      *(_WORD *)(a1 + 132) = v42;
      v43 = malloc((unsigned __int8)v42);
      *(_DWORD *)(a1 + 128) = v43;
      Keys = -8;
      if ( !v43 )
        return Keys;
      *(_DWORD *)v10 = 0;
      v44 = *(_DWORD *)(a1 + 128);
      *(_DWORD *)(v10 + 8) = v9;
      *(_WORD *)(v10 + 14) = 6;
      *(_DWORD *)(v10 + 4) = v44;
      *(_WORD *)(v10 + 12) = 0;
    }
  }
  else if ( ((v23 >> 18) & 1) != 0 )
  {
    matrixSslPskGetKey(a1, v49, v48[0], &v52, v48);
    Keys = -12;
    if ( !v52 )
      return Keys;
    v34 = 2 * v48[0];
    *(_WORD *)(a1 + 132) = v34 + 4;
    v35 = malloc(v34 + 4);
    *(_DWORD *)(a1 + 128) = v35;
    Keys = -8;
    if ( !v35 )
      return Keys;
    memset(v35, 0, *(unsigned __int16 *)(a1 + 132));
    **(_BYTE **)(a1 + 128) = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 128) + 1) = v48[0];
    *(_BYTE *)(*(_DWORD *)(a1 + 128) + v48[0] + 2) = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 128) + v48[0] + 3) = v48[0];
    memcpy(*(_DWORD *)(a1 + 128) + v48[0] + 4, v52, v48[0]);
    if ( ((*(_DWORD *)(a1 + 4656) >> 17) & 1) == 0 )
    {
      Keys = sslCreateKeys(a1);
      if ( Keys < 0 )
        return Keys;
    }
  }
  else if ( (unsigned __int16)(*(_WORD *)(*(_DWORD *)(a1 + 3344) + 2) - 8) >= 2u )
  {
    *(_WORD *)(a1 + 132) = 48;
    v29 = (_BYTE *)malloc(48);
    *(_DWORD *)(a1 + 128) = v29;
    Keys = -8;
    if ( !v29 )
      return Keys;
    v30 = *(_BYTE *)(a1 + 3388);
    *v29 = *(_BYTE *)(a1 + 3387);
    v29[1] = v30;
    PrngLocked = psGetPrngLocked((int)(v29 + 2), 0x2Eu);
    Keys = -12;
    if ( PrngLocked < 0 )
      return Keys;
    v32 = v46;
    v33 = &v51[v46];
    *(_DWORD *)(v10 + 4) = v51;
    *(_WORD *)(v10 + 14) = 4;
    *(_DWORD *)(v10 + 8) = v9;
    *(_WORD *)(v10 + 16) = v32;
    v51 = v33;
    *(_DWORD *)(v10 + 20) = 0;
  }
  else
  {
    *v51 = --v46;
    v24 = v46;
    v25 = v51 + 1;
    v26 = *(_DWORD *)(a1 + 600);
    *(_WORD *)(v10 + 14) = 5;
    *(_WORD *)(v10 + 16) = v24;
    *(_DWORD *)(v10 + 4) = v25;
    *(_DWORD *)(v10 + 8) = v9;
    *(_DWORD *)(v10 + 20) = 0;
    v27 = **(unsigned __int8 **)(v26 + 92);
    v51 = &v25[v24];
    *(_WORD *)(a1 + 132) = v27;
    v28 = malloc((unsigned __int8)v27);
    *(_DWORD *)(a1 + 128) = v28;
    Keys = -8;
    if ( !v28 )
      return Keys;
  }
  Keys = sub_45B4B0(a1, 22, 16, v47, v45[0], v50, (int)a2, (int *)&v51);
  if ( Keys < 0 )
    return Keys;
  a2[2] = (int)v51;
  return 0;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0045FE18) --------------------------------------------------------
int   sub_45FE18(int a1, int *a2)
{
  int *v3; // $a0
  int v5; // $s7
  int *v6; // $s0
  _BYTE *v7; // $a2
  _BYTE *v8; // $a0
  _BYTE *v9; // $v1
  _BYTE *v10; // $t8
  _BYTE *v11; // $s3
  _BYTE *v12; // $t6
  _BYTE *v13; // $t3
  unsigned int v14; // $a2
  int result; // $v0
  int v16; // $s1
  int *v17; // $a0
  int v18; // $v0
  _BYTE *v19; // $t4
  _BYTE *v20; // $t9
  _BYTE *v21; // $a3
  _BYTE *v22; // $v1
  _BYTE *v23; // $ra
  _BYTE *v24; // $s3
  _BYTE *v25; // $t6
  int v26; // $s5
  int v27; // $v1
  _BYTE *v28; // $s1
  char *v29; // $a2
  unsigned __int16 v30; // $a3
  int v31; // $ra
  int v32; // $s5
  int v33; // $a0
  int v34; // $s3
  int v35; // $s1
  __int16 v36; // $t7
  __int16 v37; // $t6
  int v38; // $a0
  int v39; // $v1
  int v40; // $t2
  int v41; // $t0
  _BYTE *v42; // $a0
  _BYTE *v43; // $v1
  _BYTE *v44; // $t8
  _BYTE *v45; // $s3
  _BYTE *v46; // $t6
  int v47; // $s1
  int v48; // $a0
  int *v49; // $s1
  int v50; // $s1
  int v51; // $a0
  int v52; // $s4
  int (  *v53)(int, int, int, unsigned __int16, unsigned __int8 *, unsigned __int16); // $t9
  int v54; // $a0
  int v55; // $t4
  int v56; // $t3
  __int16 v57; // $t2
  __int16 v58; // $t1
  int v59; // $s1
  int v60; // $v0
  int v61; // $s3
  int v62; // $v0
  unsigned int v63; // $a2
  int v64; // $s4
  int v65; // $fp
  int v66; // $v1
  int v67; // $a0
  int v68; // $a0
  int v69; // $s0
  int v70; // $a0
  int v71; // $s0
  int v72; // $a0
  int v73; // $s0
  int v74; // [sp+28h] [-68h] BYREF
  int v75; // [sp+2Ch] [-64h]
  int v76; // [sp+30h] [-60h]
  _DWORD v77[4]; // [sp+38h] [-58h] BYREF
  _DWORD v78[4]; // [sp+48h] [-48h] BYREF
  char v79; // [sp+58h] [-38h] BYREF
  unsigned __int16 v80; // [sp+88h] [-8h] BYREF
  int v81; // [sp+8Ch] [-4h] BYREF

  v3 = *(int **)(a1 + 3196);
  v5 = *a2;
  v6 = v3;
  if ( !v3 )
  {
LABEL_50:
    if ( v3 )
    {
      while ( 1 )
      {
        v47 = v3[8];
        free2(v3);
        v48 = v47;
        if ( !v47 )
          break;
        v49 = *(int **)(v47 + 32);
        free2(v48);
        v3 = v49;
        if ( !v49 )
        {
          *(_DWORD *)(a1 + 3196) = 0;
          return 0;
        }
      }
    }
    *(_DWORD *)(a1 + 3196) = 0;
    return 0;
  }
  while ( 1 )
  {
    v18 = (*(_DWORD *)(a1 + 3372) >> 14) & 1;
    v81 = *v6 + v6[2];
    if ( v18 )
    {
      if ( v6[6] == 20 )
      {
        incrTwoByte(a1, (_BYTE *)(a1 + 3529), 1);
        zeroSixByte(a1 + 3537);
      }
      *(_BYTE *)v6[1] = *(_BYTE *)(a1 + 3529);
      v19 = (_BYTE *)(v6[1] + 1);
      v6[1] = (int)v19;
      *v19 = *(_BYTE *)(a1 + 3530);
      v20 = (_BYTE *)(v6[1] + 1);
      v6[1] = (int)v20;
      *v20 = *(_BYTE *)(a1 + 3537);
      v21 = (_BYTE *)(v6[1] + 1);
      v6[1] = (int)v21;
      *v21 = *(_BYTE *)(a1 + 3538);
      v22 = (_BYTE *)(v6[1] + 1);
      v6[1] = (int)v22;
      *v22 = *(_BYTE *)(a1 + 3539);
      v23 = (_BYTE *)(v6[1] + 1);
      v6[1] = (int)v23;
      *v23 = *(_BYTE *)(a1 + 3540);
      v24 = (_BYTE *)(v6[1] + 1);
      v6[1] = (int)v24;
      *v24 = *(_BYTE *)(a1 + 3541);
      v25 = (_BYTE *)(v6[1] + 1);
      v6[1] = (int)v25;
      *v25 = *(_BYTE *)(a1 + 3542);
      v6[1] += 3;
    }
    if ( v6[6] != 20 )
      goto LABEL_17;
    result = sslActivateWriteCipher(a1);
    v50 = result;
    if ( result < 0 )
      break;
    result = sslSnapshotHSHash((int *)a1, *(_DWORD *)(a1 + 3200), *(_DWORD *)(a1 + 3372) & 1);
    v16 = result;
    if ( result <= 0 )
    {
      v51 = *(_DWORD *)(a1 + 3196);
      if ( v51 )
      {
        do
        {
          v52 = *(_DWORD *)(v51 + 32);
          free2(v51);
          v51 = v52;
        }
        while ( v52 );
        goto LABEL_61;
      }
LABEL_62:
      *(_DWORD *)(a1 + 3196) = 0;
      return result;
    }
LABEL_17:
    v14 = *(_DWORD *)(a1 + 3372);
    if ( ((v14 >> 22) & 1) != 0 )
    {
      v75 = *v6 - *(_DWORD *)(a1 + 4660) - 8;
      v76 = v75;
      v74 = v75;
      if ( ((v14 >> 14) & 1) != 0 )
      {
        *(_BYTE *)v6[1] = *(_BYTE *)(a1 + 3529);
        v7 = (_BYTE *)(v6[1] + 1);
        v6[1] = (int)v7;
        *v7 = *(_BYTE *)(a1 + 3530);
        v8 = (_BYTE *)(v6[1] + 1);
        v6[1] = (int)v8;
        *v8 = *(_BYTE *)(a1 + 3537);
        v9 = (_BYTE *)(v6[1] + 1);
        v6[1] = (int)v9;
        *v9 = *(_BYTE *)(a1 + 3538);
        v10 = (_BYTE *)(v6[1] + 1);
        v6[1] = (int)v10;
        *v10 = *(_BYTE *)(a1 + 3539);
        v11 = (_BYTE *)(v6[1] + 1);
        v6[1] = (int)v11;
        *v11 = *(_BYTE *)(a1 + 3540);
        v12 = (_BYTE *)(v6[1] + 1);
        v6[1] = (int)v12;
        *v12 = *(_BYTE *)(a1 + 3541);
        v13 = (_BYTE *)(v6[1] + 1);
        v6[1] = (int)v13;
        *v13 = *(_BYTE *)(a1 + 3542);
        v14 = *(_DWORD *)(a1 + 3372);
        ++v6[1];
      }
      else
      {
        *(_BYTE *)v6[1] = *(_BYTE *)(a1 + 576);
        v40 = v6[1];
        v6[1] = v40 + 1;
        *(_BYTE *)(v40 + 1) = *(_BYTE *)(a1 + 577);
        v41 = v6[1];
        v6[1] = v41 + 1;
        *(_BYTE *)(v41 + 1) = *(_BYTE *)(a1 + 578);
        v42 = (_BYTE *)(v6[1] + 1);
        v6[1] = (int)v42;
        *v42 = *(_BYTE *)(a1 + 579);
        v43 = (_BYTE *)(v6[1] + 1);
        v6[1] = (int)v43;
        *v43 = *(_BYTE *)(a1 + 580);
        v44 = (_BYTE *)(v6[1] + 1);
        v6[1] = (int)v44;
        *v44 = *(_BYTE *)(a1 + 581);
        v45 = (_BYTE *)(v6[1] + 1);
        v6[1] = (int)v45;
        *v45 = *(_BYTE *)(a1 + 582);
        v46 = (_BYTE *)(v6[1] + 1);
        v6[1] = (int)v46;
        *v46 = *(_BYTE *)(a1 + 583);
        v14 = *(_DWORD *)(a1 + 3372);
      }
      if ( v6[6] != 15 )
        goto LABEL_6;
    }
    else
    {
      v26 = v6[6];
      v75 = *v6 - *(_DWORD *)(a1 + 4660);
      v76 = v75;
      v74 = v75;
      if ( v26 != 15 )
        goto LABEL_6;
    }
    v77[3] = *(_DWORD *)(a1 + 3316) - (v5 - v75);
    v77[0] = v75;
    v77[1] = v75;
    v77[2] = v5;
    if ( ((v14 >> 14) & 1) != 0 && *(_DWORD *)(a1 + 3580) )
      goto LABEL_43;
    if ( sslSnapshotHSHash((int *)a1, (int)v78, -1) <= 0 )
      return -12;
    if ( ((*(_DWORD *)(a1 + 3372) >> 13) & 1) != 0 )
    {
      v27 = *(unsigned __int16 *)(a1 + 3160);
      if ( v27 == 48 )
      {
        sslSha384SnapshotHSHash(a1, v78);
      }
      else if ( *(unsigned __int16 *)(a1 + 3160) >= 0x31u )
      {
        if ( v27 == 64 )
          sslSha512SnapshotHSHash(a1, (int)v78);
      }
      else if ( v27 == 20 )
      {
        sslSha1SnapshotHSHash(a1, (int)v78);
      }
    }
    if ( !*(_WORD *)(a1 + 3162) )
      return -12;
    if ( *(unsigned __int16 *)(a1 + 3162) < 3u )
    {
      if ( ((*(_DWORD *)(a1 + 3372) >> 13) & 1) != 0 )
        v53 = privRsaEncryptSignedElement;
      else
        v53 = psRsaEncryptPriv;
      if ( v53(
             0,
             *(_DWORD *)(a1 + 3144) + 4,
             (int)v78,
             *(_WORD *)(a1 + 3160),
             *(unsigned __int8 **)(a1 + 3152),
             *(_WORD *)(*(_DWORD *)(a1 + 3144) + 112)) >= 0
        && ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
      {
        v59 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 3144) + 112);
        *(_DWORD *)(a1 + 4648) = v59;
        v60 = malloc(v59);
        *(_DWORD *)(a1 + 4644) = v60;
        if ( v60 )
          memcpy(v60, *(_DWORD *)(a1 + 3152), v59);
      }
      v54 = *(_DWORD *)(a1 + 3148);
      if ( v54 )
      {
        free2(v54);
        *(_DWORD *)(a1 + 3148) = 0;
      }
      if ( *(_WORD *)(a1 + 3186) )
      {
        v55 = *(_DWORD *)(a1 + 3176);
        v56 = *(_DWORD *)(a1 + 3180);
        v57 = *(_WORD *)(a1 + 3184);
        v58 = *(_WORD *)(a1 + 3188);
        *(_WORD *)(a1 + 3162) = *(_WORD *)(a1 + 3186);
        *(_DWORD *)(a1 + 3152) = v55;
        *(_DWORD *)(a1 + 3156) = v56;
        *(_WORD *)(a1 + 3160) = v57;
        *(_WORD *)(a1 + 3164) = v58;
        *(_WORD *)(a1 + 3186) = 0;
        *(_DWORD *)(a1 + 3176) = 0;
        *(_DWORD *)(a1 + 3180) = 0;
        *(_WORD *)(a1 + 3184) = 0;
        *(_WORD *)(a1 + 3188) = 0;
      }
      else
      {
        *(_WORD *)(a1 + 3164) = 0;
        *(_WORD *)(a1 + 3160) = 0;
        *(_DWORD *)(a1 + 3156) = 0;
        *(_DWORD *)(a1 + 3152) = 0;
        *(_WORD *)(a1 + 3162) = 0;
      }
      goto LABEL_43;
    }
    if ( *(_WORD *)(a1 + 3162) != 3 )
      return -12;
    v28 = (_BYTE *)malloc(*(unsigned __int16 *)(a1 + 3164) + 1);
    result = -8;
    if ( v28 )
    {
      if ( ((*(_DWORD *)(a1 + 3372) >> 13) & 1) != 0 )
      {
        v30 = *(_WORD *)(a1 + 3160);
        v29 = (char *)v78;
      }
      else
      {
        v29 = &v79;
        v30 = 20;
      }
      v31 = *(_DWORD *)(a1 + 3144);
      v80 = *(_WORD *)(a1 + 3164) + 1;
      *(_DWORD *)(a1 + 4652) = 0;
      v32 = psEccDsaSign(0, v31 + 4, v29, v30, v28, &v80, 1u);
      if ( !v32 )
      {
        if ( *(unsigned __int16 *)(a1 + 3164) == v80 )
        {
          memcpy(*(_DWORD *)(a1 + 3152), v28, v80);
          goto LABEL_36;
        }
        v32 = sub_459804(a1, a1 + 3148, v80, (int)v28, v77, 15);
        if ( v32 >= 0 )
        {
LABEL_36:
          if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
          {
            v61 = v80;
            *(_DWORD *)(a1 + 4648) = v80;
            v62 = malloc(v61);
            *(_DWORD *)(a1 + 4644) = v62;
            if ( v62 )
              memcpy(v62, *(_DWORD *)(a1 + 3152), v61);
            else
              v32 = -8;
          }
        }
      }
      free2(v28);
      v33 = *(_DWORD *)(a1 + 3148);
      if ( v33 )
      {
        free2(v33);
        *(_DWORD *)(a1 + 3148) = 0;
      }
      if ( *(_WORD *)(a1 + 3186) )
      {
        v34 = *(_DWORD *)(a1 + 3176);
        v35 = *(_DWORD *)(a1 + 3180);
        v36 = *(_WORD *)(a1 + 3184);
        v37 = *(_WORD *)(a1 + 3188);
        *(_WORD *)(a1 + 3162) = *(_WORD *)(a1 + 3186);
        *(_DWORD *)(a1 + 3152) = v34;
        *(_DWORD *)(a1 + 3156) = v35;
        *(_WORD *)(a1 + 3160) = v36;
        *(_WORD *)(a1 + 3164) = v37;
        *(_WORD *)(a1 + 3186) = 0;
        *(_DWORD *)(a1 + 3176) = 0;
        *(_DWORD *)(a1 + 3180) = 0;
        *(_WORD *)(a1 + 3184) = 0;
        *(_WORD *)(a1 + 3188) = 0;
      }
      else
      {
        *(_WORD *)(a1 + 3164) = 0;
        *(_WORD *)(a1 + 3160) = 0;
        *(_DWORD *)(a1 + 3156) = 0;
        *(_DWORD *)(a1 + 3152) = 0;
        *(_WORD *)(a1 + 3162) = 0;
      }
      result = v32;
    }
    if ( result < 0 )
      return result;
LABEL_43:
    v14 = *(_DWORD *)(a1 + 3372);
    v38 = *v6;
    v81 = *v6 + v6[2];
    if ( ((v14 >> 20) & 1) == 0 )
    {
      v75 = v38 - *(_DWORD *)(a1 + 4660);
      v76 = v75;
      v74 = v75;
LABEL_6:
      if ( ((v14 >> 14) & 1) == 0 )
        goto LABEL_47;
      goto LABEL_7;
    }
    v39 = v38 - *(_DWORD *)(a1 + 4660);
    if ( ((v14 >> 22) & 1) != 0 )
      v39 -= 8;
    v75 = v39;
    v76 = v39;
    v74 = v39;
    if ( ((v14 >> 14) & 1) == 0 )
      goto LABEL_47;
LABEL_7:
    if ( v6[7] > 0 )
    {
      result = dtlsEncryptFragRecord(a1, v6, (int)&v74, &v81);
      goto LABEL_9;
    }
LABEL_47:
    result = sub_45BE58(a1, v6[3], v6[6], v6[4], v6[5], *v6, (int)&v74, &v81);
LABEL_9:
    v16 = result;
    *a2 = v81;
    if ( result == -15 )
    {
      v63 = *(_DWORD *)(a1 + 3372);
      v64 = *(_DWORD *)(a1 + 4660);
      v65 = *v6 + v6[4];
      v66 = v65 - v64;
      if ( ((v63 >> 20) & 1) != 0 )
      {
        v67 = v65 - v64;
        if ( ((v63 >> 22) & 1) != 0 )
          v67 = v66 - 8;
        *a2 = v67;
      }
      else
      {
        *a2 = v66;
      }
      *(_DWORD *)(a1 + 3196) = v6[8];
      free2(v6);
      return -15;
    }
    v17 = v6;
    if ( result < 0 )
    {
      v68 = *(_DWORD *)(a1 + 3196);
      if ( v68 )
      {
        while ( 1 )
        {
          v69 = *(_DWORD *)(v68 + 32);
          free2(v68);
          v70 = v69;
          if ( !v69 )
            break;
          v71 = *(_DWORD *)(v69 + 32);
          free2(v70);
          v68 = v71;
          if ( !v71 )
          {
            result = v16;
            goto LABEL_62;
          }
        }
LABEL_61:
        result = v16;
      }
      goto LABEL_62;
    }
    v6 = (int *)v6[8];
    *(_DWORD *)(a1 + 3196) = v6;
    free2(v17);
    if ( !v6 )
    {
      v3 = *(int **)(a1 + 3196);
      goto LABEL_50;
    }
  }
  v72 = *(_DWORD *)(a1 + 3196);
  if ( !v72 )
    goto LABEL_62;
  do
  {
    v73 = *(_DWORD *)(v72 + 32);
    free2(v72);
    v72 = v73;
  }
  while ( v73 );
  result = v50;
  *(_DWORD *)(a1 + 3196) = 0;
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0046097C) --------------------------------------------------------
int   sub_46097C(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  int v5; // $t0
  char *v6; // $a3
  __int16 v7; // $s4
  int v8; // $v0
  int v10; // $v1
  int v12; // $s7
  unsigned __int16 v13; // $a1
  int v14; // $s0
  char *v15; // $v0
  int v16; // $s6
  int v17; // $s2
  int v18; // $s5
  int v19; // $v1
  char *v20; // $v1
  _BYTE *v21; // $a0
  int v22; // $t6
  int v23; // $a2
  int v24; // $s0
  char *v25; // $a1
  int v26; // $fp
  int v27; // $a0
  int v28; // $s1
  __int16 v29; // $a1
  int v30; // $a0
  int v31; // $v0
  char *v32; // $a2
  _BYTE *v33; // $a3
  int v34; // $t5
  int v35; // $s0
  __int16 v36; // $ra
  char *v37; // $v1
  __int16 v38; // $s2
  int v39; // $a1
  int v40; // $a2
  int v41; // $v1
  int v43; // $a0
  char *v44; // $s2
  unsigned int v45; // $a3
  unsigned __int16 v46; // $v0
  unsigned __int16 v47; // $t6
  int v48; // $s1
  char *v49; // $a0
  char *v50; // $v0
  int v51; // $v0
  char *v52; // $a0
  int v53; // $a2
  int v54; // $a0
  int v55; // $s1
  BOOL v56; // $a2
  int v57; // $a0
  int v58; // $a1
  unsigned __int16 v59; // $a2
  unsigned int v60; // $t2
  char v61[2]; // [sp+28h] [-20h] BYREF
  unsigned __int16 v62; // [sp+2Ah] [-1Eh] BYREF
  _BYTE v63[2]; // [sp+2Ch] [-1Ch] BYREF
  unsigned __int16 v64; // [sp+2Eh] [-1Ah] BYREF
  int v65; // [sp+30h] [-18h] BYREF
  char *v66; // [sp+34h] [-14h] BYREF
  int v67; // [sp+38h] [-10h] BYREF
  char *v68; // [sp+3Ch] [-Ch] BYREF
  int v69; // [sp+40h] [-8h]
  int v70; // [sp+44h] [-4h]

  v5 = a1[1165];
  v6 = (char *)a2[2];
  v7 = 2 * a4;
  v8 = v5 + a1[1166] + 2 * a4 + a3;
  v10 = (a1[843] >> 13) & 1;
  v69 = *a2 + a2[3];
  v68 = v6;
  v12 = 0;
  v13 = v8 + 5;
  if ( v10 )
  {
    v62 = v8 + 19;
    v14 = a1[832];
    v12 = 14;
    if ( v14 < (unsigned __int16)(v8 + 19) - v5 )
    {
      v15 = v6;
LABEL_4:
      v66 = v6;
      v16 = a3;
      v17 = 0;
      v18 = 0;
      v70 = 0;
      if ( a3 <= 0 )
      {
LABEL_28:
        a2[2] = v15;
        return 0;
      }
      v64 = a1[1165] + a1[1166] + v7 + a3 + v12 + 5;
      v19 = sub_45AD54((int)a1, 0x5Au, 0xDu, &v64, v63, &v65, v69, (int *)&v66);
      if ( v19 >= 0 )
      {
        v20 = v66;
        v66[1] = 64;
        *v20 = 2;
        v20[2] = 1;
        v21 = v20 + 3;
        v22 = (a1[843] >> 13) & 1;
        v66 = v20 + 3;
        v23 = v14 - 3;
        if ( v22 )
        {
          v21 = v20 + 17;
          v20[4] = v12 - 2;
          v20[10] = 3;
          v20[11] = 5;
          v20[13] = 4;
          v20[15] = 2;
          v20[16] = 1;
          v20[3] = 0;
          v20[5] = 5;
          v20[6] = 3;
          v20[7] = 4;
          v20[8] = 3;
          v20[9] = 2;
          v20[12] = 1;
          v20[14] = 1;
          v23 -= v12;
          v66 = v20 + 17;
        }
        v24 = *(_DWORD *)(a1[786] + 120);
        *v21 = (unsigned __int16)(v7 + a3) >> 8;
        *++v66 = v7 + a3;
        v25 = v66 + 1;
        v26 = v23 - a1[1166];
        ++v66;
        v27 = v26 - 2;
        while ( 1 )
        {
          v28 = v27 - 2;
          if ( !v24 )
            break;
          if ( !*(_DWORD *)(v24 + 392) )
            return -1;
          v17 = *(unsigned __int16 *)(v24 + 396);
          v18 = 0;
          if ( *(_WORD *)(v24 + 396) )
          {
            if ( v27 < 2 )
            {
              *v25 = BYTE1(v17);
              v70 = 1;
              ++v66;
              break;
            }
            *v25 = BYTE1(v17);
            v29 = *(_WORD *)(v24 + 396);
            *++v66 = v29;
            v18 = v17;
            v30 = (int)++v66;
            if ( v28 < v17 )
              v18 = v28;
            memcpy(v30, *(_DWORD *)(v24 + 392), v18);
            v25 = &v66[v18];
            v27 = v28 - v18;
            v66 += v18;
            v17 = (unsigned __int16)(v17 - v18);
            v16 -= v18;
            if ( v28 == v18 )
              break;
          }
          v24 = *(_DWORD *)(v24 + 796);
        }
        v19 = sub_45B4B0((int)a1, 22, 13, v64, v63[0], v65, (int)a2, (int *)&v66);
        if ( v19 >= 0 )
        {
          while ( 1 )
          {
            v15 = v66;
            if ( v16 <= 0 )
              goto LABEL_28;
            a2[2] = v66;
            if ( !v24 || !*(_DWORD *)(v24 + 392) )
              return -1;
            if ( v70 <= 0 )
              v64 = 0;
            else
              v64 = v70;
            v45 = a1[832];
            v46 = v17 + v64;
            if ( (int)v45 >= v64 + v16 )
            {
              v57 = *(_DWORD *)(v24 + 796);
              v64 += v17;
              if ( v57 )
              {
                v58 = v57;
                v59 = v46;
                while ( 1 )
                {
                  v60 = v59 + *(unsigned __int16 *)(v58 + 396) + 2;
                  v59 += *(_WORD *)(v58 + 396) + 2;
                  if ( v45 < v60 )
                    break;
                  v58 = *(_DWORD *)(v58 + 796);
                  if ( !v58 )
                  {
                    v64 = v59;
                    goto LABEL_42;
                  }
                }
                v64 = v45;
              }
            }
            else
            {
              v64 += v45;
            }
LABEL_42:
            v47 = v64;
            v64 += a1[1165];
            v48 = v47;
            v19 = sub_45AD54((int)a1, 0x5Bu, 0xDu, &v64, v63, &v65, v69, (int *)&v66);
            if ( v19 < 0 )
              return v19;
            if ( v70 <= 0 )
            {
              v49 = v66;
            }
            else
            {
              --v48;
              *v66 = v17;
              v49 = ++v66;
            }
            v70 = 0;
            if ( v48 >= v17 )
            {
              memcpy(v49, *(_DWORD *)(v24 + 392) + v18, v17);
              v52 = &v66[v17];
              v53 = v48 - v17;
              v16 -= v17;
              v17 = 0;
              v66 = v52;
              do
              {
                v55 = v53 - 2;
                if ( v53 <= 0 )
                  break;
                v24 = *(_DWORD *)(v24 + 796);
                v56 = v53 < 2;
                if ( !v24 )
                  return -1;
                v18 = 0;
                if ( !*(_DWORD *)(v24 + 392) )
                  return -1;
                v17 = *(unsigned __int16 *)(v24 + 396);
                if ( v56 )
                {
                  *v52 = BYTE1(v17);
                  v50 = v66 + 1;
                  v70 = 1;
                  goto LABEL_47;
                }
                *v52 = BYTE1(v17);
                *++v66 = v17;
                v18 = v17;
                v54 = (int)++v66;
                if ( v55 < v17 )
                  v18 = v55;
                memcpy(v54, *(_DWORD *)(v24 + 392), v18);
                v52 = &v66[v18];
                v53 = v55 - v18;
                v66 += v18;
                v17 = (unsigned __int16)(v17 - v18);
                v16 -= v18;
              }
              while ( v55 != v18 );
            }
            else
            {
              memcpy(v49, *(_DWORD *)(v24 + 392) + v18, v48);
              v50 = &v66[v48];
              v18 += v48;
              v17 = (unsigned __int16)(v17 - v48);
              v16 -= v48;
LABEL_47:
              v66 = v50;
            }
            v51 = sub_45B4B0((int)a1, 22, 13, v64, v63[0], v65, (int)a2, (int *)&v66);
            if ( v51 < 0 )
              return v51;
          }
        }
      }
      return v19;
    }
  }
  else
  {
    v62 = v8 + 5;
    v14 = a1[832];
    v15 = v6;
    if ( v14 < v13 - v5 )
      goto LABEL_4;
  }
  v31 = sub_45AD54((int)a1, 0x16u, 0xDu, &v62, v61, &v67, v69, (int *)&v68);
  v19 = v31;
  if ( v31 < 0 )
  {
    if ( ((a1[843] >> 14) & 1) != 0 && v31 == -60 )
    {
      v43 = dtlsWriteCertificateRequest(a1[804], (int)a1, a3, a4, v12, v68);
      v19 = v43;
      if ( v43 >= 0 )
      {
        v44 = &v68[v43];
        v19 = 0;
        a2[2] = &v68[v43];
        v68 = v44;
      }
    }
    return v19;
  }
  v32 = v68;
  v68[1] = 64;
  *v32 = 2;
  v32[2] = 1;
  v33 = v32 + 3;
  v34 = (a1[843] >> 13) & 1;
  v68 = v32 + 3;
  if ( v34 )
  {
    v33 = v32 + 17;
    v32[4] = v12 - 2;
    v32[10] = 3;
    v32[11] = 5;
    v32[13] = 4;
    v32[15] = 2;
    v32[16] = 1;
    v32[3] = 0;
    v32[5] = 5;
    v32[6] = 3;
    v32[7] = 4;
    v32[8] = 3;
    v32[9] = 2;
    v32[12] = 1;
    v32[14] = 1;
    v68 = v32 + 17;
  }
  v35 = *(_DWORD *)(a1[786] + 120);
  v36 = v7 + a3;
  if ( !v35 )
  {
    *v33 = 0;
    v33[1] = 0;
    v68 = v33 + 2;
LABEL_25:
    v19 = sub_45B4B0((int)a1, 22, 13, v62, (unsigned __int8)v61[0], v67, (int)a2, (int *)&v68);
    if ( v19 >= 0 )
    {
      v19 = 0;
      a2[2] = v68;
    }
    return v19;
  }
  *v33 = HIBYTE(v36);
  *++v68 = v36;
  v37 = ++v68;
  while ( *(_DWORD *)(v35 + 392) )
  {
    *v37 = HIBYTE(*(_WORD *)(v35 + 396));
    v38 = *(_WORD *)(v35 + 396);
    *++v68 = v38;
    v39 = *(_DWORD *)(v35 + 392);
    v40 = *(unsigned __int16 *)(v35 + 396);
    memcpy(++v68, v39, v40);
    v41 = *(unsigned __int16 *)(v35 + 396);
    v35 = *(_DWORD *)(v35 + 796);
    v37 = &v68[v41];
    v68 = v37;
    if ( !v35 )
      goto LABEL_25;
  }
  return -1;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0046126C) --------------------------------------------------------
int   sslEncodeResponse(int a1, int *a2, int *a3)
{
  int v5; // $a2
  int v6; // $a1
  int v7; // $s1
  int v8; // $a1
  int v9; // $v1
  int v10; // $t1
  char v11; // $s0
  char v12; // $s1
  int v13; // $v0
  int v14; // $s0
  int v15; // $a2
  int v17; // $ra
  unsigned int v18; // $t1
  unsigned int v19; // $v1
  unsigned int v20; // $a3
  int v21; // $v0
  int v22; // $t2
  char v23; // $t2
  char v24; // $t0
  int v25; // $a3
  int v26; // $s0
  unsigned int v27; // $a1
  unsigned int v28; // $a0
  unsigned int v29; // $s7
  int v30; // $v1
  int v31; // $a0
  int v32; // $s1
  int v33; // $v0
  unsigned int v34; // $t0
  int v35; // $a0
  int v36; // $s2
  int v37; // $v0
  int v38; // $t5
  int v39; // $v0
  int v40; // $v1
  int v41; // $s2
  int v42; // $a2
  int v43; // $t3
  __int16 v44; // $a0
  int v45; // $v1
  int v46; // $a0
  int v47; // $a3
  int v48; // $a1
  int v49; // $v1
  int v50; // $v0
  int v51; // $a0
  int v52; // $s2
  int v53; // $a2
  unsigned int v54; // $t2
  int v55; // $s5
  int v56; // $a2
  unsigned int v57; // $t0
  int v58; // $v1
  int v59; // $t0
  int v60; // $t2
  int v61; // $a0
  int v62; // $t7
  int v63; // $a3
  int v64; // $t3
  unsigned int v65; // $a2
  int v66; // $t6
  int v67; // $t5
  unsigned int v68; // $a3
  unsigned int v69; // $v1
  unsigned int v70; // $a3
  int v71; // $v0
  int v72; // $t4
  int v73; // $a0
  int v74; // $a1
  int v75; // $t0
  int v76; // $v0
  int v77; // $s7
  int v78; // $t0
  unsigned int v79; // $a1
  unsigned int v80; // $a2
  unsigned int v81; // $t4
  int v82; // $t4
  unsigned int v83; // $a3
  unsigned int v84; // $v1
  unsigned int v85; // $a3
  int v86; // $fp
  int v87; // $t2
  unsigned int v88; // $a2
  unsigned int v89; // $a1
  unsigned int v90; // $a0
  unsigned int v91; // $v0
  unsigned int v92; // $s6
  int v93; // $a0
  unsigned int v94; // $a0
  int v95; // $a1
  unsigned int v96; // $s5
  int v97; // $v1
  int v98; // $a0
  int v99; // $lo
  bool v100; // dc
  int v101; // $a1
  unsigned int v102; // $a0
  unsigned int v103; // $v1
  unsigned int v104; // $s1
  int v105; // $a0
  int v106; // $lo
  int v107; // $v0
  int v108; // $a2
  BOOL v109; // $s0
  unsigned int v110; // $a0
  int v111; // $a1
  unsigned int v112; // $t9
  int v113; // $s7
  int v114; // $a0
  int v115; // $lo
  int v116; // $a1
  unsigned int v117; // $a3
  int v118; // $t7
  unsigned int v119; // $a2
  unsigned int v120; // $a0
  unsigned int v121; // $t6
  int v122; // $a0
  int v123; // $v0
  unsigned int v124; // $t5
  int v125; // $v1
  int v126; // $v0
  unsigned int v127; // $v1
  unsigned int v128; // $s7
  int v129; // $s0
  int v130; // $t4
  int v131; // $fp
  int Hint; // $v0
  int v133; // $a0
  int v134; // $t7
  int v135; // $t1
  int v136; // $t4
  int v137; // $fp
  int v138; // $a1
  unsigned int v139; // $a0
  unsigned int v140; // $s0
  int v141; // $a2
  int v142; // $v1
  int v143; // $v0
  int v144; // $a3
  int v145; // $a1
  unsigned int v146; // $v1
  int v147; // $t7
  unsigned int v148; // $v0
  int v149; // $t6
  unsigned int v150; // $t4
  int v151; // $s1
  int v152; // $a2
  int v153; // $t2
  int v154; // $s0
  int v155; // $v1
  int v156; // $t0
  int v157; // $s2
  int v158; // $t4
  int v159; // $t5
  int v160; // $t3
  int v161; // $a2
  int v162; // $s1
  int v163; // $t5
  unsigned int v164; // $a3
  unsigned int v165; // $v1
  unsigned int v166; // $a3
  int v167; // $ra
  int v168; // $v1
  int v169; // $t0
  int v170; // $s2
  int v171; // $v1
  int v172; // $ra
  int v173; // $s7
  int v174; // $s5
  __int16 v175; // $a0
  int v176; // $v0
  int v177; // $a0
  int v178; // $t0
  int v179; // $a1
  int v180; // $a0
  int v181; // $a3
  int v182; // $a2
  int v183; // $t2
  unsigned int v184; // $a1
  unsigned int v185; // $a0
  unsigned int v186; // $ra
  int v187; // $a0
  int v188; // $t1
  int v189; // $v1
  _BYTE *v190; // $t1
  _BYTE *v191; // $a3
  int v192; // $a1
  int v193; // $t4
  int v194; // $t6
  int v195; // $s6
  unsigned int v196; // $a2
  unsigned int v197; // $s0
  int v198; // $t4
  unsigned int v199; // $a3
  unsigned int v200; // $v1
  unsigned int v201; // $a3
  int v202; // $fp
  int v203; // $t2
  unsigned int v204; // $a2
  unsigned int v205; // $a1
  unsigned int v206; // $a0
  unsigned int v207; // $v0
  int v208; // $a0
  unsigned int v209; // $a0
  int v210; // $a0
  int v211; // $s0
  int v212; // $s5
  int v213; // $ra
  int v214; // $t4
  int v215; // $a2
  int v216; // $t2
  unsigned int v217; // $a3
  unsigned int v218; // $v1
  unsigned int v219; // $a3
  int v220; // $v1
  int v221; // $t0
  int v222; // $ra
  int v223; // $fp
  int v224; // $s0
  int v225; // $t5
  int v226; // $a1
  int v227; // $s7
  int v228; // $a0
  int v229; // $ra
  int v230; // $fp
  int v231; // $s0
  int v232; // $t0
  int v233; // $a1
  unsigned int v234; // $t8
  unsigned int v235; // $v1
  unsigned int v236; // $v0
  int v237; // $v0
  int v238; // $a1
  int v239; // $v1
  unsigned int v240; // $a0
  unsigned int v241; // $t2
  unsigned int v242; // $s7
  int v243; // $a0
  int v244; // $v0
  int v245; // $a1
  unsigned int v246; // $a0
  int v247; // $v1
  unsigned int v248; // $t8
  int v249; // $fp
  int v250; // $a0
  int v251; // $lo
  unsigned int v252; // $v1
  int v253; // $t2
  int v254; // $a2
  int v255; // $t0
  int v256; // $t2
  int v257; // $v1
  int v258; // $s5
  int v259; // $a3
  int v260; // $ra
  __int16 v261; // $a0
  int v262; // $a0
  int v263; // $t0
  int v264; // $a1
  unsigned int v265; // $a0
  unsigned int v266; // $fp
  int v267; // $a0
  unsigned int v268; // $a1
  unsigned int v269; // $a0
  int v270; // $v1
  unsigned int v271; // $a0
  unsigned int v272; // $ra
  int v273; // $t8
  int v274; // $a0
  int v275; // $lo
  int v276; // $v1
  int v277; // $s5
  int v278; // $v1
  int v279; // $v0
  int v280; // $s2
  int v281; // $v0
  int v282; // $s0
  int v283; // [sp+10h] [-120h]
  int v284; // [sp+14h] [-11Ch]
  _BYTE v285[72]; // [sp+28h] [-108h] BYREF
  char v286[2]; // [sp+70h] [-C0h] BYREF
  unsigned __int16 v287; // [sp+72h] [-BEh] BYREF
  char v288[2]; // [sp+74h] [-BCh] BYREF
  unsigned __int16 v289; // [sp+76h] [-BAh] BYREF
  unsigned __int16 v290; // [sp+78h] [-B8h] BYREF
  unsigned __int8 v291; // [sp+7Ah] [-B6h] BYREF
  unsigned __int8 v292; // [sp+7Bh] [-B5h] BYREF
  char v293[2]; // [sp+7Ch] [-B4h] BYREF
  unsigned __int16 v294; // [sp+7Eh] [-B2h] BYREF
  char v295[2]; // [sp+80h] [-B0h] BYREF
  unsigned __int16 v296; // [sp+82h] [-AEh] BYREF
  char v297[2]; // [sp+84h] [-ACh] BYREF
  unsigned __int16 v298; // [sp+86h] [-AAh] BYREF
  char v299[2]; // [sp+88h] [-A8h] BYREF
  unsigned __int16 v300; // [sp+8Ah] [-A6h] BYREF
  char v301[2]; // [sp+8Ch] [-A4h] BYREF
  unsigned __int16 v302; // [sp+8Eh] [-A2h] BYREF
  char v303[2]; // [sp+90h] [-A0h] BYREF
  unsigned __int16 v304; // [sp+92h] [-9Eh] BYREF
  char v305[2]; // [sp+94h] [-9Ch] BYREF
  unsigned __int16 v306; // [sp+96h] [-9Ah] BYREF
  char v307[2]; // [sp+98h] [-98h] BYREF
  unsigned __int16 v308; // [sp+9Ah] [-96h] BYREF
  char v309[2]; // [sp+9Ch] [-94h] BYREF
  unsigned __int16 v310; // [sp+9Eh] [-92h] BYREF
  char v311[2]; // [sp+A0h] [-90h] BYREF
  unsigned __int16 v312; // [sp+A2h] [-8Eh] BYREF
  char v313[2]; // [sp+A4h] [-8Ch] BYREF
  unsigned __int16 v314; // [sp+A6h] [-8Ah] BYREF
  int v315; // [sp+A8h] [-88h] BYREF
  char *v316; // [sp+ACh] [-84h] BYREF
  int v317; // [sp+B0h] [-80h] BYREF
  _BYTE *v318; // [sp+B4h] [-7Ch] BYREF
  int v319; // [sp+B8h] [-78h] BYREF
  int v320; // [sp+BCh] [-74h] BYREF
  unsigned __int8 *v321; // [sp+C0h] [-70h] BYREF
  int v322; // [sp+C4h] [-6Ch] BYREF
  _BYTE *v323; // [sp+C8h] [-68h] BYREF
  int v324; // [sp+CCh] [-64h] BYREF
  int v325; // [sp+D0h] [-60h] BYREF
  int v326; // [sp+D4h] [-5Ch] BYREF
  int v327; // [sp+D8h] [-58h] BYREF
  _BYTE *v328; // [sp+DCh] [-54h] BYREF
  int v329; // [sp+E0h] [-50h] BYREF
  int v330; // [sp+E4h] [-4Ch] BYREF
  int v331; // [sp+E8h] [-48h] BYREF
  int v332; // [sp+ECh] [-44h] BYREF
  _BYTE *v333; // [sp+F0h] [-40h] BYREF
  int v334; // [sp+F4h] [-3Ch] BYREF
  int v335; // [sp+F8h] [-38h] BYREF
  int v336; // [sp+FCh] [-34h] BYREF
  _BYTE *v337; // [sp+100h] [-30h] BYREF
  int v338; // [sp+104h] [-2Ch] BYREF
  int v339; // [sp+108h] [-28h] BYREF
  int v340; // [sp+10Ch] [-24h] BYREF
  _BYTE *v341; // [sp+110h] [-20h] BYREF
  int v342; // [sp+114h] [-1Ch] BYREF
  _BYTE *v343; // [sp+118h] [-18h] BYREF
  int v344; // [sp+11Ch] [-14h] BYREF
  int v345; // [sp+120h] [-10h] BYREF
  int v346; // [sp+124h] [-Ch]
  int v347; // [sp+128h] [-8h]

  memset(v285, 0, 68);
  v5 = *(_DWORD *)(a1 + 3376);
  v6 = -12;
  v346 = 0;
  v7 = 0;
  v347 = 0;
  if ( v5 != 255 )
  {
    v8 = *a2;
    v9 = a2[3];
    v10 = *(_DWORD *)(a1 + 4660) + 2;
    v11 = v5;
    v316 = (char *)a2[2];
    v287 = v10;
    v12 = 2;
    if ( (unsigned __int8)v5 == 100 )
    {
      v12 = 1;
      *(_DWORD *)(a1 + 3376) = 255;
    }
    v13 = sub_45AD54(a1, 0x15u, 0, &v287, v286, &v315, v8 + v9, (int *)&v316);
    if ( v13 < 0 )
    {
      v14 = v13;
      *a3 = v287;
      if ( v13 != -12 )
        goto LABEL_8;
    }
    else
    {
      *v316++ = v12;
      *v316++ = v11;
      v14 = sub_45BE58(a1, 21, 0, v287, (unsigned __int8)v286[0], v315, (int)a2, (int *)&v316);
      if ( v14 < 0 )
      {
        *a3 = v287;
      }
      else
      {
        v14 = 0;
        a2[2] = (int)v316;
      }
      if ( v14 != -12 )
      {
LABEL_8:
        if ( (*(_DWORD *)(a1 + 3372) & 1) == 0 )
          return v14;
LABEL_13:
        matrixClearSession(a1, 1);
        return v14;
      }
    }
    v17 = *(_DWORD *)(a1 + 3372);
    *(_DWORD *)(a1 + 3372) = v17 | 0x40;
    if ( (v17 & 1) == 0 )
      return v14;
    goto LABEL_13;
  }
  v18 = *(_DWORD *)(a1 + 3372);
  if ( ((v18 >> 14) & 1) != 0 )
  {
    v23 = *(_BYTE *)(a1 + 3529);
    v24 = *(_BYTE *)(a1 + 3530);
    *(_DWORD *)(a1 + 3568) = *(_DWORD *)(a1 + 3564);
    *(_BYTE *)(a1 + 3531) = v23;
    *(_BYTE *)(a1 + 3532) = v24;
  }
  v19 = *(unsigned __int8 *)(a1 + 3384);
  v20 = v19 < 0xC;
  if ( v19 == 11 )
    goto LABEL_79;
  if ( *(unsigned __int8 *)(a1 + 3384) < 0xCu )
  {
    if ( v19 != 1 )
    {
      if ( v19 != 2 )
        goto LABEL_20;
      v6 = matrixSslEncodeClientHello(a1, a2, (unsigned __int16 *)(a1 + 3512), *(_BYTE *)(a1 + 3528), a3, 0, (int)v285);
LABEL_71:
      if ( v6 >= 0 )
        goto LABEL_72;
      goto LABEL_20;
    }
    v181 = *(_DWORD *)(a1 + 4660);
    v182 = *(_DWORD *)(a1 + 4664);
    v183 = v181 + v182 + 19;
    v184 = 0;
    if ( ((v18 >> 2) & 1) == 0 )
    {
LABEL_324:
      v188 = *a2 + a2[3];
      if ( v188 - a2[2] < (int)(v183 + v184) )
      {
        v15 = -50;
        *a3 = v183 + v184;
        return v15;
      }
      v328 = (_BYTE *)a2[2];
      *(_DWORD *)(a1 + 3564) = 0;
      v298 = v181 + v182 + 19;
      v189 = sub_45AD54(a1, 0x16u, 3u, &v298, v297, &v327, v188, (int *)&v328);
      if ( v189 >= 0 )
      {
        v190 = v328;
        v191 = v328 + 1;
        *v328 = *(_BYTE *)(a1 + 2);
        v190[1] = *(_BYTE *)(a1 + 3);
        v191[1] = 16;
        v192 = *(_DWORD *)(a1 + 3406);
        BYTE2(v193) = *(_BYTE *)(a1 + 3412);
        HIBYTE(v193) = *(_BYTE *)(a1 + 3413);
        BYTE2(v194) = *(_BYTE *)(a1 + 3416);
        HIBYTE(v194) = *(_BYTE *)(a1 + 3417);
        BYTE2(v195) = *(_BYTE *)(a1 + 3420);
        HIBYTE(v195) = *(_BYTE *)(a1 + 3421);
        v328 = v190 + 3;
        LOWORD(v195) = *(_WORD *)(a1 + 3418);
        LOWORD(v194) = *(_WORD *)(a1 + 3414);
        LOWORD(v193) = *(_WORD *)(a1 + 3410);
        *(_DWORD *)(v190 + 3) = v192;
        *(_DWORD *)(v190 + 7) = v193;
        *(_DWORD *)(v190 + 11) = v194;
        *(_DWORD *)(v190 + 15) = v195;
        v328 += 16;
        v189 = sub_45B4B0(a1, 22, 3, v298, (unsigned __int8)v297[0], v327, (int)a2, (int *)&v328);
        if ( v189 >= 0 )
        {
          v189 = 0;
          a2[2] = (int)v328;
        }
      }
      v6 = v189;
      goto LABEL_71;
    }
    v185 = *(unsigned __int8 *)(a1 + 3367);
    v184 = *(unsigned __int8 *)(a1 + 3364) + v185;
    if ( ((v18 >> 12) & 1) != 0 )
    {
      v186 = v18 >> 20;
      if ( v185 < 2 )
        goto LABEL_319;
      v184 += v185;
    }
    v186 = v18 >> 20;
LABEL_319:
    if ( (v186 & 1) != 0 )
    {
      v187 = 8;
      if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
        v187 = 16;
      if ( ((v18 >> 22) & 1) != 0 )
        v184 += v187 + 8;
      else
        v184 += v187;
    }
    goto LABEL_324;
  }
  if ( v19 == 20 )
  {
    v137 = v18 & 1;
    if ( (v18 & 1) == 0 )
      goto LABEL_267;
    v138 = 0;
    if ( ((v18 >> 2) & 1) == 0 )
      goto LABEL_429;
    v139 = *(unsigned __int8 *)(a1 + 3367);
    v138 = 2 * (*(unsigned __int8 *)(a1 + 3364) + v139);
    if ( ((v18 >> 12) & 1) != 0 )
    {
      v140 = v18 >> 20;
      if ( v139 < 2 )
        goto LABEL_249;
      v138 += 2 * v139;
    }
    v140 = v18 >> 20;
LABEL_249:
    if ( (v140 & 1) != 0 )
    {
      v141 = *(_DWORD *)(a1 + 3344);
      v142 = 8;
      if ( ((*(_DWORD *)(v141 + 4) >> 13) & 1) == 0 )
        v142 = 16;
      v143 = 2 * v142;
      if ( ((v18 >> 22) & 1) != 0 )
        v143 = 2 * (v142 + 8);
      v138 += v143;
LABEL_255:
      v144 = *(unsigned __int8 *)(v141 + 11);
      v145 = 3 * *(_DWORD *)(a1 + 4660)
           + 2 * *(_DWORD *)(a1 + 4664)
           + 107
           + v138
           + *(unsigned __int8 *)(v141 + 8)
           + v144;
      if ( ((v18 >> 19) & 1) != 0 )
        v145 += 8;
      if ( ((v18 >> 11) & 1) != 0 )
        v145 -= 24;
      if ( ((v18 >> 12) & 1) != 0 )
      {
        v146 = *(_DWORD *)(v141 + 4);
        if ( (v146 & 0x1800) != 0 )
        {
          if ( ((v146 >> 13) & 1) == 0 )
          {
            v145 += 25;
            goto LABEL_263;
          }
LABEL_524:
          v145 += 17;
          goto LABEL_263;
        }
        if ( ((v146 >> 6) & 1) != 0 )
        {
          if ( ((v146 >> 13) & 1) != 0 )
          {
            v145 += 9;
            goto LABEL_263;
          }
          goto LABEL_524;
        }
        v145 += v144;
      }
LABEL_263:
      v15 = -50;
      if ( *a2 + a2[3] - a2[2] < v145 )
      {
        *a3 = v145;
        return v15;
      }
      v6 = sub_45C7D0(a1, a2);
      if ( !v6 )
      {
        v169 = *a2 + a2[3];
        v170 = *(_DWORD *)(a1 + 4660) + 1;
        v337 = (_BYTE *)a2[2];
        v306 = v170;
        v171 = sub_45AD54(a1, 0x14u, 0, &v306, v305, &v336, v169, (int *)&v337);
        if ( v171 >= 0 )
        {
          *v337++ = 1;
          v171 = sub_45B4B0(a1, 20, 0, v306, (unsigned __int8)v305[0], v336, (int)a2, (int *)&v337);
          if ( v171 >= 0 )
          {
            a2[2] = (int)v337;
            v172 = *a2;
            v173 = a2[3];
            v174 = (*(_DWORD *)(a1 + 3372) >> 11) & 1;
            v339 = a2[2];
            v175 = 36;
            if ( v174 )
              v175 = 12;
            v308 = *(_WORD *)(a1 + 4660) + *(_WORD *)(a1 + 4664) + v175;
            v176 = sub_45AD54(a1, 0x16u, 0x14u, &v308, v307, &v338, v172 + v173, &v339);
            if ( v176 < 0 )
              goto LABEL_555;
            v177 = v339;
            v178 = (*(_DWORD *)(a1 + 3372) >> 11) & 1;
            *(_DWORD *)(a1 + 3200) = v339;
            v179 = 12;
            if ( !v178 )
              v179 = 36;
            v339 = v179 + v177;
            v176 = sub_45B4B0(a1, 22, 20, v308, (unsigned __int8)v307[0], v338, (int)a2, &v339);
            if ( v176 < 0 )
            {
LABEL_555:
              v18 = *(_DWORD *)(a1 + 3372);
              v6 = v176;
              goto LABEL_266;
            }
            v18 = *(_DWORD *)(a1 + 3372);
            v20 = v18 >> 14;
            a2[2] = v339;
            if ( ((v18 >> 14) & 1) == 0 )
            {
              v6 = 0;
              if ( *(_WORD *)(a1 + 3162) )
                goto LABEL_266;
              v137 = v18 & 1;
              if ( ((*(_DWORD *)(a1 + 3324) >> 3) & 1) != 0 )
              {
LABEL_267:
                if ( v137 )
                  goto LABEL_70;
                v147 = 0;
                if ( ((v18 >> 17) & 1) != 0 )
                {
                  if ( ((v18 >> 14) & 1) != 0 && *(_DWORD *)(a1 + 3580) == 1 )
                  {
                    v147 = *(_DWORD *)(a1 + 4636);
                    v148 = v18 >> 18;
                  }
                  else
                  {
                    v148 = v18 >> 18;
                    if ( ((v18 >> 19) & 1) != 0 )
                      v147 = 2 * **(unsigned __int8 **)(*(_DWORD *)(a1 + 3124) + 52) + 2;
                  }
                  if ( (v148 & 1) == 0 )
                  {
                    v149 = *(_DWORD *)(a1 + 3344);
                    v150 = v18 >> 7;
                    goto LABEL_276;
                  }
                  v149 = *(_DWORD *)(a1 + 3344);
                  v147 += 130;
                }
                else
                {
                  v147 = 130;
                  if ( ((v18 >> 18) & 1) != 0 )
                  {
                    v149 = *(_DWORD *)(a1 + 3344);
                    v150 = v18 >> 7;
                    goto LABEL_276;
                  }
                  v149 = *(_DWORD *)(a1 + 3344);
                  if ( (unsigned __int16)(*(_WORD *)(v149 + 2) - 8) >= 2u )
                  {
                    v270 = *(_DWORD *)(a1 + 600);
                    if ( !v270 )
                    {
                      v15 = -12;
                      *(_DWORD *)(a1 + 3372) = v18 | 0x40;
                      return v15;
                    }
                    v147 = *(unsigned __int16 *)(v270 + 148);
                    v151 = (v18 >> 7) & 1;
LABEL_277:
                    v152 = 0;
                    if ( v151 )
                    {
                      v153 = 0;
                      if ( *(int *)(a1 + 608) <= 0 )
                      {
                        v163 = *(_DWORD *)(a1 + 4660);
                        v158 = *(_DWORD *)(a1 + 4664);
                        if ( (*(_DWORD *)(a1 + 3388) & 0xFFFF00) == 0x300 )
                          v152 = v163 + 2;
                        else
                          v152 = v163 + v158 + 3;
                      }
                      else
                      {
                        v154 = *(_DWORD *)(a1 + 3144);
                        v155 = *(_DWORD *)(v154 + 116);
                        v156 = 0;
                        while ( v155 )
                        {
                          v157 = *(unsigned __int16 *)(v155 + 788);
                          v155 = *(_DWORD *)(v155 + 796);
                          v153 += v157;
                          ++v156;
                        }
                        v158 = *(_DWORD *)(a1 + 4664);
                        v159 = 3 * v156 + v153;
                        v160 = *(_DWORD *)(a1 + 3328);
                        v161 = v159 + v158 + 3;
                        if ( v160 >= v161 )
                        {
                          v163 = *(_DWORD *)(a1 + 4660);
                        }
                        else
                        {
                          *(_DWORD *)(a1 + 3340) = v161;
                          *(_DWORD *)(a1 + 3336) = 0;
                          v162 = 0;
                          if ( v159 + v158 != -3 )
                          {
                            v163 = *(_DWORD *)(a1 + 4660);
                            while ( !*(_DWORD *)(a1 + 3336) )
                            {
                              *(_DWORD *)(a1 + 3340) = v161 - v160;
                              *(_DWORD *)(a1 + 3336) = 1;
LABEL_286:
                              v161 = *(_DWORD *)(a1 + 3340);
                              if ( !v161 )
                                goto LABEL_530;
                            }
                            v164 = 0;
                            if ( ((v18 >> 2) & 1) != 0 )
                            {
                              v165 = *(unsigned __int8 *)(a1 + 3367);
                              v166 = *(unsigned __int8 *)(a1 + 3364) + v165;
                              if ( ((v18 >> 12) & 1) != 0 && v165 >= 2 )
                                v166 += v165;
                              v167 = v162 + v166;
                              if ( ((v18 >> 20) & 1) == 0 )
                                goto LABEL_298;
                              v168 = 8;
                              if ( ((*(_DWORD *)(v149 + 4) >> 13) & 1) == 0 )
                                v168 = 16;
                              if ( ((v18 >> 22) & 1) != 0 )
                                v164 = v166 + v168 + 8;
                              else
                                v164 = v166 + v168;
                            }
                            v167 = v162 + v164;
LABEL_298:
                            v162 = v167 + v163;
                            if ( v160 >= (unsigned int)v161 )
                              *(_DWORD *)(a1 + 3340) = 0;
                            else
                              *(_DWORD *)(a1 + 3340) = v161 - v160;
                            goto LABEL_286;
                          }
                          v163 = *(_DWORD *)(a1 + 4660);
LABEL_530:
                          v153 += v162;
                        }
                        v268 = *(unsigned __int16 *)(v154 + 112);
                        v269 = 2 * v163 + 3 * v156 + 2 * v158 + v153 + v268;
                        v152 = v269 + 5;
                        if ( *(_DWORD *)(*(_DWORD *)(v154 + 116) + 444) == 518 )
                        {
                          v152 = v269 + 13;
                          if ( v268 >= 0x80 )
                            v152 = v269 + 14;
                        }
                      }
                    }
                    else
                    {
                      v163 = *(_DWORD *)(a1 + 4660);
                      v158 = *(_DWORD *)(a1 + 4664);
                    }
                    v237 = 3 * v163
                         + 2 * v158
                         + v147
                         + *(unsigned __int8 *)(v149 + 8)
                         + *(unsigned __int8 *)(v149 + 11)
                         + v152;
                    v238 = v237 + 37;
                    if ( ((v18 >> 11) & 1) != 0 )
                      v238 = v237 + 15;
                    if ( ((v18 >> 7) & 1) != 0 )
                    {
                      if ( *(int *)(a1 + 608) > 0 )
                      {
                        if ( ((v18 >> 13) & 1) != 0 )
                          v238 += 2;
                        v239 = 0;
                        if ( ((v18 >> 2) & 1) == 0 )
                          goto LABEL_454;
                        v240 = *(unsigned __int8 *)(a1 + 3367);
                        v239 = 4 * (*(unsigned __int8 *)(a1 + 3364) + v240);
                        if ( ((v18 >> 12) & 1) != 0 )
                        {
                          v241 = v18 >> 20;
                          if ( v240 < 2 )
                          {
LABEL_448:
                            v242 = v18 >> 14;
                            if ( (v241 & 1) == 0 )
                            {
LABEL_455:
                              v245 = v238 + v239;
                              if ( (v242 & 1) == 0 )
                                goto LABEL_468;
                              v245 += 15 * (v163 + v158);
                              if ( ((v18 >> 2) & 1) == 0 )
                                goto LABEL_468;
                              v246 = *(unsigned __int8 *)(a1 + 3367);
                              v247 = 15 * (*(unsigned __int8 *)(a1 + 3364) + v246);
                              v248 = v18 >> 20;
                              if ( ((v18 >> 12) & 1) != 0 )
                              {
                                v249 = (v18 & 0x100000) != 0;
                                if ( v246 < 2 )
                                {
LABEL_461:
                                  if ( v249 )
                                  {
                                    v250 = 8;
                                    if ( ((*(_DWORD *)(v149 + 4) >> 13) & 1) == 0 )
                                      v250 = 16;
                                    v251 = 15 * v250;
                                    if ( ((v18 >> 22) & 1) != 0 )
                                      v251 = 15 * (v250 + 8);
                                    v247 += v251;
                                  }
                                  v245 += v247;
LABEL_468:
                                  if ( ((v18 >> 12) & 1) == 0 )
                                    goto LABEL_472;
                                  v252 = *(_DWORD *)(v149 + 4);
                                  if ( (v252 & 0x1800) != 0 )
                                  {
                                    if ( ((v252 >> 13) & 1) == 0 )
                                    {
                                      v245 += 25;
                                      goto LABEL_472;
                                    }
                                  }
                                  else
                                  {
                                    if ( ((v252 >> 6) & 1) == 0 )
                                    {
                                      v245 += *(unsigned __int8 *)(v149 + 11);
LABEL_472:
                                      v253 = *a2 + a2[3];
                                      v15 = -50;
                                      if ( v253 - a2[2] < v245 )
                                      {
                                        *a3 = v245;
                                        return v15;
                                      }
                                      if ( ((v18 >> 7) & 1) == 0 )
                                        goto LABEL_478;
                                      v254 = *(_DWORD *)(a1 + 608);
                                      if ( !v254 && (*(_DWORD *)(a1 + 3388) & 0xFFFF00) == 0x300 )
                                      {
                                        v341 = (_BYTE *)a2[2];
                                        v310 = v163 + 2;
                                        v276 = sub_45AD54(a1, 0x15u, 0, &v310, v309, &v340, v253, (int *)&v341);
                                        if ( v276 < 0
                                          || (*v341 = 1,
                                              ++v341,
                                              *v341 = 41,
                                              ++v341,
                                              v276 = sub_45BE58(
                                                       a1,
                                                       21,
                                                       0,
                                                       v310,
                                                       (unsigned __int8)v309[0],
                                                       v340,
                                                       (int)a2,
                                                       (int *)&v341),
                                              v276 < 0) )
                                        {
                                          v6 = v276;
                                          *a3 = v310;
                                        }
                                        else
                                        {
                                          v6 = 0;
                                          a2[2] = (int)v341;
                                        }
                                      }
                                      else
                                      {
                                        v6 = sub_45DA18(a1, a2, v254);
                                      }
                                      if ( !v6 )
LABEL_478:
                                        v6 = sub_45F5A0(a1, a2);
                                      if ( *(unsigned __int8 *)(a1 + 3372) >> 7 )
                                      {
                                        if ( v6 )
                                          goto LABEL_70;
                                        if ( *(int *)(a1 + 608) <= 0 )
                                        {
LABEL_484:
                                          v255 = *a2 + a2[3];
                                          v256 = *(_DWORD *)(a1 + 4660) + 1;
                                          v343 = (_BYTE *)a2[2];
                                          v312 = v256;
                                          v257 = sub_45AD54(a1, 0x14u, 0, &v312, v311, &v342, v255, (int *)&v343);
                                          if ( v257 < 0
                                            || (*v343 = 1,
                                                ++v343,
                                                v257 = sub_45B4B0(
                                                         a1,
                                                         20,
                                                         0,
                                                         v312,
                                                         (unsigned __int8)v311[0],
                                                         v342,
                                                         (int)a2,
                                                         (int *)&v343),
                                                v257 < 0) )
                                          {
                                            v6 = v257;
                                            goto LABEL_70;
                                          }
                                          a2[2] = (int)v343;
                                          v258 = *a2;
                                          v259 = a2[3];
                                          v260 = (*(_DWORD *)(a1 + 3372) >> 11) & 1;
                                          v345 = a2[2];
                                          v261 = 36;
                                          if ( v260 )
                                            v261 = 12;
                                          v314 = *(_WORD *)(a1 + 4660) + *(_WORD *)(a1 + 4664) + v261;
                                          v45 = sub_45AD54(a1, 0x16u, 0x14u, &v314, v313, &v344, v258 + v259, &v345);
                                          if ( v45 < 0 )
                                            goto LABEL_69;
                                          v262 = v345;
                                          v263 = (*(_DWORD *)(a1 + 3372) >> 11) & 1;
                                          *(_DWORD *)(a1 + 3200) = v345;
                                          v264 = 12;
                                          if ( !v263 )
                                            v264 = 36;
                                          v345 = v264 + v262;
                                          v45 = sub_45B4B0(
                                                  a1,
                                                  22,
                                                  20,
                                                  v314,
                                                  (unsigned __int8)v313[0],
                                                  v344,
                                                  (int)a2,
                                                  &v345);
                                          if ( v45 < 0 )
                                            goto LABEL_69;
                                          v49 = v345;
                                          v50 = (*(_DWORD *)(a1 + 3372) >> 14) & 1;
LABEL_64:
                                          a2[2] = v49;
                                          v45 = 0;
                                          if ( v50 )
                                          {
LABEL_69:
                                            v6 = v45;
                                            goto LABEL_70;
                                          }
                                          v6 = 0;
                                          if ( !*(_WORD *)(a1 + 3162) )
                                          {
                                            v20 = *(_DWORD *)(a1 + 3324);
                                            if ( ((v20 >> 3) & 1) == 0 )
                                            {
                                              v51 = *(_DWORD *)(a1 + 600);
                                              if ( v51 )
                                              {
                                                psX509FreeCert(v51);
                                                v45 = 0;
                                                *(_DWORD *)(a1 + 600) = 0;
                                              }
                                              goto LABEL_69;
                                            }
                                          }
                                          goto LABEL_70;
                                        }
                                        v6 = sub_45B710(a1, a2);
                                      }
                                      if ( v6 )
                                        goto LABEL_70;
                                      goto LABEL_484;
                                    }
                                    if ( ((v252 >> 13) & 1) != 0 )
                                    {
                                      v245 += 9;
                                      goto LABEL_472;
                                    }
                                  }
                                  v245 += 17;
                                  goto LABEL_472;
                                }
                                v247 += 15 * v246;
                                v248 = v18 >> 20;
                              }
                              v249 = v248 & 1;
                              goto LABEL_461;
                            }
                            v243 = 8;
                            if ( ((*(_DWORD *)(v149 + 4) >> 13) & 1) == 0 )
                              v243 = 16;
                            v244 = 4 * v243;
                            if ( ((v18 >> 22) & 1) != 0 )
                              v244 = 4 * (v243 + 8);
                            goto LABEL_453;
                          }
                          v239 += 4 * v240;
                        }
                        v241 = v18 >> 20;
                        goto LABEL_448;
                      }
                      v239 = 0;
                      if ( ((v18 >> 2) & 1) == 0 )
                        goto LABEL_454;
                      v271 = *(unsigned __int8 *)(a1 + 3367);
                      v239 = 3 * (*(unsigned __int8 *)(a1 + 3364) + v271);
                      v272 = v18 >> 20;
                      if ( ((v18 >> 12) & 1) != 0 )
                      {
                        v273 = (v18 & 0x100000) != 0;
                        if ( v271 < 2 )
                        {
LABEL_544:
                          v242 = v18 >> 14;
                          if ( !v273 )
                            goto LABEL_455;
                          v274 = 8;
                          if ( ((*(_DWORD *)(v149 + 4) >> 13) & 1) == 0 )
                            v274 = 16;
                          v275 = 3 * v274;
                          if ( ((v18 >> 22) & 1) != 0 )
                            v275 = 3 * (v274 + 8);
                          v239 += v275;
                          goto LABEL_454;
                        }
                        v239 += 3 * v271;
                        v272 = v18 >> 20;
                      }
                      v273 = v272 & 1;
                      goto LABEL_544;
                    }
                    v239 = 0;
                    if ( ((v18 >> 2) & 1) == 0 )
                      goto LABEL_454;
                    v265 = *(unsigned __int8 *)(a1 + 3367);
                    v239 = 2 * (*(unsigned __int8 *)(a1 + 3364) + v265);
                    if ( ((v18 >> 12) & 1) != 0 )
                    {
                      v266 = v18 >> 20;
                      if ( v265 < 2 )
                      {
LABEL_498:
                        v242 = v18 >> 14;
                        if ( (v266 & 1) == 0 )
                          goto LABEL_455;
                        v267 = 8;
                        if ( ((*(_DWORD *)(v149 + 4) >> 13) & 1) == 0 )
                          v267 = 16;
                        if ( ((v18 >> 22) & 1) != 0 )
                          v244 = 2 * (v267 + 8);
                        else
                          v244 = 2 * v267;
LABEL_453:
                        v239 += v244;
LABEL_454:
                        v242 = v18 >> 14;
                        goto LABEL_455;
                      }
                      v239 += 2 * v265;
                    }
                    v266 = v18 >> 20;
                    goto LABEL_498;
                  }
                  v147 = 2 * **(unsigned __int8 **)(*(_DWORD *)(a1 + 600) + 92) + 2;
                }
                v150 = v18 >> 7;
LABEL_276:
                v151 = v150 & 1;
                goto LABEL_277;
              }
              v180 = *(_DWORD *)(a1 + 600);
              if ( v180 )
              {
                psX509FreeCert(v180);
                v18 = *(_DWORD *)(a1 + 3372);
                *(_DWORD *)(a1 + 600) = 0;
              }
            }
            v6 = 0;
            goto LABEL_266;
          }
        }
        v6 = v171;
      }
      v18 = *(_DWORD *)(a1 + 3372);
LABEL_266:
      v137 = v18 & 1;
      goto LABEL_267;
    }
LABEL_429:
    v141 = *(_DWORD *)(a1 + 3344);
    goto LABEL_255;
  }
  if ( *(unsigned __int8 *)(a1 + 3384) < 0x15u )
  {
    if ( v19 != 16 )
      goto LABEL_20;
LABEL_79:
    if ( ((v18 >> 7) & 1) != 0 )
    {
      v73 = *(_DWORD *)(*(_DWORD *)(a1 + 3144) + 120);
      v347 = 0;
      v74 = 0;
      v346 = 0;
      if ( ((v18 >> 13) & 1) != 0 )
        v74 = 14;
      v15 = -12;
      if ( !v73 )
        return v15;
      v7 = *(_DWORD *)(a1 + 4660) + *(_DWORD *)(a1 + 4664) + v74 + 5;
      do
      {
        v75 = *(unsigned __int16 *)(v73 + 396);
        v73 = *(_DWORD *)(v73 + 796);
        v347 += v75;
        v7 += 2;
        ++v346;
      }
      while ( v73 );
      v54 = v18 >> 17;
    }
    else
    {
      v54 = v18 >> 17;
    }
    v55 = 0;
    if ( (v54 & 1) != 0 )
    {
      if ( ((v18 >> 19) & 1) == 0 )
      {
        v56 = *(_DWORD *)(a1 + 3144);
        goto LABEL_88;
      }
      if ( ((v18 >> 15) & 1) != 0 )
      {
        v56 = *(_DWORD *)(a1 + 3144);
        v55 = 2 * **(unsigned __int8 **)(*(_DWORD *)(a1 + 3124) + 52) + *(unsigned __int16 *)(v56 + 112) + 7;
      }
      else
      {
        if ( (v18 & 0x10000) == 0 )
        {
          v56 = *(_DWORD *)(a1 + 3144);
          v57 = v18 >> 13;
LABEL_86:
          if ( (v57 & 1) != 0 )
            v55 += 2;
LABEL_88:
          v58 = *(_DWORD *)(v56 + 116);
          v59 = 0;
          v60 = 0;
          while ( v58 )
          {
            v61 = *(unsigned __int16 *)(v58 + 788);
            v58 = *(_DWORD *)(v58 + 796);
            v60 += v61;
            ++v59;
          }
          v62 = *(_DWORD *)(a1 + 4664);
          v63 = 3 * v59 + v60 + v62;
          v64 = *(_DWORD *)(a1 + 3328);
          v65 = v63 + 3;
          if ( v64 >= v63 + 3 )
          {
            v67 = *(_DWORD *)(a1 + 4660);
          }
          else
          {
            *(_DWORD *)(a1 + 3340) = v65;
            *(_DWORD *)(a1 + 3336) = 0;
            v66 = 0;
            if ( v63 != -3 )
            {
              v67 = *(_DWORD *)(a1 + 4660);
              while ( !*(_DWORD *)(a1 + 3336) )
              {
                *(_DWORD *)(a1 + 3340) = v65 - v64;
                *(_DWORD *)(a1 + 3336) = 1;
LABEL_95:
                v65 = *(_DWORD *)(a1 + 3340);
                if ( !v65 )
                  goto LABEL_371;
              }
              v68 = 0;
              if ( ((v18 >> 2) & 1) != 0 )
              {
                v69 = *(unsigned __int8 *)(a1 + 3367);
                v70 = *(unsigned __int8 *)(a1 + 3364) + v69;
                if ( ((v18 >> 12) & 1) != 0 && v69 >= 2 )
                  v70 += v69;
                v71 = v66 + v70;
                if ( ((v18 >> 20) & 1) == 0 )
                  goto LABEL_107;
                v72 = 8;
                if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
                  v72 = 16;
                if ( ((v18 >> 22) & 1) != 0 )
                  v68 = v70 + v72 + 8;
                else
                  v68 = v70 + v72;
              }
              v71 = v66 + v68;
LABEL_107:
              v66 = v71 + v67;
              if ( v64 >= v65 )
                *(_DWORD *)(a1 + 3340) = 0;
              else
                *(_DWORD *)(a1 + 3340) = v65 - v64;
              goto LABEL_95;
            }
            v67 = *(_DWORD *)(a1 + 4660);
LABEL_371:
            v60 += v66;
          }
          v78 = 4 * (v67 + v62) + 3 * v59 + v55 + v60 + 73;
          if ( ((v18 >> 7) & 1) == 0 )
            goto LABEL_361;
          v196 = v7 + v347;
          v197 = v18 >> 2;
          if ( v64 < v7 + v347 )
          {
            *(_DWORD *)(a1 + 3340) = v196;
            *(_DWORD *)(a1 + 3336) = 0;
            v198 = 0;
            if ( v196 )
            {
              while ( !*(_DWORD *)(a1 + 3336) )
              {
                *(_DWORD *)(a1 + 3340) = v196 - v64;
                *(_DWORD *)(a1 + 3336) = 1;
LABEL_335:
                v196 = *(_DWORD *)(a1 + 3340);
                if ( !v196 )
                  goto LABEL_349;
              }
              v199 = 0;
              if ( ((v18 >> 2) & 1) != 0 )
              {
                v200 = *(unsigned __int8 *)(a1 + 3367);
                v201 = *(unsigned __int8 *)(a1 + 3364) + v200;
                if ( ((v18 >> 12) & 1) != 0 && v200 >= 2 )
                  v201 += v200;
                v202 = v198 + v201;
                if ( ((v18 >> 20) & 1) == 0 )
                  goto LABEL_347;
                v203 = 8;
                if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
                  v203 = 16;
                if ( ((v18 >> 22) & 1) != 0 )
                  v199 = v201 + v203 + 8;
                else
                  v199 = v201 + v203;
              }
              v202 = v198 + v199;
LABEL_347:
              v198 = v202 + v67;
              if ( v64 >= v196 )
                *(_DWORD *)(a1 + 3340) = 0;
              else
                *(_DWORD *)(a1 + 3340) = v196 - v64;
              goto LABEL_335;
            }
LABEL_349:
            v196 = v7 + v198 + v347;
            v197 = v18 >> 2;
          }
          v204 = v78 + v196;
          v205 = 0;
          if ( (v197 & 1) == 0 )
            goto LABEL_360;
          v206 = *(unsigned __int8 *)(a1 + 3367);
          v205 = *(unsigned __int8 *)(a1 + 3364) + v206;
          if ( ((v18 >> 12) & 1) != 0 )
          {
            v207 = v18 >> 20;
            if ( v206 < 2 )
              goto LABEL_355;
            v205 += v206;
          }
          v207 = v18 >> 20;
LABEL_355:
          if ( (v207 & 1) != 0 )
          {
            v208 = 8;
            if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
              v208 = 16;
            if ( ((v18 >> 22) & 1) == 0 )
            {
              v78 = v204 + v205 + v208;
LABEL_361:
              v101 = 0;
              if ( ((v18 >> 2) & 1) == 0 )
                goto LABEL_176;
              v209 = *(unsigned __int8 *)(a1 + 3367);
              v101 = 4 * (*(unsigned __int8 *)(a1 + 3364) + v209);
              if ( ((v18 >> 12) & 1) != 0 && v209 >= 2 )
                v101 += 4 * v209;
              if ( ((v18 >> 20) & 1) == 0 )
                goto LABEL_176;
              v210 = 8;
              if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
                v210 = 16;
              if ( ((v18 >> 22) & 1) != 0 )
                v107 = 4 * (v210 + 8);
              else
                v107 = 4 * v210;
              goto LABEL_175;
            }
            v205 += v208 + 8;
          }
LABEL_360:
          v78 = v204 + v205;
          goto LABEL_361;
        }
        v56 = *(_DWORD *)(a1 + 3144);
        v234 = *(unsigned __int16 *)(v56 + 112);
        v235 = 2 * **(unsigned __int8 **)(*(_DWORD *)(a1 + 3124) + 52) + v234;
        v236 = v235 + 13;
        if ( v234 >= 0x80 )
          v236 = v235 + 14;
        v55 = v236 + 2;
      }
      v57 = v18 >> 13;
      goto LABEL_86;
    }
    v77 = 0;
    if ( ((v18 >> 18) & 1) != 0 )
    {
      v67 = *(_DWORD *)(a1 + 4660);
      v62 = *(_DWORD *)(a1 + 4664);
      v64 = *(_DWORD *)(a1 + 3328);
      v78 = 3 * (v67 + v62) + 104;
      goto LABEL_120;
    }
    v211 = *(_DWORD *)(*(_DWORD *)(a1 + 3144) + 116);
    v212 = 0;
    if ( v211 )
    {
      do
      {
        ++v212;
        if ( !*(_DWORD *)(v211 + 784) )
        {
          psTraceStr("psAssert %s", (int)"sslEncode.c");
          psTraceInt(":%d ", 1571);
          psError((int)"cert->unparsedBin != NULL");
        }
        v213 = *(unsigned __int16 *)(v211 + 788);
        v211 = *(_DWORD *)(v211 + 796);
        v77 += v213;
      }
      while ( v211 );
      v18 = *(_DWORD *)(a1 + 3372);
    }
    v62 = *(_DWORD *)(a1 + 4664);
    v214 = 3 * v212 + v77;
    v64 = *(_DWORD *)(a1 + 3328);
    v215 = v214 + v62 + 3;
    if ( v64 >= v215 )
    {
      v67 = *(_DWORD *)(a1 + 4660);
    }
    else
    {
      *(_DWORD *)(a1 + 3340) = v215;
      *(_DWORD *)(a1 + 3336) = 0;
      v216 = 0;
      if ( v214 + v62 != -3 )
      {
        v67 = *(_DWORD *)(a1 + 4660);
        while ( !*(_DWORD *)(a1 + 3336) )
        {
          *(_DWORD *)(a1 + 3340) = v215 - v64;
          *(_DWORD *)(a1 + 3336) = 1;
LABEL_382:
          v215 = *(_DWORD *)(a1 + 3340);
          if ( !v215 )
            goto LABEL_428;
        }
        v217 = 0;
        if ( ((v18 >> 2) & 1) != 0 )
        {
          v218 = *(unsigned __int8 *)(a1 + 3367);
          v219 = *(unsigned __int8 *)(a1 + 3364) + v218;
          if ( ((v18 >> 12) & 1) != 0 && v218 >= 2 )
            v219 += v218;
          v220 = v216 + v219;
          if ( ((v18 >> 20) & 1) == 0 )
            goto LABEL_394;
          v221 = 8;
          if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
            v221 = 16;
          if ( ((v18 >> 22) & 1) != 0 )
            v217 = v219 + v221 + 8;
          else
            v217 = v219 + v221;
        }
        v220 = v216 + v217;
LABEL_394:
        v216 = v220 + v67;
        if ( v64 >= (unsigned int)v215 )
          *(_DWORD *)(a1 + 3340) = 0;
        else
          *(_DWORD *)(a1 + 3340) = v215 - v64;
        goto LABEL_382;
      }
      v67 = *(_DWORD *)(a1 + 4660);
LABEL_428:
      v77 += v216;
    }
    v78 = 3 * (v67 + v62 + v212) + v77 + 73;
LABEL_120:
    v79 = v18 >> 2;
    if ( ((v18 >> 7) & 1) == 0 )
      goto LABEL_165;
    v80 = v7 + v347;
    v81 = v18 >> 2;
    if ( v64 < v7 + v347 )
    {
      *(_DWORD *)(a1 + 3340) = v80;
      *(_DWORD *)(a1 + 3336) = 0;
      v82 = 0;
      if ( v80 )
      {
        while ( !*(_DWORD *)(a1 + 3336) )
        {
          *(_DWORD *)(a1 + 3340) = v80 - v64;
          *(_DWORD *)(a1 + 3336) = 1;
LABEL_125:
          v80 = *(_DWORD *)(a1 + 3340);
          if ( !v80 )
            goto LABEL_139;
        }
        v83 = 0;
        if ( ((v18 >> 2) & 1) != 0 )
        {
          v84 = *(unsigned __int8 *)(a1 + 3367);
          v85 = *(unsigned __int8 *)(a1 + 3364) + v84;
          if ( ((v18 >> 12) & 1) != 0 && v84 >= 2 )
            v85 += v84;
          v86 = v82 + v85;
          if ( ((v18 >> 20) & 1) == 0 )
            goto LABEL_137;
          v87 = 8;
          if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
            v87 = 16;
          if ( ((v18 >> 22) & 1) != 0 )
            v83 = v85 + v87 + 8;
          else
            v83 = v85 + v87;
        }
        v86 = v82 + v83;
LABEL_137:
        v82 = v86 + v67;
        if ( v64 >= v80 )
          *(_DWORD *)(a1 + 3340) = 0;
        else
          *(_DWORD *)(a1 + 3340) = v80 - v64;
        goto LABEL_125;
      }
LABEL_139:
      v80 = v7 + v82 + v347;
      v81 = v18 >> 2;
    }
    v88 = v78 + v80;
    v89 = 0;
    if ( (v81 & 1) == 0 )
      goto LABEL_150;
    v90 = *(unsigned __int8 *)(a1 + 3367);
    v89 = *(unsigned __int8 *)(a1 + 3364) + v90;
    if ( ((v18 >> 12) & 1) != 0 )
    {
      v91 = v18 >> 20;
      if ( v90 < 2 )
      {
LABEL_145:
        v92 = v18 >> 14;
        if ( (v91 & 1) == 0 )
          goto LABEL_151;
        v93 = 8;
        if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
          v93 = 16;
        if ( ((v18 >> 22) & 1) != 0 )
          v89 += v93 + 8;
        else
          v89 += v93;
LABEL_150:
        v92 = v18 >> 14;
LABEL_151:
        v78 = v88 + v89;
        if ( (v92 & 1) == 0 )
        {
LABEL_164:
          v79 = v18 >> 2;
          goto LABEL_165;
        }
        v79 = v18 >> 2;
        v78 += 15 * (v67 + v62);
        if ( ((v18 >> 2) & 1) != 0 )
        {
          v94 = *(unsigned __int8 *)(a1 + 3367);
          v95 = 15 * (*(unsigned __int8 *)(a1 + 3364) + v94);
          v96 = v18 >> 20;
          if ( ((v18 >> 12) & 1) != 0 )
          {
            v97 = (v18 & 0x100000) != 0;
            if ( v94 < 2 )
            {
LABEL_157:
              if ( v97 )
              {
                v98 = 8;
                if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
                  v98 = 16;
                v99 = 15 * v98;
                if ( ((v18 >> 22) & 1) != 0 )
                  v99 = 15 * (v98 + 8);
                v95 += v99;
              }
              v78 += v95;
              goto LABEL_164;
            }
            v95 += 15 * v94;
            v96 = v18 >> 20;
          }
          v97 = v96 & 1;
          goto LABEL_157;
        }
LABEL_165:
        v100 = (v79 & 1) == 0;
        v101 = 0;
        if ( v100 )
        {
LABEL_176:
          v104 = v18 >> 14;
          goto LABEL_177;
        }
        v102 = *(unsigned __int8 *)(a1 + 3367);
        v101 = 3 * (*(unsigned __int8 *)(a1 + 3364) + v102);
        v103 = v18 >> 20;
        if ( ((v18 >> 12) & 1) != 0 && v102 >= 2 )
        {
          v101 += 3 * *(unsigned __int8 *)(a1 + 3367);
          v103 = v18 >> 20;
        }
        v104 = v18 >> 14;
        if ( (v103 & 1) == 0 )
        {
LABEL_177:
          v108 = v78 + v101;
          v109 = v64 < 0x4000;
          if ( (v104 & 1) == 0 )
            goto LABEL_191;
          v108 += 15 * (v67 + v62);
          if ( ((v18 >> 2) & 1) == 0 )
          {
LABEL_190:
            v109 = v64 < 0x4000;
LABEL_191:
            v116 = 0;
            if ( v109 )
            {
              v108 += 5;
              v116 = 2;
            }
            v117 = *(_DWORD *)(a1 + 4656);
            if ( (v117 & 0x10000) != 0 )
            {
              v108 += 4;
              v116 = 2;
            }
            if ( ((v117 >> 17) & 1) != 0 )
            {
              v108 += 4;
              v116 = 2;
            }
            if ( ((v117 >> 20) & 1) == 0 )
            {
LABEL_209:
              v123 = *(_DWORD *)(a1 + 3260);
              v124 = v117 >> 15;
              if ( v123 )
              {
                if ( *(_WORD *)(v123 + 92) == 3 )
                {
                  v108 += 4;
                  v116 = 2;
                }
                v124 = v117 >> 15;
              }
              if ( (v124 & 1) != 0 )
              {
                v108 += 4;
                v116 = 2;
              }
              if ( ((v18 >> 19) & 1) != 0 )
              {
                v108 += 6;
                v116 = 2;
              }
              v125 = v108 + v116;
              if ( *a2 + a2[3] - a2[2] < v108 + v116 )
              {
                v15 = -50;
                *a3 = v125;
                return v15;
              }
              v126 = sub_45C7D0(a1, a2);
              v127 = *(_DWORD *)(a1 + 3372);
              v6 = v126;
              if ( ((v127 >> 17) & 1) != 0 )
              {
                if ( ((v127 >> 15) & 1) == 0 && (v127 & 0x10000) == 0 )
                {
LABEL_417:
                  v128 = v127 >> 7;
                  if ( v6 )
                    goto LABEL_223;
                  v129 = (v127 & 0x80) != 0;
                  if ( ((v127 >> 19) & 1) == 0 )
                    goto LABEL_224;
                  v283 = 0;
                  v284 = 0;
                  v6 = sub_45CF80(a1, a2);
                  goto LABEL_420;
                }
                if ( v126 )
                {
LABEL_222:
                  v128 = v127 >> 7;
LABEL_223:
                  v129 = v128 & 1;
LABEL_224:
                  if ( v129 )
                  {
                    if ( v6 )
                      goto LABEL_70;
                    v6 = sub_46097C((_DWORD *)a1, a2, v347, v346);
                  }
                  if ( !v6 )
                  {
                    v130 = *(_DWORD *)(a1 + 4660) + *(_DWORD *)(a1 + 4664);
                    v131 = *a2 + a2[3];
                    v325 = a2[2];
                    v296 = v130;
                    v45 = sub_45AD54(a1, 0x16u, 0xEu, &v296, v295, &v324, v131, &v325);
                    if ( v45 >= 0 )
                    {
                      v45 = sub_45B4B0(a1, 22, 14, v296, (unsigned __int8)v295[0], v324, (int)a2, &v325);
                      if ( v45 >= 0 )
                      {
                        v45 = 0;
                        a2[2] = v325;
                      }
                    }
                    goto LABEL_69;
                  }
LABEL_70:
                  if ( v6 == -50 )
                  {
                    *(_DWORD *)(a1 + 3376) = 80;
                    v227 = a2[3];
                    a2[2] = a2[1];
                    v326 = v227;
                    return sslEncodeResponse(a1, a2, &v326, v20, v283, v284);
                  }
                  goto LABEL_71;
                }
                v6 = sub_45DA18(a1, a2, 1);
                if ( !v6 )
                {
                  v228 = 0;
                  if ( ((*(_DWORD *)(a1 + 4656) >> 20) & 1) != 0 )
                  {
                    v229 = *(_DWORD *)(a1 + 4660);
                    v230 = *(_DWORD *)(a1 + 4664);
                    v231 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 3144) + 140);
                    v232 = *a2 + a2[3];
                    v318 = (_BYTE *)a2[2];
                    v289 = v229 + v230 + v231 + 4;
                    v228 = sub_45AD54(a1, 0x16u, 0x16u, &v289, v288, &v317, v232, (int *)&v318);
                    if ( v228 >= 0 )
                    {
                      *v318++ = 1;
                      *v318++ = 0;
                      *v318++ = BYTE1(v231);
                      *v318 = v231;
                      v233 = *(_DWORD *)(*(_DWORD *)(a1 + 3144) + 136);
                      memcpy(++v318, v233, v231);
                      v318 += v231;
                      v228 = sub_45B4B0(a1, 22, 22, v289, (unsigned __int8)v288[0], v317, (int)a2, (int *)&v318);
                      if ( v228 >= 0 )
                      {
                        v228 = 0;
                        a2[2] = (int)v318;
                      }
                    }
                  }
                  v127 = *(_DWORD *)(a1 + 3372);
                  v6 = v228;
                  goto LABEL_417;
                }
LABEL_420:
                v128 = *(_DWORD *)(a1 + 3372) >> 7;
                goto LABEL_223;
              }
              if ( ((v127 >> 18) & 1) != 0 )
              {
                v128 = v127 >> 7;
                if ( v126 )
                  goto LABEL_223;
                Hint = matrixPskGetHint(a1, &v319, &v292);
                v133 = -12;
                if ( Hint < 0 )
                  goto LABEL_237;
                v133 = 0;
                if ( !v319 )
                  goto LABEL_237;
                if ( !v292 )
                {
                  v133 = 0;
                  goto LABEL_237;
                }
                v134 = *(_DWORD *)(a1 + 4660);
                v135 = *(_DWORD *)(a1 + 4664);
                v136 = *a2 + a2[3];
                v321 = (unsigned __int8 *)a2[2];
                v290 = v134 + v135 + v292 + 2;
                v133 = sub_45AD54(a1, 0x16u, 0xCu, &v290, &v291, &v320, v136, (int *)&v321);
                if ( v133 < 0 )
                  goto LABEL_237;
                *v321++ = 0;
                *v321++ = v292;
                memcpy(v321, v319, v292);
                v321 += v292;
                v133 = sub_45B4B0(a1, 22, 12, v290, v291, v320, (int)a2, (int *)&v321);
                if ( v133 < 0 )
                  goto LABEL_237;
                a2[2] = (int)v321;
              }
              else
              {
                v128 = v127 >> 7;
                if ( v126 )
                  goto LABEL_223;
                v6 = sub_45DA18(a1, a2, 1);
                if ( v6 )
                  goto LABEL_420;
                v133 = 0;
                if ( ((*(_DWORD *)(a1 + 4656) >> 20) & 1) == 0 )
                  goto LABEL_237;
                v222 = *(_DWORD *)(a1 + 4660);
                v223 = *(_DWORD *)(a1 + 4664);
                v224 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 3144) + 140);
                v225 = *a2 + a2[3];
                v323 = (_BYTE *)a2[2];
                v294 = v222 + v223 + v224 + 4;
                v133 = sub_45AD54(a1, 0x16u, 0x16u, &v294, v293, &v322, v225, (int *)&v323);
                if ( v133 < 0 )
                  goto LABEL_237;
                *v323++ = 1;
                *v323++ = 0;
                *v323++ = BYTE1(v224);
                *v323 = v224;
                v226 = *(_DWORD *)(*(_DWORD *)(a1 + 3144) + 136);
                memcpy(++v323, v226, v224);
                v323 += v224;
                v133 = sub_45B4B0(a1, 22, 22, v294, (unsigned __int8)v293[0], v322, (int)a2, (int *)&v323);
                if ( v133 < 0 )
                {
LABEL_237:
                  v127 = *(_DWORD *)(a1 + 3372);
                  v6 = v133;
                  goto LABEL_222;
                }
                a2[2] = (int)v323;
              }
              v127 = *(_DWORD *)(a1 + 3372);
              v6 = 0;
              goto LABEL_222;
            }
            v118 = v108 + v62 + v67 + *(unsigned __int16 *)(*(_DWORD *)(a1 + 3144) + 140);
            v116 = 2;
            v119 = 0;
            if ( ((v18 >> 2) & 1) == 0 )
            {
LABEL_208:
              v108 = v118 + 8 + v119;
              goto LABEL_209;
            }
            v120 = *(unsigned __int8 *)(a1 + 3367);
            v119 = *(unsigned __int8 *)(a1 + 3364) + v120;
            if ( ((v18 >> 12) & 1) != 0 )
            {
              v121 = v18 >> 20;
              if ( v120 < 2 )
                goto LABEL_203;
              v119 += v120;
            }
            v121 = v18 >> 20;
LABEL_203:
            if ( (v121 & 1) != 0 )
            {
              v122 = 8;
              if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
                v122 = 16;
              if ( ((v18 >> 22) & 1) != 0 )
                v119 += v122 + 8;
              else
                v119 += v122;
            }
            goto LABEL_208;
          }
          v110 = *(unsigned __int8 *)(a1 + 3367);
          v111 = 15 * (*(unsigned __int8 *)(a1 + 3364) + v110);
          v112 = v18 >> 20;
          if ( ((v18 >> 12) & 1) != 0 )
          {
            v113 = (v18 & 0x100000) != 0;
            if ( v110 < 2 )
            {
LABEL_183:
              if ( v113 )
              {
                v114 = 8;
                if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
                  v114 = 16;
                v115 = 15 * v114;
                if ( ((v18 >> 22) & 1) != 0 )
                  v115 = 15 * (v114 + 8);
                v111 += v115;
              }
              v108 += v111;
              goto LABEL_190;
            }
            v111 += 15 * v110;
            v112 = v18 >> 20;
          }
          v113 = v112 & 1;
          goto LABEL_183;
        }
        v105 = 8;
        if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
          v105 = 16;
        v106 = 3 * v105;
        if ( ((v18 >> 22) & 1) != 0 )
          v106 = 3 * (v105 + 8);
        v107 = v106;
LABEL_175:
        v101 += v107;
        goto LABEL_176;
      }
      v89 += v90;
    }
    v91 = v18 >> 20;
    goto LABEL_145;
  }
  if ( v19 == 255 )
  {
    v25 = *(_DWORD *)(a1 + 4660);
    v26 = *(_DWORD *)(a1 + 4664);
    v27 = 0;
    if ( ((v18 >> 2) & 1) == 0 )
      goto LABEL_433;
    v28 = *(unsigned __int8 *)(a1 + 3367);
    v27 = *(unsigned __int8 *)(a1 + 3364) + v28;
    if ( ((v18 >> 12) & 1) != 0 )
    {
      v29 = v18 >> 20;
      if ( v28 < 2 )
        goto LABEL_33;
      v27 += v28;
    }
    v29 = v18 >> 20;
LABEL_33:
    if ( (v29 & 1) != 0 )
    {
      v30 = *(_DWORD *)(a1 + 3344);
      v31 = 8;
      if ( ((*(_DWORD *)(v30 + 4) >> 13) & 1) == 0 )
        v31 = 16;
      if ( ((v18 >> 22) & 1) != 0 )
        v27 += v31 + 8;
      else
        v27 += v31;
LABEL_38:
      v32 = 2 * v25 + v26 + 37 + v27 + *(unsigned __int8 *)(v30 + 8) + *(unsigned __int8 *)(v30 + 11);
      if ( (v18 & 1) != 0 )
      {
        v33 = *(_DWORD *)(a1 + 3260);
        v34 = v18 >> 11;
        if ( !v33 )
        {
LABEL_43:
          if ( (v34 & 1) != 0 )
            v32 -= 24;
          if ( ((v18 >> 12) & 1) != 0 )
          {
            if ( ((v18 >> 20) & 1) != 0 )
            {
              v35 = 8;
              if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
                v35 = 16;
              if ( ((v18 >> 22) & 1) != 0 )
                v32 += v35 + 9;
              else
                v32 += v35 + 1;
            }
            else
            {
              v32 += *(unsigned __int8 *)(*(_DWORD *)(a1 + 3344) + 11);
            }
          }
          v36 = *a2 + a2[3];
          v15 = -50;
          if ( v36 - a2[2] < v32 )
          {
            *a3 = v32;
            return v15;
          }
          if ( (v18 & 1) != 0 )
          {
            v37 = *(_DWORD *)(a1 + 3260);
            if ( v37 )
            {
              if ( *(_WORD *)(v37 + 92) == 3 )
              {
                v277 = *(_DWORD *)(a1 + 4660) + *(_DWORD *)(a1 + 4664);
                v330 = a2[2];
                v300 = v277 + matrixSessionTicketLen() + 6;
                v331 = sub_45AD54(a1, 0x16u, 4u, &v300, v299, &v329, v36, &v330);
                v278 = v331;
                if ( v331 >= 0 )
                {
                  v331 = v36 - v330;
                  v279 = matrixCreateSessionTicket(a1, v330, &v331);
                  v278 = -12;
                  if ( v279 >= 0 )
                  {
                    v330 += v331;
                    v331 = sub_45B4B0(a1, 22, 4, v300, (unsigned __int8)v299[0], v329, (int)a2, &v330);
                    v278 = v331;
                    if ( v331 >= 0 )
                    {
                      v280 = v330;
                      *(_WORD *)(*(_DWORD *)(a1 + 3260) + 92) = 5;
                      a2[2] = v280;
                      v278 = 0;
                    }
                  }
                }
                v6 = v278;
                if ( v278 )
                  goto LABEL_70;
              }
            }
          }
          v38 = *a2 + a2[3];
          v39 = *(_DWORD *)(a1 + 4660) + 1;
          v333 = (_BYTE *)a2[2];
          v302 = v39;
          v40 = sub_45AD54(a1, 0x14u, 0, &v302, v301, &v332, v38, (int *)&v333);
          if ( v40 < 0
            || (*v333 = 1,
                ++v333,
                v40 = sub_45B4B0(a1, 20, 0, v302, (unsigned __int8)v301[0], v332, (int)a2, (int *)&v333),
                v40 < 0) )
          {
            v6 = v40;
            goto LABEL_70;
          }
          a2[2] = (int)v333;
          v41 = *a2;
          v42 = a2[3];
          v43 = (*(_DWORD *)(a1 + 3372) >> 11) & 1;
          v335 = a2[2];
          v44 = 36;
          if ( v43 )
            v44 = 12;
          v304 = *(_WORD *)(a1 + 4660) + *(_WORD *)(a1 + 4664) + v44;
          v45 = sub_45AD54(a1, 0x16u, 0x14u, &v304, v303, &v334, v41 + v42, &v335);
          if ( v45 < 0 )
            goto LABEL_69;
          v46 = v335;
          v47 = (*(_DWORD *)(a1 + 3372) >> 11) & 1;
          *(_DWORD *)(a1 + 3200) = v335;
          v48 = 12;
          if ( !v47 )
            v48 = 36;
          v335 = v48 + v46;
          v45 = sub_45B4B0(a1, 22, 20, v304, (unsigned __int8)v303[0], v334, (int)a2, &v335);
          if ( v45 < 0 )
            goto LABEL_69;
          v49 = v335;
          v50 = (*(_DWORD *)(a1 + 3372) >> 14) & 1;
          goto LABEL_64;
        }
        if ( *(_WORD *)(v33 + 92) == 3 )
        {
          v282 = v25 + v26;
          v281 = matrixSessionTicketLen();
          v18 = *(_DWORD *)(a1 + 3372);
          v32 += v282 + v281 + 6;
        }
      }
      v34 = v18 >> 11;
      goto LABEL_43;
    }
LABEL_433:
    v30 = *(_DWORD *)(a1 + 3344);
    goto LABEL_38;
  }
LABEL_20:
  if ( v6 != -50 )
  {
    v21 = 40;
    if ( v6 != -10 )
      v21 = 80;
    *(_DWORD *)(a1 + 3376) = v21;
    v22 = a2[3];
    a2[2] = a2[1];
    v326 = v22;
    return sslEncodeResponse(a1, a2, &v326, v20, v283, v284);
  }
LABEL_72:
  v52 = *(_DWORD *)(a1 + 3372) & 1;
  if ( v52 && *(_WORD *)(a1 + 3162) )
  {
    v6 = sub_459D0C(a1, a2);
    v15 = v6;
    if ( v6 < 0 )
      return v15;
    v52 = *(_DWORD *)(a1 + 3372) & 1;
  }
  if ( !v52 )
  {
    if ( *(_WORD *)(a1 + 3162) )
    {
      v6 = sub_45A220(a1);
      v15 = v6;
      if ( v6 < 0 )
        return v15;
    }
  }
  v53 = v6;
  if ( *(_DWORD *)(a1 + 3196) )
  {
    v76 = sub_45FE18(a1, a2 + 2);
    v15 = v76;
    if ( v76 < 0 )
      return v15;
    return v76;
  }
  return v53;
}
// 463984: conditional instruction was optimized away because $v1.4<0
// 463A50: conditional instruction was optimized away because $v1.4<0
// 463B00: conditional instruction was optimized away because $v1.4<0
// 4614F8: variable 'v20' is possibly undefined
// 4614F8: variable 'v283' is possibly undefined
// 4614F8: variable 'v284' is possibly undefined
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00463EB0) --------------------------------------------------------
int   sub_463EB0(int a1)
{
  int v2; // $a2
  int v3; // $v0
  int v4; // $v1
  int v5; // $ra
  int v6; // $t9
  int v7; // $s1
  int v8; // $t8
  int v9; // $s2
  int v10; // $t7
  int v11; // $t6
  int v12; // $t5
  int v13; // $a1
  int v14; // $t4
  int v15; // $t3
  int v16; // $t2
  int v17; // $t1
  int v18; // $a1
  int v19; // $v0
  int v20; // $s1
  int v21; // $s2
  int v22; // $v0
  unsigned __int8 *v23; // $a2
  int v24; // $a0
  int v25; // $a3
  int v26; // $v0
  int v27; // $t8
  int result; // $v0
  unsigned __int8 *v29; // $t6
  int v30; // $t8
  int v31; // $a1
  int v32; // $t7
  int v33; // $t4
  _BYTE v34[13]; // [sp+28h] [-50h] BYREF
  __int16 v35; // [sp+35h] [-43h]
  char v36; // [sp+37h] [-41h]
  char v37; // [sp+38h] [-40h]
  __int16 v38; // [sp+39h] [-3Fh]
  char v39; // [sp+3Bh] [-3Dh]
  char v40; // [sp+3Ch] [-3Ch]
  __int16 v41; // [sp+3Dh] [-3Bh]
  char v42; // [sp+3Fh] [-39h]
  char v43; // [sp+40h] [-38h]
  __int16 v44; // [sp+41h] [-37h]
  char v45; // [sp+43h] [-35h]
  char v46; // [sp+44h] [-34h]
  int v47; // [sp+45h] [-33h]
  int v48; // [sp+49h] [-2Fh]
  int v49; // [sp+4Dh] [-2Bh]
  __int16 v50; // [sp+51h] [-27h]
  char v51; // [sp+53h] [-25h]
  char v52; // [sp+54h] [-24h]
  __int16 v53; // [sp+55h] [-23h]
  char v54; // [sp+57h] [-21h]
  char v55; // [sp+58h] [-20h]
  int v56; // [sp+59h] [-1Fh]
  int v57; // [sp+5Dh] [-1Bh]
  int v58; // [sp+61h] [-17h]
  int v59; // [sp+65h] [-13h]
  int v60; // [sp+69h] [-Fh]
  int v61; // [sp+6Dh] [-Bh]
  __int16 v62; // [sp+71h] [-7h]
  char v63; // [sp+73h] [-5h]
  char v64; // [sp+74h] [-4h]

  v2 = *(_DWORD *)(a1 + 48);
  qmemcpy(v34, "key expansion", sizeof(v34));
  v37 = HIBYTE(v2);
  v3 = *(_DWORD *)(a1 + 52);
  v35 = v2;
  v36 = BYTE2(v2);
  v40 = HIBYTE(v3);
  v4 = *(_DWORD *)(a1 + 56);
  v38 = v3;
  v39 = BYTE2(v3);
  v43 = HIBYTE(v4);
  v5 = *(_DWORD *)(a1 + 60);
  v6 = *(_DWORD *)(a1 + 64);
  v41 = v4;
  v42 = BYTE2(v4);
  v46 = HIBYTE(v5);
  v7 = *(_DWORD *)(a1 + 76);
  v8 = *(_DWORD *)(a1 + 68);
  v9 = *(_DWORD *)(a1 + 72);
  v44 = v5;
  v45 = BYTE2(v5);
  v47 = v6;
  v48 = v8;
  v49 = v9;
  v52 = HIBYTE(v7);
  v10 = *(_DWORD *)(a1 + 16);
  v50 = v7;
  v51 = BYTE2(v7);
  v11 = *(_DWORD *)(a1 + 20);
  v55 = HIBYTE(v10);
  v12 = *(_DWORD *)(a1 + 24);
  v53 = v10;
  v54 = BYTE2(v10);
  v13 = *(_DWORD *)(a1 + 28);
  v14 = *(_DWORD *)(a1 + 32);
  v15 = *(_DWORD *)(a1 + 36);
  v16 = *(_DWORD *)(a1 + 40);
  v17 = *(_DWORD *)(a1 + 44);
  v56 = v11;
  v57 = v12;
  v58 = v13;
  v59 = v14;
  v60 = v15;
  v61 = v16;
  v64 = HIBYTE(v17);
  v18 = *(_DWORD *)(a1 + 3344);
  v62 = v17;
  v63 = BYTE2(v17);
  v19 = *(unsigned __int8 *)(v18 + 8) + *(unsigned __int8 *)(v18 + 9) + *(unsigned __int8 *)(v18 + 10);
  v20 = -8;
  if ( (unsigned int)(2 * v19) < 0xE1 )
  {
    v21 = a1 + 134;
    v22 = ((*(_DWORD *)(a1 + 3372) >> 13) & 1) != 0
        ? prf2(a1 + 80, 0x30u, (int)v34, 0x4Du, a1 + 134, 2 * v19, *(_DWORD *)(v18 + 4))
        : prf(a1 + 80, 0x30u, (int)v34, 0x4Du, a1 + 134, 2 * v19);
    v20 = v22;
    if ( v22 >= 0 )
    {
      if ( (*(_DWORD *)(a1 + 3372) & 1) != 0 )
      {
        v23 = *(unsigned __int8 **)(a1 + 3344);
        *(_DWORD *)(a1 + 364) = v21;
        v24 = v21 + v23[8];
        *(_DWORD *)(a1 + 360) = v24;
        v25 = v24 + v23[8];
        *(_DWORD *)(a1 + 372) = v25;
        v26 = v25 + v23[9];
        *(_DWORD *)(a1 + 368) = v26;
        v27 = v26 + v23[9];
        *(_DWORD *)(a1 + 540) = v27;
        *(_DWORD *)(a1 + 536) = v27 + v23[10];
      }
      else
      {
        v29 = *(unsigned __int8 **)(a1 + 3344);
        *(_DWORD *)(a1 + 360) = v21;
        v30 = v21 + v29[8];
        *(_DWORD *)(a1 + 364) = v30;
        v31 = v30 + v29[8];
        *(_DWORD *)(a1 + 368) = v31;
        v32 = v31 + v29[9];
        *(_DWORD *)(a1 + 372) = v32;
        v33 = v32 + v29[9];
        *(_DWORD *)(a1 + 536) = v33;
        *(_DWORD *)(a1 + 540) = v33 + v29[10];
      }
      v20 = 48;
    }
  }
  memset_s(v34, 0x4Du, 0, 0x4Du);
  result = v20;
  if ( v20 < 0 )
  {
    memset_s((unsigned __int8 *)(a1 + 80), 0x30u, 0, 0x30u);
    memset_s((unsigned __int8 *)(a1 + 134), 0xE0u, 0, 0xE0u);
    return v20;
  }
  return result;
}

//----- (004641B8) --------------------------------------------------------
int   tlsDeriveKeys(int a1)
{
  unsigned int v1; // $t1
  int v3; // $a2
  int v4; // $a0
  int v5; // $a0
  int v6; // $a3
  int v7; // $t0
  int v8; // $a0
  int v9; // $v0
  int v10; // $a1
  int v11; // $v1
  int v12; // $a2
  int v13; // $ra
  int v14; // $t9
  int v15; // $t8
  int v16; // $t7
  int v17; // $t6
  int v18; // $t5
  int v19; // $t4
  int v20; // $t3
  int v21; // $t0
  int v22; // $v0
  _BYTE v24[13]; // [sp+28h] [-50h] BYREF
  __int16 v25; // [sp+35h] [-43h]
  char v26; // [sp+37h] [-41h]
  char v27; // [sp+38h] [-40h]
  __int16 v28; // [sp+39h] [-3Fh]
  char v29; // [sp+3Bh] [-3Dh]
  char v30; // [sp+3Ch] [-3Ch]
  __int16 v31; // [sp+3Dh] [-3Bh]
  char v32; // [sp+3Fh] [-39h]
  char v33; // [sp+40h] [-38h]
  __int16 v34; // [sp+41h] [-37h]
  char v35; // [sp+43h] [-35h]
  char v36; // [sp+44h] [-34h]
  int v37; // [sp+45h] [-33h]
  int v38; // [sp+49h] [-2Fh]
  int v39; // [sp+4Dh] [-2Bh]
  __int16 v40; // [sp+51h] [-27h]
  char v41; // [sp+53h] [-25h]
  char v42; // [sp+54h] [-24h]
  __int16 v43; // [sp+55h] [-23h]
  char v44; // [sp+57h] [-21h]
  char v45; // [sp+58h] [-20h]
  int v46; // [sp+59h] [-1Fh]
  int v47; // [sp+5Dh] [-1Bh]
  int v48; // [sp+61h] [-17h]
  int v49; // [sp+65h] [-13h]
  int v50; // [sp+69h] [-Fh]
  int v51; // [sp+6Dh] [-Bh]
  int v52; // [sp+71h] [-7h]

  v1 = *(_DWORD *)(a1 + 3372);
  if ( ((v1 >> 14) & 1) == 0 || (v3 = *(_DWORD *)(a1 + 3580), v4 = 48, v3 != 1) )
  {
    v5 = a1;
    if ( ((v1 >> 3) & 1) != 0 )
      return sub_463EB0(v5);
    v6 = *(_DWORD *)(a1 + 16);
    qmemcpy(v24, "master secret", sizeof(v24));
    v27 = HIBYTE(v6);
    v7 = *(_DWORD *)(a1 + 20);
    v25 = v6;
    v26 = BYTE2(v6);
    v30 = HIBYTE(v7);
    v8 = *(_DWORD *)(a1 + 24);
    v28 = v7;
    v29 = BYTE2(v7);
    v33 = HIBYTE(v8);
    v9 = *(_DWORD *)(a1 + 28);
    v10 = *(_DWORD *)(a1 + 32);
    v31 = v8;
    v32 = BYTE2(v8);
    v36 = HIBYTE(v9);
    v11 = *(_DWORD *)(a1 + 36);
    v12 = *(_DWORD *)(a1 + 40);
    v13 = *(_DWORD *)(a1 + 44);
    v34 = v9;
    v35 = BYTE2(v9);
    v37 = v10;
    v38 = v11;
    v39 = v12;
    v42 = HIBYTE(v13);
    v14 = *(_DWORD *)(a1 + 48);
    v40 = v13;
    v41 = BYTE2(v13);
    v15 = *(_DWORD *)(a1 + 52);
    v45 = HIBYTE(v14);
    v16 = *(_DWORD *)(a1 + 56);
    v43 = v14;
    v44 = BYTE2(v14);
    v17 = *(_DWORD *)(a1 + 60);
    v18 = *(_DWORD *)(a1 + 64);
    v19 = *(_DWORD *)(a1 + 68);
    v20 = *(_DWORD *)(a1 + 72);
    v21 = *(_DWORD *)(a1 + 76);
    v46 = v15;
    v47 = v16;
    v48 = v17;
    v49 = v18;
    v50 = v19;
    v51 = v20;
    v52 = v21;
    if ( ((v1 >> 13) & 1) != 0 )
      v22 = prf2(
              *(_DWORD *)(a1 + 128),
              *(_WORD *)(a1 + 132),
              (int)v24,
              0x4Du,
              a1 + 80,
              0x30u,
              *(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4));
    else
      v22 = prf(*(_DWORD *)(a1 + 128), *(_WORD *)(a1 + 132), (int)v24, 0x4Du, a1 + 80, 0x30u);
    v4 = v22;
    if ( v22 >= 0 )
    {
      v5 = a1;
      if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) == 0 )
      {
        free2(*(_DWORD *)(a1 + 128));
        *(_DWORD *)(a1 + 128) = 0;
        *(_WORD *)(a1 + 132) = 0;
        v5 = a1;
      }
      return sub_463EB0(v5);
    }
  }
  return v4;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (004643D8) --------------------------------------------------------
int   tlsExtendedDeriveKeys(int a1)
{
  unsigned int v2; // $a0
  int v3; // $a1
  int v5; // $v0
  int v6; // $a0
  _BYTE v7[22]; // [sp+28h] [-80h] BYREF
  _BYTE v8[50]; // [sp+3Eh] [-6Ah] BYREF
  _DWORD v9[12]; // [sp+70h] [-38h] BYREF
  int v10; // [sp+A0h] [-8h] BYREF

  v2 = *(_DWORD *)(a1 + 3372);
  if ( ((v2 >> 14) & 1) != 0 )
  {
    v3 = 48;
    if ( *(_DWORD *)(a1 + 3580) == 1 )
      return v3;
  }
  if ( ((*(_DWORD *)(a1 + 4656) >> 17) & 1) == 0 || ((v2 >> 3) & 1) != 0 )
    return -1;
  extMasterSecretSnapshotHSHash((int *)a1, v9, (int)&v10);
  qmemcpy(v7, "extended master secret", sizeof(v7));
  memcpy(v8, v9, v10);
  if ( ((*(_DWORD *)(a1 + 3372) >> 13) & 1) != 0 )
    v5 = prf2(
           *(_DWORD *)(a1 + 128),
           *(_WORD *)(a1 + 132),
           (int)v7,
           v10 + 22,
           a1 + 80,
           0x30u,
           *(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4));
  else
    v5 = prf(*(_DWORD *)(a1 + 128), *(_WORD *)(a1 + 132), (int)v7, v10 + 22, a1 + 80, 0x30u);
  v3 = v5;
  if ( v5 < 0 )
    return v3;
  v6 = a1;
  if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) == 0 )
  {
    free2(*(_DWORD *)(a1 + 128));
    *(_DWORD *)(a1 + 128) = 0;
    *(_WORD *)(a1 + 132) = 0;
    v6 = a1;
  }
  return sub_463EB0(v6);
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (004645C8) --------------------------------------------------------
int   tlsHMACSha1(int a1, int a2, char a3, int a4, unsigned int a5, int a6)
{
  char v7; // $t1
  char v8; // $t2
  int v9; // $a3
  __int16 *v10; // $s0
  int v11; // $v1
  int v12; // $v0
  int v13; // $a1
  _BYTE *v14; // $t1
  char v15; // $t3
  __int16 v17; // $t8
  __int16 v18; // $ra
  __int16 v19; // $t9
  int v20; // $t6
  char v21; // $t7
  char v22; // $t5
  char v23; // $a1
  _BYTE v24[160]; // [sp+18h] [-B0h] BYREF
  _BYTE v25[8]; // [sp+B8h] [-10h] BYREF
  __int16 v26; // [sp+C0h] [-8h] BYREF
  int v27; // [sp+C2h] [-6h]
  __int16 v28; // [sp+C6h] [-2h]

  v7 = *(_BYTE *)(a1 + 3389);
  v8 = *(_BYTE *)(a1 + 3390);
  if ( a2 == 1 )
  {
    v9 = a1 + 376;
    v10 = (__int16 *)(a1 + 576);
  }
  else
  {
    v9 = a1 + 424;
    v10 = (__int16 *)(a1 + 584);
  }
  v11 = -1;
  if ( v9 )
  {
    if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
    {
      if ( a2 == 1 )
      {
        v20 = *(_DWORD *)(a1 + 3537);
        v21 = *(_BYTE *)(a1 + 3530);
        v22 = *(_BYTE *)(a1 + 3542);
        v23 = *(_BYTE *)(a1 + 3541);
        LOBYTE(v26) = *(_BYTE *)(a1 + 3529);
        HIBYTE(v26) = v21;
        v10 = &v26;
        v27 = v20;
        LOBYTE(v28) = v23;
        HIBYTE(v28) = v22;
      }
      else
      {
        v17 = *(_WORD *)(a1 + 10);
        v18 = *(_WORD *)(a1 + 6);
        v19 = *(_WORD *)(a1 + 8);
        v10 = &v26;
        v26 = *(_WORD *)(a1 + 4);
        LOWORD(v27) = v18;
        HIWORD(v27) = v19;
        v28 = v17;
      }
    }
    v25[0] = a3;
    v25[1] = v7;
    v25[2] = v8;
    v25[3] = BYTE1(a5);
    v25[4] = a5;
    v12 = psHmacSha1Init((int)v24, v9, 0x14u);
    v11 = -1;
    if ( v12 >= 0 )
    {
      psHmacSha1Update((int)v24, (int)v10, 8u);
      psHmacSha1Update((int)v24, (int)v25, 5u);
      psHmacSha1Update((int)v24, a4, a5);
      psHmacSha1Final((int)v24, a6);
      v13 = 7;
      do
      {
        v14 = (char *)v10 + v13;
        v15 = *((_BYTE *)v10 + v13--);
        *v14 = v15 + 1;
      }
      while ( v15 == -1 && v13 >= 0 );
      return 0;
    }
  }
  return v11;
}

//----- (00464788) --------------------------------------------------------
int   tlsHMACSha2(int a1, int a2, char a3, int a4, unsigned int a5, _DWORD *a6, int a7)
{
  char v8; // $t1
  char v9; // $t2
  int v10; // $a3
  __int16 *v11; // $s0
  int v12; // $v1
  int v13; // $a2
  unsigned int v14; // $a1
  unsigned __int16 v15; // $a3
  int v16; // $v0
  int v17; // $a1
  _BYTE *v18; // $t2
  char v19; // $t4
  __int16 v21; // $t9
  __int16 v22; // $v1
  __int16 v23; // $ra
  int v24; // $t7
  char v25; // $t8
  char v26; // $t6
  char v27; // $a1
  _BYTE v28[344]; // [sp+18h] [-168h] BYREF
  char v29; // [sp+170h] [-10h] BYREF
  char v30; // [sp+171h] [-Fh]
  char v31; // [sp+172h] [-Eh]
  char v32; // [sp+173h] [-Dh]
  char v33; // [sp+174h] [-Ch]
  __int16 v34; // [sp+178h] [-8h] BYREF
  int v35; // [sp+17Ah] [-6h]
  __int16 v36; // [sp+17Eh] [-2h]

  v8 = *(_BYTE *)(a1 + 3389);
  v9 = *(_BYTE *)(a1 + 3390);
  if ( a2 == 1 )
  {
    v10 = a1 + 376;
    v11 = (__int16 *)(a1 + 576);
  }
  else
  {
    v10 = a1 + 424;
    v11 = (__int16 *)(a1 + 584);
  }
  v12 = -1;
  if ( !v10 )
    return v12;
  if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) == 0 )
  {
LABEL_5:
    v29 = a3;
    v30 = v8;
    v31 = v9;
    v32 = BYTE1(a5);
    v33 = a5;
    if ( a7 != 32 )
      goto LABEL_6;
LABEL_16:
    v13 = v10;
    v14 = 20;
    v15 = 32;
LABEL_8:
    v16 = psHmacInit((int)v28, v14, v13, v15);
    v12 = -1;
    if ( v16 >= 0 )
    {
      psHmacUpdate((int)v28, (int)v11, 8u);
      psHmacUpdate((int)v28, (int)&v29, 5u);
      psHmacUpdate((int)v28, a4, a5);
      psHmacFinal((int)v28, a6);
      v17 = 7;
      do
      {
        v18 = (char *)v11 + v17;
        v19 = *((_BYTE *)v11 + v17--);
        *v18 = v19 + 1;
      }
      while ( v19 == -1 && v17 >= 0 );
      return 0;
    }
    return v12;
  }
  if ( a2 == 1 )
  {
    v24 = *(_DWORD *)(a1 + 3537);
    v25 = *(_BYTE *)(a1 + 3529);
    v26 = *(_BYTE *)(a1 + 3542);
    v27 = *(_BYTE *)(a1 + 3541);
    HIBYTE(v34) = *(_BYTE *)(a1 + 3530);
    LOBYTE(v34) = v25;
    v11 = &v34;
    v35 = v24;
    LOBYTE(v36) = v27;
    HIBYTE(v36) = v26;
    goto LABEL_5;
  }
  v21 = *(_WORD *)(a1 + 10);
  v22 = *(_WORD *)(a1 + 6);
  v23 = *(_WORD *)(a1 + 8);
  v34 = *(_WORD *)(a1 + 4);
  LOWORD(v35) = v22;
  HIWORD(v35) = v23;
  v36 = v21;
  v11 = &v34;
  v29 = a3;
  v30 = v8;
  v31 = v9;
  v32 = BYTE1(a5);
  v33 = a5;
  if ( a7 == 32 )
    goto LABEL_16;
LABEL_6:
  v13 = v10;
  if ( a7 == 48 )
  {
    v14 = 21;
    v15 = 48;
    goto LABEL_8;
  }
  return -1;
}

//----- (004649B4) --------------------------------------------------------
int   sslCreateKeys(int a1)
{
  if ( ((*(_DWORD *)(a1 + 3372) >> 11) & 1) != 0 )
    return tlsDeriveKeys(a1);
  else
    return -6;
}

//----- (004649E8) --------------------------------------------------------
int   sslActivateReadCipher(int a1)
{
  int v1; // $a3
  __int16 v2; // $a1
  int v4; // $a0
  unsigned __int8 v5; // $a2
  char v6; // $t1
  int v7; // $v1
  char v9; // $t1
  int v10; // $a1
  int v11; // $t4
  int v12; // $v1
  unsigned int v13; // $v0
  int v14; // $v0
  int v15; // $v0
  int (  *v16)(int, int, _DWORD); // $t9
  int v17; // $v0

  v1 = *(_DWORD *)(a1 + 3344);
  v2 = *(_WORD *)(a1 + 4658);
  v4 = *(_DWORD *)(v1 + 28);
  *(_DWORD *)(a1 + 3352) = *(_DWORD *)(v1 + 20);
  *(_DWORD *)(a1 + 3360) = v4;
  *(_BYTE *)(a1 + 3369) = *(_BYTE *)(v1 + 8);
  if ( (v2 & 1) == 0 )
  {
    v5 = *(_BYTE *)(v1 + 8);
LABEL_7:
    *(_BYTE *)(a1 + 3368) = v5;
    *(_BYTE *)(a1 + 3371) = *(_BYTE *)(v1 + 11);
    v9 = *(_BYTE *)(v1 + 10);
    *(_DWORD *)(a1 + 584) = 0;
    *(_BYTE *)(a1 + 3370) = v9;
    *(_DWORD *)(a1 + 588) = 0;
    v7 = 0;
    if ( !*(_WORD *)v1 )
      return v7;
    goto LABEL_8;
  }
  v5 = 10;
  if ( *(_BYTE *)(v1 + 8) )
    goto LABEL_7;
  v5 = *(_BYTE *)(v1 + 8);
  *(_BYTE *)(a1 + 3368) = 0;
  *(_BYTE *)(a1 + 3371) = *(_BYTE *)(v1 + 11);
  v6 = *(_BYTE *)(v1 + 10);
  *(_DWORD *)(a1 + 584) = 0;
  *(_BYTE *)(a1 + 3370) = v6;
  *(_DWORD *)(a1 + 588) = 0;
  if ( !*(_WORD *)v1 )
    return 0;
LABEL_8:
  v10 = *(_DWORD *)(a1 + 364);
  v7 = -1;
  if ( !v10 )
    return v7;
  v11 = *(_DWORD *)(a1 + 3372);
  if ( v5 )
  {
    v13 = v11 & 0xFFDFFFFD | 2;
    v12 = -8388609;
  }
  else
  {
    v12 = v11 | 0x200002;
    *(_DWORD *)(a1 + 3372) = v11 | 0x200002;
    if ( ((*(_DWORD *)(v1 + 4) >> 6) & 1) == 0 )
    {
      v14 = v11 | 0xA00002;
      goto LABEL_13;
    }
    v13 = -8388609;
  }
  v14 = v13 & v12;
LABEL_13:
  *(_DWORD *)(a1 + 3372) = v14;
  memcpy(a1 + 424, v10, v5);
  memcpy(a1 + 504, *(_DWORD *)(a1 + 372), *(unsigned __int8 *)(*(_DWORD *)(a1 + 3344) + 9));
  memcpy(a1 + 560, *(_DWORD *)(a1 + 540), *(unsigned __int8 *)(*(_DWORD *)(a1 + 3344) + 10));
  v15 = *(_DWORD *)(a1 + 3344);
  v16 = *(int (  **)(int, int, _DWORD))(v15 + 12);
  v7 = 0;
  if ( v16 )
  {
    v17 = v16(a1 + 16, 1, *(unsigned __int8 *)(v15 + 9));
    v7 = -1;
    if ( v17 >= 0 )
      return 0;
  }
  return v7;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00464BBC) --------------------------------------------------------
int   sslActivateWriteCipher(int a1)
{
  int v2; // $a0
  int v3; // $a1
  __int16 v4; // $a2
  int v5; // $a3
  unsigned __int8 v6; // $a2
  char v7; // $t2
  int v8; // $v1
  char v10; // $t2
  int v11; // $t5
  int v12; // $v1
  unsigned int v13; // $v0
  int v14; // $v0
  int v15; // $a1
  int v16; // $v0
  int (  *v17)(int, _DWORD, _DWORD); // $t9
  int v18; // $v0
  unsigned __int8 v19; // $a2
  char v20; // $a3
  int v21; // $t3
  int v22; // $t2
  char v23; // $t1
  int *v24; // $a2
  _DWORD *v25; // $a3
  int v26; // $t7
  int v27; // $t6
  int v28; // $t5
  int v29; // $t4
  int v30; // $ra

  if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 )
  {
    v2 = a1 + 3812;
    if ( !*(_DWORD *)(a1 + 3580) )
    {
      v19 = *(_BYTE *)(a1 + 3364);
      v20 = *(_BYTE *)(a1 + 3366);
      v21 = *(_DWORD *)(a1 + 3348);
      v22 = *(_DWORD *)(a1 + 3356);
      v23 = *(_BYTE *)(a1 + 3365);
      *(_BYTE *)(a1 + 3795) = *(_BYTE *)(a1 + 3367);
      *(_BYTE *)(a1 + 3794) = v20;
      *(_BYTE *)(a1 + 3792) = v19;
      *(_DWORD *)(a1 + 3784) = v21;
      *(_DWORD *)(a1 + 3788) = v22;
      *(_BYTE *)(a1 + 3793) = v23;
      memcpy(v2, a1 + 376, v19);
      v24 = (int *)(a1 + 612);
      v25 = (_DWORD *)(a1 + 3860);
      do
      {
        v26 = *v24;
        v27 = v24[1];
        v28 = v24[2];
        v29 = v24[3];
        v24 += 4;
        *v25 = v26;
        v25[1] = v27;
        v25[2] = v28;
        v25[3] = v29;
        v25 += 4;
      }
      while ( v24 != (int *)(a1 + 1380) );
      v30 = *v24;
      v25[1] = v24[1];
      *v25 = v30;
      memcpy(a1 + 3796, a1 + 544, *(unsigned __int8 *)(*(_DWORD *)(a1 + 3344) + 10));
    }
  }
  v3 = *(_DWORD *)(a1 + 3344);
  v4 = *(_WORD *)(a1 + 4658);
  v5 = *(_DWORD *)(v3 + 24);
  *(_DWORD *)(a1 + 3348) = *(_DWORD *)(v3 + 16);
  *(_DWORD *)(a1 + 3356) = v5;
  *(_BYTE *)(a1 + 3365) = *(_BYTE *)(v3 + 8);
  if ( (v4 & 1) == 0 )
  {
    v6 = *(_BYTE *)(v3 + 8);
LABEL_9:
    *(_BYTE *)(a1 + 3364) = v6;
    *(_BYTE *)(a1 + 3367) = *(_BYTE *)(v3 + 11);
    v10 = *(_BYTE *)(v3 + 10);
    *(_DWORD *)(a1 + 576) = 0;
    *(_BYTE *)(a1 + 3366) = v10;
    *(_DWORD *)(a1 + 580) = 0;
    v8 = 0;
    if ( !*(_WORD *)v3 )
      return v8;
    goto LABEL_10;
  }
  v6 = 10;
  if ( *(_BYTE *)(v3 + 8) )
    goto LABEL_9;
  v6 = *(_BYTE *)(v3 + 8);
  *(_BYTE *)(a1 + 3364) = 0;
  *(_BYTE *)(a1 + 3367) = *(_BYTE *)(v3 + 11);
  v7 = *(_BYTE *)(v3 + 10);
  *(_DWORD *)(a1 + 576) = 0;
  *(_BYTE *)(a1 + 3366) = v7;
  *(_DWORD *)(a1 + 580) = 0;
  if ( !*(_WORD *)v3 )
    return 0;
LABEL_10:
  v11 = *(_DWORD *)(a1 + 3372);
  if ( v6 )
  {
    v13 = v11 & 0xFFEFFFFB | 4;
    v12 = -4194305;
  }
  else
  {
    v12 = v11 | 0x100004;
    *(_DWORD *)(a1 + 3372) = v11 | 0x100004;
    if ( ((*(_DWORD *)(v3 + 4) >> 6) & 1) == 0 )
    {
      v14 = v11 | 0x500004;
      goto LABEL_14;
    }
    v13 = -4194305;
  }
  v14 = v13 & v12;
LABEL_14:
  v15 = *(_DWORD *)(a1 + 360);
  *(_DWORD *)(a1 + 3372) = v14;
  memcpy(a1 + 376, v15, v6);
  memcpy(a1 + 472, *(_DWORD *)(a1 + 368), *(unsigned __int8 *)(*(_DWORD *)(a1 + 3344) + 9));
  memcpy(a1 + 544, *(_DWORD *)(a1 + 536), *(unsigned __int8 *)(*(_DWORD *)(a1 + 3344) + 10));
  v16 = *(_DWORD *)(a1 + 3344);
  v17 = *(int (  **)(int, _DWORD, _DWORD))(v16 + 12);
  v8 = 0;
  if ( v17 )
  {
    v18 = v17(a1 + 16, 0, *(unsigned __int8 *)(v16 + 9));
    v8 = -1;
    if ( v18 >= 0 )
      return 0;
  }
  return v8;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00464E5C) --------------------------------------------------------
int sub_464E5C()
{
  return 0;
}

//----- (00464E64) --------------------------------------------------------
int   csAesGcmInit(int a1, int a2, unsigned __int8 a3)
{
  int v3; // $s0
  int v5; // $s2
  int v7; // $a0
  int v8; // $a0
  unsigned int *v9; // $a1
  int inited; // $v1

  v3 = a1 + 1372;
  v5 = a1 + 596;
  v7 = a1 + 1372;
  if ( a2 )
  {
    memset(v7, 0, 508);
    v8 = v3;
    v9 = (unsigned int *)(a1 + 488);
  }
  else
  {
    memset(v5, 0, 508);
    v8 = v5;
    v9 = (unsigned int *)(a1 + 456);
  }
  inited = psAesInitGCM(v8, v9, a3);
  if ( inited >= 0 )
    return 0;
  return inited;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (00464F18) --------------------------------------------------------
unsigned int   csAesGcmEncrypt(int a1, _BYTE *a2, _BYTE *a3, unsigned int a4)
{
  int v8; // $v1
  int v9; // $v1
  int v10; // $a0
  unsigned int v11; // $s1
  char v12; // $t4^3
  char v13; // $t3
  int v14; // $t2
  __int16 v15; // $t4
  char v16; // $t4^2
  char v17; // $t1
  char v18; // $t0
  char v19; // $ra
  char v20; // $a0
  int v21; // $a1
  int v22; // $s5
  char v23; // $a2
  int v25; // $t5
  int v26; // [sp+18h] [-20h] BYREF
  int v27; // [sp+1Ch] [-1Ch]
  int v28; // [sp+20h] [-18h]
  __int64 v29; // [sp+28h] [-10h] BYREF
  char v30; // [sp+30h] [-8h]
  char v31; // [sp+31h] [-7h]
  char v32; // [sp+32h] [-6h]
  char v33; // [sp+33h] [-5h]
  char v34; // [sp+34h] [-4h]

  v8 = 0;
  if ( a4 )
  {
    v8 = -9;
    if ( a4 >= 0x11 )
    {
      v9 = *(_DWORD *)(a1 + 544);
      v10 = (*(_DWORD *)(a1 + 3372) >> 14) & 1;
      v26 = v9;
      v11 = a4 - 16;
      if ( v10 )
      {
        v12 = *(_BYTE *)(a1 + 3540);
        v13 = *(_BYTE *)(a1 + 3530);
        HIBYTE(v14) = v12;
        v15 = *(_WORD *)(a1 + 3537);
        v16 = *(_BYTE *)(a1 + 3539);
        LOBYTE(v27) = *(_BYTE *)(a1 + 3529);
        BYTE1(v27) = v13;
        LOWORD(v14) = *(_WORD *)(a1 + 3537);
        BYTE2(v14) = *(_BYTE *)(a1 + 3539);
        LOBYTE(v28) = v16;
        BYTE1(v28) = v12;
        v17 = *(_BYTE *)(a1 + 3541);
        v18 = *(_BYTE *)(a1 + 3542);
        HIWORD(v27) = v15;
        LOBYTE(v29) = v27;
        BYTE1(v29) = v13;
        BYTE2(v28) = v17;
        HIBYTE(v28) = v18;
        *(_DWORD *)((char *)&v29 + 2) = v14;
        BYTE6(v29) = v17;
        HIBYTE(v29) = v18;
      }
      else
      {
        v25 = *(_DWORD *)(a1 + 580);
        LODWORD(v29) = *(_DWORD *)(a1 + 576);
        HIDWORD(v29) = v25;
        v27 = v29;
        v28 = v25;
      }
      v19 = *(_BYTE *)(a1 + 3390);
      v20 = *(_BYTE *)(a1 + 3392);
      v31 = *(_BYTE *)(a1 + 3389);
      v32 = v19;
      v33 = (unsigned __int16)(a4 - 16) >> 8;
      v34 = a4 - 16;
      v30 = v20;
      psAesReadyGCM(a1 + 612, &v26, (int)&v29, 0xDu);
      psAesEncryptGCM(a1 + 612, a2, a3, v11);
      psAesGetGCMTag(a1 + 612, 0x10u, &a3[v11]);
      v8 = a4;
      if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) == 0 )
      {
        v21 = 7;
        v22 = a1 + 7;
        do
        {
          v23 = *(_BYTE *)(v22 + 576);
          --v21;
          *(_BYTE *)(v22 + 576) = v23 + 1;
          if ( v23 != -1 )
            break;
          v22 = v21 + a1;
        }
        while ( v21 >= 0 );
        return a4;
      }
    }
  }
  return v8;
}

//----- (004650D4) --------------------------------------------------------
int   csAesGcmDecrypt(int a1, _DWORD *a2, _BYTE *a3, int a4)
{
  unsigned int v5; // $t2
  int v6; // $a0
  int v7; // $t0
  _BYTE *v9; // $s4
  unsigned int v10; // $s3
  __int16 v11; // $a3
  __int16 v12; // $a2
  __int16 v13; // $a1
  char v14; // $t8
  char v15; // $t7
  int v16; // $a2
  int result; // $v0
  int v18; // $a1
  int v19; // $s3
  char v20; // $s5
  int v21; // $t4
  _DWORD v22[4]; // [sp+20h] [-20h] BYREF
  int v23; // [sp+30h] [-10h] BYREF
  int v24; // [sp+34h] [-Ch]
  char v25; // [sp+38h] [-8h]
  char v26; // [sp+39h] [-7h]
  char v27; // [sp+3Ah] [-6h]
  char v28; // [sp+3Bh] [-5h]
  char v29; // [sp+3Ch] [-4h]

  v5 = *(_DWORD *)(a1 + 3372);
  v6 = *a2;
  v7 = a2[1];
  v22[0] = *(_DWORD *)(a1 + 560);
  v22[1] = v6;
  v22[2] = v7;
  v9 = a2 + 2;
  v10 = a4 - 8;
  if ( ((v5 >> 14) & 1) != 0 )
  {
    v11 = *(_WORD *)(a1 + 6);
    v12 = *(_WORD *)(a1 + 8);
    v13 = *(_WORD *)(a1 + 10);
    LOWORD(v23) = *(_WORD *)(a1 + 4);
    HIWORD(v23) = v11;
    LOWORD(v24) = v12;
    HIWORD(v24) = v13;
  }
  else
  {
    v21 = *(_DWORD *)(a1 + 588);
    v23 = *(_DWORD *)(a1 + 584);
    v24 = v21;
  }
  v14 = *(_BYTE *)(a1 + 3389);
  v15 = *(_BYTE *)(a1 + 3390);
  v25 = *(_BYTE *)(a1 + 12);
  v26 = v14;
  v27 = v15;
  v28 = (unsigned __int16)(v10 - 16) >> 8;
  v29 = v10 - 16;
  psAesReadyGCM(a1 + 1388, v22, (int)&v23, 0xDu);
  v16 = psAesDecryptGCM(a1 + 1388, v9, v10, a3, v10 - 16);
  result = -1;
  if ( v16 >= 0 )
  {
    v18 = 7;
    v19 = a1 + 7;
    do
    {
      v20 = *(_BYTE *)(v19 + 584);
      --v18;
      *(_BYTE *)(v19 + 584) = v20 + 1;
      if ( v20 != -1 )
        break;
      v19 = v18 + a1;
    }
    while ( v18 >= 0 );
    return v16;
  }
  return result;
}

//----- (0046523C) --------------------------------------------------------
int   csAesInit(int a1, int a2, unsigned __int8 a3)
{
  int v3; // $s0
  int v5; // $s2
  int v7; // $a0
  int inited; // $v0
  int v9; // $v1

  v3 = a1 + 1372;
  v5 = a1 + 596;
  v7 = a1 + 1372;
  if ( a2 )
  {
    memset(v7, 0, 276);
    inited = psAesInitCBC(v3, a1 + 544, (unsigned int *)(a1 + 488), a3, 2);
  }
  else
  {
    memset(v5, 0, 276);
    inited = psAesInitCBC(v5, a1 + 528, (unsigned int *)(a1 + 456), a3, 1);
  }
  v9 = inited;
  if ( inited >= 0 )
    return 0;
  return v9;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (00465310) --------------------------------------------------------
unsigned int   csAesEncrypt(int a1, int a2, _BYTE *a3, unsigned int a4)
{
  psAesEncryptCBC(a1 + 612, a2, a3, a4);
  return a4;
}

//----- (00465354) --------------------------------------------------------
unsigned int   csAesDecrypt(int a1, unsigned int *a2, int a3, unsigned int a4)
{
  psAesDecryptCBC(a1 + 1388, a2, a3, a4);
  return a4;
}

//----- (00465398) --------------------------------------------------------
int   sub_465398(int a1, int a2, int a3, int a4)
{
  if ( a3 != a2 )
    memcpy(a3, a2, a4);
  return a4;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (004653EC) --------------------------------------------------------
int   sub_4653EC(int a1, int a2, int a3, int a4)
{
  if ( a3 != a2 )
    memmove(a3);
  return a4;
}
// 4EA0A8: using guessed type int   memmove(_DWORD);

//----- (00465440) --------------------------------------------------------
int sub_465440()
{
  return 0;
}

//----- (00465448) --------------------------------------------------------
int sub_465448()
{
  return 0;
}

//----- (00465450) --------------------------------------------------------
int   sub_465450(int a1, char a2, int a3, unsigned int a4, int a5)
{
  int v6; // $v1
  int v7; // $v1
  _DWORD v9[16]; // [sp+28h] [-40h] BYREF

  v6 = -6;
  if ( ((*(_DWORD *)(a1 + 3372) >> 11) & 1) != 0 )
  {
    v7 = *(unsigned __int8 *)(a1 + 3365);
    if ( v7 == 32 || v7 == 48 )
      tlsHMACSha2(a1, 1, a2, a3, a4, v9, v7);
    else
      tlsHMACSha1(a1, 1, a2, a3, a4, (int)v9);
    memcpy(a5, v9, *(unsigned __int8 *)(a1 + 3364));
    return *(unsigned __int8 *)(a1 + 3364);
  }
  return v6;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00465528) --------------------------------------------------------
int   sub_465528(int a1, char a2, int a3, unsigned int a4, int a5)
{
  int v8; // $v1
  int v9; // $t5
  unsigned int v10; // $a1
  unsigned int v11; // $a3
  _DWORD v13[16]; // [sp+28h] [-40h] BYREF

  if ( ((*(_DWORD *)(a1 + 3372) >> 11) & 1) == 0 )
  {
    v10 = 20;
    v11 = 20;
    goto LABEL_7;
  }
  v8 = *(unsigned __int8 *)(a1 + 3369);
  if ( v8 == 32 )
  {
    v9 = *(unsigned __int8 *)(a1 + 3369);
  }
  else
  {
    if ( *(unsigned __int8 *)(a1 + 3369) < 0x21u )
    {
      v10 = *(unsigned __int8 *)(a1 + 3369);
      if ( v8 == 20 )
      {
        tlsHMACSha1(a1, 2, a2, a3, a4, (int)v13);
        return -(memcmpct((int)v13, a5, *(unsigned __int8 *)(a1 + 3368)) != 0);
      }
      goto LABEL_6;
    }
    v9 = *(unsigned __int8 *)(a1 + 3369);
    if ( v8 != 48 )
    {
      v10 = *(unsigned __int8 *)(a1 + 3369);
LABEL_6:
      v11 = v10;
LABEL_7:
      memset_s((unsigned __int8 *)v13, v10, 0, v11);
      return -(memcmpct((int)v13, a5, *(unsigned __int8 *)(a1 + 3368)) != 0);
    }
  }
  tlsHMACSha2(a1, 2, a2, a3, a4, v13, v9);
  return -(memcmpct((int)v13, a5, *(unsigned __int8 *)(a1 + 3368)) != 0);
}

//----- (00465678) --------------------------------------------------------
int   haveKeyMaterial(_DWORD *a1, int a2, __int16 a3)
{
  int v3; // $v0
  int v5; // $v0
  int v6; // $v0
  int v7; // $a2
  int v8; // $a2
  int j; // $v1
  int v10; // $a2
  int v11; // $a2
  int i; // $v1
  int v13; // $a2
  int v14; // $a2
  int v15; // $v0
  int k; // $v1
  int m; // $v1
  int v18; // $a0
  int v19; // $a2
  int v20; // $a2
  int n; // $v1

  if ( a1[821] && !a3 )
    return 0;
  if ( (unsigned int)(a2 - 1) < 2 || a2 == 7 || a2 == 9 || a2 == 6 || a2 == 8 )
  {
    if ( (a1[843] & 1) != 0 )
    {
      v3 = a1[786];
      if ( !v3 || !*(_DWORD *)(v3 + 116) )
        return -1;
    }
    else
    {
      v5 = a1[786];
      if ( !v5 || !*(_DWORD *)(v5 + 120) )
        return -1;
    }
  }
  if ( a2 == 1 )
  {
    if ( (a1[843] & 1) == 0 )
    {
      for ( i = *(_DWORD *)(a1[786] + 120); i; i = *(_DWORD *)(i + 796) )
      {
        if ( *(_DWORD *)(i + 444) == 645 )
          goto LABEL_8;
      }
      return -1;
    }
    v7 = *(_DWORD *)(a1[786] + 116);
    if ( !v7 || *(_DWORD *)(v7 + 444) != 645 )
      return -1;
    v8 = *(_DWORD *)(v7 + 8);
    if ( v8 != 1673 && v8 != 1679 && v8 != 1680 && v8 != 1681 && v8 != 648 && v8 != 1670 && v8 != 1678 )
      return -1;
  }
LABEL_8:
  if ( a2 == 2 )
  {
    if ( (a1[843] & 1) == 0 )
    {
      for ( j = *(_DWORD *)(a1[786] + 120); j; j = *(_DWORD *)(j + 796) )
      {
        if ( *(_DWORD *)(j + 444) == 645 )
          goto LABEL_9;
      }
      return -1;
    }
    v15 = *(_DWORD *)(a1[786] + 116);
    if ( !v15 || *(_DWORD *)(v15 + 444) != 645 )
      return -1;
  }
LABEL_9:
  if ( a2 == 4 && (a1[843] & 1) == 0 )
  {
    v6 = a1[786];
    if ( !v6 || !*(_DWORD *)(v6 + 124) )
      return -1;
  }
  if ( a2 == 7 )
  {
    if ( (a1[843] & 1) == 0 )
    {
      for ( k = *(_DWORD *)(a1[786] + 120); k; k = *(_DWORD *)(k + 796) )
      {
        if ( *(_DWORD *)(k + 444) == 645 )
          goto LABEL_11;
      }
      return -1;
    }
    v10 = *(_DWORD *)(a1[786] + 116);
    if ( !v10 || *(_DWORD *)(v10 + 444) != 645 )
      return -1;
    v11 = *(_DWORD *)(v10 + 8);
    if ( v11 != 1673 && v11 != 1679 && v11 != 1680 && v11 != 1681 && v11 != 648 && v11 != 1670 && v11 != 1678 )
      return -1;
  }
LABEL_11:
  if ( a2 == 9 )
  {
    if ( (a1[843] & 1) == 0 )
    {
      for ( m = *(_DWORD *)(a1[786] + 120); m; m = *(_DWORD *)(m + 796) )
      {
        if ( *(_DWORD *)(m + 444) == 645 )
          goto LABEL_12;
      }
      return -1;
    }
    v13 = *(_DWORD *)(a1[786] + 116);
    if ( !v13 || *(_DWORD *)(v13 + 444) != 518 )
      return -1;
    v14 = *(_DWORD *)(v13 + 8);
    if ( v14 != 1673 && v14 != 1679 && v14 != 1680 && v14 != 1681 && v14 != 648 && v14 != 1670 && v14 != 1678 )
      return -1;
  }
LABEL_12:
  if ( a2 != 6 && a2 != 8 )
    goto LABEL_14;
  if ( (a1[843] & 1) == 0 )
  {
    for ( n = *(_DWORD *)(a1[786] + 120); n; n = *(_DWORD *)(n + 796) )
    {
      if ( *(_DWORD *)(n + 444) == 518 )
        goto LABEL_14;
    }
    return -1;
  }
  v19 = *(_DWORD *)(a1[786] + 116);
  if ( !v19 || *(_DWORD *)(v19 + 444) != 518 )
    return -1;
  v20 = *(_DWORD *)(v19 + 8);
  if ( v20 == 520 || v20 == 523 || v20 == 524 || v20 == 525 || v20 == 526 )
  {
LABEL_14:
    if ( a2 == 5 )
    {
      v18 = a1[786];
      if ( !v18 || !*(_DWORD *)(v18 + 124) )
        return -1;
    }
    return 0;
  }
  return -1;
}

//----- (00465B64) --------------------------------------------------------
__int16 *  sslGetCipherSpec(int a1, unsigned __int16 a2)
{
  int v3; // $s1
  unsigned int v4; // $s3
  int v5; // $a2
  __int16 *v6; // $v1
  int v7; // $t0
  __int16 *result; // $v0
  unsigned int v9; // $a1
  int v10; // $ra
  unsigned int v11; // $a0
  unsigned int v12; // $t3
  unsigned int v13; // $a1
  unsigned int v14; // $v1
  unsigned int v15; // $v1
  unsigned int v16; // $ra
  unsigned int v17; // $v1
  unsigned int v18; // $v0
  int v19; // $ra
  __int16 *v20; // $s0
  int v21; // $v0
  unsigned int v22; // $v1

  v3 = a2;
  v4 = 0;
  while ( 1 )
  {
    v5 = 16 * v4;
    v6 = &word_4E63AC[16 * v4];
    v7 = 16 * v4;
    if ( (unsigned __int16)*v6 == v3 )
      break;
LABEL_2:
    v4 = (unsigned __int8)(v4 + 1);
    if ( !word_4E63AC[v7] )
      return 0;
  }
  if ( (*((_DWORD *)v6 + 1) & 0x6000000) != 0 )
    return 0;
  result = 0;
  if ( (dword_4E680C[v4 >> 5] & (1 << (v4 & 0x1F))) != 0 )
    return result;
  if ( v3 )
  {
    LOBYTE(v9) = 0;
    v10 = 0;
    do
    {
      v9 = (unsigned __int8)(v9 + 1);
      if ( *(unsigned __int16 *)(v10 + a1 + 3268) == v3 )
        return 0;
      v10 = 2 * v9;
    }
    while ( v9 < 8 );
  }
  if ( *(unsigned __int8 *)(a1 + 3389) == 254 && *(unsigned __int8 *)(a1 + 3390) != 253 )
  {
    v22 = *(_DWORD *)&word_4E63AC[v5 + 2];
    if ( ((v22 >> 10) & 1) != 0 || ((v22 >> 9) & 1) != 0 )
      return 0;
  }
  v11 = *(_DWORD *)(a1 + 3372);
  v12 = HIBYTE(v11);
  if ( ((v11 >> 14) & 1) == 0 )
  {
    v13 = *(unsigned __int8 *)(a1 + 3390);
    v14 = v13;
    if ( v13 < 3 )
    {
      v15 = *(_DWORD *)&word_4E63AC[v5 + 2];
      v16 = v15 >> 9;
      if ( ((v15 >> 10) & 1) != 0 )
        return 0;
      v14 = (unsigned __int8)v13;
      if ( (v16 & 1) != 0 )
        return 0;
    }
    if ( v14 == 3 )
    {
      v12 = HIBYTE(v11);
      if ( ((*(_DWORD *)&word_4E63AC[v5 + 2] >> 14) & 1) != 0 )
        return 0;
    }
    else
    {
      v12 = HIBYTE(v11);
    }
  }
  if ( (v12 & 1) != 0 )
  {
    v17 = *(_DWORD *)&word_4E63AC[v5 + 2];
    if ( ((v17 >> 11) & 1) == 0 )
    {
      result = (__int16 *)((v17 >> 6) & 1);
      if ( !result )
        return result;
    }
    v18 = (unsigned __int16)word_4E63AC[v5 + 1];
    v19 = 1 << v18;
    if ( v18 >= 8 )
      return 0;
    result = 0;
    if ( (v19 & 0xC4) == 0 )
      return result;
  }
  if ( *(_DWORD *)(a1 + 3144) )
  {
    v20 = &word_4E63AC[v5];
    if ( (((unsigned __int8)v11 ^ 1) & 1) == 0 )
    {
      v21 = haveKeyMaterial((_DWORD *)a1, (unsigned __int16)v20[1], 0);
      v7 = 16 * v4;
      if ( !v21 )
        return v20;
      goto LABEL_2;
    }
  }
  return &word_4E63AC[v5];
}
// 4E63AC: using guessed type __int16 word_4E63AC[560];
// 4E680C: using guessed type _DWORD dword_4E680C[8];

//----- (00465DE4) --------------------------------------------------------
int   chooseCipherSuite(int a1, unsigned int a2, int a3)
{
  unsigned int v3; // $s6
  unsigned __int8 *v4; // $s3
  int v6; // $s5
  unsigned __int16 v7; // $v0
  __int16 *CipherSpec; // $s2
  int v9; // $v1
  int v10; // $v1
  int v11; // $a2
  __int16 v12; // $v1
  int (  *v13)(int, _WORD *); // $t9
  int v14; // $v0
  int v15; // $a1
  __int16 v16; // $a1
  _DWORD *v17; // $s0
  int v18; // $v0
  unsigned __int16 v19; // $a3
  unsigned int v20; // $a1
  int v21; // $v1
  BOOL v22; // $t9
  BOOL v23; // $s0
  int v25; // $v1
  unsigned int v26; // $v1
  unsigned int v27; // $a0
  _WORD v28[3]; // [sp+20h] [-10h] BYREF
  __int16 v29; // [sp+26h] [-Ah]
  int v30; // [sp+28h] [-8h]

  v3 = a2 + a3;
  v4 = (unsigned __int8 *)a2;
  v6 = 0;
  if ( a2 >= a2 + a3 )
    return -10;
  while ( 1 )
  {
    if ( *(unsigned __int8 *)(a1 + 2) < 3u )
    {
      v7 = (v4[1] << 8) + v4[2];
      v4 += 3;
    }
    else
    {
      v7 = (*v4 << 8) + v4[1];
      v4 += 2;
    }
    CipherSpec = sslGetCipherSpec(a1, v7);
    if ( !CipherSpec )
      goto LABEL_36;
    if ( *(_DWORD *)(a1 + 3144) )
    {
      if ( !*(_DWORD *)(a1 + 3264) )
      {
        v6 = *(_DWORD *)(a1 + 3144);
        goto LABEL_13;
      }
      strlen(*(_DWORD *)(a1 + 3264));
      if ( matrixServerSetKeysSNI(a1) < 0 )
      {
        v10 = -12;
        *(_DWORD *)(a1 + 3376) = 112;
        return v10;
      }
      v23 = (unsigned int)v4 < v3;
      if ( haveKeyMaterial((_DWORD *)a1, (unsigned __int16)CipherSpec[1], 1) >= 0 )
      {
        v6 = *(_DWORD *)(a1 + 3144);
        goto LABEL_13;
      }
      goto LABEL_37;
    }
    v9 = (unsigned __int16)CipherSpec[1];
    v29 = 0;
    switch ( v9 )
    {
      case 1:
        v10 = 5;
        break;
      case 2:
        v10 = 5;
        v29 = 1;
        break;
      case 3:
      case 4:
        v10 = 0;
        v29 = 1;
        break;
      case 6:
      case 8:
        v10 = 6;
        break;
      case 7:
      case 9:
        v10 = 5;
        break;
      default:
        v10 = 0;
        break;
    }
    v28[0] = v10;
    if ( !v10 && !v29 )
      goto LABEL_65;
    v11 = *(_DWORD *)(a1 + 3400);
    v12 = *(_WORD *)(a1 + 3404);
    v13 = *(int (  **)(int, _WORD *))(a1 + 596);
    v30 = *(_DWORD *)(a1 + 3264);
    v28[1] = v12;
    v28[2] = v11;
    v14 = v13(a1, v28);
    v6 = v14;
    if ( !v14 )
      goto LABEL_36;
    v15 = (unsigned __int16)CipherSpec[1];
    *(_DWORD *)(a1 + 3144) = v14;
    if ( haveKeyMaterial((_DWORD *)a1, v15, 1) >= 0 )
      break;
    *(_DWORD *)(a1 + 3144) = 0;
LABEL_36:
    v23 = (unsigned int)v4 < v3;
LABEL_37:
    if ( !v23 )
    {
      if ( v6 )
      {
        psTraceStr("psAssert %s", (int)"cipherSuite.c");
        psTraceInt(":%d ", 2521);
        psError((int)"givenKey == NULL");
      }
      return -10;
    }
  }
  *(_DWORD *)(a1 + 3144) = 0;
LABEL_13:
  v16 = CipherSpec[1];
  v10 = 0;
  if ( (unsigned __int16)(v16 - 3) >= 3u && ((*(_DWORD *)(a1 + 3372) >> 13) & 1) != 0 )
  {
    v17 = *(_DWORD **)(v6 + 116);
    if ( v17 )
    {
      while ( 2 )
      {
        if ( v16 != 2 && v16 != 7 && v16 != 6 )
          goto LABEL_29;
        v25 = v17[111];
        if ( v25 == 645 )
        {
          v27 = *(unsigned __int16 *)(a1 + 3404);
          if ( ((v27 >> 2) & 1) == 0 && ((v27 >> 5) & 1) == 0 && ((v27 >> 6) & 1) == 0 && ((v27 >> 4) & 1) == 0 )
          {
            v6 = 0;
            goto LABEL_36;
          }
        }
        if ( v25 == 518
          && (v26 = *(unsigned __int16 *)(a1 + 3404), ((v26 >> 10) & 1) == 0)
          && ((v26 >> 13) & 1) == 0
          && ((v26 >> 14) & 1) == 0 )
        {
          if ( ((v26 >> 12) & 1) == 0 )
            goto LABEL_35;
          v21 = v17[2];
          v22 = v21 < 526;
          if ( v21 == 525 )
          {
LABEL_56:
            v18 = *(unsigned __int16 *)(a1 + 3404) >> 13;
            goto LABEL_20;
          }
        }
        else
        {
LABEL_29:
          v21 = v17[2];
          v22 = v21 < 526;
          if ( v21 == 525 )
            goto LABEL_56;
        }
        if ( v22 )
        {
          if ( v21 == 520 )
          {
            v18 = *(unsigned __int16 *)(a1 + 3404) >> 10;
          }
          else
          {
            if ( v21 != 524 )
              goto LABEL_35;
            v18 = *(unsigned __int16 *)(a1 + 3404) >> 12;
          }
          goto LABEL_20;
        }
        if ( v21 == 1679 )
        {
          v18 = *(unsigned __int16 *)(a1 + 3404) >> 4;
          goto LABEL_20;
        }
        if ( v21 >= 1680 )
        {
          if ( v21 != 1680 )
            goto LABEL_35;
          v18 = *(unsigned __int16 *)(a1 + 3404) >> 5;
LABEL_20:
          v19 = v16 - 8;
          if ( (v18 & 1) == 0 )
            goto LABEL_35;
        }
        else if ( v21 != 1673 || (v19 = v16 - 8, ((*(unsigned __int16 *)(a1 + 3404) >> 2) & 1) == 0) )
        {
LABEL_35:
          v6 = 0;
          goto LABEL_36;
        }
        if ( v19 < 2u )
        {
          v20 = *(_DWORD *)(a1 + 3400) & 0xFFFFFF;
          if ( !v20 || psTestUserEcID(*(unsigned __int16 *)(v17[23] + 2), v20) < 0 )
            goto LABEL_35;
        }
        v17 = (_DWORD *)v17[199];
        v10 = 0;
        if ( !v17 )
          break;
        v16 = CipherSpec[1];
        continue;
      }
    }
  }
  *(_DWORD *)(a1 + 3144) = v6;
LABEL_65:
  *(_DWORD *)(a1 + 3344) = CipherSpec;
  return v10;
}
// 4E9F24: using guessed type int   strlen(_DWORD);

//----- (0046631C) --------------------------------------------------------
int   eccSuitesSupported(int a1, _WORD *a2, unsigned __int8 a3)
{
  int v4; // $a3
  int v5; // $v0
  int result; // $v0
  bool v7; // dc

  v4 = 0;
  if ( a3 )
  {
    while ( 1 )
    {
      v5 = (unsigned __int16)*a2;
      if ( (unsigned __int16)(*a2 + 16375) < 2u )
        break;
      if ( v5 == 49172 )
        break;
      if ( v5 == 49171 )
        break;
      if ( v5 == 49170 )
        break;
      if ( v5 == 49156 )
        break;
      if ( v5 == 49157 )
        break;
      if ( v5 == 49167 )
        break;
      if ( v5 == 49187 )
        break;
      if ( v5 == 49188 )
        break;
      if ( v5 == 49189 )
        break;
      if ( v5 == 49190 )
        break;
      if ( v5 == 49197 )
        break;
      if ( v5 == 49198 )
        break;
      if ( v5 == 49195 )
        break;
      if ( v5 == 49196 )
        break;
      if ( v5 == 49191 )
        break;
      if ( v5 == 49192 )
        break;
      if ( v5 == 49199 )
        break;
      if ( v5 == 49200 )
        break;
      if ( v5 == 49193 )
        break;
      if ( v5 == 49194 )
        break;
      if ( v5 == 49201 )
        break;
      if ( v5 == 49202 )
        break;
      if ( v5 == 52393 )
        break;
      if ( v5 == 52392 )
        break;
      ++v4;
      if ( v5 == 49166 )
        break;
      ++a2;
      if ( v4 >= a3 )
        return 0;
    }
    return 1;
  }
  v7 = sslGetCipherSpec(a1, 0xC00Au) != 0;
  result = 1;
  if ( v7 )
    return result;
  if ( sslGetCipherSpec(a1, 0xC009u) )
    return 1;
  v7 = sslGetCipherSpec(a1, 0xC014u) != 0;
  result = 1;
  if ( !v7 )
  {
    v7 = sslGetCipherSpec(a1, 0xC013u) != 0;
    result = 1;
    if ( !v7 )
    {
      v7 = sslGetCipherSpec(a1, 0xC012u) != 0;
      result = 1;
      if ( !v7 )
      {
        v7 = sslGetCipherSpec(a1, 0xC004u) != 0;
        result = 1;
        if ( !v7 )
        {
          v7 = sslGetCipherSpec(a1, 0xC005u) != 0;
          result = 1;
          if ( !v7 )
          {
            v7 = sslGetCipherSpec(a1, 0xC00Fu) != 0;
            result = 1;
            if ( !v7 )
            {
              v7 = sslGetCipherSpec(a1, 0xC023u) != 0;
              result = 1;
              if ( !v7 )
              {
                v7 = sslGetCipherSpec(a1, 0xC024u) != 0;
                result = 1;
                if ( !v7 )
                {
                  v7 = sslGetCipherSpec(a1, 0xC025u) != 0;
                  result = 1;
                  if ( !v7 )
                  {
                    v7 = sslGetCipherSpec(a1, 0xC026u) != 0;
                    result = 1;
                    if ( !v7 )
                    {
                      v7 = sslGetCipherSpec(a1, 0xC02Du) != 0;
                      result = 1;
                      if ( !v7 )
                      {
                        v7 = sslGetCipherSpec(a1, 0xC02Eu) != 0;
                        result = 1;
                        if ( !v7 )
                        {
                          v7 = sslGetCipherSpec(a1, 0xC02Bu) != 0;
                          result = 1;
                          if ( !v7 )
                          {
                            v7 = sslGetCipherSpec(a1, 0xC02Cu) != 0;
                            result = 1;
                            if ( !v7 )
                            {
                              v7 = sslGetCipherSpec(a1, 0xC027u) != 0;
                              result = 1;
                              if ( !v7 )
                              {
                                v7 = sslGetCipherSpec(a1, 0xC028u) != 0;
                                result = 1;
                                if ( !v7 )
                                {
                                  v7 = sslGetCipherSpec(a1, 0xC02Fu) != 0;
                                  result = 1;
                                  if ( !v7 )
                                  {
                                    v7 = sslGetCipherSpec(a1, 0xC030u) != 0;
                                    result = 1;
                                    if ( !v7 )
                                    {
                                      v7 = sslGetCipherSpec(a1, 0xC029u) != 0;
                                      result = 1;
                                      if ( !v7 )
                                      {
                                        v7 = sslGetCipherSpec(a1, 0xC02Au) != 0;
                                        result = 1;
                                        if ( !v7 )
                                        {
                                          v7 = sslGetCipherSpec(a1, 0xC031u) != 0;
                                          result = 1;
                                          if ( !v7 )
                                          {
                                            v7 = sslGetCipherSpec(a1, 0xC032u) != 0;
                                            result = 1;
                                            if ( !v7 )
                                            {
                                              v7 = sslGetCipherSpec(a1, 0xCCA9u) != 0;
                                              result = 1;
                                              if ( !v7 )
                                              {
                                                v7 = sslGetCipherSpec(a1, 0xCCA8u) != 0;
                                                result = 1;
                                                if ( !v7 )
                                                {
                                                  v7 = sslGetCipherSpec(a1, 0xC00Eu) == 0;
                                                  result = 1;
                                                  if ( v7 )
                                                    return 0;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (00466814) --------------------------------------------------------
BOOL   csCheckCertAgainstCipherSuite(int a1, int a2)
{
  if ( a1 != 1 )
    return a1 == 3 && (a2 == 6 || a2 == 8 || a2 == 9);
  if ( (unsigned int)(a2 - 1) < 2 )
    return 1;
  if ( a2 != 7 )
    return a1 == 3 && (a2 == 6 || a2 == 8 || a2 == 9);
  return 1;
}

//----- (00466870) --------------------------------------------------------
int   sslGetCipherSpecList(int a1, _BYTE *a2, int a3)
{
  int v4; // $a0
  _BYTE *v6; // $s7
  _BYTE *v7; // $s2
  int v8; // $s4
  int v9; // $s1
  int v10; // $a1
  int v11; // $a0
  unsigned int v12; // $v1
  int v13; // $v1
  __int16 *v15; // $s0
  __int16 v16; // $a0
  unsigned int v17; // $v1

  v4 = -1;
  if ( a3 < 4 )
    return v4;
  v6 = &a2[a3];
  v7 = a2 + 2;
  v8 = 0;
  v9 = 0;
  if ( !word_4E63AC[0] )
  {
LABEL_11:
    v13 = (unsigned __int16)(2 * v9 - v8);
    if ( ((*(_DWORD *)(a1 + 4656) >> 10) & 1) != 0 )
    {
      v4 = -8;
      if ( v6 - v7 < 2 )
        return v4;
      *(_WORD *)v7 = 86;
      v13 = (unsigned __int16)(2 * v9 - v8 + 2);
    }
    *a2 = BYTE1(v13);
    a2[1] = v13;
    return v13 + 2;
  }
  v10 = v6 - v7;
  while ( v10 >= 2 )
  {
    v11 = 16 * v9;
    if ( *(unsigned __int8 *)(a1 + 3389) == 254 )
    {
      if ( *(unsigned __int8 *)(a1 + 3390) == 253 )
      {
        v11 = 16 * v9;
      }
      else
      {
        v17 = *(_DWORD *)&word_4E63AC[v11 + 2];
        if ( ((v17 >> 10) & 1) != 0 )
          goto LABEL_9;
        if ( ((v17 >> 9) & 1) != 0 )
        {
          v8 += 2;
          goto LABEL_10;
        }
      }
    }
    if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0
      || *(_BYTE *)(a1 + 3390) == 3
      || (v12 = *(_DWORD *)&word_4E63AC[v11 + 2], ((v12 >> 10) & 1) == 0) && ((v12 >> 9) & 1) == 0 )
    {
      v15 = &word_4E63AC[v11];
      if ( !haveKeyMaterial((_DWORD *)a1, (unsigned __int16)word_4E63AC[v11 + 1], 0) )
      {
        v16 = *v15;
        *v7 = HIBYTE(*v15);
        v7[1] = v16;
        v7 += 2;
        goto LABEL_10;
      }
    }
LABEL_9:
    v8 += 2;
LABEL_10:
    v9 = (unsigned __int16)(v9 + 1);
    v10 = v6 - v7;
    if ( !word_4E63AC[16 * v9] )
      goto LABEL_11;
  }
  return -8;
}
// 4E63AC: using guessed type __int16 word_4E63AC[560];

//----- (00466AA4) --------------------------------------------------------
int   sslGetCipherSpecListLen(int a1)
{
  int v2; // $s2
  int v3; // $s0
  int v4; // $a0
  __int16 *v5; // $v1
  unsigned int v6; // $v1
  unsigned int v8; // $v1

  v2 = 0;
  v3 = 0;
  if ( word_4E63AC[0] )
  {
    v4 = 0;
    while ( 1 )
    {
      if ( *(unsigned __int8 *)(a1 + 3389) != 254
        || *(unsigned __int8 *)(a1 + 3390) == 253
        || (v8 = *(_DWORD *)&word_4E63AC[v4 + 2], ((v8 >> 10) & 1) == 0) && ((v8 >> 9) & 1) == 0 )
      {
        v5 = &word_4E63AC[v4];
        if ( ((*(_DWORD *)(a1 + 3372) >> 14) & 1) != 0 || *(_BYTE *)(a1 + 3390) == 3 )
          goto LABEL_12;
        v6 = *(_DWORD *)&word_4E63AC[v4 + 2];
        if ( ((v6 >> 10) & 1) == 0 && ((v6 >> 9) & 1) == 0 )
          break;
      }
      v2 += 2;
LABEL_8:
      ++v3;
      v4 = 16 * v3;
      if ( !word_4E63AC[16 * v3] )
        return 2 * v3 - v2 + 2;
    }
    v5 = &word_4E63AC[v4];
LABEL_12:
    if ( haveKeyMaterial((_DWORD *)a1, (unsigned __int16)v5[1], 0) )
      v2 += 2;
    goto LABEL_8;
  }
  return 2 * v3 - v2 + 2;
}
// 4E63AC: using guessed type __int16 word_4E63AC[560];

//----- (00466C1C) --------------------------------------------------------
int   matrixSslSetKexFlags(int a1)
{
  int v1; // $a1
  int result; // $v0
  int v3; // $t3
  int v4; // $v1
  int v5; // $t8
  unsigned int v6; // $v1

  v1 = *(_DWORD *)(a1 + 3344);
  result = 2;
  if ( *(_WORD *)(v1 + 2) == 2 )
    *(_DWORD *)(a1 + 3372) |= 0x28000u;
  if ( *(_WORD *)(v1 + 2) == 4 )
  {
    v5 = *(_DWORD *)(a1 + 3372);
    v6 = v5 | 0x60100;
    if ( (v5 & 1) != 0 && (result = (v6 >> 7) & 1) != 0 )
      *(_DWORD *)(a1 + 3372) = v5 & 0xFFF9FE7F | 0x60100;
    else
      *(_DWORD *)(a1 + 3372) = v6;
  }
  if ( *(_WORD *)(v1 + 2) == 7 )
    *(_DWORD *)(a1 + 3372) |= 0xA8000u;
  if ( *(_WORD *)(v1 + 2) == 6 )
  {
    result = *(_DWORD *)(a1 + 3372) | 0xB0000;
    *(_DWORD *)(a1 + 3372) = result;
  }
  if ( *(_WORD *)(v1 + 2) == 8 )
    *(_DWORD *)(a1 + 3372) |= 0x80000u;
  if ( *(_WORD *)(v1 + 2) == 9 )
  {
    result = *(_DWORD *)(a1 + 3372) | 0x80000;
    *(_DWORD *)(a1 + 3372) = result;
  }
  if ( *(_WORD *)(v1 + 2) == 5 )
  {
    v3 = *(_DWORD *)(a1 + 3372);
    v4 = v3 | 0x40000;
    if ( (v3 & 1) != 0 )
    {
      if ( (((v3 | 0x40000u) >> 7) & 1) != 0 )
        *(_DWORD *)(a1 + 3372) = v3 & 0xFFFBFF7F | 0x40000;
      else
        *(_DWORD *)(a1 + 3372) = v4;
    }
    else
    {
      *(_DWORD *)(a1 + 3372) = v4;
    }
  }
  return result;
}

//----- (00466DA8) --------------------------------------------------------
int dtlsGenCookieSecret()
{
  int v0; // $s1
  int PrngLocked; // $a2
  int result; // $v0

  v0 = 0;
  while ( 1 )
  {
    PrngLocked = psGetPrngLocked((int)&byte_4E682C, 0x20u);
    ++v0;
    if ( (unsigned __int8)(byte_4E682C | byte_4E682D | byte_4E682E) | (unsigned __int8)byte_4E682F )
      break;
    result = -1;
    if ( v0 >= 4 )
      return result;
  }
  return PrngLocked;
}
// 4E682C: using guessed type char byte_4E682C;
// 4E682D: using guessed type char byte_4E682D;
// 4E682E: using guessed type char byte_4E682E;
// 4E682F: using guessed type char byte_4E682F;

//----- (00466E5C) --------------------------------------------------------
int   dtlsComputeCookie(int a1, int a2, unsigned int a3)
{
  int v4; // $v1
  int v5; // $s1
  int v6; // $v1
  int v7; // $ra
  int v8; // $s2
  _DWORD v10[8]; // [sp+28h] [-48h] BYREF
  _DWORD v11[8]; // [sp+48h] [-28h] BYREF
  unsigned __int16 v12[4]; // [sp+68h] [-8h] BYREF

  v4 = -1;
  if ( (unsigned __int8)(byte_4E682C | byte_4E682D | byte_4E682E) | (unsigned __int8)byte_4E682F )
  {
    v5 = psHmacSha256((int)&byte_4E682C, 0x20u, a2, a3, v11, v10, v12);
    if ( v5 >= 0 )
    {
      v6 = v11[1];
      *(_DWORD *)(a1 + 3406) = v11[0];
      *(_BYTE *)(a1 + 3412) = BYTE2(v6);
      *(_BYTE *)(a1 + 3413) = HIBYTE(v6);
      v7 = v11[2];
      *(_WORD *)(a1 + 3410) = v6;
      *(_BYTE *)(a1 + 3416) = BYTE2(v7);
      *(_BYTE *)(a1 + 3417) = HIBYTE(v7);
      v8 = v11[3];
      *(_WORD *)(a1 + 3414) = v7;
      *(_DWORD *)(a1 + 3418) = v8;
    }
    memset_s((unsigned __int8 *)v11, 0x10u, 0, 0x10u);
    return v5;
  }
  return v4;
}
// 4E682C: using guessed type char byte_4E682C;
// 4E682D: using guessed type char byte_4E682D;
// 4E682E: using guessed type char byte_4E682E;
// 4E682F: using guessed type char byte_4E682F;

//----- (00466F64) --------------------------------------------------------
int   matrixDtlsSetPmtu(int a1)
{
  int v1; // $v1

  if ( a1 < 0 )
    dword_4E9E5C = 1500;
  else
    dword_4E9E5C = a1;
  v1 = dword_4E9E5C;
  if ( dword_4E9E5C < 256 )
  {
    v1 = 256;
    dword_4E9E5C = 256;
  }
  return v1;
}
// 4E9E5C: using guessed type int dword_4E9E5C;

//----- (00466FAC) --------------------------------------------------------
int matrixDtlsGetPmtu()
{
  return dword_4E9E5C;
}
// 4E9E5C: using guessed type int dword_4E9E5C;

//----- (00466FCC) --------------------------------------------------------
char *  sub_466FCC(int a1, int a2, int a3, int a4, char *a5)
{
  unsigned int v5; // $t0
  char *v6; // $t1
  int v10; // $fp
  int v11; // $s5
  int v12; // $s6
  int v13; // $s3
  unsigned int v14; // $a0
  int v15; // $a0
  int v16; // $a0
  int v17; // $a2
  int v18; // $s0
  int i; // $a2
  unsigned int v20; // $t3
  unsigned int v21; // $a1
  unsigned int v22; // $t7
  int v23; // $s2
  _BYTE *v24; // $v1
  unsigned int v25; // $a1
  int *v26; // $a1
  int v27; // $a2
  int v28; // $v0
  int v29; // $a0
  int v30; // $t3
  char *v31; // $a0
  char *v32; // $a1
  int v33; // $v1
  int v34; // $a0
  int v35; // $t3
  unsigned int v36; // $v0
  char *v37; // $v1
  char *result; // $v0
  char *v39; // [sp+28h] [-10h]
  int v40; // [sp+2Ch] [-Ch]
  int v41; // [sp+30h] [-8h]
  char v42; // [sp+34h] [-4h]
  _BYTE *v44; // [sp+70h] [+38h]
  _BYTE *v45; // [sp+70h] [+38h]

  v5 = *(_DWORD *)(a1 + 3372);
  v6 = a5;
  v41 = *(_DWORD *)(a1 + 4660) + *(_DWORD *)(a1 + 4664);
  v10 = 0;
  v40 = 0;
  v11 = 0;
  v12 = 0;
  v39 = a5;
  v13 = a3;
  if ( ((v5 >> 2) & 1) != 0 )
  {
    v14 = *(unsigned __int8 *)(a1 + 3367);
    if ( v14 >= 2 )
      v10 = *(unsigned __int8 *)(a1 + 3364) + 2 * v14;
  }
  if ( ((v5 >> 20) & 1) != 0 )
  {
    v15 = 8;
    if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
      v15 = 16;
    v10 += v15;
    if ( ((v5 >> 22) & 1) != 0 )
      v10 += 8;
  }
  if ( a3 > 0 )
  {
    v16 = *(_DWORD *)(a1 + 3576);
    v17 = v16 - v41 - v10;
    v42 = a4;
    if ( v13 < v17 )
      goto LABEL_29;
LABEL_11:
    v18 = v17;
    for ( i = v16 - *(_DWORD *)(a1 + 4660); ; i = *(_DWORD *)(a1 + 4664) + v13 )
    {
      v20 = v5 >> 20;
      if ( ((v5 >> 2) & 1) != 0 )
      {
        v21 = *(unsigned __int8 *)(a1 + 3367);
        if ( v21 >= 2 )
        {
          v22 = *(_DWORD *)(a1 + 4664) + v18 + *(unsigned __int8 *)(a1 + 3364) + v21;
          v40 = (unsigned __int8)(*(_BYTE *)(a1 + 3367) - ((*(_BYTE *)(a1 + 3367) - 1) & v22));
          LOWORD(i) = v22 + v40;
          v20 = v5 >> 20;
        }
      }
      if ( (v20 & 1) != 0 )
        i = *(_DWORD *)(a1 + 4664) + v18 + v10;
      v23 = (int)&a5[psWriteRecordInfo(a1, 22, i, v6, a4)];
      v44 = (_BYTE *)v23;
      v24 = (_BYTE *)v23;
      if ( ((*(_DWORD *)(a1 + 3372) >> 2) & 1) != 0 )
      {
        v25 = *(unsigned __int8 *)(a1 + 3367);
        if ( v25 >= 2 )
        {
          psGetPrngLocked(v23, v25);
          v24 = (_BYTE *)(*(unsigned __int8 *)(a1 + 3367) + v23);
          v44 = v24;
        }
      }
      v45 = &v44[psWriteHandshakeHeader(a1, v42, a3, *(_DWORD *)(a1 + 3564), v12, v18, v24)];
      memcpy(v45, a2, v18);
      a5 = &v45[v18];
      v26 = (int *)malloc(36);
      a2 += v18;
      v12 += v18;
      v13 -= v18;
      v27 = v11 + 1;
      if ( !v26 )
        goto LABEL_27;
      v28 = *(_DWORD *)(a1 + 3196);
      *v26 = 0;
      v26[1] = 0;
      v26[2] = 0;
      v26[3] = 0;
      v26[4] = 0;
      v26[5] = 0;
      v26[6] = 0;
      v26[7] = 0;
      v26[8] = 0;
      if ( v28 )
      {
        do
        {
          v33 = v28;
          v28 = *(_DWORD *)(v28 + 32);
          v27 = v11 + 1;
        }
        while ( v28 );
        *(_DWORD *)(v33 + 32) = v26;
        v34 = *(unsigned __int8 *)(a1 + 3364);
        v35 = *(_DWORD *)(a1 + 3204);
        *v26 = v23;
        v26[2] = v18;
        v26[3] = 22;
        v26[7] = v27;
        v26[5] = v40;
        v26[1] = v35;
        v26[4] = a3;
        v26[6] = a4;
        v31 = &a5[v34 + v40];
        if ( a4 != 20 )
        {
LABEL_23:
          if ( ((*(_DWORD *)(a1 + 3372) >> 20) & 1) != 0 )
          {
            v32 = v31 + 8;
            if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
              v32 = v31 + 16;
            a5 = v32;
          }
          else
          {
LABEL_38:
            a5 = v31;
          }
LABEL_27:
          v11 = v27;
          if ( v13 <= 0 )
            goto LABEL_36;
          goto LABEL_28;
        }
      }
      else
      {
        v29 = *(unsigned __int8 *)(a1 + 3364);
        v30 = *(_DWORD *)(a1 + 3204);
        *v26 = v23;
        v27 = v11 + 1;
        v26[2] = v18;
        v26[3] = 22;
        v26[7] = v11 + 1;
        v26[5] = v40;
        *(_DWORD *)(a1 + 3196) = v26;
        v26[1] = v30;
        v26[4] = a3;
        v26[6] = a4;
        v31 = &a5[v29 + v40];
        if ( a4 != 20 )
          goto LABEL_23;
      }
      v36 = *(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4);
      if ( (v36 & 0x1840) == 0 )
        goto LABEL_38;
      v37 = v31 + 8;
      if ( ((v36 >> 13) & 1) == 0 )
        v37 = v31 + 16;
      a5 = v37;
      v11 = v27;
      if ( v13 <= 0 )
      {
LABEL_36:
        v6 = a5;
        break;
      }
LABEL_28:
      v16 = *(_DWORD *)(a1 + 3576);
      v6 = a5;
      v17 = v16 - v41 - v10;
      v5 = *(_DWORD *)(a1 + 3372);
      if ( v13 >= v17 )
        goto LABEL_11;
LABEL_29:
      v18 = v13;
    }
  }
  result = (char *)(v6 - v39);
  ++*(_DWORD *)(a1 + 3564);
  return result;
}
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00467448) --------------------------------------------------------
int   dtlsWriteCertificateRequest(int a1, int a2, int a3, int a4, int a5, char *a6)
{
  int v6; // $s3
  int v7; // $s5
  _BYTE *v9; // $s2
  int result; // $v0
  int v11; // $v1
  _BYTE *v12; // $s0
  int v13; // $s1
  _BYTE *v14; // $a0
  _BYTE *v15; // $s0
  int v16; // $t6
  char *v17; // $s1
  char *v18; // $s1

  v6 = 2 * a4 + a3;
  v7 = v6 + a5 + 5;
  v9 = (_BYTE *)malloc(v7);
  result = -8;
  if ( v9 )
  {
    v11 = (*(_DWORD *)(a2 + 3372) >> 13) & 1;
    v9[1] = 64;
    *v9 = 2;
    v9[2] = 1;
    v12 = v9 + 3;
    if ( v11 )
    {
      v9[4] = a5 - 2;
      v9[10] = 3;
      v9[11] = 5;
      v9[13] = 4;
      v9[15] = 2;
      v9[16] = 1;
      v9[3] = 0;
      v9[5] = 5;
      v9[6] = 3;
      v9[7] = 4;
      v9[8] = 3;
      v9[9] = 2;
      v9[12] = 1;
      v9[14] = 1;
      v13 = *(_DWORD *)(*(_DWORD *)(a2 + 3144) + 120);
      v12 = v9 + 17;
      if ( v13 )
      {
LABEL_4:
        *v12 = BYTE1(v6);
        v12[1] = v6;
        v14 = v12 + 2;
        do
        {
          v15 = v14 + 2;
          *v14 = HIBYTE(*(_WORD *)(v13 + 396));
          v14[1] = *(_WORD *)(v13 + 396);
          memcpy(v14 + 2, *(_DWORD *)(v13 + 392), *(unsigned __int16 *)(v13 + 396));
          v16 = *(unsigned __int16 *)(v13 + 396);
          v13 = *(_DWORD *)(v13 + 796);
          v14 = &v15[v16];
        }
        while ( v13 );
        v17 = sub_466FCC(a2, (int)v9, v7, 13, a6);
        free2(v9);
        return (int)v17;
      }
    }
    else
    {
      v13 = *(_DWORD *)(*(_DWORD *)(a2 + 3144) + 120);
      if ( v13 )
        goto LABEL_4;
    }
    v12[1] = 0;
    *v12 = 0;
    v18 = sub_466FCC(a2, (int)v9, v7, 13, a6);
    free2(v9);
    return (int)v18;
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00467658) --------------------------------------------------------
int   dtlsWriteCertificate(int a1, int a2, int a3, char *a4)
{
  int v4; // $s4
  _BYTE *v8; // $s3
  int result; // $v0
  _BYTE *v10; // $v1
  int i; // $s1
  int v12; // $s0
  _BYTE *v13; // $s2
  char *v14; // $s0

  v4 = a2 + a3;
  v8 = (_BYTE *)malloc(a2 + a3);
  result = -8;
  if ( v8 )
  {
    *v8 = (unsigned int)(v4 - 3) >> 16;
    v8[1] = (unsigned __int16)(v4 - 3) >> 8;
    v8[2] = v4 - 3;
    v10 = v8 + 3;
    if ( a2 > 0 )
    {
      for ( i = *(_DWORD *)(*(_DWORD *)(a1 + 3144) + 116); i; i = *(_DWORD *)(i + 796) )
      {
        v12 = *(unsigned __int16 *)(i + 788);
        v13 = v10 + 3;
        if ( *(_WORD *)(i + 788) )
        {
          v10[1] = BYTE1(v12);
          *v10 = 0;
          v10[2] = v12;
          memcpy(v10 + 3, *(_DWORD *)(i + 784), v12);
          v10 = &v13[v12];
        }
      }
    }
    v14 = sub_466FCC(a1, (int)v8, v4, 11, a4);
    free2(v8);
    return (int)v14;
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (004677AC) --------------------------------------------------------
int   dtlsIncrRsn(int a1)
{
  int v1; // $a2
  int v2; // $a1
  unsigned __int8 v3; // $v1
  int result; // $v0
  unsigned int v5; // $a3

  v1 = 5;
  while ( 1 )
  {
    v2 = v1 + a1;
    v3 = *(_BYTE *)(v1 + a1 + 3537);
    result = v3;
    --v1;
    if ( v3 != 255 )
      break;
    *(_BYTE *)(v2 + 3537) = 0;
    if ( v1 < 0 )
      return result;
  }
  v5 = *(unsigned __int8 *)(v2 + 3543);
  *(_BYTE *)(v2 + 3537) = v3 + 1;
  if ( v5 < (unsigned __int8)(v3 + 1) )
    *(_BYTE *)(v2 + 3543) = v3 + 1;
  return result;
}

//----- (004677FC) --------------------------------------------------------
int   dtlsEncryptFragRecord(int a1, int *a2, int a3, _DWORD *a4)
{
  int v6; // $s5
  int v7; // $s2
  unsigned int v9; // $v1
  unsigned int v10; // $a1
  _BYTE *v11; // $a0
  unsigned int v12; // $a2
  int v13; // $a0
  int v14; // $a1
  int (  *v15)(int, int, int, int); // $t9
  int v16; // $v0
  int v17; // $v1
  int v18; // $a1
  int v19; // $a0
  unsigned __int8 v20; // $v1
  int v22; // $t3
  int v23; // $t4
  int v24; // $t8
  char v25; // $t7
  _BYTE *v26; // $t5
  unsigned int v27; // $s5
  _BYTE v28[16]; // [sp+20h] [-10h] BYREF

  v6 = *(_DWORD *)(a3 + 8) + *(_DWORD *)(a1 + 4660);
  v7 = *a2;
  if ( ((*(_DWORD *)(a1 + 3372) >> 2) & 1) != 0 && (v9 = *(unsigned __int8 *)(a1 + 3367), v9 >= 2) )
  {
    v22 = a2[7];
    v7 += v9;
    *a4 += v9;
    if ( v22 != 1 )
      goto LABEL_4;
  }
  else if ( a2[7] != 1 )
  {
    goto LABEL_4;
  }
  memcpy(v28, v7, *(_DWORD *)(a1 + 4664));
  v23 = *(_DWORD *)(a1 + 4664);
  v24 = a2[4];
  v25 = *((_BYTE *)a2 + 18);
  v26 = &v28[v23];
  *(v26 - 1) = v24;
  *(v26 - 3) = v25;
  *(v26 - 2) = BYTE1(v24);
  sslUpdateHSHash(a1, (int)v28, v23);
LABEL_4:
  sslUpdateHSHash(a1, *(_DWORD *)(a1 + 4664) + v7, *((_WORD *)a2 + 4));
  v10 = *(_DWORD *)(a1 + 3372);
  v11 = (_BYTE *)(*a4 + *(_DWORD *)(a1 + 4664));
  *a4 = v11;
  if ( ((v10 >> 20) & 1) != 0 )
  {
    if ( ((v10 >> 22) & 1) != 0 )
      v6 += 8;
    *(_BYTE *)(a1 + 3392) = a2[3];
    v11 = (_BYTE *)*a4;
  }
  if ( ((v10 >> 2) & 1) != 0 )
  {
    v12 = *(unsigned __int8 *)(a1 + 3367);
    if ( v12 >= 2 )
    {
      v11 = (_BYTE *)(*a4
                    + (*(int (  **)(int, _DWORD, unsigned int, _BYTE *, _BYTE *))(a1 + 3356))(
                        a1,
                        *((unsigned __int8 *)a2 + 12),
                        v12 + v6,
                        &v11[-v6 - v12],
                        v11));
      *a4 = v11;
    }
  }
  v13 = *a4 + sslWritePad(v11, *((_BYTE *)a2 + 20));
  if ( ((*(_DWORD *)(a1 + 3372) >> 20) & 1) != 0 )
  {
    v14 = v13 + 8;
    if ( ((*(_DWORD *)(*(_DWORD *)(a1 + 3344) + 4) >> 13) & 1) == 0 )
      v14 = v13 + 16;
    v13 = v14;
  }
  v15 = *(int (  **)(int, int, int, int))(a1 + 3348);
  *a4 = v13;
  v16 = v15(a1, v6, v6, v13 - v6);
  v17 = -1;
  if ( v16 >= 0 )
  {
    v18 = 5;
    while ( 1 )
    {
      v19 = v18 + a1;
      v20 = *(_BYTE *)(v18 + a1 + 3537);
      --v18;
      if ( v20 != 255 )
        break;
      *(_BYTE *)(v19 + 3537) = 0;
      if ( v18 < 0 )
        return 0;
    }
    v27 = *(unsigned __int8 *)(v19 + 3543);
    *(_BYTE *)(v19 + 3537) = v20 + 1;
    if ( v27 < (unsigned __int8)(v20 + 1) )
      *(_BYTE *)(v19 + 3543) = v20 + 1;
    return 0;
  }
  return v17;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00467A94) --------------------------------------------------------
int   dtlsHsHashFragMsg(int a1)
{
  int v2; // $s3
  int v3; // $a0
  int v4; // $s1
  int v5; // $a1
  int v6; // $s0
  int v7; // $v0
  _BYTE v9[16]; // [sp+18h] [-10h] BYREF

  v2 = 0;
  v3 = 0;
  v4 = 0;
LABEL_2:
  v5 = 0;
  do
  {
    v6 = 4 * (v5 + v3) + a1;
    v7 = *(_DWORD *)(v6 + 3592);
    ++v3;
    if ( v7 == v4 )
    {
      if ( !v4 )
      {
        memcpy(v9, *(_DWORD *)(v6 + 3600), 12);
        v9[9] = v9[1];
        v9[10] = v9[2];
        v9[11] = v9[3];
        sslUpdateHSHash(a1, (int)v9, 0xCu);
        v7 = *(_DWORD *)(v6 + 3592);
        v2 = (v9[1] << 16) + (v9[2] << 8) + v9[3];
      }
      sslUpdateHSHash(a1, *(_DWORD *)(a1 + 3332) + v7, *(_WORD *)(v6 + 3596));
      v3 = 0;
      v4 += *(_DWORD *)(v6 + 3596);
      goto LABEL_2;
    }
    if ( v4 && v4 == v2 )
      break;
    v5 = 2 * v3;
  }
  while ( v3 < 16 );
  return 0;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00467BD0) --------------------------------------------------------
int   dtlsCompareEpoch(int a1, int a2)
{
  int v3; // $a2
  unsigned int v4; // $a1
  unsigned int v5; // $t1
  int result; // $v0

  v3 = 0;
  while ( 1 )
  {
    v4 = *(unsigned __int8 *)(a2 + v3);
    v5 = *(unsigned __int8 *)(a1 + v3++);
    if ( v5 < v4 )
      return -1;
    if ( v4 < v5 )
      break;
    result = 0;
    if ( v3 >= 2 )
      return result;
  }
  return 1;
}

//----- (00467C28) --------------------------------------------------------
int   dtlsChkReplayWindow(int a1, int a2)
{
  unsigned int v2; // $v1
  unsigned int v3; // $a3
  int v4; // $a2
  unsigned __int8 *v5; // $t7
  unsigned int v6; // $t5
  unsigned int v7; // $a1
  int v8; // $v1
  int result; // $v0
  unsigned int v10; // $v1
  unsigned int v11; // $v1
  int v12; // $a1

  v2 = (*(unsigned __int8 *)(a2 + 2) << 24)
     + (*(unsigned __int8 *)(a2 + 3) << 16)
     + (*(unsigned __int8 *)(a2 + 4) << 8)
     + *(unsigned __int8 *)(a2 + 5);
  v3 = (*(unsigned __int8 *)(a1 + 3551) << 24)
     + (*(unsigned __int8 *)(a1 + 3552) << 16)
     + (*(unsigned __int8 *)(a1 + 3553) << 8)
     + *(unsigned __int8 *)(a1 + 3554);
  if ( !v2 )
  {
    if ( !v3 && !*(_WORD *)(a1 + 4) )
      goto LABEL_15;
    v4 = 0;
    v5 = (unsigned __int8 *)(a1 + 4);
    while ( 1 )
    {
      v6 = *v5;
      v7 = *(unsigned __int8 *)(a1 + 3531 + v4++);
      v8 = v7 < v6;
      if ( v6 < v7 )
      {
        v8 = -1;
        goto LABEL_7;
      }
      if ( v7 < v6 )
        break;
      v5 = (unsigned __int8 *)(a1 + 4 + v4);
      if ( v4 >= 2 )
        goto LABEL_7;
    }
    v8 = 1;
LABEL_7:
    if ( v8 == 1 && v3 )
    {
      *(_DWORD *)(a1 + 3556) = 0;
      return 1;
    }
    if ( v3 == 0xFFFFFFF )
    {
LABEL_15:
      *(_DWORD *)(a1 + 3556) = 0;
      return 1;
    }
    return 0;
  }
  if ( v3 >= v2 )
  {
    v11 = v3 - v2;
    if ( v11 >= 0x20 )
      return 0;
    v12 = *(_DWORD *)(a1 + 3556);
    if ( (v12 & (1 << v11)) != 0 )
      return 0;
    result = 1;
    *(_DWORD *)(a1 + 3556) = v12 | (1 << v11);
  }
  else
  {
    v10 = v2 - v3;
    if ( v10 < 0x20 )
      *(_DWORD *)(a1 + 3556) = (*(_DWORD *)(a1 + 3556) << v10) | 1;
    else
      *(_BYTE *)(a1 + 3549) = 1;
    result = 1;
    *(_DWORD *)(a1 + 3549) = *(_DWORD *)a2;
    *(_BYTE *)(a1 + 3553) = *(_BYTE *)(a2 + 4);
    *(_BYTE *)(a1 + 3554) = *(_BYTE *)(a2 + 5);
  }
  return result;
}

//----- (00467DDC) --------------------------------------------------------
int   dtlsInitFrag(int a1)
{
  int v1; // $s0
  int v2; // $s1
  int result; // $v0

  v1 = a1;
  v2 = 15;
  *(_DWORD *)(a1 + 3340) = 0;
  do
  {
    while ( 1 )
    {
      result = *(_DWORD *)(v1 + 3600);
      --v2;
      *(_DWORD *)(v1 + 3592) = -1;
      if ( result )
        break;
      v1 += 12;
      if ( v2 < 0 )
        return result;
    }
    result = free2(result);
    *(_DWORD *)(v1 + 3600) = 0;
    v1 += 12;
  }
  while ( v2 >= 0 );
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00467E64) --------------------------------------------------------
int   dtlsSeenFrag(int a1, int a2, int *a3)
{
  int *v3; // $a0
  int v4; // $a3
  int v5; // $v1
  bool v6; // dc
  int result; // $v0

  v3 = (int *)(a1 + 3592);
  v4 = 0;
  while ( 1 )
  {
    v5 = *v3;
    v6 = *v3 == -1;
    v3 += 3;
    if ( v6 )
    {
      result = 0;
      *a3 = v4;
      return result;
    }
    ++v4;
    if ( v5 == a2 )
      break;
    result = -1;
    if ( v4 >= 16 )
      return result;
  }
  return 1;
}

//----- (00467EB0) --------------------------------------------------------
int   incrTwoByte(int a1, _BYTE *a2, int a3)
{
  int v3; // $t0
  int result; // $v0
  _BYTE *v5; // $a3
  unsigned __int8 v6; // $v1
  int v7; // $a0

  v3 = 1;
  if ( a3 )
  {
    result = *(unsigned __int8 *)(a1 + 3535);
    *a2 = result;
    a2[1] = *(_BYTE *)(a1 + 3536);
  }
  while ( 1 )
  {
    v5 = &a2[v3];
    v6 = a2[v3];
    if ( v6 != 255 )
      break;
    --v3;
    *v5 = 0;
    if ( v3 < 0 )
      return result;
  }
  *v5 = v6 + 1;
  if ( a3 )
  {
    v7 = v3 + a1;
    if ( *(unsigned __int8 *)(v7 + 3535) < (unsigned int)(unsigned __int8)(v6 + 1) )
      *(_BYTE *)(v7 + 3535) = v6 + 1;
  }
  return result;
}

//----- (00467F2C) --------------------------------------------------------
_BYTE *  zeroSixByte(int a1)
{
  int i; // $v1
  _BYTE *result; // $v0

  for ( i = 5; i >= 0; --i )
  {
    result = (_BYTE *)(a1 + i);
    *result = 0;
  }
  return result;
}

//----- (00467F48) --------------------------------------------------------
int   parseClientHello(unsigned int a1, unsigned __int8 **a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3; // $v1
  int v5; // $a1
  int v7; // $s0
  unsigned __int8 v8; // $a1
  unsigned __int8 *v9; // $t5
  unsigned int v10; // $s6
  unsigned int v11; // $v1
  int v12; // $v1
  char v13; // $a1
  unsigned int v14; // $t4
  char v15; // $v1
  unsigned int v16; // $a1
  int v17; // $a0
  int v18; // $v0
  int v20; // $t9
  int v21; // $t8
  int v22; // $s5
  int v23; // $s4
  int v24; // $s2
  int v25; // $s1
  int v26; // $v0
  unsigned int v27; // $t7
  unsigned __int8 *v28; // $a1
  unsigned int v29; // $a2
  int v30; // $v1
  int v31; // $v0
  int v32; // $a2
  int v33; // $v0
  int v34; // $t3
  unsigned __int8 *v35; // $s1
  unsigned int v36; // $s5
  unsigned __int8 *v37; // $a1
  unsigned __int8 *v38; // $s2
  unsigned __int8 *v39; // $s4
  unsigned __int8 *v40; // $ra
  int v41; // $t8
  int v42; // $t7
  unsigned int v43; // $v1
  unsigned __int8 *v44; // $a2
  unsigned int v45; // $a1
  signed int v46; // $a0
  unsigned __int8 *v47; // $t3
  unsigned int v48; // $a0
  int v49; // $v0
  unsigned int v50; // $a1
  unsigned int v51; // $a0
  int v52; // $a2
  int v53; // $t2
  int v54; // $t1
  unsigned int v55; // $v1
  int EccParamById; // $v0
  int v57; // $v0
  int v58; // $s1
  char v59; // $v0
  __int16 *CipherSpec; // $v0
  int v61; // $a1
  __int16 *v62; // $v0
  int v63; // $s4
  unsigned __int8 *v64; // [sp+18h] [-8h] BYREF
  char *v65; // [sp+1Ch] [-4h] BYREF

  v3 = *a2;
  v5 = a3 - *a2;
  v64 = v3;
  v7 = a1;
  if ( v5 < 2 )
    goto LABEL_60;
  v8 = *v3;
  v64 = v3 + 1;
  *(_BYTE *)(a1 + 3387) = v8;
  LOBYTE(a1) = v3[1];
  v9 = v3 + 2;
  *(_BYTE *)(v7 + 3388) = a1;
  v64 = v3 + 2;
  if ( v8 != 3 && v8 != 254 )
    goto LABEL_27;
  v10 = 3;
  if ( *(_BYTE *)(v7 + 3389) )
  {
    v16 = (unsigned __int8)a1;
    a1 = *(unsigned __int8 *)(v7 + 3390);
    if ( v16 < a1 || ((*(_DWORD *)(v7 + 3372) >> 14) & 1) != 0 && a1 < v16 )
      goto LABEL_27;
    v11 = *(unsigned __int8 *)(v7 + 3389);
    v10 = *(unsigned __int8 *)(v7 + 3390);
  }
  else
  {
    a1 = (unsigned __int8)a1;
    v11 = v8;
  }
  if ( v11 < 3 || (*(_BYTE *)(v7 + 3389) = v11, !a1) )
  {
LABEL_27:
    v17 = -12;
    v18 = 70;
LABEL_28:
    *(_DWORD *)(v7 + 3376) = v18;
    return v17;
  }
  v12 = *(_DWORD *)(v7 + 3372);
  v13 = 1;
  v14 = v12 | 0x800;
  if ( a1 >= 2 )
  {
    v14 = v12 | 0x1800;
    v13 = 2;
  }
  if ( a1 == 3 )
  {
    v14 |= 0x3800u;
    v13 = 3;
  }
  if ( ((v14 >> 14) & 1) != 0 && a1 == 253 )
    *(_BYTE *)(v7 + 3390) = -3;
  else
    *(_BYTE *)(v7 + 3390) = v13;
  if ( !*(_BYTE *)(v7 + 3390) )
    goto LABEL_66;
  if ( ((v14 >> 14) & 1) == 0 )
  {
    *(_DWORD *)(v7 + 3372) = v14;
    goto LABEL_31;
  }
  if ( a1 < 0xFD )
  {
LABEL_66:
    v17 = -12;
    *(_DWORD *)(v7 + 3376) = 70;
    *(_DWORD *)(v7 + 3372) = v14;
    return v17;
  }
  v15 = -1;
  if ( a1 == 253 )
  {
    v14 |= 0x3800u;
    v15 = -3;
  }
  *(_DWORD *)(v7 + 3372) = v14;
  if ( ((v14 >> 14) & 1) != 0 && a1 == 253 )
    *(_BYTE *)(v7 + 3390) = -3;
  else
    *(_BYTE *)(v7 + 3390) = v15;
LABEL_31:
  if ( *(unsigned __int8 *)(v7 + 2) < 3u || a3 - v9 < 33 )
    goto LABEL_41;
  v20 = *((_DWORD *)v9 + 2);
  v21 = *((_DWORD *)v9 + 3);
  v22 = *((_DWORD *)v9 + 4);
  v23 = *((_DWORD *)v9 + 5);
  v24 = *((_DWORD *)v9 + 6);
  v25 = *((_DWORD *)v9 + 7);
  v26 = *((_DWORD *)v9 + 1);
  *(_DWORD *)(v7 + 16) = *(_DWORD *)v9;
  *(_DWORD *)(v7 + 20) = v26;
  v64 = v9 + 32;
  *(_DWORD *)(v7 + 24) = v20;
  *(_DWORD *)(v7 + 28) = v21;
  *(_DWORD *)(v7 + 32) = v22;
  *(_DWORD *)(v7 + 36) = v23;
  *(_DWORD *)(v7 + 40) = v24;
  *(_DWORD *)(v7 + 44) = v25;
  v27 = v9[32];
  v28 = v9 + 33;
  *(_BYTE *)(v7 + 3224) = v27;
  v64 = v9 + 33;
  if ( v27 )
  {
    if ( v27 >= 0x21 )
      goto LABEL_41;
    v17 = -12;
    if ( a3 - v28 < (int)v27 )
      goto LABEL_42;
    memcpy(v7 + 3225, v28, v27);
    v29 = *(_DWORD *)(v7 + 3372);
    v28 = &v64[*(unsigned __int8 *)(v7 + 3224)];
    v64 = v28;
  }
  else
  {
    v29 = v14 & 0xFFFFFFF7;
    *(_DWORD *)(v7 + 3372) = v14 & 0xFFFFFFF7;
  }
  v30 = a3 - v28;
  if ( ((v29 >> 14) & 1) == 0 )
    goto LABEL_50;
  if ( a3 - v28 <= 0 )
  {
LABEL_60:
    v17 = -12;
    v18 = 50;
    goto LABEL_28;
  }
  v31 = dtlsComputeCookie(v7, (int)&v28[-*(unsigned __int8 *)(v7 + 3224) - 35], *(unsigned __int8 *)(v7 + 3224) + 35);
  v17 = -12;
  if ( v31 < 0 )
    goto LABEL_113;
  v32 = *v64;
  v28 = v64 + 1;
  if ( *v64 )
  {
    ++v64;
    if ( a3 - v28 < v32 )
    {
LABEL_42:
      v18 = 47;
      goto LABEL_28;
    }
    if ( v32 != 16 )
    {
LABEL_41:
      v17 = -12;
      goto LABEL_42;
    }
    v33 = memcmpct((int)v28, v7 + 3406, 16);
    v17 = -12;
    if ( v33 )
      goto LABEL_42;
    v28 = v64 + 16;
  }
  else
  {
    v43 = *(_DWORD *)(v7 + 3372);
    if ( ((v43 >> 1) & 1) == 0 )
    {
      *(_BYTE *)(v7 + 3384) = 1;
      *a2 = a3;
      v64 = a3;
      if ( ((v43 >> 3) & 1) != 0 )
        matrixClearSession(v7, 0);
      return -53;
    }
  }
  v64 = v28;
  v30 = a3 - v28;
LABEL_50:
  if ( v30 < 2 )
    goto LABEL_60;
  v34 = *v28;
  v64 = v28 + 1;
  v35 = v28 + 2;
  v36 = (v34 << 8) + v28[1];
  v64 = v35;
  v37 = v28 + 2;
  v38 = v35;
  if ( !v36 )
    goto LABEL_60;
  if ( (v36 & 1) != 0 )
    goto LABEL_60;
  v39 = &v35[v36];
  if ( a3 - v35 < v36 )
    goto LABEL_60;
  if ( v35 < v39 )
  {
    v40 = v37 + 1;
    while ( 1 )
    {
      v41 = *v37;
      v64 = v40;
      v42 = v37[1];
      v37 += 2;
      v64 = v37;
      if ( (v41 << 8) + v42 == 22016 )
      {
        v18 = 86;
        if ( *(unsigned __int8 *)(v7 + 3388) < v10 )
          break;
      }
      v40 = v37 + 1;
      if ( v37 >= v39 )
        goto LABEL_67;
    }
    v17 = -12;
    goto LABEL_28;
  }
LABEL_67:
  v44 = v37 + 1;
  if ( a3 - v37 <= 0 )
    goto LABEL_60;
  v45 = *v37;
  v64 = v44;
  if ( a3 - v44 < v45 )
    goto LABEL_60;
  v46 = 0;
  if ( v45 )
  {
    v47 = v44;
    do
    {
      if ( !*v47 )
        break;
      v47 = &v44[++v46];
    }
    while ( v46 < (int)v45 );
  }
  if ( v45 == v46 )
    goto LABEL_60;
  v64 = &v44[v45];
  v17 = parseClientHelloExtensions(v7, &v64, (_WORD)a3 - (v45 + (_WORD)v44));
  if ( v17 < 0 )
    return v17;
  v17 = -12;
  if ( v64 != a3 )
    goto LABEL_42;
  if ( *(_BYTE *)(v7 + 3224) )
  {
    v48 = *(_DWORD *)(v7 + 3372);
    if ( ((v48 >> 3) & 1) == 0 || (v49 = *(_DWORD *)(v7 + 3260)) == 0 || (v50 = v48 >> 3, *(_WORD *)(v49 + 92) != 5) )
    {
      if ( matrixResumeSession(v7) < 0 )
      {
        v61 = *(_DWORD *)(v7 + 3260);
        v51 = *(_DWORD *)(v7 + 3372) & 0xFFFFFFF7;
        *(_DWORD *)(v7 + 3372) = v51;
        if ( v61 && *(_WORD *)(v61 + 92) )
        {
          *(_DWORD *)(v7 + 4656) |= 0x40000u;
        }
        else
        {
          memset(v7 + 3225, 0, 32);
          v51 = *(_DWORD *)(v7 + 3372);
          *(_BYTE *)(v7 + 3224) = 0;
        }
      }
      else
      {
        v51 = *(_DWORD *)(v7 + 3372) & 0xFFFFFF77 | 8;
        *(_DWORD *)(v7 + 3372) = v51;
      }
      v50 = v51 >> 3;
    }
  }
  else
  {
    v50 = *(_DWORD *)(v7 + 3372) >> 3;
  }
  if ( (v50 & 1) != 0 )
  {
    v52 = 0;
    if ( v35 >= v39 )
      goto LABEL_107;
    v17 = -12;
    if ( *(unsigned __int8 *)(v7 + 2) < 3u )
    {
      v18 = 40;
      goto LABEL_28;
    }
    do
    {
      v53 = v38[1];
      v54 = *v38 << 8;
      v38 += 2;
      if ( **(unsigned __int16 **)(v7 + 3344) == v54 + v53 )
        v52 = 1;
    }
    while ( v38 < v39 );
    if ( !v52 )
    {
LABEL_107:
      CipherSpec = sslGetCipherSpec(v7, 0);
      v17 = -12;
      *(_DWORD *)(v7 + 3376) = 40;
      *(_DWORD *)(v7 + 3344) = CipherSpec;
      return v17;
    }
  }
  else
  {
    if ( chooseCipherSuite(v7, (unsigned int)v35, v36) < 0 )
    {
      v62 = sslGetCipherSpec(v7, 0);
      v63 = *(_DWORD *)(v7 + 3376);
      *(_DWORD *)(v7 + 3344) = v62;
      if ( v63 != 112 )
        *(_DWORD *)(v7 + 3376) = 40;
      return -12;
    }
    if ( !**(_WORD **)(v7 + 3344) )
    {
LABEL_106:
      v17 = -12;
      v18 = 40;
      goto LABEL_28;
    }
  }
  matrixSslSetKexFlags(v7);
  v55 = *(_DWORD *)(v7 + 3372);
  if ( ((v55 >> 3) & 1) != 0 )
  {
    v59 = 20;
LABEL_102:
    *(_BYTE *)(v7 + 3384) = v59;
    v17 = -53;
    *a2 = v64;
    *(_BYTE *)(v7 + 3385) = 1;
    return v17;
  }
  if ( ((v55 >> 17) & 1) == 0 || ((v55 >> 19) & 1) == 0 )
  {
LABEL_100:
    v59 = 16;
    if ( ((v55 >> 7) & 1) != 0 )
      v59 = 11;
    goto LABEL_102;
  }
  if ( !*(_BYTE *)(v7 + 3403) && ((*(_DWORD *)(v7 + 3400) >> 23) & 1) != 0 )
    goto LABEL_106;
  EccParamById = getEccParamById(*(unsigned __int8 *)(v7 + 3403), &v65);
  v17 = -12;
  if ( EccParamById >= 0 )
  {
    v57 = psEccNewKey(*(_DWORD *)(v7 + 3216), (int *)(v7 + 3124), (int)v65);
    v17 = -8;
    if ( v57 >= 0 )
    {
      v58 = matrixSslGenEphemeralEcKey(*(_DWORD *)(v7 + 3144), *(_DWORD *)(v7 + 3124), (unsigned __int8 *)v65);
      if ( v58 >= 0 )
      {
        v55 = *(_DWORD *)(v7 + 3372);
        goto LABEL_100;
      }
      psEccDeleteKey((int *)(v7 + 3124));
      v17 = v58;
LABEL_113:
      v18 = 80;
      goto LABEL_28;
    }
  }
  return v17;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (004687BC) --------------------------------------------------------
int   parseClientKeyExchange(int a1, signed int a2, unsigned __int8 **a3, int a4)
{
  unsigned __int8 *v4; // $s1
  int v6; // $t1
  unsigned int v9; // $s2
  unsigned int v10; // $t0
  unsigned int v11; // $t7
  unsigned int v12; // $t5
  int v13; // $v0
  void (  *v14)(int, unsigned __int8 *, _DWORD, int *, char *); // $t9
  unsigned __int8 *v15; // $a2
  int v16; // $a0
  unsigned __int8 *v17; // $s1
  int v18; // $t1
  int v19; // $a0
  int v20; // $a0
  unsigned int v21; // $v1
  int v22; // $a0
  int v24; // $v0
  int (  *v25)(int, unsigned __int8 *, _DWORD, int *, char *); // $t9
  int v26; // $t4
  int v27; // $v0
  int v28; // $v0
  _BYTE *v29; // $v0
  int v30; // $s3
  int v31; // $s3
  unsigned __int8 *v32; // $a3
  int *v33; // $a2
  int v34; // $t4
  int v35; // $s4
  int v36; // $t3
  int v37; // $t9
  int v38; // $t7
  int v39; // $t6
  int v40; // $v0
  int v41; // $v0
  int v42; // $a1
  int v43; // $a0
  int v44; // $a3
  int v45; // $t1
  int v46; // $t2
  int v47; // $v0
  unsigned __int8 *v48; // $t0
  int v49; // $a0
  int v50; // $a3
  unsigned __int8 *v51; // $a3
  int v52; // $a2
  int v53; // $ra
  int v54; // $t8
  int v55; // $t7
  int v56; // $t1
  int v57; // $a1
  int v58; // $a0
  unsigned __int8 v59[32]; // [sp+28h] [-38h] BYREF
  char v60; // [sp+48h] [-18h] BYREF
  char v61[4]; // [sp+58h] [-8h] BYREF
  int v62; // [sp+5Ch] [-4h] BYREF

  v4 = *a3;
  v6 = a4 - (_DWORD)*a3;
  v62 = 0;
  if ( v6 < a2 )
    goto LABEL_34;
  v9 = a2;
  if ( *(unsigned __int8 *)(a1 + 3389) >= 3u && *(_BYTE *)(a1 + 3390) )
  {
    if ( v6 < 2 )
      goto LABEL_34;
    v10 = *(_DWORD *)(a1 + 3372);
    if ( ((v10 >> 19) & 1) != 0 )
    {
      v9 = *v4++;
    }
    else
    {
      v9 = (*v4 << 8) + v4[1];
      v4 += 2;
    }
    v6 = a4 - (_DWORD)v4;
    v11 = v10 >> 17;
    if ( a4 - (int)v4 < (int)v9 )
      goto LABEL_34;
  }
  else
  {
    v10 = *(_DWORD *)(a1 + 3372);
    v11 = v10 >> 17;
  }
  if ( (v11 & 1) != 0 )
  {
    if ( (*(_DWORD *)(a1 + 3388) & 0xFFFF00) == 0x300 )
    {
      if ( ((v10 >> 19) & 1) == 0 )
      {
        if ( v6 < 2 )
          goto LABEL_34;
        v45 = v4[1];
        v46 = *v4 << 8;
        v4 += 2;
        v9 = v46 + v45;
        v12 = v10 >> 18;
        if ( a4 - (int)v4 < v46 + v45 )
          goto LABEL_34;
        goto LABEL_7;
      }
      v9 = *v4++;
    }
    v12 = v10 >> 18;
LABEL_7:
    if ( (v12 & 1) == 0 )
    {
LABEL_15:
      if ( ((v10 >> 19) & 1) == 0 )
      {
        if ( ((*(_DWORD *)(a1 + 4656) >> 17) & 1) != 1 )
          goto LABEL_17;
LABEL_46:
        v28 = tlsExtendedDeriveKeys(a1);
        v22 = -12;
        if ( v28 >= 0 )
        {
          matrixUpdateSession(a1);
          v16 = *(_DWORD *)(a1 + 128);
          v17 = &v4[v9];
          *(_BYTE *)(a1 + 3384) = 20;
          if ( !v16 )
            goto LABEL_19;
          goto LABEL_48;
        }
        return v22;
      }
      v47 = psEccNewKey(*(_DWORD *)(a1 + 3216), (int *)(a1 + 3128), *(_DWORD *)(*(_DWORD *)(a1 + 3124) + 52));
      v22 = -8;
      if ( v47 < 0 )
        return v22;
      if ( psEccX963ImportKey(
             *(_DWORD *)(a1 + 3216),
             v4,
             v9,
             *(_DWORD *)(a1 + 3128),
             *(unsigned __int8 **)(*(_DWORD *)(a1 + 3124) + 52)) >= 0 )
      {
        v48 = *(unsigned __int8 **)(*(_DWORD *)(a1 + 3124) + 52);
        v49 = *v48;
        *(_WORD *)(a1 + 132) = *v48;
        v50 = malloc(v49);
        *(_DWORD *)(a1 + 128) = v50;
        v22 = -8;
        if ( !v50 )
          return v22;
        if ( psEccGenSharedSecret(
               *(_DWORD *)(a1 + 3216),
               *(_DWORD *)(a1 + 3124),
               *(_DWORD *)(a1 + 3128),
               v50,
               (_WORD *)(a1 + 132)) >= 0 )
        {
          psEccDeleteKey((int *)(a1 + 3128));
          psEccDeleteKey((int *)(a1 + 3124));
          goto LABEL_45;
        }
LABEL_86:
        v58 = *(_DWORD *)(a1 + 128);
        *(_DWORD *)(a1 + 3376) = 80;
        free2(v58);
        v22 = -12;
        *(_DWORD *)(a1 + 128) = 0;
        return v22;
      }
      goto LABEL_34;
    }
    if ( a4 - (int)v4 < v9 )
      goto LABEL_34;
    v13 = *(_DWORD *)(a1 + 3144);
    if ( v13 && *(_DWORD *)(v13 + 124) )
    {
      matrixSslPskGetKey(a1, (int)v4, v9, &v62, v61);
    }
    else
    {
      v14 = *(void (  **)(int, unsigned __int8 *, _DWORD, int *, char *))(a1 + 592);
      if ( v14 )
        v14(a1, v4, (unsigned __int8)v9, &v62, v61);
    }
    v15 = &v4[v9];
    if ( v62 )
    {
      v4 = v15 + 2;
      v9 = (*v15 << 8) + v15[1];
      if ( a4 - (int)(v15 + 2) < v9 )
        goto LABEL_34;
      v10 = *(_DWORD *)(a1 + 3372);
      goto LABEL_15;
    }
    goto LABEL_80;
  }
  if ( ((v10 >> 18) & 1) != 0 )
  {
    if ( (*(_DWORD *)(a1 + 3388) & 0xFFFF00) == 0x300 )
    {
      v9 = (*v4 << 8) + v4[1];
      v4 += 2;
    }
    v24 = *(_DWORD *)(a1 + 3144);
    if ( v24 && *(_DWORD *)(v24 + 124) )
    {
      matrixSslPskGetKey(a1, (int)v4, v9, &v62, v61);
    }
    else
    {
      v25 = *(int (  **)(int, unsigned __int8 *, _DWORD, int *, char *))(a1 + 592);
      if ( v25 && v25(a1, v4, (unsigned __int8)v9, &v62, v61) < 0 )
        goto LABEL_80;
    }
    if ( v62 )
    {
      v26 = 2 * (unsigned __int8)v61[0];
      *(_WORD *)(a1 + 132) = v26 + 4;
      v27 = malloc(v26 + 4);
      *(_DWORD *)(a1 + 128) = v27;
      v22 = -8;
      if ( !v27 )
        return v22;
      memset(v27, 0, *(unsigned __int16 *)(a1 + 132));
      **(_BYTE **)(a1 + 128) = 0;
      *(_BYTE *)(*(_DWORD *)(a1 + 128) + 1) = v61[0];
      *(_BYTE *)(*(_DWORD *)(a1 + 128) + (unsigned __int8)v61[0] + 2) = 0;
      *(_BYTE *)(*(_DWORD *)(a1 + 128) + (unsigned __int8)v61[0] + 3) = v61[0];
      memcpy(*(_DWORD *)(a1 + 128) + (unsigned __int8)v61[0] + 4, v62, (unsigned __int8)v61[0]);
      goto LABEL_45;
    }
LABEL_80:
    *(_DWORD *)(a1 + 3376) = 115;
    return -12;
  }
  if ( (unsigned __int16)(*(_WORD *)(*(_DWORD *)(a1 + 3344) + 2) - 8) >= 2u )
  {
    if ( !*(_DWORD *)(a1 + 3144) )
      goto LABEL_82;
    *(_WORD *)(a1 + 132) = 48;
    v29 = (_BYTE *)malloc(48);
    *(_DWORD *)(a1 + 128) = v29;
    v22 = -8;
    if ( v29 )
    {
      v30 = psRsaDecryptPriv(0, *(_DWORD *)(a1 + 3144) + 4, v4, v9, v29, *(_WORD *)(a1 + 132));
      if ( psGetPrngLocked((int)v59, 0x2Eu) < 0 )
        goto LABEL_82;
      **(_BYTE **)(a1 + 128) = *(_BYTE *)(a1 + 3387);
      *(_BYTE *)(*(_DWORD *)(a1 + 128) + 1) = *(_BYTE *)(a1 + 3388);
      if ( v30 < 0 )
      {
        v51 = v59;
        v52 = *(_DWORD *)(a1 + 128) + 2;
        do
        {
          v53 = *((_DWORD *)v51 + 1);
          v54 = *((_DWORD *)v51 + 2);
          v55 = *((_DWORD *)v51 + 3);
          *(_DWORD *)v52 = *(_DWORD *)v51;
          *(_DWORD *)(v52 + 4) = v53;
          *(_DWORD *)(v52 + 8) = v54;
          *(_DWORD *)(v52 + 12) = v55;
          v51 += 16;
          *(_DWORD *)(v52 + 12) = v55;
          v52 += 16;
        }
        while ( v51 != (unsigned __int8 *)&v60 );
        v56 = *((_DWORD *)v51 + 1);
        v57 = *((_DWORD *)v51 + 2);
        *(_DWORD *)v52 = *(_DWORD *)v51;
        *(_DWORD *)(v52 + 4) = v56;
        *(_DWORD *)(v52 + 8) = v57;
        *(_BYTE *)(v52 + 12) = v51[12];
        *(_BYTE *)(v52 + 13) = v51[13];
      }
      else
      {
        v31 = *(_DWORD *)(a1 + 128);
        v32 = v59;
        v33 = (int *)(v31 + 2);
        do
        {
          v34 = *v33;
          v35 = v33[1];
          v36 = v33[2];
          v37 = v33[3];
          v33 += 4;
          *(_DWORD *)v32 = v34;
          *((_DWORD *)v32 + 1) = v35;
          *((_DWORD *)v32 + 2) = v36;
          *((_DWORD *)v32 + 3) = v37;
          v32 += 16;
        }
        while ( v33 != (int *)(v31 + 34) );
        v38 = v33[1];
        v39 = v33[2];
        *(_DWORD *)v32 = *v33;
        *((_DWORD *)v32 + 1) = v38;
        *((_DWORD *)v32 + 2) = v39;
        v32[12] = *((_BYTE *)v33 + 12);
        v32[13] = *((_BYTE *)v33 + 13);
      }
      memset_s(v59, 0x2Eu, 0, 0x2Eu);
LABEL_45:
      if ( ((*(_DWORD *)(a1 + 4656) >> 17) & 1) != 1 )
      {
LABEL_17:
        if ( sslCreateKeys(a1) >= 0 )
        {
          matrixUpdateSession(a1);
          v16 = *(_DWORD *)(a1 + 128);
          v17 = &v4[v9];
          *(_BYTE *)(a1 + 3384) = 20;
          if ( !v16 )
          {
LABEL_19:
            v18 = *(_DWORD *)(a1 + 3372) >> 7;
            if ( (v18 & 1) == 0 )
            {
              v19 = *(_DWORD *)(a1 + 600);
              if ( v19 )
              {
                free2(v19);
                *(_DWORD *)(a1 + 600) = 0;
              }
              v20 = *(_DWORD *)(a1 + 4640);
              if ( v20 )
              {
                free2(v20);
                *(_DWORD *)(a1 + 4640) = 0;
              }
              v21 = *(_DWORD *)(a1 + 3372);
              *(_DWORD *)(a1 + 3216) = 0;
              v18 = v21 >> 7;
            }
            if ( (v18 & 1) != 0 )
              *(_BYTE *)(a1 + 3384) = 15;
            *a3 = v17;
            *(_BYTE *)(a1 + 3385) = 16;
            return 0;
          }
LABEL_48:
          free2(v16);
          *(_DWORD *)(a1 + 128) = 0;
          *(_WORD *)(a1 + 132) = 0;
          goto LABEL_19;
        }
LABEL_82:
        *(_DWORD *)(a1 + 3376) = 80;
        return -12;
      }
      goto LABEL_46;
    }
    return v22;
  }
  if ( (*(_DWORD *)(a1 + 3388) & 0xFFFF00) == 0x300 )
    v9 = *v4++;
  v40 = *(_DWORD *)(a1 + 3144);
  if ( !v40 )
    goto LABEL_82;
  v41 = psEccNewKey(*(_DWORD *)(a1 + 3216), (int *)(a1 + 3128), *(_DWORD *)(v40 + 56));
  v22 = -8;
  if ( v41 < 0 )
    return v22;
  if ( psEccX963ImportKey(
         *(_DWORD *)(a1 + 3216),
         v4,
         v9,
         *(_DWORD *)(a1 + 3128),
         *(unsigned __int8 **)(*(_DWORD *)(a1 + 3144) + 56)) >= 0 )
  {
    v42 = *(_DWORD *)(a1 + 3144);
    v43 = **(unsigned __int8 **)(v42 + 56);
    *(_WORD *)(a1 + 132) = **(unsigned __int8 **)(v42 + 56);
    v44 = malloc(v43);
    *(_DWORD *)(a1 + 128) = v44;
    v22 = -8;
    if ( !v44 )
      return v22;
    if ( psEccGenSharedSecret(
           *(_DWORD *)(a1 + 3216),
           *(_DWORD *)(a1 + 3144) + 4,
           *(_DWORD *)(a1 + 3128),
           v44,
           (_WORD *)(a1 + 132)) >= 0 )
    {
      psEccDeleteKey((int *)(a1 + 3128));
      goto LABEL_45;
    }
    goto LABEL_86;
  }
LABEL_34:
  *(_DWORD *)(a1 + 3376) = 50;
  return -12;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00469158) --------------------------------------------------------
int   parseCertificateVerify(int a1, int a2, unsigned __int8 **a3, int a4)
{
  int v6; // $v0
  unsigned __int8 *v9; // $s0
  int v10; // $s3
  unsigned __int16 v11; // $a1
  int v12; // $v1
  unsigned __int8 *v14; // $s2
  unsigned int v15; // $s0
  int v16; // $a1
  void *v17; // $t9
  int v18; // $v0
  int v19; // $v1
  int v20; // $v0
  int v21; // $t0
  int v22; // $v0
  _BYTE v23[64]; // [sp+28h] [-48h] BYREF
  _DWORD v24[2]; // [sp+68h] [-8h] BYREF

  v6 = (*(_DWORD *)(a1 + 3372) >> 13) & 1;
  v24[0] = 0;
  v9 = *a3;
  v10 = 36;
  if ( v6 )
  {
    if ( (unsigned int)(a4 - (_DWORD)v9) < 2 )
      goto LABEL_10;
    v11 = (unsigned __int8)(1 << (*v9 & 7));
    if ( v9[1] != 1 )
      v11 = (unsigned __int8)(1 << (*v9 & 7)) << 8;
    v12 = *v9;
    if ( (*(_WORD *)(a1 + 3404) & v11) == 0 )
      goto LABEL_10;
    if ( v12 == 4 )
    {
      v10 = 32;
      v9 += 2;
    }
    else if ( *v9 < 5u )
    {
      if ( v12 != 2 )
        goto LABEL_10;
      sslSha1RetrieveHSHash((_DWORD *)a1, (_DWORD *)a2);
      v10 = 20;
      v9 += 2;
    }
    else if ( v12 == 5 )
    {
      sslSha384RetrieveHSHash(a1, (_DWORD *)a2);
      v10 = 48;
      v9 += 2;
    }
    else
    {
      if ( v12 != 6 )
      {
LABEL_10:
        *(_DWORD *)(a1 + 3376) = 50;
        return -12;
      }
      sslSha512RetrieveHSHash(a1, (_DWORD *)a2);
      v10 = 64;
      v9 += 2;
    }
  }
  v14 = v9 + 2;
  if ( (unsigned int)(a4 - (_DWORD)v9) < 2 )
    goto LABEL_10;
  v15 = (*v9 << 8) | v9[1];
  if ( a4 - (int)v14 < v15 )
    goto LABEL_10;
  v16 = *(_DWORD *)(a1 + 600);
  if ( *(_DWORD *)(v16 + 444) == 518 )
  {
    v21 = (*(_DWORD *)(a1 + 3372) >> 13) & 1;
    v24[0] = 0;
    if ( v21 )
      v22 = psEccDsaVerify(0, v16 + 40, (_BYTE *)a2, v10, v14, v15, v24);
    else
      v22 = psEccDsaVerify(0, v16 + 40, (_BYTE *)(a2 + 16), 0x14u, v14, v15, v24);
    if ( v22 || v24[0] != 1 )
    {
      *(_DWORD *)(a1 + 3376) = 42;
      return -12;
    }
    v24[0] = 0;
  }
  else
  {
    v17 = pubRsaDecryptSignedElement;
    if ( ((*(_DWORD *)(a1 + 3372) >> 13) & 1) == 0 )
      v17 = psRsaDecryptPub;
    v18 = ((int (  *)(int, int, _BYTE *, unsigned __int16, _BYTE *, unsigned __int16))v17)(
            0,
            v16 + 40,
            v14,
            v15,
            v23,
            v10);
    v19 = -12;
    if ( v18 < 0 )
      return v19;
    v20 = memcmpct((int)v23, a2, v10);
    v19 = -12;
    if ( v20 )
      return v19;
  }
  *(_BYTE *)(a1 + 3384) = 20;
  v19 = 0;
  *a3 = &v14[v15];
  *(_BYTE *)(a1 + 3385) = 15;
  return v19;
}

//----- (00469484) --------------------------------------------------------
int   parseServerHello(int a1, int a2, unsigned __int8 **a3, unsigned __int8 *a4)
{
  int v5; // $a0
  unsigned __int8 *v9; // $s5
  int v10; // $a0
  unsigned __int8 *v11; // $a1
  int v12; // $a3
  int v13; // $a2
  unsigned __int8 *v14; // $t4
  unsigned __int8 v15; // $v1
  unsigned __int8 *v16; // $t3
  unsigned int v17; // $a2
  unsigned int v18; // $a0
  unsigned int v19; // $a1
  unsigned int v21; // $t9
  int v22; // $a0
  int v23; // $v0
  int v24; // $s2
  int v25; // $s0
  int v26; // $t9
  int v27; // $ra
  int v28; // $t8
  int v29; // $s4
  int v30; // $a3
  unsigned int v31; // $s2
  unsigned __int8 *v32; // $s0
  unsigned __int8 *v33; // $ra
  unsigned int v34; // $t0
  int v35; // $t4
  int v36; // $s0
  unsigned __int16 *v37; // $v0
  unsigned __int8 *v38; // $v1
  unsigned int v39; // $a0
  int v40; // $a0
  unsigned int v41; // $v1
  char v42; // $v0
  __int16 *v43; // $v0
  __int16 *CipherSpec; // $v0
  unsigned __int8 *v45; // $a1
  int Keys; // $v0
  unsigned __int8 *v47; // [sp+20h] [-8h] BYREF

  v5 = *(_DWORD *)(a1 + 3424);
  v47 = *a3;
  v9 = v47;
  if ( v5 )
  {
    free2(v5);
    *(_DWORD *)(a1 + 3424) = 0;
    *(_DWORD *)(a1 + 3428) = 0;
    *(_DWORD *)(a1 + 3432) = 0;
  }
  v10 = *(_DWORD *)(a1 + 3436);
  if ( v10 )
  {
    free2(v10);
    *(_DWORD *)(a1 + 3436) = 0;
    *(_DWORD *)(a1 + 3440) = 0;
  }
  v11 = v47;
  if ( a4 - v47 < 2 )
    goto LABEL_52;
  v12 = *v47;
  v13 = *(unsigned __int8 *)(a1 + 3389);
  ++v47;
  v14 = v11 + 2;
  *(_BYTE *)(a1 + 3387) = v12;
  v15 = v11[1];
  v16 = v11 + 2;
  v47 = v11 + 2;
  if ( v12 != v13 )
  {
LABEL_15:
    *(_DWORD *)(a1 + 3376) = 70;
    *(_BYTE *)(a1 + 3388) = v15;
    return -12;
  }
  v17 = *(unsigned __int8 *)(a1 + 3390);
  v18 = v15;
  if ( v15 == v17 )
  {
    *(_BYTE *)(a1 + 3388) = v15;
    goto LABEL_26;
  }
  if ( *(_BYTE *)(a1 + 3391) )
    goto LABEL_15;
  if ( !v15 )
  {
    v18 = v15;
    if ( *(_BYTE *)(a1 + 3390) )
      goto LABEL_15;
  }
  if ( v18 >= 3 )
  {
    v19 = *(_DWORD *)(a1 + 3372);
LABEL_17:
    v18 = v15;
    goto LABEL_18;
  }
  v19 = *(_DWORD *)(a1 + 3372);
  if ( ((v19 >> 13) & 1) != 0 )
  {
    v19 &= ~0x2000u;
    *(_DWORD *)(a1 + 3372) = v19;
    if ( v18 == 2 )
    {
      *(_BYTE *)(a1 + 3388) = v17;
      *(_BYTE *)(a1 + 3390) = 2;
      goto LABEL_26;
    }
    goto LABEL_17;
  }
LABEL_18:
  if ( v18 == 1 )
  {
    v21 = v19 >> 14;
    if ( v17 < 4 )
    {
      *(_BYTE *)(a1 + 3388) = v17;
      *(_BYTE *)(a1 + 3390) = 1;
      *(_DWORD *)(a1 + 3372) = v19 & 0xFFFFEFFF;
      goto LABEL_26;
    }
  }
  else
  {
    v21 = v19 >> 14;
  }
  *(_BYTE *)(a1 + 3388) = v15;
  if ( (v21 & 1) == 0 || (*(_DWORD *)(a1 + 3388) & 0xFF00FF) != 0xFD00FF )
  {
    v22 = -12;
    v23 = 70;
LABEL_23:
    *(_DWORD *)(a1 + 3376) = v23;
    return v22;
  }
  *(_BYTE *)(a1 + 3388) = v17;
  *(_BYTE *)(a1 + 3390) = -1;
  *(_DWORD *)(a1 + 3372) = v19 & 0xFFFFDFFF;
LABEL_26:
  v22 = -12;
  if ( a4 - v16 < 33 )
    goto LABEL_53;
  v24 = *((_DWORD *)v16 + 6);
  v25 = *((_DWORD *)v16 + 7);
  v26 = *((_DWORD *)v16 + 2);
  v27 = *((_DWORD *)v16 + 3);
  v28 = *((_DWORD *)v16 + 4);
  v29 = *((_DWORD *)v16 + 5);
  v30 = *((_DWORD *)v16 + 1);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)v16;
  *(_DWORD *)(a1 + 52) = v30;
  v47 = v16 + 32;
  *(_DWORD *)(a1 + 76) = v25;
  *(_DWORD *)(a1 + 56) = v26;
  *(_DWORD *)(a1 + 60) = v27;
  *(_DWORD *)(a1 + 64) = v28;
  *(_DWORD *)(a1 + 68) = v29;
  *(_DWORD *)(a1 + 72) = v24;
  v31 = v14[32];
  v32 = v14 + 33;
  v47 = v14 + 33;
  if ( v31 >= 0x21 )
    goto LABEL_53;
  if ( a4 - v32 < v31 )
    goto LABEL_52;
  if ( v31 )
  {
    if ( *(_BYTE *)(a1 + 3224) )
    {
      if ( !memcmp(a1 + 3225, v32, v31) )
      {
        v32 += v31;
        *(_DWORD *)(a1 + 3372) |= 8u;
      }
      else
      {
        CipherSpec = sslGetCipherSpec(a1, 0);
        v45 = v47;
        *(_DWORD *)(a1 + 3344) = CipherSpec;
        *(_DWORD *)(a1 + 80) = 0;
        *(_DWORD *)(a1 + 84) = 0;
        *(_DWORD *)(a1 + 88) = 0;
        *(_DWORD *)(a1 + 92) = 0;
        *(_DWORD *)(a1 + 96) = 0;
        *(_DWORD *)(a1 + 100) = 0;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 108) = 0;
        *(_DWORD *)(a1 + 112) = 0;
        *(_DWORD *)(a1 + 116) = 0;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 124) = 0;
        *(_BYTE *)(a1 + 3224) = v31;
        memcpy(a1 + 3225, v45, v31);
        v32 = &v47[v31];
        *(_DWORD *)(a1 + 3372) &= ~8u;
      }
      v47 = v32;
    }
    else
    {
      *(_BYTE *)(a1 + 3224) = v31;
      memcpy(a1 + 3225, v32, v31);
      v32 = &v47[v31];
      v47 += v31;
    }
  }
  else if ( *(_BYTE *)(a1 + 3224) )
  {
    *(_DWORD *)(a1 + 3344) = sslGetCipherSpec(a1, 0);
    *(_DWORD *)(a1 + 80) = 0;
    *(_DWORD *)(a1 + 84) = 0;
    *(_DWORD *)(a1 + 88) = 0;
    *(_DWORD *)(a1 + 92) = 0;
    *(_DWORD *)(a1 + 96) = 0;
    *(_DWORD *)(a1 + 100) = 0;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 108) = 0;
    *(_DWORD *)(a1 + 112) = 0;
    *(_DWORD *)(a1 + 116) = 0;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 124) = 0;
    *(_BYTE *)(a1 + 3224) = 0;
    memset(a1 + 3225, 0, 32);
    v32 = v47;
    *(_DWORD *)(a1 + 3372) &= ~8u;
  }
  v33 = v32 + 2;
  if ( a4 - v32 < 2 )
  {
LABEL_52:
    v22 = -12;
LABEL_53:
    v23 = 50;
    goto LABEL_23;
  }
  v34 = *(_DWORD *)(a1 + 3372);
  v35 = *v32;
  v47 = v32 + 1;
  v36 = (v35 << 8) + v32[1];
  v47 = v33;
  if ( ((v34 >> 3) & 1) == 0 )
  {
    v43 = sslGetCipherSpec(a1, v36);
    *(_DWORD *)(a1 + 3344) = v43;
    if ( v43 )
      goto LABEL_37;
    v22 = -12;
LABEL_63:
    v23 = 40;
    goto LABEL_23;
  }
  v37 = *(unsigned __int16 **)(a1 + 3344);
  if ( !v37 )
  {
    psTraceStr("psAssert %s", (int)"hsDecode.c");
    psTraceInt(":%d ", 1797);
    psError((int)"ssl->cipher != NULL");
    v37 = *(unsigned __int16 **)(a1 + 3344);
  }
  v22 = -12;
  if ( *v37 != v36 )
    goto LABEL_63;
LABEL_37:
  matrixSslSetKexFlags(a1);
  if ( a4 - v47 <= 0 )
  {
    v22 = -12;
    v23 = 47;
    goto LABEL_23;
  }
  v38 = v47 + 1;
  if ( *v47 )
    goto LABEL_52;
  ++v47;
  if ( v38 != a4 && v38 - v9 < a2 )
  {
    v22 = parseServerHelloExtensions(a1, a2, (int)v9, &v47, (_WORD)v38 - (_WORD)a4);
    if ( v22 < 0 )
      return v22;
  }
  v39 = *(_DWORD *)(a1 + 4656);
  if ( ((v39 >> 11) & 1) == 1 )
  {
    v23 = 40;
    if ( ((v39 >> 20) & 1) == 0 )
    {
      v22 = -12;
      goto LABEL_23;
    }
  }
  if ( (*(_WORD *)(a1 + 3330) & 1) != 0 || ((v39 >> 1) & 1) != 0 )
    *(_DWORD *)(a1 + 3328) = 0x4000;
  v40 = *(_DWORD *)(a1 + 3260);
  if ( v40 && *(_WORD *)(v40 + 92) == 2 )
    *(_WORD *)(v40 + 92) = 4;
  v41 = *(_DWORD *)(a1 + 3372);
  if ( ((v41 >> 3) & 1) != 0 )
  {
    Keys = sslCreateKeys(a1);
    v22 = -12;
    if ( Keys < 0 )
    {
      v23 = 80;
      goto LABEL_23;
    }
    v42 = 20;
  }
  else
  {
    v42 = 11;
    if ( ((v41 >> 18) & 1) != 0 )
      v42 = 12;
  }
  *(_BYTE *)(a1 + 3384) = v42;
  *a3 = v47;
  *(_BYTE *)(a1 + 3385) = 2;
  return 0;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00469BA0) --------------------------------------------------------
int   parseServerKeyExchange(int a1, _DWORD *a2, unsigned __int8 **a3, int a4)
{
  unsigned int v4; // $t0
  int v7; // $s5
  unsigned __int8 *v8; // $s0
  _BYTE *v9; // $s7
  int v10; // $t1
  int v11; // $v0
  int v12; // $t8
  _BYTE *v13; // $s1
  int v14; // $v0
  int v15; // $v1
  int v16; // $s1
  int v17; // $t5
  unsigned int v18; // $v1
  int v19; // $v0
  int v20; // $s6
  unsigned int v21; // $t7
  void *v22; // $t9
  unsigned int v23; // $v1
  int v24; // $s5
  unsigned int v25; // $t7
  unsigned __int8 v27; // $t1
  int v28; // $v0
  int v29; // $v0
  __int64 v30[26]; // [sp+28h] [-118h] BYREF
  _BYTE v31[64]; // [sp+F8h] [-48h] BYREF
  char *v32; // [sp+138h] [-8h] BYREF
  int v33; // [sp+13Ch] [-4h] BYREF

  v4 = *(_DWORD *)(a1 + 3372);
  v7 = 0;
  v8 = *a3;
  v9 = 0;
  if ( ((v4 >> 17) & 1) == 0 )
    goto LABEL_46;
  if ( ((v4 >> 18) & 1) != 0 )
  {
    if ( a4 - (int)v8 < 2 )
      goto LABEL_61;
    *(_BYTE *)(a1 + 3120) = 0;
    v27 = v8[1];
    v8 += 2;
    *(_BYTE *)(a1 + 3120) = v27;
    if ( v27 )
    {
      if ( (unsigned __int16)(a4 - (_WORD)v8) < (unsigned int)v27 )
        goto LABEL_61;
      v28 = malloc(v27);
      *(_DWORD *)(a1 + 3116) = v28;
      v15 = -8;
      if ( !v28 )
        return v15;
      memcpy(v28, v8, *(unsigned __int8 *)(a1 + 3120));
      v4 = *(_DWORD *)(a1 + 3372);
      v8 += *(unsigned __int8 *)(a1 + 3120);
    }
  }
  v10 = a4 - (_DWORD)v8;
  if ( ((v4 >> 19) & 1) == 0 )
    goto LABEL_11;
  v7 = (int)v8;
  if ( a4 - (int)v8 >= 4 )
  {
    if ( *v8 != 3
      || (v11 = v8[1],
          v33 = v11 << 8,
          v12 = v8[2],
          v33 = v12 | (v11 << 8),
          v13 = v8 + 4,
          getEccParamById(v12 | ((_WORD)v11 << 8), &v32) < 0) )
    {
      *(_DWORD *)(a1 + 3376) = 47;
      return -12;
    }
    v33 = v8[3];
    if ( a4 - (int)v13 >= v33 )
    {
      v14 = psEccNewKey(*(_DWORD *)(a1 + 3216), (int *)(a1 + 3128), (int)v32);
      v15 = -8;
      if ( v14 < 0 )
        return v15;
      if ( psEccX963ImportKey(*(_DWORD *)(a1 + 3216), v13, v33, *(_DWORD *)(a1 + 3128), (unsigned __int8 *)v32) >= 0 )
      {
        v8 = &v13[v33];
        v9 = &v13[v33];
        v10 = a4 - (_DWORD)&v13[v33];
LABEL_11:
        if ( v10 >= 2 )
        {
          v4 = *(_DWORD *)(a1 + 3372);
          v16 = 0;
          if ( ((v4 >> 13) & 1) != 0 )
          {
            v17 = *v8;
            v8 += 2;
            v16 = 32;
            if ( v17 != 4 )
            {
              v16 = 48;
              if ( v17 != 5 )
              {
                v16 = 64;
                if ( v17 != 6 )
                {
                  v16 = 20;
                  if ( v17 != 2 )
                    return -12;
                }
              }
            }
          }
          v18 = v8[1];
          v19 = *v8 << 8;
          v8 += 2;
          v20 = v19 | v18;
          if ( a4 - (int)v8 >= (v19 | v18) )
          {
            v21 = HIWORD(v4);
            if ( ((v4 >> 15) & 1) == 0 )
              goto LABEL_30;
            if ( ((v4 >> 13) & 1) == 0 )
            {
              psMd5Sha1Init(v30);
              psMd5Sha1Update((int *)v30, a1 + 16, 0x20u);
              psMd5Sha1Update((int *)v30, a1 + 48, 0x20u);
              psMd5Sha1Update((int *)v30, v7, (unsigned int)&v9[-v7]);
              psMd5Sha1Final(v30, (int)a2);
              goto LABEL_25;
            }
            switch ( v16 )
            {
              case ' ':
                psSha256Init(v30);
                psSha256Update((int *)v30, a1 + 16, 0x20u);
                psSha256Update((int *)v30, a1 + 48, 0x20u);
                psSha256Update((int *)v30, v7, (unsigned int)&v9[-v7]);
                psSha256Final((int)v30, (int)a2);
                goto LABEL_25;
              case '0':
                psSha384Init(v30);
                psSha384Update((int *)v30, a1 + 16, 0x20u);
                psSha384Update((int *)v30, a1 + 48, 0x20u);
                psSha384Update((int *)v30, v7, (unsigned int)&v9[-v7]);
                psSha384Final((int)v30, a2);
                goto LABEL_25;
              case '@':
                psSha512Init(v30);
                psSha512Update((int *)v30, a1 + 16, 0x20u);
                psSha512Update((int *)v30, a1 + 48, 0x20u);
                psSha512Update((int *)v30, v7, (unsigned int)&v9[-v7]);
                psSha512Final((int)v30, (int)a2);
                goto LABEL_25;
            }
            v15 = -12;
            if ( v16 == 20 )
            {
              psSha1Init(v30);
              psSha1Update((int *)v30, a1 + 16, 0x20u);
              psSha1Update((int *)v30, a1 + 48, 0x20u);
              psSha1Update((int *)v30, v7, (unsigned int)&v9[-v7]);
              psSha1Final(v30, (int)a2);
LABEL_25:
              if ( ((*(_DWORD *)(a1 + 3372) >> 13) & 1) != 0 )
              {
                v22 = pubRsaDecryptSignedElement;
              }
              else
              {
                v22 = psRsaDecryptPub;
                v16 = 36;
              }
              v33 = ((int (  *)(int, int, _BYTE *, unsigned __int16, _BYTE *, unsigned __int16))v22)(
                      0,
                      *(_DWORD *)(a1 + 600) + 40,
                      v8,
                      v20,
                      v31,
                      v16);
              if ( v33 < 0 )
                goto LABEL_65;
              v8 += v20;
              if ( memcmpct((int)v31, (int)a2, v16) )
                goto LABEL_65;
              v4 = *(_DWORD *)(a1 + 3372);
              v21 = HIWORD(v4);
LABEL_30:
              if ( (v21 & 1) == 0 )
              {
LABEL_45:
                *(_BYTE *)(a1 + 3384) = 14;
LABEL_46:
                if ( ((v4 >> 18) & 1) == 0 )
                {
LABEL_51:
                  *a3 = v8;
                  *(_BYTE *)(a1 + 3385) = 12;
                  return 0;
                }
                if ( a4 - (int)v8 >= 2 )
                {
                  *(_BYTE *)(a1 + 3120) = 0;
                  v25 = v8[1];
                  v8 += 2;
                  *(_BYTE *)(a1 + 3120) = v25;
                  if ( a4 - (int)v8 >= v25 )
                  {
                    if ( v25 )
                    {
                      v29 = malloc(v25);
                      *(_DWORD *)(a1 + 3116) = v29;
                      v15 = -8;
                      if ( !v29 )
                        return v15;
                      memcpy(v29, v8, *(unsigned __int8 *)(a1 + 3120));
                      v8 += *(unsigned __int8 *)(a1 + 3120);
                      *(_BYTE *)(a1 + 3384) = 14;
                    }
                    else
                    {
                      *(_BYTE *)(a1 + 3384) = 14;
                    }
                    goto LABEL_51;
                  }
                }
                goto LABEL_61;
              }
              if ( ((v4 >> 13) & 1) != 0 && v16 == 32 )
              {
                psSha256Init(v30);
                psSha256Update((int *)v30, a1 + 16, 0x20u);
                psSha256Update((int *)v30, a1 + 48, 0x20u);
                psSha256Update((int *)v30, v7, (unsigned int)&v9[-v7]);
                psSha256Final((int)v30, (int)a2);
              }
              else if ( ((v4 >> 13) & 1) != 0 && v16 == 48 )
              {
                psSha384Init(v30);
                psSha384Update((int *)v30, a1 + 16, 0x20u);
                psSha384Update((int *)v30, a1 + 48, 0x20u);
                psSha384Update((int *)v30, v7, (unsigned int)&v9[-v7]);
                psSha384Final((int)v30, a2);
              }
              else if ( v16 == 64 )
              {
                psSha512Init(v30);
                psSha512Update((int *)v30, a1 + 16, 0x20u);
                psSha512Update((int *)v30, a1 + 48, 0x20u);
                psSha512Update((int *)v30, v7, (unsigned int)&v9[-v7]);
                psSha512Final((int)v30, (int)a2);
              }
              else
              {
                v23 = *(unsigned __int8 *)(a1 + 3390);
                if ( v23 >= 3 && v23 != 255 && (((v4 >> 13) & 1) == 0 || v16 != 20) )
                  return -12;
                psSha1Init(v30);
                psSha1Update((int *)v30, a1 + 16, 0x20u);
                psSha1Update((int *)v30, a1 + 48, 0x20u);
                psSha1Update((int *)v30, v7, (unsigned int)&v9[-v7]);
                LOWORD(v16) = 20;
                psSha1Final(v30, (int)a2);
              }
              v24 = *(_DWORD *)(a1 + 600);
              v33 = 0;
              if ( !psEccDsaVerify(0, v24 + 40, a2, v16, v8, v20, &v33) )
              {
                v8 += v20;
                if ( v33 == 1 )
                {
                  v4 = *(_DWORD *)(a1 + 3372);
                  goto LABEL_45;
                }
              }
LABEL_65:
              *(_DWORD *)(a1 + 3376) = 42;
              return -12;
            }
            return v15;
          }
        }
      }
    }
  }
LABEL_61:
  *(_DWORD *)(a1 + 3376) = 50;
  return -12;
}
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0046A4B0) --------------------------------------------------------
int   parseCertificateStatus(int a1, int a2, unsigned __int8 **a3, unsigned __int8 *a4)
{
  unsigned __int8 *v4; // $t0
  int v6; // $v1
  int v9; // $t6
  int v10; // $t5
  int v11; // $s0
  int v12; // $a1
  int v13; // $a0
  int v14; // $a2
  char v15; // $v0
  _BYTE *v17[70]; // [sp+20h] [-120h] BYREF
  unsigned __int8 *v18; // [sp+138h] [-8h] BYREF

  v4 = *a3;
  v6 = a4 - *a3;
  v18 = *a3;
  if ( v6 < 4 )
    goto LABEL_9;
  if ( *v4 != 1 )
  {
    *(_DWORD *)(a1 + 3376) = 47;
    return -12;
  }
  v18 = v4 + 1;
  v9 = v4[1];
  v18 = v4 + 2;
  v10 = v4[2];
  v18 = v4 + 3;
  v11 = (v9 << 16) | (v10 << 8) | v4[3];
  v18 = v4 + 4;
  if ( a4 - (v4 + 4) < v11 )
  {
LABEL_9:
    *(_DWORD *)(a1 + 3376) = 50;
    return -12;
  }
  memset(v17, 0, 276);
  if ( psOcspParseResponse(*(_DWORD *)(a1 + 3216), v11, &v18, a4, (int)v17) < 0
    || (v12 = *(_DWORD *)(*(_DWORD *)(a1 + 3144) + 120),
        v13 = *(_DWORD *)(a1 + 3216),
        v14 = *(_DWORD *)(a1 + 600),
        *a3 = v18,
        psOcspResponseValidateOld(v13, v12, v14, v17) < 0) )
  {
    psX509FreeCert((int)v17[62]);
    *(_DWORD *)(a1 + 3376) = 113;
    return -12;
  }
  psX509FreeCert((int)v17[62]);
  v15 = 14;
  if ( ((*(_DWORD *)(a1 + 3372) >> 17) & 1) != 0 )
    v15 = 12;
  *(_BYTE *)(a1 + 3384) = v15;
  *(_BYTE *)(a1 + 3385) = 22;
  return 0;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (0046A688) --------------------------------------------------------
int   parseServerHelloDone(int a1, int a2, int *a3)
{
  int v5; // $v1
  int v6; // $s3
  int v7; // $v0
  unsigned int v8; // $a1
  int v10; // $v0

  v5 = -12;
  v6 = *a3;
  v7 = 47;
  if ( a2 )
    goto LABEL_9;
  v8 = *(_DWORD *)(a1 + 3372);
  if ( ((v8 >> 17) & 1) != 0 && ((v8 >> 19) & 1) != 0 )
  {
    v10 = psEccNewKey(*(_DWORD *)(a1 + 3132), (int *)(a1 + 3124), *(_DWORD *)(*(_DWORD *)(a1 + 3128) + 52));
    v5 = -8;
    if ( v10 < 0 )
      return v5;
    if ( matrixSslGenEphemeralEcKey(
           *(_DWORD *)(a1 + 3144),
           *(_DWORD *)(a1 + 3124),
           *(unsigned __int8 **)(*(_DWORD *)(a1 + 3128) + 52)) < 0 )
    {
      psEccDeleteKey((int *)(a1 + 3124));
      v5 = -12;
      v7 = 80;
LABEL_9:
      *(_DWORD *)(a1 + 3376) = v7;
      return v5;
    }
  }
  *(_BYTE *)(a1 + 3384) = 20;
  v5 = -53;
  *a3 = v6;
  *(_BYTE *)(a1 + 3385) = 14;
  return v5;
}

//----- (0046A7A4) --------------------------------------------------------
int   parseCertificateRequest(int a1, int a2, unsigned __int8 **a3, int a4)
{
  unsigned __int8 *v5; // $v0
  int v7; // $a1
  bool v8; // dc
  unsigned __int8 *v9; // $a1
  unsigned int v10; // $s7
  int v11; // $s6
  int v12; // $t0
  int v13; // $s1
  int v14; // $s2
  int v15; // $s3
  unsigned int v16; // $s0
  int v17; // $v1
  unsigned __int8 *v18; // $a1
  BOOL v19; // $t2
  BOOL v20; // $a3
  unsigned int v21; // $t0
  int v23; // $v0
  int v24; // $t3
  unsigned __int8 *v25; // $s1
  int v26; // $s0
  int v27; // $v1
  int v28; // $s2
  unsigned __int8 *v29; // $a1
  int v30; // $t3
  int v31; // $t6
  char *v32; // $t4
  int v33; // $t5
  unsigned int v34; // $t1
  unsigned __int16 v35; // $a3
  char v36; // $s3
  int v37; // $s0
  unsigned __int16 v38; // $a0
  int v39; // $v0
  _DWORD *v40; // $t3
  int v41; // $v0
  int v42; // $fp
  _DWORD *v43; // $t6
  int v44; // $a3
  int v45; // $t0
  int v46; // $t3
  int v47; // $t7
  int v48; // $v0
  int v49; // [sp+18h] [-18h]
  int v50; // [sp+24h] [-Ch]
  int v51; // [sp+28h] [-8h]

  v5 = *a3;
  if ( a2 < 4 )
  {
    *(_DWORD *)(a1 + 3376) = 47;
    return -12;
  }
  v7 = *v5;
  v8 = a4 - (int)(v5 + 1) < v7;
  v9 = &v5[v7 + 1];
  if ( v8 )
  {
LABEL_58:
    *(_DWORD *)(a1 + 3376) = 50;
    return -12;
  }
  v10 = *(_DWORD *)(a1 + 3372);
  v11 = 0;
  if ( ((v10 >> 13) & 1) != 0 )
  {
    if ( a4 - (int)v9 < 2 )
      goto LABEL_58;
    v30 = v9[1];
    v31 = *v9 << 8;
    v32 = (char *)(v9 + 2);
    v33 = v31 | v30;
    if ( a4 - (int)(v9 + 2) < (v31 | v30) )
      goto LABEL_58;
    v34 = 0;
    if ( (v31 | v30) >= 2 )
    {
      v35 = *(_WORD *)(a1 + 3404);
      do
      {
        v36 = *v32;
        v37 = (unsigned __int8)v32[1];
        v33 -= 2;
        v32 += 2;
        v38 = (unsigned __int8)(1 << (v36 & 7));
        if ( v37 != 1 )
          v38 = (unsigned __int8)(1 << (v36 & 7)) << 8;
        if ( (v35 & v38) != 0 )
          v34 |= v38;
      }
      while ( v33 >= 2 );
    }
    v39 = *(_DWORD *)(a1 + 3144);
    v11 = 1;
    if ( !v39 || (v40 = *(_DWORD **)(v39 + 116)) == 0 )
    {
      v11 = 0;
LABEL_61:
      v9 = (unsigned __int8 *)&v32[v33];
      goto LABEL_4;
    }
    v41 = (v34 >> 2) & 1;
    v49 = (v34 >> 4) & 1;
    v42 = (v34 >> 5) & 1;
    v50 = (v34 >> 12) & 1;
    v43 = v40;
    v44 = (v34 >> 10) & 1;
    v45 = (v34 >> 13) & 1;
    v51 = (v34 >> 14) & 1;
    while ( 1 )
    {
      v47 = v43[111];
      if ( v47 == 645 && !v41 && !v42 && !v49 && ((v34 >> 1) & 1) == 0 )
        v11 = 0;
      v46 = v43[2];
      if ( (v46 == 1673 || v46 == 648) && !v41 )
      {
        v11 = 0;
      }
      else if ( v46 == 1679 && !v49 )
      {
        v11 = 0;
        goto LABEL_44;
      }
      if ( v46 == 1680 && !v42 )
      {
        v11 = 0;
LABEL_45:
        if ( v47 == 518 )
          goto LABEL_70;
        goto LABEL_46;
      }
LABEL_44:
      if ( v46 != 1681 || ((v34 >> 6) & 1) != 0 )
        goto LABEL_45;
      v11 = 0;
      if ( v47 == 518 )
      {
LABEL_70:
        if ( !v44 && !v45 && !v51 && !v50 )
          v11 = 0;
      }
LABEL_46:
      if ( v46 == 520 && !v44 )
        v11 = 0;
      if ( v46 == 524 && !v50 )
        v11 = 0;
      if ( v46 == 525 && !v45 )
        v11 = 0;
      if ( v46 == 526 && !v51 )
        v11 = 0;
      v43 = (_DWORD *)v43[199];
      if ( !v43 )
        goto LABEL_61;
    }
  }
LABEL_4:
  v12 = 0;
  if ( a4 - (int)v9 >= 2 )
  {
    v13 = v9[1];
    v14 = *v9 << 8;
    v9 += 2;
    v12 = v14 | v13;
    if ( a4 - (int)v9 < (v14 | v13) )
      goto LABEL_58;
  }
  v15 = *(_DWORD *)(a1 + 3144);
  if ( v15 && *(_DWORD *)(v15 + 116) )
    *(_DWORD *)(a1 + 608) = 254;
  else
    *(_DWORD *)(a1 + 608) = 0;
  if ( v12 >= 3 )
  {
    if ( v15 )
    {
      while ( 1 )
      {
        v23 = *v9;
        v24 = v9[1];
        v25 = v9 + 2;
        v26 = (v23 << 8) | v24;
        if ( a4 - (int)(v9 + 2) < (unsigned int)v26 || !v26 || v12 < v26 )
          break;
        v27 = *(_DWORD *)(v15 + 116);
        v28 = v12 - 2;
        if ( v27 && (v29 = v9 + 2, *(unsigned __int16 *)(v27 + 264) == v26) )
        {
          v48 = memcmp(*(_DWORD *)(v27 + 260), v29, (v23 << 8) | v24);
          v12 = v28 - v26;
          if ( !v48 )
            *(_DWORD *)(a1 + 608) = 1;
        }
        else
        {
          v12 = v28 - v26;
        }
        v9 = &v25[v26];
        if ( v12 < 3 )
        {
          v21 = v10 >> 13;
          goto LABEL_16;
        }
      }
    }
    else
    {
      while ( 1 )
      {
        v16 = v9[1];
        v17 = *v9 << 8;
        v18 = v9 + 2;
        v19 = a4 - (int)v18 < (v17 | v16);
        v20 = v12 < (int)(v17 | v16);
        v12 = v12 - 2 - (v17 | v16);
        v9 = &v18[v17 | v16];
        if ( v19 || !(v17 | v16) || v20 )
          break;
        if ( v12 < 3 )
          goto LABEL_15;
      }
    }
    goto LABEL_58;
  }
LABEL_15:
  v21 = v10 >> 13;
LABEL_16:
  if ( (v21 & 1) != 0 && !v11 )
    *(_DWORD *)(a1 + 608) = 0;
  *(_BYTE *)(a1 + 3384) = 14;
  *a3 = v9;
  *(_BYTE *)(a1 + 3385) = 13;
  return 0;
}
// 46AC00: conditional instruction was optimized away because $t3.4 is in (==288|==689)
// 46AC18: conditional instruction was optimized away because $t3.4==68F
// 46AC28: conditional instruction was optimized away because $t3.4==690
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);

//----- (0046AD04) --------------------------------------------------------
int   parseFinished(int a1, int a2, int a3, int *a4, int a5)
{
  int v9; // $s1
  int v10; // $s4
  unsigned int v11; // $v1
  int v12; // $v0
  unsigned int v13; // $a1
  int v14; // $s1
  unsigned int v15; // $t0
  int v16; // $a0
  int v17; // $a0
  int v18; // $a0
  int v19; // $a0
  int v20; // $a0
  int v22; // $v1
  unsigned int v23; // $a0
  int v24; // $v0
  int v25; // $a0

  v9 = *a4;
  v10 = 0;
  if ( a2 >= 49 )
  {
    psTraceStr("psAssert %s", (int)"hsDecode.c");
    psTraceInt(":%d ", 3108);
    psError((int)"hsLen <= SHA384_HASH_SIZE");
  }
  v11 = *(_DWORD *)(a1 + 3372);
  if ( ((v11 >> 1) & 1) == 0 )
  {
    *(_DWORD *)(a1 + 3376) = 10;
    return -12;
  }
  v12 = 12;
  if ( ((v11 >> 11) & 1) == 0 )
    v12 = 36;
  if ( a2 != v12 || a5 - v9 < a2 )
  {
    *(_DWORD *)(a1 + 3376) = 50;
    return -12;
  }
  if ( memcmpct(v9, a3, a2) )
  {
    *(_DWORD *)(a1 + 3376) = 51;
    return -12;
  }
  v13 = *(_DWORD *)(a1 + 3372);
  v14 = v9 + a2;
  *(_BYTE *)(a1 + 3384) = -1;
  if ( (v13 & 1) == 0 )
  {
    v22 = *(_DWORD *)(a1 + 3260);
    v23 = v13 >> 3;
    if ( v22 )
    {
      v24 = (v13 & 8) != 0;
      if ( !*(_WORD *)(v22 + 94) )
        goto LABEL_29;
      *(_WORD *)(v22 + 92) = 5;
      v23 = v13 >> 3;
    }
    v24 = v23 & 1;
LABEL_29:
    if ( !v24 )
      goto LABEL_11;
LABEL_30:
    v10 = -53;
    goto LABEL_11;
  }
  if ( ((v13 >> 3) & 1) == 0 )
    goto LABEL_30;
LABEL_11:
  v15 = v13 >> 14;
  if ( ((*(_DWORD *)(a1 + 3324) >> 3) & 1) == 0 )
  {
    v16 = *(_DWORD *)(a1 + 600);
    if ( v16 )
    {
      psX509FreeCert(v16);
      v13 = *(_DWORD *)(a1 + 3372);
      *(_DWORD *)(a1 + 600) = 0;
    }
    v15 = v13 >> 14;
  }
  if ( (v15 & 1) != 0 )
  {
    zeroSixByte(a1 + 3549);
    v25 = *(_DWORD *)(a1 + 3332);
    *(_DWORD *)(a1 + 3560) = 1;
    if ( v25 )
    {
      free2(v25);
      *(_DWORD *)(a1 + 3332) = 0;
    }
  }
  v17 = *(_DWORD *)(a1 + 128);
  if ( v17 )
  {
    free2(v17);
    *(_DWORD *)(a1 + 128) = 0;
  }
  v18 = *(_DWORD *)(a1 + 4640);
  if ( v18 )
  {
    free2(v18);
    *(_DWORD *)(a1 + 4640) = 0;
  }
  v19 = *(_DWORD *)(a1 + 4644);
  if ( v19 )
  {
    free2(v19);
    *(_DWORD *)(a1 + 4644) = 0;
  }
  v20 = *(_DWORD *)(a1 + 3116);
  if ( v20 )
  {
    free2(v20);
    *(_DWORD *)(a1 + 3116) = 0;
  }
  *a4 = v14;
  *(_BYTE *)(a1 + 3385) = 20;
  *(_DWORD *)(a1 + 3216) = 0;
  return v10;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (0046B050) --------------------------------------------------------
int   parseCertificate(int a1, unsigned __int8 **a2, int a3)
{
  unsigned __int8 *v3; // $a3
  int v5; // $fp
  int v7; // $a1
  unsigned __int8 *v8; // $s0
  int v9; // $s5
  _DWORD *v10; // $s6
  unsigned __int8 *v11; // $s1
  unsigned int v12; // $s2
  int v13; // $s3
  int v14; // $v0
  int v15; // $s0
  _DWORD *v16; // $a3
  BOOL v17; // $v0
  int v18; // $v0
  int v19; // $a2
  int v20; // $s2
  _DWORD *v21; // $a0
  int v22; // $s1
  int v23; // $v1
  int v24; // $a1
  _DWORD *v25; // $a2
  int v26; // $v0
  int (  *v27)(int, int, int); // $a3
  _DWORD *v29; // $t8
  unsigned int v30; // $ra
  int v31; // $v0
  int v32; // $v0
  unsigned int v33; // $v1
  char v34; // $v0
  char v35; // $a0
  unsigned int v36; // $v1
  _DWORD *v37; // [sp+28h] [-8h] BYREF
  int v38; // [sp+2Ch] [-4h] BYREF

  v3 = *a2;
  v5 = *(_DWORD *)(a1 + 4688);
  if ( a3 - (int)*a2 < 3 )
    goto LABEL_34;
  v7 = (*v3 << 16) | (v3[1] << 8) | v3[2];
  v8 = v3 + 3;
  if ( !v7 )
  {
    if ( (*(_DWORD *)(a1 + 3388) & 0xFFFF00) == 0x300 )
    {
      *(_DWORD *)(a1 + 3376) = 41;
      return -12;
    }
    goto LABEL_66;
  }
  if ( a3 - (int)v8 < 3 )
  {
LABEL_34:
    v31 = 50;
LABEL_35:
    *(_DWORD *)(a1 + 3376) = v31;
    return -12;
  }
  v9 = 0;
  v10 = 0;
  if ( v7 >= 3 )
  {
    do
    {
      v11 = v8 + 3;
      v12 = (*v8 << 16) | (v8[1] << 8) | v8[2];
      v13 = v7 - 3;
      if ( a3 - (int)(v8 + 3) < v12 || v13 < (int)v12 )
        goto LABEL_34;
      v14 = psX509ParseCert(*(_DWORD *)(a1 + 3216), v11, v12, (int *)&v37, ((*(_DWORD *)(a1 + 3324) >> 4) & 1) != 0);
      v15 = v14;
      if ( v14 < 0 )
      {
        psX509FreeCert((int)v37);
        if ( v15 != -8 )
          goto LABEL_66;
        *(_DWORD *)(a1 + 3376) = 80;
        return -12;
      }
      ++v9;
      v8 = &v11[v14];
      if ( v9 == 1 )
      {
        v7 = v13 - v12;
        v10 = v37;
        v17 = (int)(v13 - v12) < 3;
        *(_DWORD *)(a1 + 600) = v37;
      }
      else
      {
        v16 = v37;
        v7 = v13 - v12;
        v10[199] = v37;
        v17 = (int)(v13 - v12) < 3;
        v10 = v16;
      }
    }
    while ( !v17 );
  }
  if ( (*(_DWORD *)(a1 + 3372) & 1) == 0
    && !csCheckCertAgainstCipherSuite(
          *(unsigned __int8 *)(*(_DWORD *)(a1 + 600) + 150),
          *(unsigned __int16 *)(*(_DWORD *)(a1 + 3344) + 2)) )
  {
    v31 = 43;
    goto LABEL_35;
  }
  v18 = *(_DWORD *)(a1 + 3144);
  v19 = 0;
  if ( v18 )
    v19 = *(_DWORD *)(v18 + 120);
  v20 = matrixValidateCertsExt(
          *(_DWORD *)(a1 + 3216),
          *(_DWORD **)(a1 + 600),
          v19,
          *(unsigned __int8 **)(a1 + 3264),
          &v38,
          v5,
          *(_DWORD *)(a1 + 4684),
          (unsigned int *)(a1 + 4668));
  if ( v20 == -8 )
    goto LABEL_71;
  v22 = 0;
  v37 = *(_DWORD **)(a1 + 600);
  v21 = v37;
  if ( v37 )
  {
    while ( 2 )
    {
      v23 = *(_DWORD *)(a1 + 4680);
      ++v22;
      if ( v23 > 0 && (v23 < v22 || v23 == v22 && memcmpct((int)(v21 + 74), (int)(v21 + 41), 132)) )
      {
        v29 = v37;
        *(_DWORD *)(a1 + 3376) = 48;
        v30 = v29[172] | 0xFFFFFFDA;
        v29[173] |= 0x10u;
        v29[172] = v30;
      }
      v24 = *(_DWORD *)(a1 + 3376);
      if ( v24 == 255 )
      {
        v25 = v37;
        switch ( v37[172] )
        {
          case 0xFFFFFFD9:
          case 0xFFFFFFDA:
          case 0xFFFFFFDE:
            goto LABEL_56;
          case 0xFFFFFFDB:
            v36 = v37[173];
            v24 = 45;
            if ( ((v36 >> 3) & 1) != 0 )
              goto LABEL_23;
            v24 = 46;
            if ( ((v36 >> 2) & 1) != 0 )
              goto LABEL_23;
            v24 = 47;
            if ( !v37[199] )
              goto LABEL_23;
LABEL_56:
            v24 = 42;
            goto LABEL_57;
          case 0xFFFFFFDD:
            v24 = 44;
            goto LABEL_23;
          case 0xFFFFFFDF:
          case 0xFFFFFFE0:
            v24 = 48;
            if ( v37[199] )
            {
              v24 = 42;
LABEL_57:
              *(_DWORD *)(a1 + 3376) = 42;
            }
            else
            {
LABEL_23:
              *(_DWORD *)(a1 + 3376) = v24;
            }
LABEL_24:
            v37 = (_DWORD *)v25[199];
            v21 = v37;
            if ( v37 )
              continue;
            if ( v24 == 255 )
              goto LABEL_26;
            goto LABEL_39;
          default:
            goto LABEL_24;
        }
      }
      break;
    }
  }
  else
  {
    v24 = *(_DWORD *)(a1 + 3376);
  }
  if ( v24 == 255 )
  {
LABEL_26:
    v26 = *(_DWORD *)(a1 + 3144);
    if ( !v26 || !*(_DWORD *)(v26 + 120) )
    {
      v24 = 48;
      *(_DWORD *)(a1 + 3376) = 48;
      goto LABEL_29;
    }
  }
LABEL_39:
  if ( v20 < 0 )
  {
LABEL_29:
    v27 = *(int (  **)(int, int, int))(a1 + 604);
    if ( v27 )
      goto LABEL_41;
    if ( v24 != 255 )
      return -12;
LABEL_66:
    *(_DWORD *)(a1 + 3376) = 42;
    return -12;
  }
  v27 = *(int (  **)(int, int, int))(a1 + 604);
LABEL_41:
  v32 = matrixUserCertValidator(a1, v24, *(_DWORD *)(a1 + 600), v27);
  if ( v32 == 254 )
  {
    *(_DWORD *)(a1 + 3136) = 1;
    goto LABEL_44;
  }
  *(_DWORD *)(a1 + 3136) = 0;
  if ( v32 > 0 )
  {
    *(_DWORD *)(a1 + 3376) = v32;
    return -12;
  }
  if ( v32 < 0 )
  {
LABEL_71:
    v31 = 80;
    goto LABEL_35;
  }
LABEL_44:
  if ( *(_DWORD *)(a1 + 3376) != 255 )
    *(_DWORD *)(a1 + 3376) = 255;
  v33 = *(_DWORD *)(a1 + 3372);
  if ( (v33 & 1) == 0 )
  {
    v35 = 14;
    if ( ((v33 >> 17) & 1) != 0 )
    {
      v35 = 12;
      if ( (*(_DWORD *)(a1 + 4656) & 0x300000) != 0 )
        goto LABEL_52;
    }
    else if ( (*(_DWORD *)(a1 + 4656) & 0x300000) != 0 )
    {
LABEL_52:
      v34 = 22;
      goto LABEL_48;
    }
    *(_BYTE *)(a1 + 3384) = v35;
    goto LABEL_49;
  }
  v34 = 16;
LABEL_48:
  *(_BYTE *)(a1 + 3384) = v34;
LABEL_49:
  *a2 = v8;
  *(_BYTE *)(a1 + 3385) = 11;
  return 0;
}

//----- (0046B5E4) --------------------------------------------------------
int   sslInitHSHash(_DWORD *a1)
{
  int v2; // $v1
  __int64 *v3; // $a0

  v2 = a1[843] >> 14;
  v3 = (__int64 *)(a1 + 542);
  if ( (v2 & 1) == 0 || !a1[895] )
  {
    psMd5Sha1Init(v3);
    psSha256Init(a1 + 590);
    psSha1Init(a1 + 618);
    psSha384Init(a1 + 642);
    psSha512Init(a1 + 694);
  }
  return 0;
}

//----- (0046B6AC) --------------------------------------------------------
int   sslUpdateHSHash(int a1, int a2, unsigned __int16 a3)
{
  unsigned int v4; // $s1
  int v5; // $v1
  int *v6; // $a0
  int v8; // $v1

  v4 = a3;
  v5 = *(_DWORD *)(a1 + 3372) >> 14;
  v6 = (int *)(a1 + 2360);
  if ( (v5 & 1) == 0 || !*(_DWORD *)(a1 + 3580) )
  {
    if ( (*(_DWORD *)(a1 + 3388) & 0xFFFF00) == 0 || (v8 = *(unsigned __int8 *)(a1 + 3390), v8 == 253) || v8 == 3 )
    {
      psSha256Update(v6, a2, a3);
      psSha1Update((int *)(a1 + 2472), a2, v4);
      psSha384Update((int *)(a1 + 2568), a2, v4);
      psSha512Update((int *)(a1 + 2776), a2, v4);
    }
    psMd5Sha1Update((int *)(a1 + 2168), a2, v4);
  }
  return 0;
}

//----- (0046B7C8) --------------------------------------------------------
int   sslSha1RetrieveHSHash(_DWORD *a1, _DWORD *a2)
{
  int v2; // $v0
  int v3; // $t0
  int v4; // $a2
  int v5; // $a3
  int result; // $v0

  v2 = a1[747];
  v3 = a1[750];
  v4 = a1[748];
  v5 = a1[749];
  *a2 = a1[746];
  a2[1] = v2;
  a2[2] = v4;
  a2[3] = v5;
  a2[4] = v3;
  result = 20;
  a2[4] = v3;
  return result;
}

//----- (0046B80C) --------------------------------------------------------
int   sslSha384RetrieveHSHash(int a1, _DWORD *a2)
{
  _DWORD *v3; // $t0
  _DWORD *v4; // $a3
  int v5; // $v1
  int v6; // $a0
  int v7; // $a1

  v3 = (_DWORD *)(a1 + 3052);
  v4 = (_DWORD *)(a1 + 3004);
  do
  {
    v5 = v4[1];
    v6 = v4[2];
    v7 = v4[3];
    *a2 = *v4;
    a2[1] = v5;
    a2[2] = v6;
    a2[3] = v7;
    v4 += 4;
    a2[3] = v7;
    a2 += 4;
  }
  while ( v4 != v3 );
  return 48;
}

//----- (0046B85C) --------------------------------------------------------
int   sslSha512RetrieveHSHash(int a1, _DWORD *a2)
{
  _DWORD *v3; // $t0
  _DWORD *v4; // $a3
  int v5; // $v1
  int v6; // $a0
  int v7; // $a1

  v3 = (_DWORD *)(a1 + 3116);
  v4 = (_DWORD *)(a1 + 3052);
  do
  {
    v5 = v4[1];
    v6 = v4[2];
    v7 = v4[3];
    *a2 = *v4;
    a2[1] = v5;
    a2[2] = v6;
    a2[3] = v7;
    v4 += 4;
    a2[3] = v7;
    a2 += 4;
  }
  while ( v4 != v3 );
  return 64;
}

//----- (0046B8AC) --------------------------------------------------------
int   sslSha1SnapshotHSHash(int a1, int a2)
{
  return psSha1Final((__int64 *)(a1 + 2472), a2);
}

//----- (0046B8C8) --------------------------------------------------------
int   sslSha384SnapshotHSHash(int a1, _DWORD *a2)
{
  int *v3; // $t0
  int *v4; // $a2
  _DWORD *v5; // $a3
  int v6; // $v0
  int v7; // $v1
  int v8; // $a0
  int v9; // $a1
  _BYTE v11[208]; // [sp+18h] [-D0h] BYREF

  v3 = (int *)(a1 + 2776);
  v4 = (int *)(a1 + 2568);
  v5 = v11;
  do
  {
    v6 = *v4;
    v7 = v4[1];
    v8 = v4[2];
    v9 = v4[3];
    v4 += 4;
    *v5 = v6;
    v5[1] = v7;
    v5[2] = v8;
    v5[3] = v9;
    v5 += 4;
  }
  while ( v4 != v3 );
  return psSha384Final((int)v11, a2);
}

//----- (0046B940) --------------------------------------------------------
int   sslSha512SnapshotHSHash(int a1, int a2)
{
  int *v3; // $t0
  int *v4; // $a2
  _DWORD *v5; // $a3
  int v6; // $v0
  int v7; // $v1
  int v8; // $a0
  int v9; // $a1
  _BYTE v11[208]; // [sp+18h] [-D0h] BYREF

  v3 = (int *)(a1 + 2984);
  v4 = (int *)(a1 + 2776);
  v5 = v11;
  do
  {
    v6 = *v4;
    v7 = v4[1];
    v8 = v4[2];
    v9 = v4[3];
    v4 += 4;
    *v5 = v6;
    v5[1] = v7;
    v5[2] = v8;
    v5[3] = v9;
    v5 += 4;
  }
  while ( v4 != v3 );
  return psSha512Final((int)v11, a2);
}

//----- (0046B9B8) --------------------------------------------------------
int   extMasterSecretSnapshotHSHash(int *a1, _DWORD *a2, int a3)
{
  int *v5; // $t0
  int *v6; // $a2
  _DWORD *v7; // $a3
  int v8; // $t5
  int v9; // $t4
  int v10; // $a0
  int v11; // $t3
  int *v13; // $a2
  __int64 *v14; // $a3
  int v15; // $v0
  int v16; // $v1
  int v17; // $t2
  int v18; // $a1
  int *v19; // $a2
  _DWORD *v20; // $a3
  int v21; // $ra
  int v22; // $t8
  int v23; // $t7
  int v24; // $t6
  __int64 v25[24]; // [sp+18h] [-200h] BYREF
  _BYTE v26[112]; // [sp+D8h] [-140h] BYREF
  _BYTE v27[208]; // [sp+148h] [-D0h] BYREF

  *(_DWORD *)a3 = 0;
  if ( (((unsigned int)a1[843] >> 13) & 1) != 0 )
  {
    if ( ((*(_DWORD *)(a1[836] + 4) >> 10) & 1) != 0 )
    {
      v5 = a1 + 694;
      v6 = a1 + 642;
      v7 = v27;
      do
      {
        v8 = *v6;
        v9 = v6[1];
        v10 = v6[2];
        v11 = v6[3];
        v6 += 4;
        *v7 = v8;
        v7[1] = v9;
        v7[2] = v10;
        v7[3] = v11;
        v7 += 4;
      }
      while ( v6 != v5 );
      psSha384Final((int)v27, a2);
      *(_DWORD *)a3 = 48;
      return *(_DWORD *)a3;
    }
    else
    {
      v19 = a1 + 590;
      v20 = v26;
      do
      {
        v21 = *v19;
        v22 = v19[1];
        v23 = v19[2];
        v24 = v19[3];
        v19 += 4;
        *v20 = v21;
        v20[1] = v22;
        v20[2] = v23;
        v20[3] = v24;
        v20 += 4;
      }
      while ( v19 != a1 + 618 );
      psSha256Final((int)v26, (int)a2);
      *(_DWORD *)a3 = 32;
      return *(_DWORD *)a3;
    }
  }
  else
  {
    v13 = a1 + 542;
    v14 = v25;
    do
    {
      v15 = *v13;
      v16 = v13[1];
      v17 = v13[2];
      v18 = v13[3];
      v13 += 4;
      *(_DWORD *)v14 = v15;
      *((_DWORD *)v14 + 1) = v16;
      *((_DWORD *)v14 + 2) = v17;
      *((_DWORD *)v14 + 3) = v18;
      v14 += 2;
    }
    while ( v13 != a1 + 590 );
    psMd5Sha1Final(v25, (int)a2);
    *(_DWORD *)a3 = 36;
    return *(_DWORD *)a3;
  }
}

//----- (0046BB50) --------------------------------------------------------
int   sslSnapshotHSHash(int *a1, int a2, int a3)
{
  unsigned int v3; // $a3
  int v6; // $s0
  int result; // $v0
  int *v8; // $a2
  _DWORD *v9; // $a3
  int v10; // $a1
  int v11; // $t9
  int v12; // $a0
  int v13; // $s5
  int v14; // $v0
  int *v15; // $a2
  __int64 *v16; // $a3
  int v17; // $t8
  int v18; // $s4
  int v19; // $s2
  int v20; // $t7
  int v21; // $v0
  int *v22; // $a2
  _DWORD *v23; // $a3
  int v24; // $v0
  int v25; // $v1
  int v26; // $a0
  int v27; // $a1
  int *v28; // $a2
  _DWORD *v29; // $a3
  int v30; // $t4
  int v31; // $t3
  int v32; // $t2
  int v33; // $s5
  int *v34; // $a2
  _DWORD *v35; // $a3
  int v36; // $s4
  int v37; // $t7
  int v38; // $t6
  int v39; // $t5
  int *v40; // $a2
  __int64 *v41; // $a3
  int v42; // $ra
  int v43; // $s0
  int v44; // $t8
  int v45; // $s2
  int *v46; // $a2
  _DWORD *v47; // $a3
  int v48; // $t6
  int v49; // $t5
  int v50; // $t4
  int v51; // $t3
  int *v52; // $a2
  __int64 *v53; // $a3
  int v54; // $v1
  int v55; // $a0
  int v56; // $a1
  int v57; // $t1
  _BYTE v58[15]; // [sp+28h] [-370h] BYREF
  _DWORD v59[12]; // [sp+37h] [-361h] BYREF
  __int64 v60[24]; // [sp+68h] [-330h] BYREF
  __int64 v61[12]; // [sp+128h] [-270h] BYREF
  _BYTE v62[112]; // [sp+188h] [-210h] BYREF
  _BYTE v63[208]; // [sp+1F8h] [-1A0h] BYREF
  _BYTE v64[208]; // [sp+2C8h] [-D0h] BYREF

  v3 = a1[843];
  v6 = -1;
  if ( ((v3 >> 14) & 1) != 0 && a1[895] )
  {
    memcpy(a2, a1 + 861, a1[877]);
    return a1[877];
  }
  if ( ((v3 >> 11) & 1) != 0 )
  {
    if ( a3 < 0 )
    {
      if ( ((v3 >> 13) & 1) != 0 )
      {
        v22 = a1 + 590;
        v23 = v62;
        do
        {
          v24 = *v22;
          v25 = v22[1];
          v26 = v22[2];
          v27 = v22[3];
          v22 += 4;
          *v23 = v24;
          v23[1] = v25;
          v23[2] = v26;
          v23[3] = v27;
          v23 += 4;
        }
        while ( v22 != a1 + 618 );
        psSha256Final((int)v62, a2);
        v3 = a1[843];
        if ( (v3 & 1) != 0 )
        {
          v28 = a1 + 642;
          v29 = v63;
          do
          {
            v30 = *v28;
            v31 = v28[1];
            v32 = v28[2];
            v33 = v28[3];
            v28 += 4;
            *v29 = v30;
            v29[1] = v31;
            v29[2] = v32;
            v29[3] = v33;
            v29 += 4;
          }
          while ( v28 != a1 + 694 );
          psSha384Final((int)v63, a1 + 751);
          v34 = a1 + 694;
          v35 = v64;
          do
          {
            v36 = *v34;
            v37 = v34[1];
            v38 = v34[2];
            v39 = v34[3];
            v34 += 4;
            *v35 = v36;
            v35[1] = v37;
            v35[2] = v38;
            v35[3] = v39;
            v35 += 4;
          }
          while ( v34 != a1 + 746 );
          psSha512Final((int)v64, (int)(a1 + 763));
          v40 = a1 + 618;
          v41 = v61;
          do
          {
            v42 = *v40;
            v43 = v40[1];
            v44 = v40[2];
            v45 = v40[3];
            v40 += 4;
            *(_DWORD *)v41 = v42;
            *((_DWORD *)v41 + 1) = v43;
            *((_DWORD *)v41 + 2) = v44;
            *((_DWORD *)v41 + 3) = v45;
            v41 += 2;
          }
          while ( v40 != a1 + 642 );
          psSha1Final(v61, (int)(a1 + 746));
          v3 = a1[843];
        }
        v6 = 32;
      }
      else
      {
        v52 = a1 + 542;
        v53 = v60;
        do
        {
          v54 = *v52;
          v55 = v52[1];
          v56 = v52[2];
          v57 = v52[3];
          v52 += 4;
          *(_DWORD *)v53 = v54;
          *((_DWORD *)v53 + 1) = v55;
          *((_DWORD *)v53 + 2) = v56;
          *((_DWORD *)v53 + 3) = v57;
          v53 += 2;
        }
        while ( v52 != a1 + 590 );
        psMd5Sha1Final(v60, a2);
        v3 = a1[843];
        v6 = 36;
      }
      goto LABEL_4;
    }
    if ( (a3 & 1) != 0 )
    {
      qmemcpy(v58, "server finished", sizeof(v58));
      if ( (v3 & 0x2000) != 0 )
        goto LABEL_11;
    }
    else
    {
      qmemcpy(v58, "client finished", sizeof(v58));
      if ( (v3 & 0x2000) != 0 )
      {
LABEL_11:
        if ( ((*(_DWORD *)(a1[836] + 4) >> 10) & 1) != 0 )
        {
          v8 = a1 + 642;
          v9 = v63;
          do
          {
            v10 = *v8;
            v11 = v8[1];
            v12 = v8[2];
            v13 = v8[3];
            v8 += 4;
            *v9 = v10;
            v9[1] = v11;
            v9[2] = v12;
            v9[3] = v13;
            v9 += 4;
          }
          while ( v8 != a1 + 694 );
          psSha384Final((int)v63, v59);
          v14 = prf2((int)(a1 + 20), 0x30u, (int)v58, 0x3Fu, a2, 0xCu, 0x400u);
        }
        else
        {
          v46 = a1 + 590;
          v47 = v62;
          do
          {
            v48 = *v46;
            v49 = v46[1];
            v50 = v46[2];
            v51 = v46[3];
            v46 += 4;
            *v47 = v48;
            v47[1] = v49;
            v47[2] = v50;
            v47[3] = v51;
            v47 += 4;
          }
          while ( v46 != a1 + 618 );
          psSha256Final((int)v62, (int)v59);
          v14 = prf2((int)(a1 + 20), 0x30u, (int)v58, 0x2Fu, a2, 0xCu, 0x200u);
        }
        v3 = a1[843];
        v6 = v14;
        goto LABEL_4;
      }
    }
    v15 = a1 + 542;
    v16 = v60;
    do
    {
      v17 = *v15;
      v18 = v15[1];
      v19 = v15[2];
      v20 = v15[3];
      v15 += 4;
      *(_DWORD *)v16 = v17;
      *((_DWORD *)v16 + 1) = v18;
      *((_DWORD *)v16 + 2) = v19;
      *((_DWORD *)v16 + 3) = v20;
      v16 += 2;
    }
    while ( v15 != a1 + 590 );
    psMd5Sha1Final(v60, (int)v59);
    v21 = prf((int)(a1 + 20), 0x30u, (int)v58, 0x33u, a2, 0xCu);
    v3 = a1[843];
    v6 = v21;
  }
LABEL_4:
  result = v6;
  if ( ((v3 >> 14) & 1) != 0 && v6 > 0 )
  {
    memcpy(a1 + 861, a2, v6);
    a1[877] = v6;
    return v6;
  }
  return result;
}
// 46BB50: too many cbuild loops
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0046C090) --------------------------------------------------------
int   prf(int a1, unsigned __int16 a2, int a3, unsigned __int16 a4, int a5, unsigned __int16 a6)
{
  unsigned int v7; // $s0
  unsigned int v8; // $s7
  unsigned __int8 *v9; // $s5
  unsigned __int16 v10; // $s6
  unsigned int v11; // $s2
  unsigned __int16 v12; // $s0
  unsigned int v13; // $t6
  int v14; // $s0
  unsigned int v15; // $s1
  int v16; // $t6
  int v17; // $t5
  int v18; // $t4
  unsigned __int8 *v19; // $t2
  unsigned __int8 *v20; // $s5
  BOOL v21; // $v0
  unsigned __int16 v22; // $s6
  unsigned int v23; // $s2
  __int16 v24; // $t8
  unsigned int v25; // $s1
  int v26; // $s0
  int v27; // $ra
  int v28; // $t8
  int v29; // $t7
  unsigned __int8 *v30; // $t3
  unsigned int i; // $a3
  unsigned __int8 v32; // $s1
  unsigned __int8 v33; // $s3
  _BYTE *v34; // $fp
  unsigned __int8 v36[224]; // [sp+28h] [-390h] BYREF
  unsigned __int8 v37[224]; // [sp+108h] [-2B0h] BYREF
  _BYTE v38[160]; // [sp+1E8h] [-1D0h] BYREF
  unsigned __int8 v39[16]; // [sp+288h] [-130h] BYREF
  _DWORD v40[4]; // [sp+298h] [-120h] BYREF
  unsigned __int8 v41[16]; // [sp+2A8h] [-110h] BYREF
  unsigned __int16 v42[4]; // [sp+2B8h] [-100h] BYREF
  _BYTE v43[160]; // [sp+2C0h] [-F8h] BYREF
  unsigned __int8 v44[24]; // [sp+360h] [-58h] BYREF
  _DWORD v45[6]; // [sp+378h] [-40h] BYREF
  unsigned __int8 v46[24]; // [sp+390h] [-28h] BYREF
  unsigned __int16 v47; // [sp+3A8h] [-10h] BYREF
  unsigned int v48; // [sp+3ACh] [-Ch]
  unsigned __int8 *v49; // [sp+3B0h] [-8h]

  v7 = a2;
  v48 = a4;
  if ( a6 >= 0xE1u )
  {
    psTraceStr("psAssert %s", (int)"prf.c");
    psTraceInt(":%d ", 221);
    psError((int)"outLen <= SSL_MAX_KEY_BLOCK_SIZE");
  }
  v8 = (v7 >> 1) + (v7 & 1);
  v49 = (unsigned __int8 *)((v7 >> 1) + a1);
  v9 = (unsigned __int8 *)a1;
  v10 = v8;
  v11 = 1;
  if ( a6 > 0x10u )
  {
    v12 = 2;
    do
    {
      v11 = v12;
      v13 = (unsigned __int16)(16 * v12++);
    }
    while ( v13 < a6 );
  }
  v14 = psHmacMd5(a1, v8, a3, v48, (int)v39, (int)v41, v42);
  if ( v14 >= 0 )
  {
    if ( v42[0] != v8 )
    {
      if ( v8 < 0x41 )
      {
        psTraceStr("psAssert %s", (int)"prf.c");
        psTraceInt(":%d ", 95);
        psError((int)"keyLen > 64");
      }
      v10 = v42[0];
      v9 = v41;
    }
    v15 = 0;
    if ( v11 )
    {
      while ( 1 )
      {
        v14 = psHmacMd5Init((int)v38, (int)v9, v10);
        if ( v14 < 0 )
          break;
        psHmacMd5Update((int)v38, (int)v39, 0x10u);
        psHmacMd5Update((int)v38, a3, v48);
        psHmacMd5Final((int)v38, (int)v40);
        v19 = &v36[16 * v15];
        if ( v15 == v11 - 1 )
        {
          memcpy(&v36[16 * v15], v40, a6 - 16 * v15);
          v15 = (unsigned __int16)(v15 + 1);
          if ( v15 >= v11 )
            goto LABEL_18;
        }
        else
        {
          v16 = v40[1];
          v17 = v40[2];
          v18 = v40[3];
          *(_DWORD *)v19 = v40[0];
          *((_DWORD *)v19 + 1) = v16;
          *((_DWORD *)v19 + 2) = v17;
          *((_DWORD *)v19 + 3) = v18;
          v14 = psHmacMd5((int)v9, v10, (int)v39, 0x10u, (int)v39, (int)v41, v42);
          if ( v14 < 0 )
            break;
          v15 = (unsigned __int16)(v15 + 1);
          v14 = 0;
          if ( v15 >= v11 )
            break;
        }
      }
    }
    else
    {
LABEL_18:
      v14 = 0;
    }
  }
  memset_s(v39, 0x10u, 0, 0x10u);
  memset_s((unsigned __int8 *)v40, 0x10u, 0, 0x10u);
  memset_s(v41, 0x10u, 0, 0x10u);
  if ( v14 >= 0 )
  {
    v20 = v49;
    v21 = a6 > 0x14u;
    v22 = v8;
    v23 = 1;
    while ( 1 )
    {
      v24 = v23 + 1;
      if ( !v21 )
        break;
      v23 = (unsigned __int16)(v23 + 1);
      v21 = (unsigned __int16)(20 * v24) < (unsigned int)a6;
    }
    v14 = psHmacSha1((int)v49, v8, a3, v48, (int)v44, (int)v46, &v47);
    if ( v14 >= 0 )
    {
      if ( v47 != v8 )
      {
        if ( v8 < 0x41 )
        {
          psTraceStr("psAssert %s", (int)"prf.c");
          psTraceInt(":%d ", 166);
          psError((int)"keyLen > 64");
        }
        v22 = v47;
        v20 = v46;
      }
      v25 = 0;
      if ( v23 )
      {
        while ( 1 )
        {
          v14 = psHmacSha1Init((int)v43, (int)v20, v22);
          if ( v14 < 0 )
            break;
          psHmacSha1Update((int)v43, (int)v44, 0x14u);
          psHmacSha1Update((int)v43, a3, v48);
          psHmacSha1Final((int)v43, (int)v45);
          v30 = &v37[20 * v25];
          if ( v25 == v23 - 1 )
          {
            memcpy(&v37[20 * v25], v45, a6 - 20 * v25);
            v25 = (unsigned __int16)(v25 + 1);
            if ( v25 >= v23 )
              goto LABEL_36;
          }
          else
          {
            v26 = v45[3];
            v27 = v45[1];
            v28 = v45[2];
            v29 = v45[4];
            *(_DWORD *)v30 = v45[0];
            *((_DWORD *)v30 + 1) = v27;
            *((_DWORD *)v30 + 2) = v28;
            *((_DWORD *)v30 + 3) = v26;
            *((_DWORD *)v30 + 4) = v29;
            *((_DWORD *)v30 + 4) = v29;
            v14 = psHmacSha1((int)v20, v22, (int)v44, 0x14u, (int)v44, (int)v46, &v47);
            if ( v14 < 0 )
              break;
            v25 = (unsigned __int16)(v25 + 1);
            v14 = 0;
            if ( v25 >= v23 )
              break;
          }
        }
      }
      else
      {
LABEL_36:
        v14 = 0;
      }
    }
    memset_s(v44, 0x14u, 0, 0x14u);
    memset_s((unsigned __int8 *)v45, 0x14u, 0, 0x14u);
    memset_s(v46, 0x14u, 0, 0x14u);
    if ( v14 >= 0 )
    {
      for ( i = 0; i < a6; *v34 = v33 ^ v32 )
      {
        v32 = v36[i + 224];
        v33 = v36[i];
        v34 = (_BYTE *)(i + a5);
        i = (unsigned __int16)(i + 1);
      }
      v14 = a6;
    }
    else
    {
      memset_s(v37, a6, 0, a6);
    }
  }
  else
  {
    memset_s(v36, a6, 0, a6);
  }
  memset_s(v36, 0xE0u, 0, 0xE0u);
  memset_s(v37, 0xE0u, 0, 0xE0u);
  return v14;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0046C7A0) --------------------------------------------------------
int   prf2(
        int a1,
        unsigned __int16 a2,
        int a3,
        unsigned __int16 a4,
        int a5,
        unsigned __int16 a6,
        unsigned int a7)
{
  unsigned int v8; // $s1
  _DWORD *v9; // $s6
  unsigned __int16 v10; // $s7
  int v11; // $s0
  unsigned int v12; // $s2
  BOOL v13; // $v0
  unsigned int v14; // $s5
  __int16 v15; // $t8
  unsigned int v16; // $s3
  int v17; // $fp
  int v18; // $lo
  int v19; // $v0
  unsigned int i; // $a2
  unsigned __int8 *v21; // $s5
  unsigned __int8 v22; // $fp
  unsigned __int8 v24[224]; // [sp+28h] [-2C8h] BYREF
  _BYTE v25[336]; // [sp+108h] [-1E8h] BYREF
  _DWORD v26[12]; // [sp+258h] [-98h] BYREF
  _DWORD v27[12]; // [sp+288h] [-68h] BYREF
  _DWORD v28[12]; // [sp+2B8h] [-38h] BYREF
  unsigned __int16 v29; // [sp+2E8h] [-8h] BYREF
  unsigned int v30; // [sp+2ECh] [-4h]

  v8 = a2;
  v30 = a4;
  if ( a6 >= 0xE1u )
  {
    psTraceStr("psAssert %s", (int)"prf.c");
    psTraceInt(":%d ", 383);
    psError((int)"outLen <= SSL_MAX_KEY_BLOCK_SIZE");
  }
  v9 = (_DWORD *)a1;
  v10 = v8;
  if ( ((a7 >> 10) & 1) != 0 )
  {
    v11 = psHmacSha384(a1, v8, a3, v30, v26, v28, &v29);
    v12 = 48;
  }
  else
  {
    v11 = psHmacSha256(a1, v8, a3, v30, v26, v28, &v29);
    v12 = 32;
  }
  v13 = v12 < a6;
  if ( v11 >= 0 )
  {
    v14 = 1;
    while ( 1 )
    {
      v15 = v14 + 1;
      if ( !v13 )
        break;
      v14 = (unsigned __int16)(v14 + 1);
      v13 = (unsigned __int16)(v12 * v15) < (unsigned int)a6;
    }
    if ( v29 != v8 )
    {
      if ( v8 < 0x41 )
      {
        psTraceStr("psAssert %s", (int)"prf.c");
        psTraceInt(":%d ", 302);
        psError((int)"keyLen > 64");
      }
      v10 = v29;
      v9 = v28;
    }
    v16 = 0;
    if ( v14 )
    {
      v17 = (a7 >> 10) & 1;
      while ( 1 )
      {
        if ( v17 )
        {
          v11 = psHmacSha384Init((int)v25, (int)v9, v10);
          if ( v11 < 0 )
            goto LABEL_26;
          psHmacSha384Update((int)v25, (int)v26, v12);
          psHmacSha384Update((int)v25, a3, v30);
          psHmacSha384Final((int)v25, v27);
          v18 = v12 * v16;
          if ( v16 != v14 - 1 )
            goto LABEL_17;
LABEL_24:
          v16 = (unsigned __int16)(v16 + 1);
          memcpy(&v24[v18], v27, a6 - v18);
          if ( v16 >= v14 )
            break;
        }
        else
        {
          v11 = psHmacSha256Init((int)v25, (int)v9, v10);
          if ( v11 < 0 )
            goto LABEL_26;
          psHmacSha256Update((int)v25, (int)v26, v12);
          psHmacSha256Update((int)v25, a3, v30);
          psHmacSha256Final((int)v25, (int)v27);
          v18 = v12 * v16;
          if ( v16 == v14 - 1 )
            goto LABEL_24;
LABEL_17:
          memcpy(&v24[v18], v27, v12);
          if ( v17 )
            v19 = psHmacSha384((int)v9, v10, (int)v26, v12, v26, v28, &v29);
          else
            v19 = psHmacSha256((int)v9, v10, (int)v26, v12, v26, v28, &v29);
          v11 = v19;
          if ( v19 < 0 )
            goto LABEL_26;
          v16 = (unsigned __int16)(v16 + 1);
          v11 = 0;
          if ( v16 >= v14 )
            goto LABEL_26;
        }
      }
    }
    v11 = 0;
  }
LABEL_26:
  memset_s((unsigned __int8 *)v26, 0x30u, 0, 0x30u);
  memset_s((unsigned __int8 *)v27, 0x30u, 0, 0x30u);
  memset_s((unsigned __int8 *)v28, 0x30u, 0, 0x30u);
  if ( v11 < 0 )
  {
    memset_s(v24, a6, 0, a6);
    return v11;
  }
  else
  {
    for ( i = 0; i < a6; *v21 = v22 )
    {
      v21 = (unsigned __int8 *)(i + a5);
      v22 = v24[i];
      i = (unsigned __int16)(i + 1);
    }
    memset_s(v24, 0xE0u, 0, 0xE0u);
    return a6;
  }
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0046CC90) --------------------------------------------------------
int   matrixPskGetHint(int a1, _DWORD *a2, _BYTE *a3)
{
  int result; // $v0

  result = 0;
  *a2 = 0;
  *a3 = 0;
  return result;
}

//----- (0046CCA0) --------------------------------------------------------
int   matrixSslPskGetKeyId(int a1, _DWORD *a2, _BYTE *a3)
{
  int v3; // $v0
  int v4; // $a0

  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 3144) + 124);
  v4 = -1;
  if ( v3 )
  {
    v4 = 0;
    *a2 = *(_DWORD *)(v3 + 8);
    *a3 = *(_BYTE *)(v3 + 12);
  }
  return v4;
}

//----- (0046CCD8) --------------------------------------------------------
int   matrixSslPskGetKey(int a1, int a2, unsigned __int8 a3, _DWORD *a4, _BYTE *a5)
{
  int v6; // $s0
  int v8; // $s1
  int v9; // $a0
  int v10; // $v0

  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 3144) + 124);
  v8 = a3;
  *a4 = 0;
  v9 = -1;
  if ( !v6 )
    return v9;
  v9 = -6;
  if ( !a3 )
    return v9;
  do
  {
    if ( *(unsigned __int8 *)(v6 + 12) == v8 )
    {
      v10 = memcmp(*(_DWORD *)(v6 + 8), a2, v8);
      v9 = 0;
      if ( !v10 )
      {
        *a4 = *(_DWORD *)v6;
        *a5 = *(_BYTE *)(v6 + 4);
        return v9;
      }
    }
    v6 = *(_DWORD *)(v6 + 16);
  }
  while ( v6 );
  return 0;
}
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);

//----- (0046CDC8) --------------------------------------------------------
int   parseClientHelloExtensions(int a1, unsigned __int8 **a2, unsigned __int16 a3)
{
  unsigned __int8 *v3; // $s0
  unsigned int v5; // $a0
  int v6; // $s6
  __int16 v7; // $v0
  __int16 v8; // $a2
  __int16 v9; // $t7
  _BYTE *v10; // $s1
  unsigned int v11; // $s2
  int v12; // $v0
  int v14; // $s0
  int v15; // $a0
  int v16; // $v0
  int v17; // $v1
  int v18; // $v0
  unsigned int v19; // $a3
  unsigned int v20; // $a2
  _BYTE *v21; // $a1
  __int16 v22; // $a0
  unsigned int v23; // $a2
  unsigned __int8 *v24; // $a0
  unsigned int v25; // $s4
  unsigned int v26; // $s5
  unsigned __int8 *v27; // $s3
  int v28; // $fp
  int v29; // $s0
  unsigned int v30; // $v1
  int v31; // $v1
  int v32; // $v0
  int v33; // $a0
  int v34; // $v1
  int v35; // $a1
  int *v36; // $a2
  _DWORD *v37; // $a3
  int v38; // $t3
  int v39; // $t2
  int v40; // $a0
  int v41; // $t1
  int v42; // $v0
  int v43; // $v0

  v3 = *a2;
  v5 = *(_DWORD *)(a1 + 4656) & 0xFFE07FFF;
  v6 = (int)&(*a2)[a3];
  *(_DWORD *)(a1 + 4656) = v5;
  if ( v3 == &v3[a3] )
    goto LABEL_23;
  if ( a3 < 2u
    || (v7 = *v3, v8 = v3[1], v3 += 2, v6 - (_DWORD)v3 != (unsigned __int16)((v7 << 8) + v8))
    || (unsigned int)(v6 - (_DWORD)v3) < 4 )
  {
LABEL_9:
    v12 = 50;
    goto LABEL_10;
  }
  *(_WORD *)(a1 + 3404) = 0;
  if ( v3 == (unsigned __int8 *)v6 )
    goto LABEL_23;
  while ( 2 )
  {
    if ( v6 - (int)(v3 + 2) < 2 )
      goto LABEL_9;
    v9 = v3[2] << 8;
    v10 = v3 + 4;
    v11 = (unsigned __int16)(v9 + v3[3]);
    if ( v6 - (int)(v3 + 4) < v11 )
      goto LABEL_9;
    switch ( (*v3 << 8) + v3[1] )
    {
      case 0:
        if ( v11 < 5 )
          goto LABEL_101;
        if ( v3[6] )
          goto LABEL_101;
        v14 = (v3[7] << 8) + v3[8];
        if ( (unsigned __int16)(v11 - 5) < v14 )
          goto LABEL_101;
        v12 = 47;
        if ( v14 >= 256 || v14 <= 0 )
          goto LABEL_10;
        v15 = *(_DWORD *)(a1 + 3264);
        if ( v15 )
          free2(v15);
        v16 = malloc(v14 + 1);
        *(_DWORD *)(a1 + 3264) = v16;
        if ( !v16 )
          goto LABEL_54;
        memcpy(v16, v10 + 5, v14);
        *(_BYTE *)(*(_DWORD *)(a1 + 3264) + v14) = 0;
        goto LABEL_20;
      case 1:
        if ( v11 != 1 )
          goto LABEL_101;
        v3 += 5;
        if ( ((*(_DWORD *)(a1 + 4656) >> 13) & 1) != 0 )
          goto LABEL_21;
        v31 = (unsigned __int8)*v10;
        v32 = 512;
        switch ( v31 )
        {
          case 1:
            goto LABEL_78;
          case 2:
            *(_DWORD *)(a1 + 3328) = 1024;
            break;
          case 3:
            *(_DWORD *)(a1 + 3328) = 2048;
            break;
          case 4:
            v32 = 4096;
LABEL_78:
            *(_DWORD *)(a1 + 3328) = v32;
            break;
          default:
LABEL_101:
            v12 = 47;
            goto LABEL_10;
        }
        goto LABEL_20;
      case 4:
        if ( v9 + v3[3] )
          goto LABEL_54;
        v30 = *(_DWORD *)(a1 + 4656);
        v3 += 4;
        if ( ((v30 >> 12) & 1) != 0 )
          goto LABEL_21;
        *(_DWORD *)(a1 + 4656) = v30 | 0x10000;
        goto LABEL_37;
      case 5:
        if ( v11 < 5 )
          goto LABEL_101;
        if ( *v10 != 1 )
          goto LABEL_101;
        v33 = (unsigned __int16)((v3[5] << 8) + v3[6]);
        if ( (unsigned __int16)(v11 - 3) < v33 + 2
          || (unsigned __int16)(v11 - 5) < (unsigned int)(unsigned __int16)((v3[v33 + 7] << 8) + v3[v33 + 8]) )
        {
          goto LABEL_101;
        }
        v34 = *(_DWORD *)(a1 + 3144);
        v3 = &v10[v11];
        if ( !*(_WORD *)(v34 + 140) || !*(_DWORD *)(v34 + 136) )
          goto LABEL_21;
        *(_DWORD *)(a1 + 4656) |= 0x100000u;
LABEL_37:
        if ( v3 == (unsigned __int8 *)v6 )
          goto LABEL_22;
        continue;
      case 10:
        if ( v11 < 4 )
          goto LABEL_54;
        v25 = (unsigned __int16)((v3[4] << 8) + v3[5]);
        v26 = (unsigned __int16)(v11 - 2);
        v27 = v3 + 6;
        if ( v26 < v25 || v25 < 2 )
          goto LABEL_54;
        v12 = 40;
        if ( (v3[5] & 1) != 0 )
          goto LABEL_10;
        *(_BYTE *)(a1 + 3403) = 0;
        v28 = 0x800000;
        if ( v26 >= 2 )
        {
          do
          {
            v29 = (unsigned __int16)((*v27 << 8) + v27[1]);
            v25 = (unsigned __int16)(v25 - 2);
            v26 = (unsigned __int16)(v26 - 2);
            v27 += 2;
            if ( !psTestUserEcID(v29, *(_DWORD *)(a1 + 3400) & 0xFFFFFF) )
            {
              if ( v28 == 0x800000 )
                *(_BYTE *)(a1 + 3403) = v29;
              v28 |= curveIdToFlag(v29);
            }
          }
          while ( v25 >= 2 && v26 >= 2 );
        }
        v3 = &v10[v11];
        *(_DWORD *)(a1 + 3400) = *(_DWORD *)(a1 + 3400) & 0xFF000000 | v28 & 0xFFFFFF;
        if ( &v10[v11] != (_BYTE *)v6 )
          continue;
        goto LABEL_22;
      case 11:
        if ( !(v9 + v3[3]) )
          goto LABEL_54;
        v23 = (unsigned __int8)*v10;
        v24 = v3 + 5;
        if ( (unsigned __int16)(v11 - 1) < v23 )
          goto LABEL_54;
        if ( !*v10 )
          goto LABEL_54;
        v3 = &v10[v11];
        if ( !memchr(v24, 0, v23) )
          goto LABEL_54;
        goto LABEL_21;
      case 13:
        if ( v11 - 4 >= 0x1F )
          goto LABEL_54;
        if ( (v3[3] & 1) != 0 )
          goto LABEL_54;
        v19 = ((unsigned __int8)*v10 << 8) | v3[5];
        v20 = (unsigned __int16)(v11 - 2);
        v21 = v3 + 6;
        if ( v20 < v19 || v19 < 2 || (v3[5] & 1) != 0 )
          goto LABEL_54;
        if ( v20 < 2 )
          goto LABEL_20;
        while ( 1 )
        {
          v22 = (unsigned __int8)(1 << (*v21 & 7));
          if ( v21[1] != 1 )
            v22 = (unsigned __int8)(1 << (*v21 & 7)) << 8;
          v19 = (unsigned __int16)(v19 - 2);
          *(_WORD *)(a1 + 3404) |= v22;
          v21 += 2;
          v20 = (unsigned __int16)(v20 - 2);
          if ( v19 < 2 )
            goto LABEL_20;
          v3 = &v10[v11];
          if ( v20 < 2 )
            goto LABEL_21;
        }
      case 23:
        if ( v9 + v3[3] )
          goto LABEL_54;
        *(_DWORD *)(a1 + 4656) |= 0x20000u;
        v3 += 4;
        goto LABEL_37;
      case 35:
        v17 = *(_DWORD *)(a1 + 3260);
        if ( v17 )
          goto LABEL_31;
        v42 = malloc(100);
        *(_DWORD *)(a1 + 3260) = v42;
        if ( v42 )
        {
          memset(v42, 0, 100);
          v17 = *(_DWORD *)(a1 + 3260);
          *(_DWORD *)v17 = *(_DWORD *)(a1 + 3212);
LABEL_31:
          if ( v11 )
          {
            *(_DWORD *)(a1 + 4656) |= 0x80000u;
            if ( !matrixUnlockSessionTicket(a1, (int)(v3 + 4), v11) )
            {
              v35 = *(_DWORD *)(a1 + 3260);
              *(_DWORD *)(a1 + 3372) |= 8u;
              *(_WORD *)(v35 + 92) = 5;
              v36 = (int *)(v35 + 36);
              v37 = (_DWORD *)(a1 + 80);
              do
              {
                v38 = *v36;
                v39 = v36[1];
                v40 = v36[2];
                v41 = v36[3];
                v36 += 4;
                *v37 = v38;
                v37[1] = v39;
                v37[2] = v40;
                v37[3] = v41;
                v37 += 4;
              }
              while ( v36 != (int *)(v35 + 84) );
              v3 = &v10[v11];
              goto LABEL_21;
            }
            if ( *(_BYTE *)(a1 + 3224) )
            {
              memset(a1 + 3225, 0, 32);
              *(_BYTE *)(a1 + 3224) = 0;
            }
            v43 = *(_DWORD *)(a1 + 3144);
            if ( v43 && *(_DWORD *)(v43 + 128) )
              *(_WORD *)(*(_DWORD *)(a1 + 3260) + 92) = 3;
            else
              *(_WORD *)(*(_DWORD *)(a1 + 3260) + 92) = 0;
          }
          else
          {
            v18 = *(_DWORD *)(a1 + 3144);
            if ( v18 && *(_DWORD *)(v18 + 128) )
              *(_WORD *)(v17 + 92) = 3;
            else
              *(_WORD *)(v17 + 92) = 0;
          }
LABEL_20:
          v3 = &v10[v11];
LABEL_21:
          if ( v3 == (unsigned __int8 *)v6 )
          {
LABEL_22:
            v5 = *(_DWORD *)(a1 + 4656);
LABEL_23:
            if ( (v5 & 0x420000) == 0x400000 )
            {
LABEL_54:
              v12 = 40;
              goto LABEL_10;
            }
            if ( ((*(_DWORD *)(a1 + 3372) >> 13) & 1) != 0 && !*(_WORD *)(a1 + 3404) )
              *(_WORD *)(a1 + 3404) |= 0x404u;
            if ( ((*(_DWORD *)(a1 + 4656) >> 18) & 1) == 1 )
            {
              memset(a1 + 3225, 0, 32);
              v5 = *(_DWORD *)(a1 + 4656);
              *(_BYTE *)(a1 + 3224) = 0;
            }
            *(_DWORD *)(a1 + 4656) = v5 & 0xFFF3FFFF;
            *a2 = v3;
            return 0;
          }
          continue;
        }
        v12 = 80;
LABEL_10:
        *(_DWORD *)(a1 + 3376) = v12;
        return -12;
      default:
        goto LABEL_20;
    }
  }
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FF4: using guessed type int   memchr(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0046D62C) --------------------------------------------------------
int   parseServerHelloExtensions(int a1, int a2, int a3, unsigned __int8 **a4, unsigned __int16 a5)
{
  unsigned __int8 *v6; // $a3
  int v10; // $t0
  unsigned __int8 *v11; // $s3
  unsigned __int8 *v12; // $a2
  int v13; // $a1
  __int16 v14; // $t1
  __int16 v15; // $a3
  _BYTE *v16; // $s1
  unsigned int v17; // $s0
  int v18; // $a2
  int (  *v19)(int, int, int, _BYTE *); // $t9
  int v20; // $a2
  unsigned int v21; // $a0
  unsigned int v23; // $v1
  unsigned int v24; // $a3
  unsigned int v25; // $v1
  unsigned int v26; // $v1
  unsigned int v27; // $a1
  int v28; // $t4
  int v29; // $t7
  int v30; // $v1
  unsigned int v31; // $v1
  unsigned int v32; // $v1
  unsigned int v33; // $v1
  unsigned int v34; // $v1
  int v35; // $v1
  int v36; // $a0
  int v37; // $v1

  v6 = *a4;
  v10 = 0;
  v11 = &v6[a5];
  if ( a5 < 2u || (v12 = v6 + 2, (unsigned int)a5 - 2 < (unsigned __int16)((*v6 << 8) + v6[1])) )
  {
LABEL_61:
    *(_DWORD *)(a1 + 3376) = 50;
    return -12;
  }
  if ( (int)&v6[-a3 + 2] >= a2 )
  {
LABEL_11:
    v21 = *(_DWORD *)(a1 + 4656);
    if ( ((v21 >> 3) & 1) == 1 && ((v21 >> 22) & 1) == 1 || ((v21 >> 11) & 1) == 1 && ((v21 >> 20) & 1) == 0 )
    {
LABEL_15:
      *(_DWORD *)(a1 + 3376) = 40;
      return -12;
    }
    *a4 = v12;
    return v10;
  }
  while ( 2 )
  {
    v13 = (unsigned __int16)((*v12 << 8) + v12[1]);
    if ( v11 - (v12 + 2) < 2 )
      goto LABEL_61;
    v14 = v12[2];
    v15 = v12[3];
    v16 = v12 + 4;
    v17 = (unsigned __int16)((v14 << 8) + v15);
    if ( v11 - (v12 + 4) < v17 )
      goto LABEL_61;
    v18 = -1;
    switch ( v13 )
    {
      case 0:
        v37 = *(_DWORD *)(a1 + 4656);
        if ( (v37 & 1) == 0 )
          goto LABEL_18;
        v19 = *(int (  **)(int, int, int, _BYTE *))(a1 + 3396);
        v24 = v37 & 0xFFFFFFFE;
        goto LABEL_23;
      case 1:
        v26 = *(_DWORD *)(a1 + 4656);
        if ( ((v26 >> 1) & 1) != 0 )
        {
          *(_DWORD *)(a1 + 4656) = v26 & 0xFFFFFFFD;
          v18 = 0;
        }
        v27 = *(_DWORD *)(a1 + 3328);
        if ( (v27 & 0x10000) == 0 || v17 != 1 )
          goto LABEL_62;
        if ( *v16 == 1 )
        {
          v28 = (unsigned __int8)*v16;
          if ( ((v27 >> 9) & 1) != 0 )
          {
            *(_DWORD *)(a1 + 3328) = 512;
            goto LABEL_9;
          }
        }
        else
        {
          v28 = (unsigned __int8)*v16;
        }
        if ( v28 == 2 )
        {
          v29 = (unsigned __int8)*v16;
          if ( ((v27 >> 10) & 1) != 0 )
          {
            *(_DWORD *)(a1 + 3328) = 1024;
            goto LABEL_9;
          }
        }
        else
        {
          v29 = (unsigned __int8)*v16;
        }
        if ( v29 == 3 )
        {
          v30 = (unsigned __int8)*v16;
          if ( ((v27 >> 11) & 1) != 0 )
          {
            *(_DWORD *)(a1 + 3328) = 2048;
            goto LABEL_9;
          }
        }
        else
        {
          v30 = (unsigned __int8)*v16;
        }
        if ( v30 != 4 || ((v27 >> 12) & 1) == 0 )
        {
LABEL_62:
          *(_DWORD *)(a1 + 3376) = 47;
          return -12;
        }
        *(_DWORD *)(a1 + 3328) = 4096;
LABEL_9:
        if ( v18 >= 0 )
        {
LABEL_10:
          v10 = v18;
          v12 = &v16[v17];
          if ( (int)&v16[v17 - a3] >= a2 )
            goto LABEL_11;
          continue;
        }
LABEL_18:
        if ( *(unsigned __int8 *)(a1 + 3390) < 3u )
          *(_DWORD *)(a1 + 3376) = 47;
        else
          *(_DWORD *)(a1 + 3376) = 110;
        return -12;
      case 4:
        v31 = *(_DWORD *)(a1 + 4656);
        if ( ((v31 >> 2) & 1) != 0 )
        {
          *(_DWORD *)(a1 + 4656) = v31 & 0xFFFFFFFB;
          v18 = 0;
        }
        if ( (v14 << 8) + v15 )
          goto LABEL_62;
        *(_DWORD *)(a1 + 4656) |= 0x10000u;
        goto LABEL_9;
      case 5:
        v32 = *(_DWORD *)(a1 + 4656);
        if ( ((v32 >> 11) & 1) == 0 )
          goto LABEL_18;
        v18 = 0;
        *(_DWORD *)(a1 + 4656) = v32 | 0x100000;
        goto LABEL_10;
      case 10:
      case 13:
        goto LABEL_18;
      case 11:
        v33 = *(_DWORD *)(a1 + 4656);
        if ( ((v33 >> 5) & 1) != 0 )
        {
          *(_DWORD *)(a1 + 4656) = v33 & 0xFFFFFFDF;
          v18 = 0;
        }
        if ( (unsigned __int8)*v16 != v17 - 1 )
          goto LABEL_15;
        goto LABEL_9;
      case 16:
        v23 = *(_DWORD *)(a1 + 4656);
        if ( ((v23 >> 7) & 1) == 0 )
          goto LABEL_18;
        v19 = *(int (  **)(int, int, int, _BYTE *))(a1 + 3396);
        v24 = v23 & 0xFFFFFF7F;
LABEL_23:
        *(_DWORD *)(a1 + 4656) = v24;
        v18 = 0;
        if ( !v19 )
          goto LABEL_10;
        v20 = (unsigned __int8)v17;
LABEL_8:
        v18 = v19(a1, v13, v20, v16);
        goto LABEL_9;
      case 23:
        v25 = *(_DWORD *)(a1 + 4656);
        if ( ((v25 >> 3) & 1) != 0 )
        {
          *(_DWORD *)(a1 + 4656) = v25 & 0xFFFFFFF7;
          v18 = 0;
        }
        if ( (v14 << 8) + v15 )
          goto LABEL_62;
        *(_DWORD *)(a1 + 4656) |= 0x20000u;
        goto LABEL_9;
      case 35:
        v34 = *(_DWORD *)(a1 + 4656);
        if ( ((v34 >> 8) & 1) != 0 )
        {
          *(_DWORD *)(a1 + 4656) = v34 & 0xFFFFFEFF;
          v18 = 0;
        }
        v35 = *(_DWORD *)(a1 + 3260);
        if ( !v35 )
          goto LABEL_62;
        v36 = *(unsigned __int16 *)(v35 + 92);
        if ( v36 != 1 && v36 != 2 )
          goto LABEL_62;
        *(_WORD *)(v35 + 92) = 3;
        goto LABEL_9;
      default:
        v19 = *(int (  **)(int, int, int, _BYTE *))(a1 + 3396);
        v20 = (unsigned __int8)v15;
        if ( v19 )
          goto LABEL_8;
        goto LABEL_18;
    }
  }
}
// 46D764: conditional instruction was optimized away because $a2.4>=0

//----- (0046DB24) --------------------------------------------------------
int   psAesClearCBC(unsigned __int8 *a1)
{
  return memset_s(a1, 0x114u, 0, 0x114u);
}

//----- (0046DB44) --------------------------------------------------------
int   psAesInitCBC(int a1, int a2, unsigned int *a3, unsigned __int8 a4, int a5)
{
  int inited; // $v1
  int i; // $a1
  int v9; // $v1
  char v10; // $a0

  inited = psAesInitBlockKey(a1, a3, a4, a5);
  if ( !inited )
  {
    for ( i = 0; i < 16; ++i )
    {
      v9 = i + a1;
      v10 = *(_BYTE *)(a2 + i);
      *(_BYTE *)(v9 + 260) = v10;
    }
    return 0;
  }
  return inited;
}

//----- (0046DBC8) --------------------------------------------------------
int   psAesEncryptCBC(int a1, int a2, _BYTE *a3, unsigned int a4)
{
  unsigned int i; // $s4
  unsigned int j; // $a3
  char v10; // $t0
  char v11; // $a1
  _BYTE *v12; // $a2
  unsigned int k; // $a1
  unsigned int v14; // $t2
  char v15; // $t3
  unsigned int v17[4]; // [sp+18h] [-10h] BYREF

  for ( i = 0; i < a4; a2 += 16 )
  {
    for ( j = 0; j < 0x10; ++j )
    {
      v10 = *(_BYTE *)(a2 + j);
      v11 = *(_BYTE *)(j + a1 + 260);
      v12 = (char *)v17 + j;
      *v12 = v10 ^ v11;
    }
    psAesEncryptBlock(a1, v17, a3);
    for ( k = 0; k < 0x10; ++k )
    {
      v14 = k + a1;
      v15 = a3[k];
      *(_BYTE *)(v14 + 260) = v15;
    }
    i += 16;
    a3 += 16;
  }
  return memset_s((unsigned __int8 *)v17, 0x10u, 0, 0x10u);
}

//----- (0046DCCC) --------------------------------------------------------
int   psAesDecryptCBC(int a1, unsigned int *a2, int a3, unsigned int a4)
{
  unsigned int i; // $s4
  unsigned int j; // $t0
  unsigned __int8 *v10; // $a3
  char v11; // $a1
  unsigned __int8 v12; // $t1
  unsigned __int8 v13; // $a2
  _BYTE *v14; // $a0
  unsigned int k; // $a1
  unsigned int v16; // $t4
  unsigned __int8 v17; // $t5
  unsigned __int8 v19[16]; // [sp+18h] [-20h] BYREF
  unsigned __int8 v20[16]; // [sp+28h] [-10h] BYREF

  for ( i = 0; i < a4; a3 += 16 )
  {
    psAesDecryptBlock(a1, a2, v19);
    for ( j = 0; j < 0x10; ++j )
    {
      v10 = &v19[j];
      v11 = *(_BYTE *)(j + a1 + 260);
      v12 = v19[j];
      v13 = *((_BYTE *)a2 + j);
      v14 = (_BYTE *)(a3 + j);
      *v14 = v12 ^ v11;
      v10[16] = v13;
    }
    for ( k = 0; k < 0x10; ++k )
    {
      v16 = k + a1;
      v17 = v19[k + 16];
      *(_BYTE *)(v16 + 260) = v17;
    }
    i += 16;
    a2 += 4;
  }
  memset_s(v19, 0x10u, 0, 0x10u);
  return memset_s(v20, 0x10u, 0, 0x10u);
}

//----- (0046DDF8) --------------------------------------------------------
int   psAesInitGCM(int a1, unsigned int *a2, unsigned __int8 a3)
{
  int inited; // $v1
  unsigned int v8[4]; // [sp+18h] [-10h] BYREF

  memset(v8, 0, sizeof(v8));
  memset(a1, 0, 508);
  inited = psAesInitBlockKey(a1, a2, a3, 1);
  if ( inited >= 0 )
  {
    psAesEncryptBlock(a1, v8, (_BYTE *)(a1 + 308));
    return 0;
  }
  return inited;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (0046DEAC) --------------------------------------------------------
int   sub_46DEAC(int a1, unsigned int *a2, _DWORD *a3)
{
  unsigned int v3; // $t2
  unsigned int v5; // $t1
  unsigned int v6; // $a3
  unsigned int v7; // $t0
  int v9; // $a2
  int result; // $v0
  int v11; // $v1
  int v12; // $a0
  int v13; // $a3
  int v14; // $a0
  unsigned int v15; // $t9
  unsigned int v16; // $s1
  unsigned int v17; // $t5
  int v18; // $t8

  v3 = *a3 ^ _byteswap_ulong(*a2);
  *a3 = v3;
  v5 = a3[1] ^ _byteswap_ulong(a2[1]);
  a3[1] = v5;
  v6 = a3[2] ^ _byteswap_ulong(a2[2]);
  a3[2] = v6;
  v7 = a3[3] ^ _byteswap_ulong(a2[3]);
  v9 = 0;
  a3[3] = 0;
  a3[2] = 0;
  a3[1] = 0;
  *a3 = 0;
  do
  {
    v14 = 1 << (31 - v9);
    v15 = v3 >> 1;
    v16 = v6 >> 1;
    v17 = v6 << 31;
    v18 = v7 & 1;
    result = *(_DWORD *)(4 * (v9 / 32) + a1);
    ++v9;
    if ( (result & v14) != 0 )
    {
      v11 = a3[1];
      result = *a3 ^ v3;
      v12 = a3[2] ^ v6;
      v13 = a3[3] ^ v7;
      *a3 = result;
      a3[1] = v11 ^ v5;
      a3[2] = v12;
      a3[3] = v13;
    }
    v7 = (v7 >> 1) | v17;
    v6 = v16 | (v5 << 31);
    v5 = (v5 >> 1) | (v3 << 31);
    v3 >>= 1;
    if ( v18 )
      v3 = v15 ^ 0xE1000000;
  }
  while ( v9 < 128 );
  return result;
}

//----- (0046E090) --------------------------------------------------------
int   sub_46E090(int a1, _BYTE *a2, _BYTE *a3, unsigned int a4, char a5)
{
  int result; // $v0
  _BYTE *v6; // $s7
  unsigned int v7; // $s3
  _BYTE *v9; // $fp
  int v10; // $a0
  int v11; // $a2
  int v12; // $a3
  _BYTE *v13; // $s6
  unsigned int v14; // $s4
  unsigned int v15; // $s0
  unsigned int v16; // $a0
  unsigned int *v17; // $s0
  int i; // $s1
  int v19; // $a1
  int v20; // $t4
  char v21; // $t5
  int v22; // $ra
  unsigned int v23; // $s3
  _BYTE *v24; // $s5
  unsigned int v25; // $s0
  unsigned int v26; // $a0
  unsigned int *v27; // $s0
  int j; // $s1

  result = a5;
  v6 = a3;
  v7 = a4;
  v9 = a2;
  if ( a5 )
  {
LABEL_15:
    if ( v7 )
    {
      result = *(_DWORD *)(a1 + 376);
      do
      {
        while ( result )
        {
          --v7;
          *v6 = *v9++ ^ *(_BYTE *)(a1 + 304 - result + 4);
          result = *(_DWORD *)(a1 + 376) - 1;
          ++v6;
          *(_DWORD *)(a1 + 376) = result;
          if ( !v7 )
            goto LABEL_23;
        }
        *(_DWORD *)(a1 + 376) = 16;
        psAesEncryptBlock(a1, (unsigned int *)(a1 + 276), (_BYTE *)(a1 + 292));
        v19 = 15;
        do
        {
          v20 = v19 + a1;
          v21 = *(_BYTE *)(v19 + a1 + 276);
          --v19;
          *(_BYTE *)(v20 + 276) = v21 + 1;
        }
        while ( v21 == -1 && v19 >= 0 );
        --v7;
        *v6 = *v9++ ^ *(_BYTE *)(a1 + 304 - *(_DWORD *)(a1 + 376) + 4);
        result = *(_DWORD *)(a1 + 376) - 1;
        ++v6;
        *(_DWORD *)(a1 + 376) = result;
      }
      while ( v7 );
    }
  }
  else
  {
    v10 = a1 + 8;
    v11 = *(_DWORD *)(v10 + 356);
    v12 = 8 * (a4 & 0xFFFFFFF);
    *(_DWORD *)(v10 + 356) = v11 + v12;
    if ( v11 + v12 < v11 )
      ++*(_DWORD *)(v10 + 360);
    v13 = a2;
    v14 = v7;
    if ( v7 )
    {
      while ( 1 )
      {
        v16 = *(_DWORD *)(a1 + 372);
        if ( v16 == 128 )
          break;
        if ( v16 < 0x80 )
          goto LABEL_7;
LABEL_10:
        if ( !v14 )
          goto LABEL_15;
      }
      v17 = (unsigned int *)(a1 + 380);
      for ( i = 128; i >= 16; i -= 16 )
      {
        sub_46DEAC(a1 + 340, v17, (_DWORD *)(a1 + 324));
        v17 += 4;
      }
      v16 = 0;
      *(_DWORD *)(a1 + 372) = 0;
LABEL_7:
      v15 = 128 - v16;
      if ( v14 < 128 - v16 )
        v15 = v14;
      result = memcpy(v16 + a1 + 380, v13, v15);
      v13 += v15;
      *(_DWORD *)(a1 + 372) += v15;
      v14 -= v15;
      goto LABEL_10;
    }
  }
LABEL_23:
  if ( a5 == 1 )
  {
    v22 = *(_DWORD *)(a1 + 364);
    result = 8 * (a4 & 0xFFFFFFF);
    *(_DWORD *)(a1 + 364) = v22 + result;
    if ( v22 + result < v22 )
      ++*(_DWORD *)(a1 + 368);
    v23 = a4;
    v24 = a3;
    if ( a4 )
    {
      while ( 1 )
      {
        v26 = *(_DWORD *)(a1 + 372);
        if ( v26 == 128 )
          break;
        if ( v26 < 0x80 )
          goto LABEL_30;
LABEL_33:
        if ( !v23 )
          return result;
      }
      v27 = (unsigned int *)(a1 + 380);
      for ( j = 128; j >= 16; j -= 16 )
      {
        sub_46DEAC(a1 + 340, v27, (_DWORD *)(a1 + 324));
        v27 += 4;
      }
      v26 = 0;
      *(_DWORD *)(a1 + 372) = 0;
LABEL_30:
      v25 = 128 - v26;
      if ( v23 < 128 - v26 )
        v25 = v23;
      memcpy(v26 + a1 + 380, v24, v25);
      result = *(_DWORD *)(a1 + 372) + v25;
      v24 += v25;
      *(_DWORD *)(a1 + 372) = result;
      v23 -= v25;
      goto LABEL_33;
    }
  }
  return result;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0046E4C8) --------------------------------------------------------
int   psAesEncryptGCM(int a1, _BYTE *a2, _BYTE *a3, unsigned int a4)
{
  return sub_46E090(a1, a2, a3, a4, 1);
}

//----- (0046E508) --------------------------------------------------------
int   psAesReadyGCM(int a1, _DWORD *a2, int a3, unsigned __int16 a4)
{
  int v5; // $s7
  int v6; // $t6
  int v7; // $t5
  int v8; // $t2
  unsigned int v9; // $t3
  int v10; // $t4
  int v11; // $a3
  int v12; // $a0
  int result; // $v0
  unsigned int v14; // $s3
  unsigned int v16; // $v1
  unsigned int v17; // $s0
  unsigned int *v18; // $s0
  int i; // $s1
  _BYTE *v20; // $s5
  unsigned int v21; // $s3
  unsigned int v22; // $s0
  unsigned int *v23; // $s0
  int j; // $s1
  _BYTE v25[8]; // [sp+18h] [-8h] BYREF

  *(_DWORD *)(a1 + 356) = 0;
  *(_DWORD *)(a1 + 360) = 0;
  *(_DWORD *)(a1 + 364) = 0;
  *(_DWORD *)(a1 + 368) = 0;
  *(_DWORD *)(a1 + 372) = 0;
  *(_DWORD *)(a1 + 340) = _byteswap_ulong(*(_DWORD *)(a1 + 308));
  v5 = a1 + 340;
  *(_DWORD *)(a1 + 344) = _byteswap_ulong(*(_DWORD *)(a1 + 312));
  *(_DWORD *)(a1 + 348) = _byteswap_ulong(*(_DWORD *)(a1 + 316));
  *(_DWORD *)(a1 + 352) = _byteswap_ulong(*(_DWORD *)(a1 + 320));
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 332) = 0;
  *(_DWORD *)(a1 + 336) = 0;
  *(_DWORD *)(a1 + 260) = 0;
  *(_DWORD *)(a1 + 264) = 0;
  *(_DWORD *)(a1 + 268) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  v6 = a2[1];
  v7 = a2[2];
  *(_DWORD *)(a1 + 260) = *a2;
  *(_BYTE *)(a1 + 275) = 1;
  *(_DWORD *)(a1 + 276) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 284) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 264) = v6;
  *(_DWORD *)(a1 + 268) = v7;
  v8 = *(_DWORD *)(a1 + 356);
  v9 = a4;
  v10 = 8 * a4;
  v11 = a2[2];
  v12 = a2[1];
  result = 2;
  *(_DWORD *)(a1 + 276) = *a2;
  *(_DWORD *)(a1 + 280) = v12;
  *(_DWORD *)(a1 + 284) = v11;
  *(_BYTE *)(a1 + 291) = 2;
  *(_DWORD *)(a1 + 356) = v8 + v10;
  if ( v8 + v10 < v8 )
    ++*(_DWORD *)(a1 + 360);
  v14 = v9;
  if ( v9 )
  {
    v16 = *(_DWORD *)(a1 + 372);
    while ( v16 != 128 )
    {
      if ( v16 < 0x80 )
        goto LABEL_6;
LABEL_9:
      if ( !v14 )
        goto LABEL_15;
    }
    v18 = (unsigned int *)(a1 + 380);
    for ( i = 128; i >= 16; i -= 16 )
    {
      sub_46DEAC(v5, v18, (_DWORD *)(a1 + 324));
      v18 += 4;
    }
    v16 = 0;
    *(_DWORD *)(a1 + 372) = 0;
LABEL_6:
    v17 = 128 - v16;
    if ( v14 < 128 - v16 )
      v17 = v14;
    result = memcpy(v16 + a1 + 380, a3, v17);
    v16 = *(_DWORD *)(a1 + 372) + v17;
    a3 += v17;
    v14 -= v17;
    *(_DWORD *)(a1 + 372) = v16;
    goto LABEL_9;
  }
  v16 = *(_DWORD *)(a1 + 372);
LABEL_15:
  if ( (v16 & 0xF) == 0 )
    return result;
  v20 = v25;
  do
  {
    v21 = 1;
    v25[0] = 0;
    do
    {
      if ( v16 == 128 )
      {
        v23 = (unsigned int *)(a1 + 380);
        for ( j = 128; j >= 16; j -= 16 )
        {
          sub_46DEAC(v5, v23, (_DWORD *)(a1 + 324));
          v23 += 4;
        }
        v16 = 0;
        *(_DWORD *)(a1 + 372) = 0;
      }
      else if ( v16 >= 0x80 )
      {
        continue;
      }
      v22 = 128 - v16;
      if ( v21 < 128 - v16 )
        v22 = v21;
      result = memcpy(v16 + a1 + 380, v20, v22);
      v16 = *(_DWORD *)(a1 + 372) + v22;
      v20 += v22;
      v21 -= v22;
      *(_DWORD *)(a1 + 372) = v16;
    }
    while ( v21 );
    v20 = v25;
  }
  while ( (v16 & 0xF) != 0 );
  return result;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0046E8E8) --------------------------------------------------------
int   sub_46E8E8(_DWORD *a1)
{
  unsigned int v1; // $v1
  int v3; // $s4
  _DWORD *v4; // $s5
  char *v5; // $s6
  unsigned int v6; // $s3
  unsigned int v7; // $s0
  unsigned int *v8; // $s0
  int i; // $s1
  int v10; // $a3
  _DWORD *v11; // $a2
  unsigned __int64 v12; // kr00_8
  unsigned __int64 v13; // $s0
  int v14; // $s1
  unsigned int *j; // $s0
  int result; // $v0
  _DWORD *v17; // $a2
  int v18; // $a1
  unsigned __int64 v19; // kr08_8
  char v20; // [sp+18h] [-8h] BYREF
  unsigned int *v21; // [sp+1Ch] [-4h]

  v1 = a1[93];
  if ( (v1 & 0xF) != 0 )
  {
    v21 = a1 + 95;
    v3 = (int)(a1 + 85);
    v4 = a1 + 81;
    v5 = &v20;
    while ( 1 )
    {
      v6 = 1;
      v20 = 0;
      do
      {
        if ( v1 == 128 )
        {
          v8 = v21;
          for ( i = 128; i >= 16; i -= 16 )
          {
            sub_46DEAC((int)(a1 + 85), v8, a1 + 81);
            v8 += 4;
          }
          v1 = 0;
          a1[93] = 0;
        }
        else if ( v1 >= 0x80 )
        {
          continue;
        }
        v7 = 128 - v1;
        if ( v6 < 128 - v1 )
          v7 = v6;
        memcpy((char *)a1 + v1 + 380, v5, v7);
        v1 = a1[93] + v7;
        v5 += v7;
        v6 -= v7;
        a1[93] = v1;
      }
      while ( v6 );
      v5 = &v20;
      if ( (v1 & 0xF) == 0 )
        goto LABEL_16;
    }
  }
  v21 = a1 + 95;
  v3 = (int)(a1 + 85);
  v4 = a1 + 81;
LABEL_16:
  v10 = 2;
  v11 = a1 + 93;
  do
  {
    v11 -= 2;
    v12 = (unsigned __int64)(((*v11 & 0xFF00FF00) >> 8) | ((*v11 & 0xFF00FF) << 8)) << 16;
    v13 = (unsigned __int64)(((v11[1] & 0xFF00FF00) >> 8) | ((v11[1] & 0xFF00FF) << 8)) << 16;
    --v10;
    *v11 = v13 | HIDWORD(v13);
    v11[1] = v12 | HIDWORD(v12);
  }
  while ( v10 );
  v14 = a1[93];
  for ( j = v21; v14 >= 16; j += 4 )
  {
    v14 -= 16;
    sub_46DEAC(v3, j, v4);
  }
  a1[93] = 0;
  result = sub_46DEAC(v3, a1 + 89, v4);
  v17 = v4 + 4;
  v18 = 4;
  do
  {
    --v17;
    --v18;
    v19 = (unsigned __int64)(((*v17 & 0xFF00FF00) >> 8) | ((*v17 & 0xFF00FF) << 8)) << 16;
    *v17 = v19 | HIDWORD(v19);
  }
  while ( v18 );
  return result;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0046EB7C) --------------------------------------------------------
int   psAesGetGCMTag(int a1, unsigned __int8 a2, _BYTE *a3)
{
  int result; // $v0
  int v6; // $s2
  _BYTE *v7; // $s3
  _BYTE *i; // $s0

  v6 = a2;
  result = sub_46E8E8((_DWORD *)a1);
  v7 = a3;
  *(_DWORD *)(a1 + 376) = 0;
  for ( i = (_BYTE *)(a1 + 324); v6; ++v7 )
  {
    while ( 1 )
    {
      result = *(_DWORD *)(a1 + 376);
      if ( !result )
        break;
      *v7 = *i ^ *(_BYTE *)(a1 + 304 - result + 4);
      v6 = (unsigned __int8)(v6 - 1);
      ++i;
      --*(_DWORD *)(a1 + 376);
      ++v7;
      if ( !v6 )
        return result;
    }
    *(_DWORD *)(a1 + 376) = 16;
    psAesEncryptBlock(a1, (unsigned int *)(a1 + 260), (_BYTE *)(a1 + 292));
    result = *(_DWORD *)(a1 + 376);
    *v7 = *i ^ *(_BYTE *)(a1 + 304 - result + 4);
    v6 = (unsigned __int8)(v6 - 1);
    ++i;
    --*(_DWORD *)(a1 + 376);
  }
  return result;
}

//----- (0046ECA0) --------------------------------------------------------
int   psAesDecryptGCM(int a1, _BYTE *a2, unsigned int a3, _BYTE *a4, unsigned int a5)
{
  int v7; // $v1
  int v8; // $s5
  _BYTE *v9; // $s3
  int v10; // $s0
  _BYTE *v11; // $s2
  int v12; // $a3
  int v13; // $v0
  _BYTE v15[16]; // [sp+20h] [-10h] BYREF

  v7 = -6;
  if ( a5 < a3 )
  {
    v8 = (unsigned __int16)(a3 - a5);
    sub_46E090(a1, a2, a4, a5, 0);
    v9 = v15;
    sub_46E8E8((_DWORD *)a1);
    v10 = (unsigned __int8)v8;
    v11 = (_BYTE *)(a1 + 324);
    *(_DWORD *)(a1 + 376) = 0;
    while ( v10 )
    {
      v12 = *(_DWORD *)(a1 + 376);
      if ( !v12 )
      {
        *(_DWORD *)(a1 + 376) = 16;
        psAesEncryptBlock(a1, (unsigned int *)(a1 + 260), (_BYTE *)(a1 + 292));
        v12 = *(_DWORD *)(a1 + 376);
      }
      *v9 = *v11++ ^ *(_BYTE *)(a1 + 304 - v12 + 4);
      *(_DWORD *)(a1 + 376) = v12 - 1;
      ++v9;
      v10 = (unsigned __int8)(v10 - 1);
    }
    v13 = memcmpct((int)v15, (int)&a2[a5], v8);
    v7 = -41;
    if ( !v13 )
      return 0;
  }
  return v7;
}

//----- (0046EE00) --------------------------------------------------------
BOOL   sub_46EE00(_DWORD *a1)
{
  unsigned int i; // $a3
  int v3; // $t0
  _DWORD *v4; // $t3
  unsigned int v5; // $t9
  unsigned int v6; // $s0
  int v7; // $s1
  int v8; // $s2
  int v9; // $s3
  unsigned int v10; // $t3
  unsigned int v11; // $t1
  int v12; // $t2
  int v13; // $a2
  int v14; // $t4
  int *v15; // $a3
  int j; // $t0
  __int64 v17; // $v0
  _DWORD *v18; // $a1
  int v19; // $t0
  int v20; // $a3
  unsigned __int64 v21; // kr00_8
  int *v22; // $a1
  unsigned int v23; // $t0
  unsigned int v24; // $a0
  unsigned int v25; // $v1
  BOOL result; // $v0
  _DWORD *v27; // $t5
  unsigned int v28; // $a1
  unsigned int v29; // $v1
  _DWORD *v30; // $a1
  unsigned __int64 v31; // kr08_8
  _BYTE v32[64]; // [sp+8h] [-140h] BYREF
  int v33; // [sp+48h] [-100h] BYREF
  int v34; // [sp+58h] [-F0h] BYREF

  for ( i = 0; i < 0x10; ++i )
  {
    v3 = 4 * i;
    v4 = &a1[i];
    *(_DWORD *)&v32[v3] = _byteswap_ulong(v4[8]);
  }
  v5 = a1[2];
  v6 = a1[3];
  v7 = a1[4];
  v8 = a1[5];
  v9 = a1[6];
  v10 = v5;
  v11 = v6;
  v12 = v7;
  v13 = v8;
  v14 = v9;
  v15 = &v33;
  for ( j = 63; j >= 0; --j )
  {
    v17 = 2LL * (*(v15 - 3) ^ *(v15 - 8) ^ *(v15 - 14) ^ (unsigned int)*(v15 - 16));
    *v15++ = v17 | HIDWORD(v17);
  }
  v18 = v32;
  v19 = 19;
  do
  {
    v20 = ((32 * v10) | (v10 >> 27)) + ((v12 ^ v13) & v11 ^ v13) + v14 + *v18 + 1518500249;
    v21 = (unsigned __int64)v11 << 30;
    --v19;
    v14 = v13;
    v11 = v10;
    v13 = v12;
    ++v18;
    v12 = v21 | HIDWORD(v21);
    v10 = v20;
  }
  while ( v19 >= 0 );
  v22 = &v34;
  v23 = 20;
  do
  {
    ++v23;
    v24 = v11 >> 2;
    v20 = ((32 * v20) | ((unsigned __int64)(unsigned int)v20 >> 27)) + (v11 ^ v12 ^ v13) + v14 + *v22 + 1859775393;
    v25 = v11 << 30;
    result = v23 < 0x28;
    v14 = v13;
    v11 = v10;
    v13 = v12;
    ++v22;
    v12 = v25 | v24;
    v10 = v20;
  }
  while ( v23 < 0x28 );
  if ( v23 < 0x3C )
  {
    v27 = &v32[4 * v23];
    do
    {
      ++v23;
      v28 = v11 >> 2;
      v20 = ((32 * v20) | ((unsigned __int64)(unsigned int)v20 >> 27))
          + (v11 & v12 | (v11 | v12) & v13)
          + v14
          + *v27
          - 1894007588;
      v29 = v11 << 30;
      result = v23 < 0x3C;
      v14 = v13;
      v11 = v10;
      v13 = v12;
      ++v27;
      v12 = v29 | v28;
      v10 = v20;
    }
    while ( v23 < 0x3C );
  }
  if ( v23 < 0x50 )
  {
    v30 = &v32[4 * v23];
    do
    {
      ++v23;
      v20 = ((32 * v20) | ((unsigned __int64)(unsigned int)v20 >> 27)) + (v11 ^ v12 ^ v13) + v14 + *v30 - 899497514;
      v31 = (unsigned __int64)v11 << 30;
      result = v23 < 0x50;
      v14 = v13;
      v11 = v10;
      v13 = v12;
      ++v30;
      v12 = v31 | HIDWORD(v31);
      v10 = v20;
    }
    while ( v23 < 0x50 );
  }
  a1[6] = v9 + v14;
  a1[2] = v5 + v20;
  a1[3] = v6 + v11;
  a1[4] = v7 + v12;
  a1[5] = v8 + v13;
  return result;
}

//----- (0046F0B8) --------------------------------------------------------
int   psSha1Init(_DWORD *a1)
{
  int result; // $v0

  *a1 = 0;
  result = 0;
  a1[2] = 1732584193;
  a1[3] = -271733879;
  a1[4] = -1732584194;
  a1[5] = 271733878;
  a1[6] = -1009589776;
  a1[1] = 0;
  a1[7] = 0;
  return result;
}

//----- (0046F110) --------------------------------------------------------
int   psSha1Update(int *a1, int a2, unsigned int a3)
{
  unsigned int i; // $s1
  int v6; // $a2
  unsigned int v7; // $s0
  int result; // $v0
  unsigned int v9; // $a1
  int v10; // $t1
  int v11; // $t0

  for ( i = a3; i; a1[1] = v11 )
  {
    while ( 1 )
    {
      v6 = a1[7];
      v7 = 64 - v6;
      if ( i < 64 - v6 )
        v7 = i;
      result = memcpy((char *)a1 + v6 + 32, a2, v7);
      i -= v7;
      v9 = a1[7] + v7;
      a2 += v7;
      a1[7] = v9;
      if ( v9 == 64 )
        break;
      if ( !i )
        return result;
    }
    sub_46EE00(a1);
    result = psBurnStack(0x15Cu);
    v10 = *a1 + 512;
    v11 = a1[1] + ((unsigned int)*a1 >= 0xFFFFFE00);
    a1[7] = 0;
    *a1 = v10;
  }
  return result;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0046F224) --------------------------------------------------------
int   psSha1Final(__int64 *a1, int a2)
{
  int v2; // $a3
  __int64 v3; // $t8
  unsigned int v6; // $v0
  unsigned int v7; // $a0
  unsigned int v8; // $a0
  unsigned int v9; // $t4
  unsigned int v10; // $a1
  char v11; // $ra
  int v12; // $a3
  int v13; // $t7
  _BYTE *v14; // $t5

  v2 = *((_DWORD *)a1 + 7);
  v3 = *a1 + (unsigned int)(8 * v2);
  *((_BYTE *)a1 + v2 + 32) = 0x80;
  *a1 = v3;
  *((_DWORD *)a1 + 7) = v2 + 1;
  if ( (unsigned int)(v2 + 1) >= 0x39 )
  {
    v6 = v2 + 1;
    if ( (unsigned int)(v2 + 1) < 0x40 )
    {
      do
      {
        v7 = v6 + 1;
        *((_BYTE *)a1 + v6 + 32) = 0;
        ++v6;
      }
      while ( v6 < 0x40 );
      *((_DWORD *)a1 + 7) = v7;
    }
    sub_46EE00(a1);
    psBurnStack(0x15Cu);
    v3 = *a1;
    *((_DWORD *)a1 + 7) = 0;
  }
  v8 = *((_DWORD *)a1 + 7);
  v9 = (unsigned int)v3 >> 8;
  if ( v8 < 0x38 )
  {
    do
    {
      v10 = v8 + 1;
      *((_BYTE *)a1 + v8 + 32) = 0;
      ++v8;
    }
    while ( v8 < 0x38 );
    *((_DWORD *)a1 + 7) = v10;
    v9 = (unsigned int)v3 >> 8;
  }
  v11 = *(_BYTE *)a1;
  *((_BYTE *)a1 + 92) = BYTE3(v3);
  *((_BYTE *)a1 + 88) = HIBYTE(v3);
  *((_BYTE *)a1 + 89) = BYTE6(v3);
  *((_BYTE *)a1 + 90) = BYTE5(v3);
  *((_BYTE *)a1 + 91) = BYTE4(v3);
  *((_BYTE *)a1 + 93) = BYTE2(v3);
  *((_BYTE *)a1 + 94) = v9;
  *((_BYTE *)a1 + 95) = v11;
  sub_46EE00(a1);
  psBurnStack(0x15Cu);
  v12 = 0;
  do
  {
    v13 = (int)a1 + 4 * v12;
    v14 = (_BYTE *)(4 * v12 + a2);
    *v14 = *(_BYTE *)(v13 + 11);
    ++v12;
    v14[1] = *(_WORD *)(v13 + 10);
    v14[2] = BYTE1(*(_DWORD *)(v13 + 8));
    v14[3] = *(_DWORD *)(v13 + 8);
  }
  while ( v12 < 5 );
  return memset(a1, 0, 96);
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (0046F42C) --------------------------------------------------------
int   sub_46F42C(int a1, int a2)
{
  int i; // $a1
  int v5; // $a2
  int v6; // $a0
  int j; // $a3
  int v8; // $t3
  unsigned int *v9; // $s0
  int *v10; // $t2
  int k; // $t3
  unsigned int v12; // $a0
  unsigned int v13; // $t7
  unsigned int v14; // $t4
  int v15; // $t2
  unsigned int v16; // $t8
  unsigned int v17; // $t5
  unsigned int v18; // $t3
  unsigned int v19; // $t6
  unsigned int v20; // $t7
  unsigned int v21; // $s0
  int v22; // $t9
  int result; // $v0
  int v24; // $t0
  unsigned int v25; // $v1
  int m; // $a2
  int v27; // $t7
  int v28; // $t8
  unsigned int v29; // [sp+8h] [-120h] BYREF
  unsigned int v30; // [sp+Ch] [-11Ch]
  unsigned int v31; // [sp+10h] [-118h]
  unsigned int v32; // [sp+14h] [-114h]
  unsigned int v33; // [sp+18h] [-110h]
  unsigned int v34; // [sp+1Ch] [-10Ch]
  unsigned int v35; // [sp+20h] [-108h]
  int v36; // [sp+24h] [-104h]
  int v37; // [sp+48h] [-E0h] BYREF

  for ( i = 0; i < 8; ++i )
  {
    v5 = 4 * i;
    v6 = *(_DWORD *)(4 * i + a1 + 8);
    *(unsigned int *)((char *)&v29 + v5) = v6;
  }
  for ( j = 0; j < 16; ++j )
  {
    v8 = 4 * j;
    v9 = (unsigned int *)(4 * j + a2);
    *(unsigned int *)((char *)&v29 + v8 + 32) = _byteswap_ulong(*v9);
  }
  v10 = &v37;
  for ( k = 47; k >= 0; --k )
  {
    v12 = v10[6];
    v13 = *(v10 - 7);
    v10[8] = (((v12 << 15) | (v12 >> 17)) ^ ((v12 << 13) | (v12 >> 19)) ^ (v12 >> 10))
           + v10[1]
           + (((v13 << 25) | (v13 >> 7)) ^ ((v13 << 14) | (v13 >> 18)) ^ (v13 >> 3))
           + *(v10 - 8);
    ++v10;
  }
  v14 = v33;
  v15 = v36;
  v16 = v34;
  v17 = v35;
  v18 = v29;
  v19 = v30;
  v20 = v31;
  v21 = v32;
  v22 = 0;
  do
  {
    result = v15
           + (((v14 << 26) | (v14 >> 6)) ^ ((v14 << 21) | (v14 >> 11)) ^ ((v14 << 7) | (v14 >> 25)))
           + (v17 ^ v14 & (v16 ^ v17))
           + dword_49F330[v22];
    v24 = result + *(&v29 + v22++ + 8);
    v25 = v24
        + (((v18 << 30) | (v18 >> 2)) ^ ((v18 << 19) | (v18 >> 13)) ^ ((v18 << 10) | ((unsigned __int64)v18 >> 22)))
        + ((v18 | v19) & v20 | v18 & v19);
    v15 = v17;
    v17 = v16;
    v16 = v14;
    v14 = v21 + v24;
    v21 = v20;
    v20 = v19;
    v19 = v18;
    v18 = v25;
  }
  while ( v22 < 64 );
  v32 = v21;
  v36 = v15;
  v35 = v17;
  v34 = v16;
  v33 = v14;
  v31 = v20;
  v30 = v19;
  v29 = v25;
  for ( m = 0; m < 8; ++m )
  {
    v27 = 4 * m + a1;
    v28 = *(&v29 + m);
    *(_DWORD *)(v27 + 8) += v28;
  }
  return result;
}
// 49F330: using guessed type _DWORD dword_49F330[64];

//----- (0046F69C) --------------------------------------------------------
int   psSha256Init(_DWORD *a1)
{
  int result; // $v0

  a1[2] = 1779033703;
  *a1 = 0;
  result = 0;
  a1[3] = -1150833019;
  a1[4] = 1013904242;
  a1[5] = -1521486534;
  a1[6] = 1359893119;
  a1[7] = -1694144372;
  a1[8] = 528734635;
  a1[9] = 1541459225;
  a1[1] = 0;
  a1[10] = 0;
  return result;
}

//----- (0046F718) --------------------------------------------------------
int   psSha256Update(int *a1, int a2, unsigned int a3)
{
  unsigned int v3; // $s1
  unsigned int v6; // $s0
  int result; // $v0
  unsigned int v8; // $t0
  int v9; // $a3
  int v10; // $v1
  int v11; // $v1

  v3 = a3;
  while ( v3 )
  {
    while ( 1 )
    {
      v9 = a1[10];
      v6 = 64 - v9;
      if ( v9 || v3 < 0x40 )
        break;
      sub_46F42C((int)a1, a2);
      a2 += 64;
      psBurnStack(0x128u);
      result = *a1 + 512;
      v10 = a1[1] + ((unsigned int)*a1 >= 0xFFFFFE00);
      v3 -= 64;
      *a1 = result;
      a1[1] = v10;
LABEL_10:
      if ( !v3 )
        return result;
    }
    if ( v3 < 64 - v9 )
      v6 = v3;
    result = memcpy((char *)a1 + v9 + 44, a2, v6);
    v3 -= v6;
    v8 = a1[10] + v6;
    a2 += v6;
    a1[10] = v8;
    if ( v8 == 64 )
    {
      sub_46F42C((int)a1, (int)(a1 + 11));
      psBurnStack(0x128u);
      result = *a1 + 512;
      v11 = a1[1] + ((unsigned int)*a1 >= 0xFFFFFE00);
      a1[10] = 0;
      *a1 = result;
      a1[1] = v11;
      goto LABEL_10;
    }
  }
  return result;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0046F894) --------------------------------------------------------
int   psSha256Final(int a1, int a2)
{
  int v2; // $a3
  __int64 v3; // $t8
  unsigned int v6; // $v0
  unsigned int v7; // $a0
  int v8; // $s4
  unsigned int v9; // $a0
  unsigned int v10; // $t4
  unsigned int v11; // $a1
  char v12; // $ra
  int v13; // $a3
  int v14; // $t6
  _BYTE *v15; // $s6

  v2 = *(_DWORD *)(a1 + 40);
  v3 = *(_QWORD *)a1 + (unsigned int)(8 * v2);
  *(_BYTE *)(v2 + a1 + 44) = 0x80;
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 40) = v2 + 1;
  if ( (unsigned int)(v2 + 1) < 0x39 )
  {
    v8 = a1 + 44;
  }
  else
  {
    v6 = v2 + 1;
    if ( (unsigned int)(v2 + 1) < 0x40 )
    {
      do
      {
        v7 = v6 + 1;
        *(_BYTE *)(v6 + a1 + 44) = 0;
        ++v6;
      }
      while ( v6 < 0x40 );
      *(_DWORD *)(a1 + 40) = v7;
    }
    v8 = a1 + 44;
    sub_46F42C(a1, a1 + 44);
    psBurnStack(0x128u);
    v3 = *(_QWORD *)a1;
    *(_DWORD *)(a1 + 40) = 0;
  }
  v9 = *(_DWORD *)(a1 + 40);
  v10 = (unsigned int)v3 >> 8;
  if ( v9 < 0x38 )
  {
    do
    {
      v11 = v9 + 1;
      *(_BYTE *)(v9 + a1 + 44) = 0;
      ++v9;
    }
    while ( v9 < 0x38 );
    *(_DWORD *)(a1 + 40) = v11;
    v10 = (unsigned int)v3 >> 8;
  }
  v12 = *(_BYTE *)a1;
  *(_BYTE *)(a1 + 104) = BYTE3(v3);
  *(_BYTE *)(a1 + 100) = HIBYTE(v3);
  *(_BYTE *)(a1 + 101) = BYTE6(v3);
  *(_BYTE *)(a1 + 102) = BYTE5(v3);
  *(_BYTE *)(a1 + 103) = BYTE4(v3);
  *(_BYTE *)(a1 + 105) = BYTE2(v3);
  *(_BYTE *)(a1 + 106) = v10;
  *(_BYTE *)(a1 + 107) = v12;
  sub_46F42C(a1, v8);
  psBurnStack(0x128u);
  v13 = 0;
  do
  {
    v14 = 4 * v13 + a1;
    v15 = (_BYTE *)(4 * v13 + a2);
    *v15 = *(_BYTE *)(v14 + 11);
    ++v13;
    v15[1] = *(_WORD *)(v14 + 10);
    v15[2] = BYTE1(*(_DWORD *)(v14 + 8));
    v15[3] = *(_DWORD *)(v14 + 8);
  }
  while ( v13 < 8 );
  return memset(a1, 0, 112);
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (0046FAB4) --------------------------------------------------------
int   sub_46FAB4(int a1, int a2)
{
  int v3; // $a2
  int v4; // $t0
  int v5; // $t1
  int v6; // $a1
  _DWORD *v7; // $v1
  int v8; // $t4
  int v9; // $s0
  unsigned int *v10; // $t9
  char *v11; // $t3
  unsigned int v12; // $t6
  __int64 *v13; // $s2
  int i; // $s3
  unsigned int v15; // $fp
  unsigned int v16; // $t5
  unsigned int v17; // $t6
  int v18; // $a3
  __int64 v19; // $s6
  __int64 v20; // $t8
  int v21; // $fp
  int v22; // $t4
  unsigned int *v23; // $s0
  unsigned int v24; // $s3
  unsigned int v25; // $s5
  BOOL v26; // $t2
  __int64 *v27; // $s0
  int v28; // $v0
  unsigned int v29; // $t4
  int v30; // $t3
  int v31; // $a1
  unsigned __int64 v32; // $a0
  int v33; // $s5
  __int64 v34; // kr08_8
  int v35; // $s0
  int result; // $v0
  int j; // $t1
  int v38; // $a0
  __int64 *v39; // $s3
  __int64 v40; // [sp+8h] [-2F0h] BYREF
  __int64 v41; // [sp+10h] [-2E8h]
  __int64 v42; // [sp+18h] [-2E0h]
  __int64 v43; // [sp+20h] [-2D8h]
  __int64 v44; // [sp+28h] [-2D0h]
  __int64 v45; // [sp+30h] [-2C8h]
  __int64 v46; // [sp+38h] [-2C0h]
  __int64 v47; // [sp+40h] [-2B8h]
  int v48; // [sp+88h] [-270h] BYREF
  __int64 v49; // [sp+2C8h] [-30h]
  __int64 v50; // [sp+2D0h] [-28h]
  __int64 v51; // [sp+2D8h] [-20h]
  __int64 v52; // [sp+2E0h] [-18h]
  __int64 v53; // [sp+2E8h] [-10h]
  __int64 v54; // [sp+2F0h] [-8h]

  v3 = 0;
  do
  {
    v4 = 8 * v3;
    v5 = 8 * v3 + a1;
    v6 = *(_DWORD *)(v5 + 12);
    ++v3;
    v7 = (_DWORD *)((char *)&v40 + v4);
    *v7 = *(_DWORD *)(v5 + 8);
    v7[1] = v6;
  }
  while ( v3 < 8 );
  v8 = 0;
  do
  {
    v9 = 8 * v8;
    v10 = (unsigned int *)(8 * v8++ + a2);
    v11 = (char *)&v40 + v9;
    v12 = _byteswap_ulong(*v10);
    *((_DWORD *)v11 + 16) = _byteswap_ulong(v10[1]);
    *((_DWORD *)v11 + 17) = v12;
  }
  while ( v8 < 16 );
  v13 = (__int64 *)&v48;
  for ( i = 63; i >= 0; --i )
  {
    v15 = *((_DWORD *)v13 + 13);
    v16 = *((_DWORD *)v13 - 13);
    v17 = (v13[6] >> 19) ^ ((v15 >> 29) | (8 * *((_DWORD *)v13 + 12))) ^ (v13[6] >> 6);
    v18 = (*(v13 - 7) >> 1) ^ (*(v13 - 7) >> 8) ^ (*(v13 - 7) >> 7);
    v13[8] = __PAIR64__(
               ((__PAIR64__(((*((_DWORD *)v13 + 12) << 13) | (v15 >> 19)) ^ (v13[6] >> 29) ^ (v15 >> 6), v17) + v13[1]) >> 32)
             + (((*((_DWORD *)v13 - 14) << 31) | (v16 >> 1)) ^ ((*((_DWORD *)v13 - 14) << 24) | (v16 >> 8)) ^ (v16 >> 7))
             + __CFADD__(v17 + *((_DWORD *)v13 + 2), v18),
               v17 + *((_DWORD *)v13 + 2) + v18)
           + *(v13 - 8);
    ++v13;
  }
  v19 = v44;
  v20 = v40;
  v54 = v42;
  v52 = v47;
  v50 = v45;
  v51 = v46;
  v53 = v41;
  v49 = v43;
  v21 = 0;
  do
  {
    v22 = v51 ^ v19 & (v50 ^ v51);
    v23 = (unsigned int *)((char *)&unk_49F430 + 8 * v21);
    v24 = *v23;
    v25 = v23[1];
    v26 = __CFADD__(v52 + ((v19 >> 14) ^ (v19 >> 18) ^ ((HIDWORD(v19) >> 9) | ((_DWORD)v19 << 23))), v22);
    v27 = &v40 + v21;
    v28 = (v20 | v53) & v54 | v20 & v53;
    v29 = v52 + ((v19 >> 14) ^ (v19 >> 18) ^ ((HIDWORD(v19) >> 9) | ((_DWORD)v19 << 23))) + v22 + v24;
    v30 = *((_DWORD *)v27 + 16);
    v31 = ((v52
          + __PAIR64__(
              (((_DWORD)v19 << 18) | (HIDWORD(v19) >> 14))
            ^ (((_DWORD)v19 << 14) | (HIDWORD(v19) >> 18))
            ^ (unsigned int)((unsigned __int64)v19 >> 9),
              (v19 >> 14) ^ (v19 >> 18) ^ ((HIDWORD(v19) >> 9) | ((_DWORD)v19 << 23)))) >> 32)
        + (HIDWORD(v51) ^ HIDWORD(v19) & (HIDWORD(v50) ^ HIDWORD(v51)))
        + v26
        + v25;
    v33 = ((v20 >> 28)
         ^ ((HIDWORD(v20) >> 2) | ((_DWORD)v20 << 30))
         ^ (((unsigned __int64)HIDWORD(v20) >> 7) | ((_DWORD)v20 << 25)))
        + v28;
    v32 = __PAIR64__(v31 + (unsigned int)(v29 < v24), v29) + v27[8];
    v35 = HIDWORD(v32)
        + (((16 * v20) | (HIDWORD(v20) >> 28)) ^ ((unsigned __int64)v20 >> 2) ^ ((unsigned __int64)v20 >> 7))
        + ((HIDWORD(v20) | HIDWORD(v53)) & HIDWORD(v54) | HIDWORD(v20) & HIDWORD(v53))
        + __CFADD__(
            (v20 >> 28)
          ^ ((HIDWORD(v20) >> 2) | ((_DWORD)v20 << 30))
          ^ (((unsigned __int64)HIDWORD(v20) >> 7) | ((_DWORD)v20 << 25)),
            v28)
        + __CFADD__(v29 + v30, v33);
    ++v21;
    v34 = v49 + v32;
    v52 = v51;
    v49 = v54;
    v51 = v50;
    v54 = v53;
    v50 = v19;
    v53 = v20;
    v19 = v34;
    LODWORD(v20) = v29 + v30 + v33;
    HIDWORD(v20) = v35;
  }
  while ( v21 < 80 );
  result = v51;
  v47 = v52;
  v46 = v51;
  v45 = v50;
  v44 = v34;
  v43 = v49;
  v42 = v54;
  v41 = v53;
  LODWORD(v40) = v29 + v30 + v33;
  HIDWORD(v40) = v35;
  for ( j = 0; j < 8; ++j )
  {
    v38 = 8 * j + a1;
    v39 = &v40 + j;
    *(_QWORD *)(v38 + 8) += *v39;
  }
  return result;
}

//----- (004700A4) --------------------------------------------------------
int   psSha512Init(_DWORD *a1)
{
  int result; // $v0

  a1[16] = 327033209;
  a1[17] = 1541459225;
  a1[2] = -205731576;
  a1[4] = -2067093701;
  a1[7] = 1013904242;
  a1[8] = 1595750129;
  a1[3] = 1779033703;
  a1[5] = -1150833019;
  a1[6] = -23791573;
  *a1 = 0;
  result = 0;
  a1[9] = -1521486534;
  a1[10] = -1377402159;
  a1[11] = 1359893119;
  a1[12] = 725511199;
  a1[13] = -1694144372;
  a1[14] = -79577749;
  a1[15] = 528734635;
  a1[18] = 0;
  a1[1] = 0;
  return result;
}

//----- (00470180) --------------------------------------------------------
int   psSha512Update(int *a1, int a2, unsigned int a3)
{
  unsigned int v6; // $s0
  unsigned int v7; // $t8
  int v8; // $t3
  int v9; // $v1
  int v10; // $v1
  int result; // $v0

  if ( !a1 )
  {
    psTraceStr("psAssert %s", (int)"digest/sha512.c");
    psTraceInt(":%d ", 209);
    result = psError((int)"sha512 != NULL");
  }
  if ( !a2 )
  {
    psTraceStr("psAssert %s", (int)"digest/sha512.c");
    psTraceInt(":%d ", 210);
    result = psError((int)"buf != NULL");
  }
  while ( a3 )
  {
    while ( 1 )
    {
      v8 = a1[18];
      v6 = 128 - v8;
      if ( v8 || a3 < 0x80 )
        break;
      sub_46FAB4((int)a1, a2);
      a2 += 128;
      psBurnStack(0x2D4u);
      result = *a1 + 1024;
      v9 = a1[1] + ((unsigned int)*a1 >= 0xFFFFFC00);
      a3 -= 128;
      *a1 = result;
      a1[1] = v9;
LABEL_14:
      if ( !a3 )
        return result;
    }
    if ( a3 < 128 - v8 )
      v6 = a3;
    result = memcpy((char *)a1 + v8 + 76, a2, v6);
    a3 -= v6;
    v7 = a1[18] + v6;
    a2 += v6;
    a1[18] = v7;
    if ( v7 == 128 )
    {
      sub_46FAB4((int)a1, (int)(a1 + 19));
      psBurnStack(0x2D4u);
      result = *a1 + 1024;
      v10 = a1[1] + ((unsigned int)*a1 >= 0xFFFFFC00);
      a1[18] = 0;
      *a1 = result;
      a1[1] = v10;
      goto LABEL_14;
    }
  }
  return result;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (004703C4) --------------------------------------------------------
int   psSha512Final(int a1, int a2)
{
  unsigned int v2; // $t2
  unsigned __int64 v3; // $t8
  unsigned int v6; // $v0
  unsigned int v7; // $a1
  int v8; // $s4
  unsigned int v9; // $a0
  unsigned int v10; // $t6
  unsigned int v11; // $a1
  char v12; // $t1
  int v13; // $t3
  int v14; // $s1
  _BYTE *v15; // $s6

  v2 = *(_DWORD *)(a1 + 72);
  v3 = *(_QWORD *)a1 + __PAIR64__(v2 >> 29, 8 * v2);
  *(_BYTE *)(v2 + a1 + 76) = 0x80;
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 72) = v2 + 1;
  if ( v2 + 1 < 0x71 )
  {
    v8 = a1 + 76;
  }
  else
  {
    v6 = v2 + 1;
    if ( v2 + 1 < 0x80 )
    {
      do
      {
        v7 = v6 + 1;
        *(_BYTE *)(v6 + a1 + 76) = 0;
        ++v6;
      }
      while ( v6 < 0x80 );
      *(_DWORD *)(a1 + 72) = v7;
    }
    v8 = a1 + 76;
    sub_46FAB4(a1, a1 + 76);
    psBurnStack(0x2D4u);
    v3 = *(_QWORD *)a1;
    *(_DWORD *)(a1 + 72) = 0;
  }
  v9 = *(_DWORD *)(a1 + 72);
  v10 = (unsigned int)v3 >> 8;
  if ( v9 < 0x78 )
  {
    do
    {
      v11 = v9 + 1;
      *(_BYTE *)(v9 + a1 + 76) = 0;
      ++v9;
    }
    while ( v9 < 0x78 );
    *(_DWORD *)(a1 + 72) = v11;
    v10 = (unsigned int)v3 >> 8;
  }
  v12 = *(_BYTE *)a1;
  *(_BYTE *)(a1 + 202) = v10;
  *(_BYTE *)(a1 + 196) = HIBYTE(v3);
  *(_BYTE *)(a1 + 197) = BYTE6(v3);
  *(_BYTE *)(a1 + 198) = BYTE5(v3);
  *(_BYTE *)(a1 + 199) = BYTE4(v3);
  *(_BYTE *)(a1 + 200) = BYTE3(v3);
  *(_BYTE *)(a1 + 201) = BYTE2(v3);
  *(_BYTE *)(a1 + 203) = v12;
  sub_46FAB4(a1, v8);
  psBurnStack(0x2D4u);
  v13 = 0;
  do
  {
    v14 = 8 * v13 + a1;
    v15 = (_BYTE *)(8 * v13 + a2);
    *v15 = HIBYTE(*(_DWORD *)(v14 + 12));
    ++v13;
    v15[1] = BYTE2(*(_DWORD *)(v14 + 12));
    v15[2] = BYTE1(*(_DWORD *)(v14 + 12));
    v15[3] = *(_DWORD *)(v14 + 12);
    v15[4] = HIBYTE(*(_DWORD *)(v14 + 8));
    v15[5] = BYTE2(*(_DWORD *)(v14 + 8));
    v15[6] = BYTE1(*(_QWORD *)(v14 + 8));
    v15[7] = *(_BYTE *)(v14 + 8);
  }
  while ( v13 < 8 );
  return psBurnStack(0xD0u);
}

//----- (0047064C) --------------------------------------------------------
int   psSha384Init(_DWORD *a1)
{
  int result; // $v0

  a1[16] = -1090891868;
  a1[17] = 1203062813;
  a1[2] = -1056596264;
  a1[4] = 914150663;
  a1[7] = -1856437926;
  a1[8] = -150054599;
  a1[3] = -876896931;
  a1[5] = 1654270250;
  a1[6] = 812702999;
  *a1 = 0;
  result = 0;
  a1[9] = 355462360;
  a1[10] = -4191439;
  a1[11] = 1731405415;
  a1[12] = 1750603025;
  a1[13] = -1900787065;
  a1[14] = 1694076839;
  a1[15] = -619958771;
  a1[18] = 0;
  a1[1] = 0;
  return result;
}

//----- (00470728) --------------------------------------------------------
int   psSha384Update(int *a1, int a2, unsigned int a3)
{
  return psSha512Update(a1, a2, a3);
}

//----- (00470744) --------------------------------------------------------
int   psSha384Final(int a1, _DWORD *a2)
{
  char *v3; // $a0
  int v4; // $a2
  int v5; // $v0
  int v6; // $v1
  _BYTE v8[48]; // [sp+18h] [-40h] BYREF
  char v9; // [sp+48h] [-10h] BYREF

  psSha512Final(a1, (int)v8);
  v3 = v8;
  do
  {
    v4 = *((_DWORD *)v3 + 1);
    *a2 = *(_DWORD *)v3;
    a2[1] = v4;
    v5 = *((_DWORD *)v3 + 2);
    a2[1] = v4;
    a2[2] = v5;
    v6 = *((_DWORD *)v3 + 3);
    a2[2] = v5;
    a2[3] = v6;
    v3 += 16;
    a2[3] = v6;
    a2 += 4;
  }
  while ( v3 != &v9 );
  return psBurnStack(0x40u);
}

//----- (004707DC) --------------------------------------------------------
int   psMd5Sha1Init(__int64 *a1)
{
  int v2; // $v1
  int v3; // $s0

  v2 = psMd5Init(a1);
  if ( v2 >= 0 )
  {
    v3 = psSha1Init((_DWORD *)a1 + 24);
    v2 = 0;
    if ( v3 < 0 )
    {
      psMd5Final(a1, 0);
      return v3;
    }
  }
  return v2;
}

//----- (00470870) --------------------------------------------------------
int   psMd5Sha1Update(int *a1, int a2, unsigned int a3)
{
  psMd5Update(a1, a2, a3);
  return psSha1Update(a1 + 24, a2, a3);
}

//----- (004708D4) --------------------------------------------------------
int   psMd5Sha1Final(__int64 *a1, int a2)
{
  psMd5Final(a1, a2);
  return psSha1Final(a1 + 12, a2 + 16);
}

//----- (00470928) --------------------------------------------------------
int   psMd5Init(_DWORD *a1)
{
  int result; // $v0

  *a1 = 0;
  result = 0;
  a1[2] = 1732584193;
  a1[3] = -271733879;
  a1[4] = -1732584194;
  a1[5] = 271733878;
  a1[1] = 0;
  a1[6] = 0;
  return result;
}

//----- (00470974) --------------------------------------------------------
int   sub_470974(_DWORD *a1)
{
  unsigned int i; // $a1
  int v2; // $a2
  _DWORD *v3; // $a3
  int v4; // $s1
  int v5; // $s2
  int v6; // $s3
  _DWORD *v7; // $t5
  int v8; // $t4
  int v9; // $a3
  int v10; // $t1
  int v11; // $t0
  unsigned int v12; // $t3
  char v13; // $a1
  int v14; // $v0
  int v15; // $t2
  _DWORD *v16; // $t4
  unsigned int v17; // $t3
  int v18; // $v0
  char v19; // $t2
  int result; // $v0
  int v21; // $a1
  _DWORD *v22; // $t4
  char v23; // $a1
  int v24; // $a2
  _DWORD *v25; // $t4
  char v26; // $t9
  _DWORD v27[16]; // [sp+8h] [-40h] BYREF

  for ( i = 0; i < 0x10; ++i )
  {
    v2 = i;
    v3 = &a1[i];
    v27[v2] = v3[7];
  }
  v4 = a1[2];
  v5 = a1[3];
  v6 = a1[4];
  v7 = &unk_49F710;
  v8 = v4;
  v9 = v5;
  v10 = v6;
  v11 = a1[5];
  v12 = 0;
  do
  {
    v13 = byte_49F6D0[v12];
    v14 = ((v10 ^ v11) & v9 ^ v11) + v8 + v27[byte_49F820[v12++]] + *v7;
    v15 = v11;
    ++v7;
    v11 = v10;
    v10 = v9;
    v9 += __ROL4__(v14, v13 & 0x1F);
    v8 = v15;
  }
  while ( v12 < 0x10 );
  v16 = &unk_49F750;
  v17 = 16;
  do
  {
    v18 = ((v10 ^ v9) & v11 ^ v10) + v15;
    v19 = byte_49F6D0[v17] & 0x1F;
    result = v18 + v27[byte_49F820[v17++]] + *v16;
    v21 = __ROL4__(result, v19);
    v15 = v11;
    ++v16;
    v11 = v10;
    v10 = v9;
    v9 += v21;
  }
  while ( v17 < 0x20 );
  if ( v17 < 0x30 )
  {
    v22 = (_DWORD *)((char *)&unk_49F710 + 4 * v17);
    do
    {
      v23 = byte_49F6D0[v17] & 0x1F;
      v24 = (v9 ^ v10 ^ v11) + v15 + v27[byte_49F820[v17++]] + *v22;
      result = __ROL4__(v24, v23);
      v15 = v11;
      ++v22;
      v11 = v10;
      v10 = v9;
      v9 += result;
    }
    while ( v17 < 0x30 );
  }
  if ( v17 < 0x40 )
  {
    v25 = (_DWORD *)((char *)&unk_49F710 + 4 * v17);
    do
    {
      v26 = byte_49F6D0[v17] & 0x1F;
      result = ((~v11 | v9) ^ v10) + v15 + v27[byte_49F820[v17++]] + *v25;
      v15 = v11;
      ++v25;
      v11 = v10;
      v10 = v9;
      v9 += __ROL4__(result, v26);
    }
    while ( v17 < 0x40 );
  }
  a1[5] += v11;
  a1[3] = v5 + v9;
  a1[2] = v4 + v15;
  a1[4] = v6 + v10;
  return result;
}
// 49F6D0: using guessed type _BYTE byte_49F6D0[64];
// 49F820: using guessed type unsigned __int8 byte_49F820[64];

//----- (00470C70) --------------------------------------------------------
int   psMd5Final(__int64 *a1, int a2)
{
  int v4; // $t0
  __int64 v5; // $t8
  unsigned int v6; // $v0
  unsigned int v7; // $a0
  unsigned int v8; // $a0
  unsigned int v9; // $t3
  unsigned int v10; // $a1
  char v11; // $ra
  int i; // $a1
  int v13; // $t6
  _DWORD *v14; // $t5

  if ( a2 )
  {
    v4 = *((_DWORD *)a1 + 6);
    v5 = *a1 + (unsigned int)(8 * v4);
    *((_BYTE *)a1 + v4 + 28) = 0x80;
    *a1 = v5;
    *((_DWORD *)a1 + 6) = v4 + 1;
    if ( (unsigned int)(v4 + 1) >= 0x39 )
    {
      v6 = v4 + 1;
      if ( (unsigned int)(v4 + 1) < 0x40 )
      {
        do
        {
          v7 = v6 + 1;
          *((_BYTE *)a1 + v6 + 28) = 0;
          ++v6;
        }
        while ( v6 < 0x40 );
        *((_DWORD *)a1 + 6) = v7;
      }
      sub_470974(a1);
      psBurnStack(0x54u);
      v5 = *a1;
      *((_DWORD *)a1 + 6) = 0;
    }
    v8 = *((_DWORD *)a1 + 6);
    v9 = (unsigned int)v5 >> 8;
    if ( v8 < 0x38 )
    {
      do
      {
        v10 = v8 + 1;
        *((_BYTE *)a1 + v8 + 28) = 0;
        ++v8;
      }
      while ( v8 < 0x38 );
      *((_DWORD *)a1 + 6) = v10;
      v9 = (unsigned int)v5 >> 8;
    }
    v11 = *(_BYTE *)a1;
    *((_BYTE *)a1 + 87) = BYTE3(v5);
    *((_BYTE *)a1 + 91) = HIBYTE(v5);
    *((_BYTE *)a1 + 90) = BYTE6(v5);
    *((_WORD *)a1 + 44) = WORD2(v5);
    *((_BYTE *)a1 + 86) = BYTE2(v5);
    *((_BYTE *)a1 + 85) = v9;
    *((_BYTE *)a1 + 84) = v11;
    sub_470974(a1);
    psBurnStack(0x54u);
    for ( i = 0; i < 4; ++i )
    {
      v13 = *((_DWORD *)a1 + i + 2);
      v14 = (_DWORD *)(4 * i + a2);
      *v14 = v13;
      *v14 = v13;
    }
  }
  return memset(a1, 0, 96);
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (00470E64) --------------------------------------------------------
int   psMd5Update(int *a1, int a2, unsigned int a3)
{
  unsigned int i; // $s1
  int v6; // $a2
  unsigned int v7; // $s0
  int result; // $v0
  unsigned int v9; // $a1
  int v10; // $t1
  int v11; // $t0

  for ( i = a3; i; a1[1] = v11 )
  {
    while ( 1 )
    {
      v6 = a1[6];
      v7 = 64 - v6;
      if ( i < 64 - v6 )
        v7 = i;
      result = memcpy((char *)a1 + v6 + 28, a2, v7);
      i -= v7;
      v9 = a1[6] + v7;
      a2 += v7;
      a1[6] = v9;
      if ( v9 == 64 )
        break;
      if ( !i )
        return result;
    }
    sub_470974(a1);
    result = psBurnStack(0x54u);
    v10 = *a1 + 512;
    v11 = a1[1] + ((unsigned int)*a1 >= 0xFFFFFE00);
    a1[6] = 0;
    *a1 = v10;
  }
  return result;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00470F78) --------------------------------------------------------
int   psHmacMd5Update(int a1, int a2, unsigned int a3)
{
  return psMd5Update((int *)(a1 + 64), a2, a3);
}

//----- (00470F94) --------------------------------------------------------
int   psHmacMd5Init(int a1, int a2, unsigned __int16 a3)
{
  unsigned int v3; // $s0
  BOOL v4; // $s5
  unsigned int i; // $a1
  char v8; // $a2
  _BYTE *v9; // $a0
  int j; // $a0
  _BYTE *v11; // $t1
  int v12; // $v1
  unsigned int v13; // $a1
  char v14; // $t5
  _BYTE *v15; // $t3
  int k; // $a2
  _BYTE *v17; // $t7

  v3 = a3;
  v4 = a3 != 0;
  for ( i = 0; i < v3; *v9 = v8 ^ 0x36 )
  {
    v8 = *(_BYTE *)(a2 + i);
    v9 = (_BYTE *)(a1 + i++);
  }
  for ( j = v3; j < 64; *v11 = 54 )
    v11 = (_BYTE *)(a1 + j++);
  v12 = psMd5Init((_DWORD *)(a1 + 64));
  if ( v12 >= 0 )
  {
    psMd5Update((int *)(a1 + 64), a1, 0x40u);
    v13 = 0;
    if ( v4 )
    {
      do
      {
        v14 = *(_BYTE *)(a2 + v13);
        v15 = (_BYTE *)(a1 + v13++);
        *v15 = v14 ^ 0x5C;
      }
      while ( v13 < v3 );
    }
    for ( k = v3; k < 64; *v17 = 92 )
      v17 = (_BYTE *)(a1 + k++);
    return 0;
  }
  return v12;
}

//----- (004710C8) --------------------------------------------------------
int   psHmacMd5Final(int a1, int a2)
{
  int *v2; // $s0

  v2 = (int *)(a1 + 64);
  psMd5Final((__int64 *)(a1 + 64), a2);
  if ( psMd5Init(v2) < 0 )
  {
    psTraceStr("psAssert %s", (int)"digest/hmac.c");
    psTraceInt(":%d ", 249);
    return psError((int)"rc >= 0");
  }
  else
  {
    psMd5Update(v2, a1, 0x40u);
    psMd5Update(v2, a2, 0x10u);
    psMd5Final((__int64 *)v2, a2);
    return memset(a1, 0, 64);
  }
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (004711FC) --------------------------------------------------------
int   psHmacMd5(int a1, unsigned __int16 a2, int a3, unsigned int a4, int a5, int a6, unsigned __int16 *a7)
{
  unsigned int v7; // $s0
  int v11; // $s2
  unsigned int v12; // $s0
  unsigned int i; // $a1
  char v14; // $t0
  _BYTE *v15; // $a0
  int j; // $a0
  _BYTE *v17; // $t3
  int v18; // $v1
  unsigned int k; // $a1
  char v20; // $t7
  _BYTE *v21; // $t5
  int m; // $a0
  _BYTE *v23; // $s2
  __int64 v25[8]; // [sp+18h] [-A0h] BYREF
  int v26[24]; // [sp+58h] [-60h] BYREF

  v7 = a2;
  v11 = a6;
  if ( a2 >= 0x41u )
  {
    v18 = psMd5Init(v25);
    if ( v18 < 0 )
      return v18;
    psMd5Update((int *)v25, a1, v7);
    psMd5Final(v25, a5);
    *a7 = 16;
    memcpy(a6, a5, 16);
  }
  else
  {
    *a7 = a2;
    v11 = a1;
  }
  v12 = *a7;
  for ( i = 0; i < v12; *v15 = v14 ^ 0x36 )
  {
    v14 = *(_BYTE *)(v11 + i);
    v15 = (char *)v25 + i++;
  }
  for ( j = v12; j < 64; *v17 = 54 )
    v17 = (char *)v25 + j++;
  v18 = psMd5Init(v26);
  if ( v18 >= 0 )
  {
    psMd5Update(v26, (int)v25, 0x40u);
    for ( k = 0; k < v12; *v21 = v20 ^ 0x5C )
    {
      v20 = *(_BYTE *)(v11 + k);
      v21 = (char *)v25 + k++;
    }
    for ( m = v12; m < 64; *v23 = 92 )
      v23 = (char *)v25 + m++;
    psMd5Update(v26, a3, a4);
    psHmacMd5Final((int)v25, a5);
    return 0;
  }
  return v18;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00471418) --------------------------------------------------------
int   psHmacSha1Update(int a1, int a2, unsigned int a3)
{
  return psSha1Update((int *)(a1 + 64), a2, a3);
}

//----- (00471434) --------------------------------------------------------
int   psHmacSha1Init(int a1, int a2, unsigned __int16 a3)
{
  unsigned int v3; // $s0
  BOOL v4; // $s4
  unsigned int i; // $a1
  char v8; // $a2
  _BYTE *v9; // $a0
  unsigned int j; // $a0
  _BYTE *v11; // $t1
  int v12; // $v1
  unsigned int v13; // $a1
  char v14; // $t5
  _BYTE *v15; // $t3
  int k; // $a2
  _BYTE *v17; // $s2

  v3 = a3;
  v4 = a3 != 0;
  for ( i = 0; i < v3; *v9 = v8 ^ 0x36 )
  {
    v8 = *(_BYTE *)(a2 + i);
    v9 = (_BYTE *)(a1 + i++);
  }
  for ( j = v3; j < 0x40; *v11 = 54 )
    v11 = (_BYTE *)(a1 + j++);
  v12 = psSha1Init((_DWORD *)(a1 + 64));
  if ( v12 >= 0 )
  {
    psSha1Update((int *)(a1 + 64), a1, 0x40u);
    v13 = 0;
    if ( v4 )
    {
      do
      {
        v14 = *(_BYTE *)(a2 + v13);
        v15 = (_BYTE *)(a1 + v13++);
        *v15 = v14 ^ 0x5C;
      }
      while ( v13 < v3 );
    }
    for ( k = v3; k < 64; *v17 = 92 )
      v17 = (_BYTE *)(a1 + k++);
    return 0;
  }
  return v12;
}

//----- (00471564) --------------------------------------------------------
int   psHmacSha1Final(int a1, int a2)
{
  int *v2; // $s0

  v2 = (int *)(a1 + 64);
  psSha1Final((__int64 *)(a1 + 64), a2);
  if ( psSha1Init(v2) < 0 )
  {
    psTraceStr("psAssert %s", (int)"digest/hmac.c");
    psTraceInt(":%d ", 373);
    return psError((int)"rc >= 0");
  }
  else
  {
    psSha1Update(v2, a1, 0x40u);
    psSha1Update(v2, a2, 0x14u);
    psSha1Final((__int64 *)v2, a2);
    return memset(a1, 0, 64);
  }
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (00471698) --------------------------------------------------------
int   psHmacSha1(int a1, unsigned __int16 a2, int a3, unsigned int a4, int a5, int a6, unsigned __int16 *a7)
{
  unsigned int v7; // $s0
  int v11; // $s2
  unsigned int v12; // $s0
  unsigned int i; // $a1
  char v14; // $t0
  _BYTE *v15; // $a0
  unsigned int j; // $a0
  _BYTE *v17; // $t3
  int v18; // $v1
  unsigned int k; // $a1
  char v20; // $t7
  _BYTE *v21; // $t5
  int m; // $a0
  _BYTE *v23; // $t8
  __int64 v25[8]; // [sp+18h] [-A0h] BYREF
  int v26[24]; // [sp+58h] [-60h] BYREF

  v7 = a2;
  v11 = a6;
  if ( a2 >= 0x41u )
  {
    v18 = psSha1Init(v25);
    if ( v18 < 0 )
      return v18;
    psSha1Update((int *)v25, a1, v7);
    psSha1Final(v25, a5);
    *a7 = 20;
    memcpy(a6, a5, 20);
  }
  else
  {
    *a7 = a2;
    v11 = a1;
  }
  v12 = *a7;
  for ( i = 0; i < v12; *v15 = v14 ^ 0x36 )
  {
    v14 = *(_BYTE *)(v11 + i);
    v15 = (char *)v25 + i++;
  }
  for ( j = v12; j < 0x40; *v17 = 54 )
    v17 = (char *)v25 + j++;
  v18 = psSha1Init(v26);
  if ( v18 >= 0 )
  {
    psSha1Update(v26, (int)v25, 0x40u);
    for ( k = 0; k < v12; *v21 = v20 ^ 0x5C )
    {
      v20 = *(_BYTE *)(v11 + k);
      v21 = (char *)v25 + k++;
    }
    for ( m = v12; m < 64; *v23 = 92 )
      v23 = (char *)v25 + m++;
    psSha1Update(v26, a3, a4);
    psHmacSha1Final((int)v25, a5);
    return 0;
  }
  return v18;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (004718B4) --------------------------------------------------------
int   psHmacSha256Update(int a1, int a2, unsigned int a3)
{
  return psSha256Update((int *)(a1 + 64), a2, a3);
}

//----- (004718D0) --------------------------------------------------------
int   psHmacSha256Init(int a1, int a2, unsigned __int16 a3)
{
  unsigned int v3; // $s0
  BOOL v4; // $s5
  unsigned int i; // $a1
  char v8; // $a2
  _BYTE *v9; // $a0
  int j; // $a0
  _BYTE *v11; // $t1
  int v12; // $v1
  unsigned int v13; // $a1
  char v14; // $t5
  _BYTE *v15; // $t3
  int k; // $a2
  _BYTE *v17; // $t7

  v3 = a3;
  v4 = a3 != 0;
  for ( i = 0; i < v3; *v9 = v8 ^ 0x36 )
  {
    v8 = *(_BYTE *)(a2 + i);
    v9 = (_BYTE *)(a1 + i++);
  }
  for ( j = v3; j < 64; *v11 = 54 )
    v11 = (_BYTE *)(a1 + j++);
  v12 = psSha256Init((_DWORD *)(a1 + 64));
  if ( v12 >= 0 )
  {
    psSha256Update((int *)(a1 + 64), a1, 0x40u);
    v13 = 0;
    if ( v4 )
    {
      do
      {
        v14 = *(_BYTE *)(a2 + v13);
        v15 = (_BYTE *)(a1 + v13++);
        *v15 = v14 ^ 0x5C;
      }
      while ( v13 < v3 );
    }
    for ( k = v3; k < 64; *v17 = 92 )
      v17 = (_BYTE *)(a1 + k++);
    return 0;
  }
  return v12;
}

//----- (00471A04) --------------------------------------------------------
int   psHmacSha256Final(int a1, int a2)
{
  int *v2; // $s0

  v2 = (int *)(a1 + 64);
  psSha256Final(a1 + 64, a2);
  if ( psSha256Init(v2) < 0 )
  {
    psTraceStr("psAssert %s", (int)"digest/hmac.c");
    psTraceInt(":%d ", 497);
    return psError((int)"rc >= 0");
  }
  else
  {
    psSha256Update(v2, a1, 0x40u);
    psSha256Update(v2, a2, 0x20u);
    psSha256Final((int)v2, a2);
    return memset(a1, 0, 64);
  }
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (00471B38) --------------------------------------------------------
int   psHmacSha256(
        int a1,
        unsigned __int16 a2,
        int a3,
        unsigned int a4,
        _DWORD *a5,
        _DWORD *a6,
        unsigned __int16 *a7)
{
  unsigned int v7; // $s1
  _DWORD *v11; // $s0
  unsigned int v12; // $s1
  unsigned int i; // $a1
  char v14; // $s3
  _BYTE *v15; // $t6
  int j; // $a0
  _BYTE *v17; // $ra
  int v18; // $v1
  unsigned int k; // $a1
  char v20; // $a0
  _BYTE *v21; // $v0
  int m; // $a0
  _BYTE *v23; // $s1
  int v25; // $t3
  int v26; // $t2
  int v27; // $a1
  int v28; // $a2
  int v29; // $a3
  int v30; // $t0
  int v31; // $t1
  int v32[16]; // [sp+18h] [-B0h] BYREF
  int v33[28]; // [sp+58h] [-70h] BYREF

  v7 = a2;
  v11 = a6;
  if ( a2 > 0x40u )
  {
    v18 = psSha256Init(v32);
    if ( v18 < 0 )
      return v18;
    psSha256Update(v32, a1, v7);
    psSha256Final((int)v32, (int)a5);
    v25 = a5[1];
    v26 = a5[2];
    v27 = a5[3];
    v28 = a5[4];
    v29 = a5[5];
    v30 = a5[6];
    v31 = a5[7];
    *a6 = *a5;
    a6[1] = v25;
    a6[2] = v26;
    a6[3] = v27;
    a6[4] = v28;
    a6[5] = v29;
    a6[6] = v30;
    a6[6] = v30;
    a6[7] = v31;
    *a7 = 32;
  }
  else
  {
    *a7 = a2;
    v11 = (_DWORD *)a1;
  }
  v12 = *a7;
  for ( i = 0; i < v12; *v15 = v14 ^ 0x36 )
  {
    v14 = *((_BYTE *)v11 + i);
    v15 = (char *)v32 + i++;
  }
  for ( j = v12; j < 64; *v17 = 54 )
    v17 = (char *)v32 + j++;
  v18 = psSha256Init(v33);
  if ( v18 >= 0 )
  {
    psSha256Update(v33, (int)v32, 0x40u);
    for ( k = 0; k < v12; *v21 = v20 ^ 0x5C )
    {
      v20 = *((_BYTE *)v11 + k);
      v21 = (char *)v32 + k++;
    }
    for ( m = v12; m < 64; *v23 = 92 )
      v23 = (char *)v32 + m++;
    psSha256Update(v33, a3, a4);
    psHmacSha256Final((int)v32, (int)a5);
    return 0;
  }
  return v18;
}

//----- (00471DBC) --------------------------------------------------------
int   psHmacSha384Update(int a1, int a2, unsigned int a3)
{
  return psSha384Update((int *)(a1 + 128), a2, a3);
}

//----- (00471DD8) --------------------------------------------------------
int   psHmacUpdate(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // $v1
  int result; // $v0

  v3 = *(unsigned __int8 *)(a1 + 336);
  result = 19;
  if ( v3 == 19 )
    return psSha1Update((int *)(a1 + 64), a2, a3);
  if ( v3 < 0x14 )
  {
    if ( v3 == 18 )
      return psMd5Update((int *)(a1 + 64), a2, a3);
  }
  else if ( v3 == 20 )
  {
    return psSha256Update((int *)(a1 + 64), a2, a3);
  }
  else if ( v3 == 21 )
  {
    return psSha384Update((int *)(a1 + 128), a2, a3);
  }
  return result;
}

//----- (00471E84) --------------------------------------------------------
int   psHmacSha384Init(int a1, int a2, unsigned __int16 a3)
{
  unsigned int v3; // $s0
  BOOL v4; // $s5
  unsigned int i; // $a1
  char v8; // $a2
  _BYTE *v9; // $a0
  int j; // $a0
  _BYTE *v11; // $t1
  int v12; // $v1
  unsigned int v13; // $a1
  char v14; // $t5
  _BYTE *v15; // $t3
  int k; // $a2
  _BYTE *v17; // $t7

  v3 = a3;
  v4 = a3 != 0;
  for ( i = 0; i < v3; *v9 = v8 ^ 0x36 )
  {
    v8 = *(_BYTE *)(a2 + i);
    v9 = (_BYTE *)(a1 + i++);
  }
  for ( j = v3; j < 128; *v11 = 54 )
    v11 = (_BYTE *)(a1 + j++);
  v12 = psSha384Init((_DWORD *)(a1 + 128));
  if ( v12 >= 0 )
  {
    psSha384Update((int *)(a1 + 128), a1, 0x80u);
    v13 = 0;
    if ( v4 )
    {
      do
      {
        v14 = *(_BYTE *)(a2 + v13);
        v15 = (_BYTE *)(a1 + v13++);
        *v15 = v14 ^ 0x5C;
      }
      while ( v13 < v3 );
    }
    for ( k = v3; k < 128; *v17 = 92 )
      v17 = (_BYTE *)(a1 + k++);
    return 0;
  }
  return v12;
}

//----- (00471FB8) --------------------------------------------------------
int   psHmacInit(int a1, unsigned int a2, int a3, unsigned __int16 a4)
{
  int v6; // $s0
  unsigned int m; // $a1
  char v9; // $t3
  _BYTE *v10; // $t1
  int v11; // $a0
  _BYTE *v12; // $t6
  int v13; // $v1
  unsigned int n; // $a1
  char v15; // $t8
  _BYTE *v16; // $s2
  int ii; // $a3
  _BYTE *v18; // $s0
  unsigned int i; // $a1
  char v20; // $a2
  _BYTE *v21; // $a0
  unsigned int j; // $a0
  _BYTE *v23; // $t2
  unsigned int k; // $a1
  char v25; // $t5
  _BYTE *v26; // $t3
  int v27; // $a3
  _BYTE *v28; // $s2
  unsigned int mm; // $a1
  char v30; // $t6
  _BYTE *v31; // $t4
  int v32; // $a0
  _BYTE *v33; // $t8
  unsigned int nn; // $a1
  char v35; // $v1
  _BYTE *v36; // $v0
  int v37; // $a3
  _BYTE *v38; // $s5
  unsigned int jj; // $a1
  char v40; // $a0
  _BYTE *v41; // $ra
  int v42; // $a0
  _BYTE *v43; // $a3
  unsigned int kk; // $a1
  char v45; // $t2
  _BYTE *v46; // $t0
  int v47; // $a3
  _BYTE *v48; // $s0

  v6 = a4;
  *(_BYTE *)(a1 + 336) = a2;
  if ( a2 == 19 )
  {
    for ( i = 0; i < a4; *v21 = v20 ^ 0x36 )
    {
      v20 = *(_BYTE *)(a3 + i);
      v21 = (_BYTE *)(a1 + i++);
    }
    for ( j = a4; j < 0x40; *v23 = 54 )
      v23 = (_BYTE *)(a1 + j++);
    v13 = psSha1Init((_DWORD *)(a1 + 64));
    if ( v13 < 0 )
      return v13;
    psSha1Update((int *)(a1 + 64), a1, 0x40u);
    for ( k = 0; k < v6; *v26 = v25 ^ 0x5C )
    {
      v25 = *(_BYTE *)(a3 + k);
      v26 = (_BYTE *)(a1 + k++);
    }
    v27 = v6;
    if ( v6 < 64 )
    {
      do
      {
        v28 = (_BYTE *)(a1 + v27++);
        *v28 = 92;
      }
      while ( v27 < 64 );
      return 0;
    }
    return 0;
  }
  if ( a2 < 0x14 )
  {
    if ( a2 != 18 )
      return -6;
    for ( m = 0; m < a4; *v10 = v9 ^ 0x36 )
    {
      v9 = *(_BYTE *)(a3 + m);
      v10 = (_BYTE *)(a1 + m++);
    }
    v11 = a4;
    if ( a4 < 0x40u )
    {
      do
      {
        v12 = (_BYTE *)(a1 + v11++);
        *v12 = 54;
      }
      while ( v11 < 64 );
    }
    v13 = psMd5Init((_DWORD *)(a1 + 64));
    if ( v13 < 0 )
      return v13;
    psMd5Update((int *)(a1 + 64), a1, 0x40u);
    for ( n = 0; n < v6; *v16 = v15 ^ 0x5C )
    {
      v15 = *(_BYTE *)(a3 + n);
      v16 = (_BYTE *)(a1 + n++);
    }
    for ( ii = v6; ii < 64; *v18 = 92 )
      v18 = (_BYTE *)(a1 + ii++);
    return 0;
  }
  if ( a2 == 20 )
  {
    for ( jj = 0; jj < a4; *v41 = v40 ^ 0x36 )
    {
      v40 = *(_BYTE *)(a3 + jj);
      v41 = (_BYTE *)(a1 + jj++);
    }
    v42 = a4;
    if ( a4 < 0x40u )
    {
      do
      {
        v43 = (_BYTE *)(a1 + v42++);
        *v43 = 54;
      }
      while ( v42 < 64 );
    }
    v13 = psSha256Init((_DWORD *)(a1 + 64));
    if ( v13 < 0 )
      return v13;
    psSha256Update((int *)(a1 + 64), a1, 0x40u);
    for ( kk = 0; kk < v6; *v46 = v45 ^ 0x5C )
    {
      v45 = *(_BYTE *)(a3 + kk);
      v46 = (_BYTE *)(a1 + kk++);
    }
    v47 = v6;
    if ( v6 < 64 )
    {
      do
      {
        v48 = (_BYTE *)(a1 + v47++);
        *v48 = 92;
      }
      while ( v47 < 64 );
      return 0;
    }
    return 0;
  }
  if ( a2 != 21 )
    return -6;
  for ( mm = 0; mm < a4; *v31 = v30 ^ 0x36 )
  {
    v30 = *(_BYTE *)(a3 + mm);
    v31 = (_BYTE *)(a1 + mm++);
  }
  v32 = a4;
  if ( a4 < 0x80u )
  {
    do
    {
      v33 = (_BYTE *)(a1 + v32++);
      *v33 = 54;
    }
    while ( v32 < 128 );
  }
  v13 = psSha384Init((_DWORD *)(a1 + 128));
  if ( v13 >= 0 )
  {
    psSha384Update((int *)(a1 + 128), a1, 0x80u);
    for ( nn = 0; nn < v6; *v36 = v35 ^ 0x5C )
    {
      v35 = *(_BYTE *)(a3 + nn);
      v36 = (_BYTE *)(a1 + nn++);
    }
    v37 = v6;
    if ( v6 < 128 )
    {
      do
      {
        v38 = (_BYTE *)(a1 + v37++);
        *v38 = 92;
      }
      while ( v37 < 128 );
      return 0;
    }
    return 0;
  }
  return v13;
}

//----- (004723C0) --------------------------------------------------------
int   psHmacSha384Final(int a1, _DWORD *a2)
{
  int *v2; // $s0

  v2 = (int *)(a1 + 128);
  psSha384Final(a1 + 128, a2);
  if ( psSha384Init(v2) < 0 )
  {
    psTraceStr("psAssert %s", (int)"digest/hmac.c");
    psTraceInt(":%d ", 622);
    return psError((int)"rc >= 0");
  }
  else
  {
    psSha384Update(v2, a1, 0x80u);
    psSha384Update(v2, (int)a2, 0x30u);
    psSha384Final((int)v2, a2);
    return memset(a1, 0, 128);
  }
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (004724F4) --------------------------------------------------------
int   psHmacFinal(int a1, _DWORD *a2)
{
  unsigned int v2; // $v1
  int result; // $v0

  v2 = *(unsigned __int8 *)(a1 + 336);
  result = 19;
  if ( v2 == 19 )
  {
    result = psHmacSha1Final(a1, (int)a2);
    *(_BYTE *)(a1 + 336) = 0;
  }
  else if ( v2 < 0x14 )
  {
    if ( v2 != 18 )
      goto LABEL_5;
    result = psHmacMd5Final(a1, (int)a2);
    *(_BYTE *)(a1 + 336) = 0;
  }
  else if ( v2 == 20 )
  {
    result = psHmacSha256Final(a1, (int)a2);
    *(_BYTE *)(a1 + 336) = 0;
  }
  else
  {
    if ( v2 != 21 )
    {
LABEL_5:
      *(_BYTE *)(a1 + 336) = 0;
      return result;
    }
    result = psHmacSha384Final(a1, a2);
    *(_BYTE *)(a1 + 336) = 0;
  }
  return result;
}

//----- (004725D8) --------------------------------------------------------
int   psHmacSha384(
        int a1,
        unsigned __int16 a2,
        int a3,
        unsigned int a4,
        _DWORD *a5,
        _DWORD *a6,
        unsigned __int16 *a7)
{
  unsigned int v7; // $s0
  int v11; // $s2
  unsigned int v12; // $s0
  unsigned int i; // $a1
  char v14; // $t4
  _BYTE *v15; // $t0
  int j; // $a0
  _BYTE *v17; // $t7
  int v18; // $v1
  unsigned int k; // $a1
  char v20; // $v1
  _BYTE *v21; // $t8
  int m; // $a0
  _BYTE *v23; // $s2
  _DWORD *v25; // $a3
  _DWORD *v26; // $a2
  int v27; // $t1
  int v28; // $a0
  int v29; // $a1
  int v30[32]; // [sp+18h] [-150h] BYREF
  int v31[52]; // [sp+98h] [-D0h] BYREF

  v7 = a2;
  v11 = (int)a6;
  if ( a2 > 0x80u )
  {
    v18 = psSha384Init(v30);
    if ( v18 < 0 )
      return v18;
    psSha384Update(v30, a1, v7);
    psSha384Final((int)v30, a5);
    v25 = a5;
    v26 = a6;
    do
    {
      v27 = v25[1];
      v28 = v25[2];
      v29 = v25[3];
      *v26 = *v25;
      v26[1] = v27;
      v26[2] = v28;
      v25 += 4;
      v26[3] = v29;
      v26 += 4;
    }
    while ( v25 != a5 + 12 );
    *a7 = 48;
  }
  else
  {
    *a7 = a2;
    v11 = a1;
  }
  v12 = *a7;
  for ( i = 0; i < v12; *v15 = v14 ^ 0x36 )
  {
    v14 = *(_BYTE *)(v11 + i);
    v15 = (char *)v30 + i++;
  }
  for ( j = v12; j < 128; *v17 = 54 )
    v17 = (char *)v30 + j++;
  v18 = psSha384Init(v31);
  if ( v18 >= 0 )
  {
    psSha384Update(v31, (int)v30, 0x80u);
    for ( k = 0; k < v12; *v21 = v20 ^ 0x5C )
    {
      v20 = *(_BYTE *)(v11 + k);
      v21 = (char *)v30 + k++;
    }
    for ( m = v12; m < 128; *v23 = 92 )
      v23 = (char *)v30 + m++;
    psSha384Update(v31, a3, a4);
    psHmacSha384Final((int)v30, a5);
    return 0;
  }
  return v18;
}

//----- (00472834) --------------------------------------------------------
int   pkcs1Pad(int a1, unsigned __int16 a2, _BYTE *a3, unsigned __int16 a4, char a5)
{
  int v5; // $s2
  int v6; // $a3
  int v7; // $s1
  int v9; // $v1
  _BYTE *v10; // $s0
  int PrngLocked; // $v0

  v5 = a2;
  v6 = a4 - a2;
  v7 = v6 - 3;
  v9 = -9;
  if ( (unsigned int)(v6 - 3) >= 8 )
  {
    *a3 = 0;
    a3[1] = a5;
    v10 = a3 + 2;
    if ( a5 == 1 )
    {
      if ( v6 == 3 )
      {
LABEL_8:
        *v10 = 0;
        memcpy(v10 + 1, a1, v5);
        return 0;
      }
      do
      {
        --v7;
        *v10++ = -1;
      }
      while ( v7 );
      *v10 = 0;
      memcpy(v10 + 1, a1, a2);
      return 0;
    }
    else
    {
      PrngLocked = psGetPrngLocked((int)v10, v7);
      v9 = -7;
      if ( PrngLocked >= 0 )
      {
        for ( ; v7; ++v10 )
        {
          --v7;
          if ( !*v10 )
            *v10 = 1;
        }
        goto LABEL_8;
      }
    }
  }
  return v9;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00472954) --------------------------------------------------------
int   pkcs1Unpad(_BYTE *a1, unsigned __int16 a2, _BYTE *a3, unsigned __int16 a4, char a5)
{
  int v5; // $v1
  unsigned int v6; // $a1
  _BYTE *v8; // $v1
  int v9; // $a0
  char *v10; // $a0
  char v11; // $t6

  v5 = -6;
  if ( a2 < a4 + 10 )
    return v5;
  v6 = (unsigned int)&a1[a2];
  if ( *a1 || a1[1] != a5 )
    return -1;
  v8 = a1 + 2;
  if ( (unsigned int)(a1 + 2) < v6 && (v9 = (unsigned __int8)a1[2]) != 0 )
  {
    if ( a5 == 1 )
    {
      while ( 1 )
      {
        ++v8;
        if ( (unsigned __int8)v9 != 255 )
          return -1;
        v10 = v8 + 1;
        if ( (unsigned int)v8 >= v6 )
          goto LABEL_12;
        LOBYTE(v9) = *v8;
        if ( !*v8 )
        {
          v10 = v8 + 1;
          goto LABEL_12;
        }
      }
    }
    while ( 1 )
    {
      v10 = ++v8 + 1;
      if ( (unsigned int)v8 >= v6 )
        break;
      if ( !*v8 )
        goto LABEL_11;
    }
  }
  else
  {
LABEL_11:
    v10 = v8 + 1;
  }
LABEL_12:
  v5 = -9;
  if ( v6 - (_DWORD)v10 != a4 )
    return v5;
  for ( ; (unsigned int)v10 < v6; ++a3 )
  {
    v11 = *v10++;
    *a3 = v11;
  }
  return 0;
}

//----- (00472A54) --------------------------------------------------------
int   psPkcs5Pbkdf2(int a1, unsigned __int16 a2, int a3, unsigned int a4, int a5, int a6, int a7)
{
  int v9; // $s1
  int v10; // $s7
  int v11; // $s3
  unsigned __int16 v12; // $s6
  int v13; // $s2
  unsigned int i; // $a2
  char *v15; // $ra
  char v16; // $v1
  char v17; // $a0
  unsigned int v18; // $a1
  char *v19; // $t1
  int v21; // [sp+18h] [-C8h] BYREF
  int v22; // [sp+1Ch] [-C4h]
  int v23; // [sp+20h] [-C0h]
  int v24; // [sp+24h] [-BCh]
  int v25; // [sp+28h] [-B8h]
  int v26; // [sp+2Ch] [-B4h] BYREF
  int v27; // [sp+30h] [-B0h]
  int v28; // [sp+34h] [-ACh]
  int v29; // [sp+38h] [-A8h]
  int v30; // [sp+3Ch] [-A4h]
  unsigned __int8 v31[160]; // [sp+40h] [-A0h] BYREF

  if ( a1 && a3 && a6 && a7 )
  {
    v9 = a7;
  }
  else
  {
    psTraceStr("psAssert %s", (int)"keyformat/pkcs.c");
    psTraceInt(":%d ", 2006);
    psError((int)"password && salt && key && kLen");
    v9 = a7;
  }
  v10 = 1;
  v11 = 0;
  if ( a7 )
  {
    v12 = a2;
    do
    {
      LOBYTE(v26) = HIBYTE(v10);
      BYTE1(v26) = BYTE2(v10);
      BYTE2(v26) = BYTE1(v10);
      HIBYTE(v26) = v10;
      v21 = 0;
      v22 = 0;
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      psHmacSha1Init((int)v31, a1, v12);
      psHmacSha1Update((int)v31, a3, a4);
      psHmacSha1Update((int)v31, (int)&v26, 4u);
      psHmacSha1Final((int)v31, (int)&v21);
      v13 = 1;
      v26 = v21;
      v27 = v22;
      v28 = v23;
      v29 = v24;
      v30 = v25;
      ++v10;
      if ( a5 > 1 )
      {
        do
        {
          psHmacSha1Init((int)v31, a1, v12);
          psHmacSha1Update((int)v31, (int)&v21, 0x14u);
          psHmacSha1Final((int)v31, (int)&v21);
          for ( i = 0; i < 0x14; ++i )
          {
            v15 = (char *)&v21 + i;
            v16 = *((_BYTE *)&v21 + i + 20);
            v17 = *((_BYTE *)&v21 + i);
            v15[20] = v16 ^ v17;
          }
          ++v13;
        }
        while ( v13 < a5 );
      }
      v18 = 0;
      if ( !v9 )
        break;
      v19 = (char *)&v21;
      while ( 1 )
      {
        ++v18;
        *(_BYTE *)(v11 + a6) = v19[20];
        --v9;
        ++v11;
        if ( v18 >= 0x14 )
          break;
        v19 = (char *)&v21 + v18;
        if ( !v9 )
          goto LABEL_16;
      }
    }
    while ( v9 );
  }
LABEL_16:
  memset_s((unsigned __int8 *)&v21, 0x28u, 0, 0x28u);
  return memset_s(v31, 0xA0u, 0, 0xA0u);
}

//----- (00472D50) --------------------------------------------------------
int   psPkcs8ParsePrivBin(int a1, unsigned __int8 *a2, int a3, int a4, int a5)
{
  int v7; // $a3
  unsigned __int8 *v8; // $s0
  int AsnSequence; // $v0
  int AsnAlgorithmIdentifier; // $v0
  int v12; // $v0
  int v13; // $v0
  int v14; // $v0
  __int16 v15; // $a0
  int v16; // $s6
  int AsnLength; // $v0
  unsigned __int8 *v18; // $a1
  int v19; // $t0
  int AsnInteger; // $v0
  int v21; // $v0
  __int16 v22; // $v1
  int v23; // $s1
  int v24; // $v0
  unsigned __int8 *v25; // $a1
  unsigned __int8 *v26; // $s5
  int v27; // $t8
  int v28; // $v0
  int v29; // $v0
  unsigned __int16 v30; // $v0
  unsigned __int16 v31; // $v1
  unsigned int v32; // $t0
  unsigned __int16 v33; // $a3
  int v34; // $s5
  int v35; // $t8
  int v36; // $v0
  int v37; // $v0
  int v38; // $v0
  __int16 v39; // $v0
  int v40; // $t6
  int v41; // $v0
  int v42; // $v1
  __int16 v43; // $a1
  int v44; // $a2
  __int16 v45; // $a0
  int v46; // $v0
  unsigned __int8 *v47; // $a2
  unsigned __int16 v48; // $v1
  int v49; // $a0
  int v50; // $t4
  int EccParamByOid; // $v0
  int v52; // $v0
  int v53; // $v0
  void (  *v54)(int); // $t9
  __int16 v55; // $v0
  int v56; // $v0
  __int16 v57; // [sp+28h] [-350h] BYREF
  unsigned __int16 v58; // [sp+2Ah] [-34Eh] BYREF
  unsigned __int16 v59; // [sp+2Ch] [-34Ch] BYREF
  unsigned __int8 v60[24]; // [sp+30h] [-348h] BYREF
  _DWORD v61[194]; // [sp+48h] [-330h] BYREF
  _DWORD v62[2]; // [sp+350h] [-28h] BYREF
  _DWORD v63[2]; // [sp+358h] [-20h] BYREF
  unsigned __int8 *v64; // [sp+360h] [-18h] BYREF
  int v65; // [sp+364h] [-14h] BYREF
  int v66; // [sp+368h] [-10h] BYREF
  int v67; // [sp+36Ch] [-Ch] BYREF
  char *v68; // [sp+370h] [-8h] BYREF

  v7 = -1;
  if ( a3 > 0xFFFF )
    return v7;
  v64 = a2;
  v8 = &a2[a3];
  if ( a4 )
  {
    AsnSequence = getAsnSequence(&v64, a3, &v57);
    v7 = -1;
    if ( AsnSequence < 0 )
      return v7;
    AsnAlgorithmIdentifier = getAsnAlgorithmIdentifier((unsigned int **)&v64, v8 - v64, &v65, &v59);
    v7 = -1;
    if ( AsnAlgorithmIdentifier < 0 )
      return v7;
    if ( v65 != 1685 || v59 != 53 )
      return -1;
    v12 = getAsnSequence(&v64, (_WORD)v8 - (_WORD)v64, &v57);
    v7 = -1;
    if ( v12 < 0 )
      return v7;
    v13 = getAsnAlgorithmIdentifier((unsigned int **)&v64, v8 - v64, &v65, &v59);
    v7 = -1;
    if ( v13 < 0 )
      return v7;
    if ( v65 != 1684 )
      return v7;
    if ( v59 != 16 )
      return v7;
    v14 = getAsnSequence(&v64, (_WORD)v8 - (_WORD)v64, &v57);
    v7 = -1;
    if ( v14 < 0 )
      return v7;
    v15 = (_WORD)v64 + 1;
    v16 = *v64++;
    if ( v16 != 4 )
      return v7;
    AsnLength = getAsnLength(&v64, (_WORD)v8 - v15, &v58);
    v7 = -1;
    if ( AsnLength < 0 )
      return v7;
    v18 = v64;
    if ( v8 - v64 < (unsigned int)v58 )
      return v7;
    if ( v58 != 8 )
      return v7;
    v19 = *(_DWORD *)v64;
    v63[1] = *((_DWORD *)v64 + 1);
    v64 += 8;
    v63[0] = v19;
    AsnInteger = getAsnInteger((char **)&v64, v8 - (v18 + 8), &v66);
    v7 = -1;
    if ( AsnInteger < 0 )
      return v7;
    v21 = getAsnAlgorithmIdentifier((unsigned int **)&v64, v8 - v64, &v65, &v59);
    v7 = -1;
    if ( v21 < 0 )
      return v7;
    if ( v65 != 1676 )
      return v7;
    if ( v59 != 10 )
      return v7;
    if ( v8 == v64 )
      return v7;
    v22 = (_WORD)v64 + 1;
    v23 = *v64++;
    if ( v23 != 4 )
      return v7;
    v24 = getAsnLength(&v64, (_WORD)v8 - v22, &v58);
    v7 = -1;
    if ( v24 < 0 )
      return v7;
    v25 = v64;
    if ( v8 - v64 < (unsigned int)v58 )
      return v7;
    v26 = v64 + 8;
    if ( v58 != 8 )
      return v7;
    v27 = *((_DWORD *)v64 + 1);
    v62[0] = *(_DWORD *)v64;
    v62[1] = v27;
    v64 += 8;
    if ( v8 == v26 )
      return v7;
    v28 = v25[8];
    v64 = v25 + 9;
    if ( v28 != v23 )
      return v7;
    v29 = getAsnLength(&v64, (_WORD)v8 - ((_WORD)v25 + 9), &v58);
    v7 = -1;
    if ( v29 < 0 )
      return v7;
    if ( v8 - v64 < (unsigned int)v58 )
      return v7;
    if ( v58 < 0x18u )
      return v7;
    v30 = strlen(a4);
    psPkcs5Pbkdf2(a4, v30, (int)v63, 8u, v66, (int)v60, 24);
    psDes3Init(v61, (int)v62, (int)v60);
    psDes3Decrypt(v61, (int)v64, (int)v64, v58);
    memset_s((unsigned __int8 *)v61, 0x308u, 0, 0x308u);
    memset_s(v60, 0x18u, 0, 0x18u);
    v7 = -1;
    if ( !v58 )
      return v7;
    LOWORD(a2) = (_WORD)v64;
    v31 = v64[v58 - 1];
    v59 = v31;
    if ( (unsigned __int16)(v31 - 1) >= 0x10u || v58 < (unsigned int)v31 )
      return v7;
    LOWORD(v32) = 0;
    if ( v31 )
    {
      v33 = v31;
      v34 = v58;
      while ( 1 )
      {
        v32 = (unsigned __int16)(v32 + 1);
        if ( v64[v34 - 1] != (unsigned __int8)v31 )
          return -1;
        v34 = v58 - v32;
        if ( v32 >= v31 )
        {
          v35 = v58;
          goto LABEL_40;
        }
      }
    }
    v33 = v59;
    v35 = v58;
LABEL_40:
    v8 = &v64[v35 - v33];
  }
  v36 = getAsnSequence(&v64, (_WORD)v8 - (_WORD)a2, &v57);
  v7 = -1;
  if ( v36 >= 0 )
  {
    v37 = getAsnInteger((char **)&v64, v8 - v64, &v67);
    v7 = -1;
    if ( v37 >= 0 && !v67 )
    {
      v38 = getAsnAlgorithmIdentifier((unsigned int **)&v64, v8 - v64, &v65, &v59);
      v7 = -1;
      if ( v38 >= 0 )
      {
        if ( v65 == 518 || (v7 = -10, v65 == 645) )
        {
          if ( v65 != 518 )
            goto LABEL_48;
          if ( v8 == v64 )
            return -31;
          v44 = *v64;
          v45 = (_WORD)v64++ + 1;
          if ( v44 != 6 )
            return -31;
          v46 = getAsnLength(&v64, (_WORD)v8 - v45, &v58);
          v7 = -31;
          if ( v46 >= 0 )
          {
            v47 = v64;
            v48 = v58;
            if ( v8 - v64 >= (unsigned int)v58 )
            {
              v49 = 0;
              if ( v58 )
              {
                while ( 1 )
                {
                  v50 = *v47++;
                  v49 += v50;
                  v64 = v47;
                  v58 = v48 - 1;
                  if ( v48 == 1 )
                    break;
                  --v48;
                }
              }
              EccParamByOid = getEccParamByOid(v49, &v68);
              v7 = -10;
              if ( EccParamByOid >= 0 )
              {
LABEL_48:
                v39 = (__int16)v64;
                v7 = -31;
                if ( v8 != v64 )
                {
                  v40 = *v64++;
                  if ( v40 != 4 )
                    return -1;
                  v41 = getAsnLength(&v64, (_WORD)v8 - (v39 + 1), &v58);
                  v7 = -1;
                  if ( v41 < 0 )
                    return v7;
                  if ( v8 - v64 < (unsigned int)v58 )
                    return -1;
                  v42 = v65;
                  if ( v65 == 645 )
                  {
                    psRsaInitKey(a1, a5);
                    v53 = psRsaParsePkcs1PrivKey(a1, v64, v58, a5);
                    v54 = psRsaClearKey;
                    if ( v53 < 0 )
                      goto LABEL_78;
                    *(_BYTE *)(a5 + 110) = 1;
                    v55 = psRsaSize(a5);
                    v42 = v65;
                    *(_WORD *)(a5 + 108) = v55;
                  }
                  if ( v42 == 518 )
                  {
                    psEccInitKey(a1, (_DWORD *)a5, (int)v68);
                    v52 = psEccParsePrivKey(a1, v64, v58, a5, v68);
                    v7 = -1;
                    if ( v52 < 0 )
                      return v7;
                    *(_BYTE *)(a5 + 110) = 3;
                    *(_WORD *)(a5 + 108) = psEccSize(a5);
                  }
                  v64 += v58;
                  v43 = (__int16)v64;
                  v59 = (_WORD)v8 - (_WORD)v64;
                  if ( (_WORD)v8 == (_WORD)v64 )
                    return 0;
                  if ( *v64 != 160 )
                  {
LABEL_56:
                    if ( !v59 )
                      return 0;
                    v54 = psClearPubKey;
LABEL_78:
                    v54(a5);
                    return -1;
                  }
                  ++v64;
                  v56 = getAsnLength(&v64, (_WORD)v8 - (v43 + 1), &v58);
                  v7 = -1;
                  if ( v56 >= 0 && v8 - v64 >= (unsigned int)v58 )
                  {
                    v59 = (_WORD)v8 - (v58 + (_WORD)v64);
                    v64 += v58;
                    goto LABEL_56;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v7;
}
// 4E9F24: using guessed type int   strlen(_DWORD);

//----- (00473564) --------------------------------------------------------
int   psPkcs5Pbkdf1(int a1, unsigned int a2, int a3, int a4, _DWORD *a5)
{
  int v8; // $v1
  int v10; // $t1
  int v11; // $t0
  int v12; // $a3
  int v13; // $t3
  __int64 v14[26]; // [sp+18h] [-E0h] BYREF
  int v15; // [sp+E8h] [-10h] BYREF
  int v16; // [sp+ECh] [-Ch]
  int v17; // [sp+F0h] [-8h]
  int v18; // [sp+F4h] [-4h]

  if ( a4 != 1 )
  {
    psTraceStr("psAssert %s", (int)"keyformat/pkcs.c");
    psTraceInt(":%d ", 1953);
    psError((int)"iter == 1");
  }
  v8 = psMd5Init(v14);
  if ( !v8 )
  {
    psMd5Update((int *)v14, a1, a2);
    psMd5Update((int *)v14, a3, 8u);
    psMd5Final(v14, (int)&v15);
    v10 = v16;
    *a5 = v15;
    a5[1] = v10;
    v11 = v17;
    a5[1] = v10;
    a5[2] = v11;
    v12 = v18;
    a5[2] = v11;
    a5[3] = v12;
    a5[3] = v12;
    v8 = psMd5Init(v14);
    if ( !v8 )
    {
      psMd5Update((int *)v14, (int)&v15, 0x10u);
      psMd5Update((int *)v14, a1, a2);
      psMd5Update((int *)v14, a3, 8u);
      psMd5Final(v14, (int)&v15);
      v13 = v16;
      a5[4] = v15;
      a5[5] = v13;
      memset_s((unsigned __int8 *)&v15, 0x10u, 0, 0x10u);
      memset_s((unsigned __int8 *)v14, 0xD0u, 0, 0xD0u);
      return 0;
    }
  }
  return v8;
}

//----- (00473798) --------------------------------------------------------
int   psPkcs1DecodePrivFile(int a1, int a2, int a3, unsigned int **a4, unsigned __int16 *a5)
{
  int v7; // $s5
  int FileBuf; // $v1
  int v9; // $s2
  int v10; // $v0
  int v11; // $s0
  int v12; // $v0
  int v13; // $s3
  int v14; // $v1
  char *v15; // $s0
  int v16; // $s1
  int v17; // $s0
  unsigned int v18; // $t4
  unsigned __int8 *v19; // $a3
  _BYTE *v20; // $t1
  char v21; // $t2
  int v22; // $a1
  char v23; // $a2
  bool v24; // dc
  int v25; // $v0
  unsigned int v26; // $v0
  int v27; // $v0
  unsigned int *v28; // $s2
  int v29; // $s0
  int v31; // $v0
  int v32; // $s0
  int v33; // $v0
  int v34; // $v1
  int v35; // $v0
  int v36; // $v0
  int v37; // $s0
  unsigned int v38; // $t3
  unsigned __int8 *v39; // $a3
  _BYTE *v40; // $t1
  char v41; // $t2
  int v42; // $a1
  char v43; // $a2
  BOOL v44; // $v0
  _DWORD v45[194]; // [sp+20h] [-458h] BYREF
  unsigned __int8 v46[280]; // [sp+328h] [-150h] BYREF
  unsigned int v47[8]; // [sp+440h] [-38h] BYREF
  _BYTE v48[16]; // [sp+460h] [-18h] BYREF
  int v49; // [sp+470h] [-8h] BYREF
  int v50; // [sp+474h] [-4h] BYREF

  v7 = 0;
  FileBuf = -6;
  if ( !a2 )
    return FileBuf;
  FileBuf = psGetFileBuf(a1, a2, &v49, &v50);
  if ( FileBuf < 0 )
    return FileBuf;
  v9 = v49;
  if ( strstr(v49, "-----BEGIN")
    && (v10 = strstr(v9, "PRIVATE KEY-----"), (v11 = v10) != 0)
    && (v12 = strstr(v10, "-----END"), (v13 = v12) != 0)
    && strstr(v12, "PRIVATE KEY-----") )
  {
    v14 = *(char *)(v11 + 16);
    v15 = (char *)(v11 + 16);
    if ( v14 == 13 || v14 == 10 )
    {
LABEL_39:
      ++v15;
      do
      {
        v36 = *v15;
        if ( v36 == 13 )
          goto LABEL_39;
        ++v15;
      }
      while ( v36 == 10 );
      --v15;
    }
  }
  else
  {
    if ( !strstr(v9, "-----BEGIN") )
      goto LABEL_44;
    v31 = strstr(v9, "PUBLIC KEY-----");
    v32 = v31;
    if ( !v31 )
      goto LABEL_44;
    v33 = strstr(v31, "-----END");
    v13 = v33;
    if ( !v33 || !strstr(v33, "PUBLIC KEY-----") )
      goto LABEL_44;
    v34 = *(char *)(v32 + 15);
    v15 = (char *)(v32 + 15);
    if ( v34 == 13 || v34 == 10 )
    {
LABEL_35:
      ++v15;
      do
      {
        v35 = *v15;
        if ( v35 == 13 )
          goto LABEL_35;
        ++v15;
      }
      while ( v35 == 10 );
      --v15;
    }
  }
  v16 = v13 - (_DWORD)v15;
  if ( !strstr(v9, "Proc-Type:") || !strstr(v9, "4,ENCRYPTED") )
    goto LABEL_23;
  if ( !a3 )
  {
    free2(v9);
    return -6;
  }
  v17 = strstr(v9, "DEK-Info: DES-EDE3-CBC,");
  if ( v17 )
  {
    v18 = v17 + strlen("DEK-Info: DES-EDE3-CBC,");
    v7 = 1;
    v19 = (unsigned __int8 *)v18;
    v20 = v48;
    v21 = 1;
    if ( v18 < v18 + 16 )
    {
      while ( 1 )
      {
        v22 = *v19;
        v23 = v22 - 48;
        if ( (unsigned __int8)(v22 - 48) >= 0xAu )
        {
          v23 = v22 - 87;
          if ( (unsigned int)(v22 - 97) >= 6 )
          {
            v23 = v22 - 55;
            if ( (unsigned int)(v22 - 65) >= 6 )
              break;
          }
        }
        v24 = (v21++ & 1) == 0;
        ++v19;
        if ( v24 )
          *v20++ |= v23;
        else
          *v20 = 16 * v23;
        if ( (unsigned int)v19 >= v18 + 16 )
          goto LABEL_20;
      }
LABEL_60:
      v25 = -1;
      goto LABEL_21;
    }
LABEL_20:
    v25 = 16;
    goto LABEL_21;
  }
  v37 = strstr(v9, "DEK-Info: AES-128-CBC,");
  if ( !v37 )
  {
LABEL_44:
    free2(v9);
    return -31;
  }
  v18 = v37 + strlen("DEK-Info: AES-128-CBC,");
  v38 = v18 + 32;
  v7 = 2;
  v39 = (unsigned __int8 *)v18;
  v40 = v48;
  v41 = 1;
  if ( v18 < v18 + 32 )
  {
    do
    {
      v42 = *v39;
      v43 = v42 - 48;
      if ( (unsigned __int8)(v42 - 48) >= 0xAu )
      {
        v43 = v42 - 87;
        if ( (unsigned int)(v42 - 97) >= 6 )
        {
          v43 = v42 - 55;
          if ( (unsigned int)(v42 - 65) >= 6 )
            goto LABEL_60;
        }
      }
      v24 = (v41++ & 1) == 0;
      ++v39;
      if ( v24 )
      {
        *v40 |= v43;
        v44 = (unsigned int)v39 < v38;
        ++v40;
      }
      else
      {
        *v40 = 16 * v43;
        v44 = (unsigned int)v39 < v38;
      }
    }
    while ( v44 );
  }
  v25 = 32;
LABEL_21:
  if ( v25 < 0
    || (v15 = (char *)(v18 + v25),
        v26 = strlen(a3),
        v16 = v13 - (_DWORD)v15,
        psPkcs5Pbkdf1(a3, v26, (int)v48, 1, v47) < 0) )
  {
    free2(v49);
    return -1;
  }
LABEL_23:
  v27 = malloc(v16);
  v28 = (unsigned int *)v27;
  if ( !v27 )
  {
    free2(v49);
    psTraceStr("psError %s", (int)"keyformat/pkcs.c");
    psTraceInt(":%d ", 1878);
    psError((int)"Memory allocation error in psPkcs1DecodePrivFile\n");
    return -8;
  }
  *a5 = v16;
  v29 = psBase64decode((int)v15, v16, v27, a5);
  if ( v29 >= 0 )
  {
    free2(v49);
    if ( v7 == 1 && a3 )
    {
      psDes3Init(v45, (int)v48, (int)v47);
      psDes3Decrypt(v45, (int)v28, (int)v28, *a5);
      memset_s((unsigned __int8 *)v45, 0x308u, 0, 0x308u);
    }
    if ( v7 == 2 )
    {
      if ( a3 )
      {
        psAesInitCBC((int)v46, (int)v48, v47, 0x10u, 2);
        psAesDecryptCBC((int)v46, v28, (int)v28, *a5);
        memset_s(v46, 0x114u, 0, 0x114u);
      }
    }
    memset_s((unsigned __int8 *)v47, 0x20u, 0, 0x20u);
    *a4 = v28;
    return 0;
  }
  free2(v28);
  free2(v49);
  return v29;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FEC: using guessed type int   strstr(_DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (00473EE0) --------------------------------------------------------
int   psPkcs1ParsePrivFile(int a1, int a2, int a3, int a4)
{
  int v7; // $s0
  unsigned __int16 v9[4]; // [sp+20h] [-80h] BYREF
  _BYTE v10[112]; // [sp+28h] [-78h] BYREF
  unsigned __int8 *v11; // [sp+98h] [-8h] BYREF

  v7 = psPkcs1DecodePrivFile(a1, a2, a3, (unsigned int **)&v11, v9);
  if ( v7 >= 0 )
  {
    v7 = psRsaParsePkcs1PrivKey(a1, v11, v9[0], a4);
    if ( v7 < 0 )
    {
      v7 = psPkcs8ParsePrivBin(a1, v11, v9[0], a3, (int)v10);
      if ( v7 >= 0 )
      {
        v7 = psRsaCopyKey(a4, (int)v10);
        psClearPubKey((int)v10);
      }
    }
    free2(v11);
  }
  return v7;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00474004) --------------------------------------------------------
int   sub_474004(int a1, int a2, unsigned int a3, int a4, _BYTE *a5, int a6)
{
  _BYTE *v8; // $s2
  int v9; // $s1
  unsigned int v11; // $s3
  int v12; // $s0
  int result; // $v0
  int v14; // $s5
  unsigned int v15; // $a0
  char v16; // $t6
  __int64 v17[26]; // [sp+18h] [-D0h] BYREF

  v8 = a5;
  v9 = a6;
  if ( !a2 || !a5 )
    return -1;
  v11 = 20;
  if ( a4 )
  {
    v11 = 16;
    if ( a4 != 1 )
    {
      v11 = 32;
      if ( a4 != 2 )
      {
        v11 = 48;
        if ( a4 != 3 )
        {
          v11 = 64;
          if ( a4 != 4 )
            return -10;
        }
      }
    }
  }
  v12 = malloc(v11);
  result = -1;
  if ( v12 )
  {
    if ( a6 )
    {
      *(_BYTE *)(v12 + 3) = 0;
      *(_BYTE *)v12 = 0;
      *(_BYTE *)(v12 + 1) = 0;
      *(_BYTE *)(v12 + 2) = 0;
      v14 = 1;
      if ( a4 )
      {
LABEL_7:
        switch ( a4 )
        {
          case 1:
            psMd5Init(v17);
            psMd5Update((int *)v17, a2, a3);
            psMd5Update((int *)v17, v12, 4u);
            psMd5Final(v17, v12);
            break;
          case 2:
            psSha256Init(v17);
            psSha256Update((int *)v17, a2, a3);
            psSha256Update((int *)v17, v12, 4u);
            psSha256Final((int)v17, v12);
            break;
          case 3:
            psSha384Init(v17);
            psSha384Update((int *)v17, a2, a3);
            psSha384Update((int *)v17, v12, 4u);
            psSha384Final((int)v17, (_DWORD *)v12);
            break;
          case 4:
            psSha512Init(v17);
            psSha512Update((int *)v17, a2, a3);
            psSha512Update((int *)v17, v12, 4u);
            psSha512Final((int)v17, v12);
            break;
        }
      }
      else
      {
LABEL_24:
        psSha1Init(v17);
        psSha1Update((int *)v17, a2, a3);
        psSha1Update((int *)v17, v12, 4u);
        psSha1Final(v17, v12);
      }
      v15 = 0;
      while ( v9 )
      {
        v16 = *(_BYTE *)(v12 + v15++);
        *v8 = v16;
        --v9;
        ++v8;
        if ( v15 >= v11 )
        {
          if ( !v9 )
            break;
          *(_BYTE *)(v12 + 3) = v14;
          *(_BYTE *)v12 = HIBYTE(v14);
          *(_BYTE *)(v12 + 1) = BYTE2(v14);
          *(_BYTE *)(v12 + 2) = BYTE1(v14);
          ++v14;
          if ( a4 )
            goto LABEL_7;
          goto LABEL_24;
        }
      }
    }
    free2(v12);
    return 0;
  }
  return result;
}
// 4740DC: conditional instruction was optimized away because $s3.4 is in (==10|==14|==20|==30|==40)
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (004743A0) --------------------------------------------------------
int   psPkcs1PssDecode(
        int a1,
        int a2,
        unsigned int a3,
        unsigned __int8 *a4,
        int a5,
        unsigned int a6,
        int a7,
        unsigned int a8,
        _DWORD *a9)
{
  int result; // $v0
  unsigned int v13; // $s3
  BOOL v14; // $a3
  unsigned int v15; // $s0
  _BYTE *v16; // $v0
  int v17; // $v0
  int v18; // $v0
  int v19; // $t7
  int v20; // $s5
  unsigned int v21; // $a3
  unsigned int v22; // $a2
  _BYTE *v23; // $s5
  char v24; // $a0
  char v25; // $v1
  unsigned int v26; // $a2
  unsigned int v27; // $a1
  _BYTE *v28; // $t8
  int v29; // $s0
  unsigned int v30; // $s1
  _BYTE *v31; // $a1
  _BYTE *v32; // $t7
  _BYTE *v33; // $fp
  _BYTE *v34; // $t3
  _BYTE *v35; // $a2
  __int64 v36[26]; // [sp+20h] [-F0h] BYREF
  _BYTE *v37; // [sp+F0h] [-20h]
  _BYTE *v38; // [sp+F4h] [-1Ch]
  int v39; // [sp+F8h] [-18h]
  int v40; // [sp+FCh] [-14h]
  int v41; // [sp+100h] [-10h]
  unsigned int v42; // [sp+104h] [-Ch]
  int v43; // [sp+108h] [-8h]

  if ( !a2 )
    return -6;
  result = -6;
  if ( !a9 )
    return result;
  *a9 = 0;
  v13 = 20;
  if ( a7 )
  {
    v13 = 16;
    if ( a7 != 1 )
    {
      v13 = 32;
      if ( a7 != 2 )
      {
        v13 = 48;
        if ( a7 != 3 )
        {
          v13 = 64;
          if ( a7 != 4 )
            return -6;
        }
      }
    }
  }
  v14 = (a8 & 7) != 0;
  v15 = (a8 >> 3) + v14;
  if ( v15 < a6 )
    return -6;
  result = -6;
  if ( v15 < v13 + a6 + 2 )
    return result;
  if ( a5 != v15 )
    return -6;
  v37 = (_BYTE *)malloc((a8 >> 3) + v14);
  result = -8;
  v41 = -8;
  if ( v37 )
  {
    memset(v37, 0, v15);
    v16 = (_BYTE *)malloc(v15);
    v38 = v16;
    if ( v16 )
    {
      memset(v16, 0, v15);
      v17 = malloc(v15);
      v39 = v17;
      if ( v17 )
      {
        memset(v17, 0, v15);
        v18 = malloc(v15);
        v40 = v18;
        if ( v18 )
        {
          memset(v18, 0, v15);
          v19 = a4[v15 - 1];
          v41 = -1;
          if ( v19 == 188 )
          {
            v42 = v15 - v13 - 1;
            memcpy(v37, a4, v42);
            v43 = 8 * v15;
            memcpy(v40, &a4[v42], v13);
            v20 = *a4 & ~(255 >> (8 * v15 - a8 + 1));
            v41 = -1;
            if ( !v20 )
            {
              v41 = sub_474004(a1, v40, v13, a7, v38, v42);
              if ( !v41 )
              {
                v21 = 0;
                if ( v42 )
                {
                  v22 = v42;
                  do
                  {
                    v23 = &v37[v21];
                    v24 = v38[v21];
                    v25 = v37[v21++];
                    *v23 = v25 ^ v24;
                  }
                  while ( v21 < v22 );
                }
                v26 = v15 - a6 - v13;
                *v37 &= 255 >> (v43 - a8 + 1);
                v27 = 0;
                if ( v26 == 2 )
                {
LABEL_31:
                  v29 = (unsigned __int8)v37[v27];
                  v30 = v27 + 1;
                  v41 = -1;
                  if ( v29 == 1 )
                  {
                    if ( !a7 )
                    {
                      psSha1Init(v36);
                      v31 = v38;
                      *v38 = 0;
                      v31[1] = 0;
                      v31[2] = 0;
                      v31[3] = 0;
                      v31[4] = 0;
                      v31[5] = 0;
                      v31[6] = 0;
                      v31[7] = 0;
                      psSha1Update((int *)v36, (int)v38, 8u);
                      psSha1Update((int *)v36, a2, a3);
                      psSha1Update((int *)v36, (int)&v37[v30], a6);
                      psSha1Final(v36, (int)v38);
                    }
                    if ( a7 == 1 )
                    {
                      psMd5Init(v36);
                      v35 = v38;
                      *v38 = 0;
                      v35[1] = 0;
                      v35[2] = 0;
                      v35[3] = 0;
                      v35[4] = 0;
                      v35[5] = 0;
                      v35[6] = 0;
                      v35[7] = 0;
                      psMd5Update((int *)v36, (int)v38, 8u);
                      psMd5Update((int *)v36, a2, a3);
                      psMd5Update((int *)v36, (int)&v37[v30], a6);
                      psMd5Final(v36, (int)v38);
                    }
                    if ( a7 == 2 )
                    {
                      psSha256Init(v36);
                      v34 = v38;
                      *v38 = 0;
                      v34[1] = 0;
                      v34[2] = 0;
                      v34[3] = 0;
                      v34[4] = 0;
                      v34[5] = 0;
                      v34[6] = 0;
                      v34[7] = 0;
                      psSha256Update((int *)v36, (int)v38, 8u);
                      psSha256Update((int *)v36, a2, a3);
                      psSha256Update((int *)v36, (int)&v37[v30], a6);
                      psSha256Final((int)v36, (int)v38);
                    }
                    if ( a7 == 3 )
                    {
                      psSha384Init(v36);
                      v33 = v38;
                      *v38 = 0;
                      v33[1] = 0;
                      v33[2] = 0;
                      v33[3] = 0;
                      v33[4] = 0;
                      v33[5] = 0;
                      v33[6] = 0;
                      v33[7] = 0;
                      psSha384Update((int *)v36, (int)v38, 8u);
                      psSha384Update((int *)v36, a2, a3);
                      psSha384Update((int *)v36, (int)&v37[v30], a6);
                      psSha384Final((int)v36, v38);
                    }
                    if ( a7 == 4 )
                    {
                      psSha512Init(v36);
                      v32 = v38;
                      *v38 = 0;
                      v32[1] = 0;
                      v32[2] = 0;
                      v32[3] = 0;
                      v32[4] = 0;
                      v32[5] = 0;
                      v32[6] = 0;
                      v32[7] = 0;
                      psSha512Update((int *)v36, (int)v38, 8u);
                      psSha512Update((int *)v36, a2, a3);
                      psSha512Update((int *)v36, (int)&v37[v30], a6);
                      psSha512Final((int)v36, (int)v38);
                    }
                    if ( !memcmp(v38, v40, v13) )
                      *a9 = 1;
                    v41 = 0;
                  }
                }
                else
                {
                  v28 = v37;
                  while ( 1 )
                  {
                    ++v27;
                    if ( *v28 )
                      break;
                    v28 = &v37[v27];
                    if ( v27 >= v26 - 2 )
                      goto LABEL_31;
                  }
                  v41 = -1;
                }
              }
            }
          }
          free2(v40);
        }
        free2(v39);
      }
      free2(v38);
    }
    free2(v37);
    memset_s((unsigned __int8 *)v36, 0xD0u, 0, 0xD0u);
    return v41;
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00474B4C) --------------------------------------------------------
int   sub_474B4C(unsigned __int8 **a1, int a2, int a3, int a4)
{
  unsigned __int8 *v5; // $a0
  unsigned __int8 *v7; // $s0
  int v9; // $v1
  int v11; // $v0
  int v12; // $a0
  int v13; // $v0
  int AsnInteger; // $v0
  int AsnAlgorithmIdentifier; // $v0
  int v16; // $a0
  int v17; // $v1
  unsigned __int16 v18; // [sp+18h] [-10h] BYREF
  unsigned __int8 *v19; // [sp+1Ch] [-Ch] BYREF
  int v20; // [sp+20h] [-8h] BYREF
  int v21; // [sp+24h] [-4h] BYREF

  v5 = *a1;
  v7 = &v5[a2];
  v19 = v5;
  if ( &v5[a2] == v5 )
    goto LABEL_10;
  if ( *v5 == 160 )
  {
    v19 = v5 + 1;
    if ( getAsnLength(&v19, a2 - 1, &v18) < 0 || v7 - v19 < v18 )
      return -31;
    AsnAlgorithmIdentifier = getAsnAlgorithmIdentifier((unsigned int **)&v19, v7 - v19, &v20, &v18);
    v9 = -31;
    if ( AsnAlgorithmIdentifier < 0 )
      return v9;
    if ( a4 )
    {
      v16 = *(_DWORD *)(a3 + 24);
      if ( v16 != v20 )
        return v9;
      v17 = 0;
      if ( v16 != 88 )
      {
        v17 = 2;
        if ( v16 != 414 )
        {
          v17 = 1;
          if ( v16 != 649 )
          {
            v17 = 3;
            if ( v16 != 415 )
            {
              v17 = 4;
              if ( v16 != 416 )
                return -10;
            }
          }
        }
      }
      v5 = v19;
      *(_DWORD *)(a3 + 24) = v17;
    }
    else
    {
      v5 = v19;
      *(_DWORD *)(a3 + 24) = v20;
    }
  }
  if ( v7 == v5 )
    goto LABEL_10;
  if ( *v5 == 161 )
  {
    v19 = v5 + 1;
    if ( getAsnLength(&v19, (_WORD)v7 - ((_WORD)v5 + 1), &v18) < 0 || v7 - v19 < v18 )
      return -31;
    v11 = getAsnAlgorithmIdentifier((unsigned int **)&v19, v7 - v19, &v20, &v18);
    v9 = -31;
    if ( v11 < 0 )
      return v9;
    if ( a4 )
    {
      v12 = v20;
      if ( *(_DWORD *)(a3 + 28) != v20 )
        return v9;
    }
    else
    {
      v12 = v20;
    }
    *(_DWORD *)(a3 + 28) = v12;
    v9 = -10;
    if ( v12 != 2700 )
      return v9;
    v13 = getAsnAlgorithmIdentifier((unsigned int **)&v19, v7 - v19, &v20, &v18);
    v9 = -31;
    if ( v13 < 0 )
      return v9;
    if ( a4 )
    {
      if ( *(_DWORD *)(a3 + 32) != v20 )
        return v9;
      v5 = v19;
      *(_DWORD *)(a3 + 32) = v20;
    }
    else
    {
      v5 = v19;
      *(_DWORD *)(a3 + 32) = v20;
    }
  }
  if ( v7 == v5 )
    goto LABEL_10;
  if ( *v5 == 162 )
  {
    v19 = v5 + 1;
    if ( getAsnLength(&v19, (_WORD)v7 - ((_WORD)v5 + 1), &v18) < 0 || v7 - v19 < v18 )
      return -31;
    AsnInteger = getAsnInteger((char **)&v19, v7 - v19, &v21);
    v9 = -31;
    if ( AsnInteger < 0 )
      return v9;
    if ( a4 )
    {
      if ( *(unsigned __int16 *)(a3 + 36) != v21 )
        return v9;
      v5 = v19;
      *(_WORD *)(a3 + 36) = v21;
    }
    else
    {
      v5 = v19;
      *(_WORD *)(a3 + 36) = v21;
    }
  }
  if ( v7 == v5 )
    goto LABEL_10;
  if ( *v5 != 163 )
    goto LABEL_9;
  v19 = v5 + 1;
  if ( getAsnLength(&v19, (_WORD)v7 - ((_WORD)v5 + 1), &v18) >= 0
    && v7 - v19 >= v18
    && getAsnInteger((char **)&v19, v7 - v19, &v21) >= 0
    && v21 == 1 )
  {
    v5 = v19;
LABEL_9:
    v9 = -31;
    if ( v5 != v7 )
      return v9;
LABEL_10:
    *a1 = v5;
    return 0;
  }
  return -31;
}

//----- (00474F0C) --------------------------------------------------------
int   getSerialNum(int a1, unsigned __int8 **a2, unsigned __int16 a3, int *a4, unsigned __int16 *a5)
{
  unsigned __int8 *v5; // $v1
  int v6; // $a0
  int v9; // $a1
  int v10; // $a2
  int v11; // $s0
  int AsnLength; // $v0
  int v13; // $a0
  int v15; // $v0
  unsigned __int16 v16; // [sp+18h] [-8h] BYREF
  unsigned __int8 *v17; // [sp+1Ch] [-4h] BYREF

  v5 = *a2;
  v17 = v5;
  v6 = *v5;
  v9 = a3;
  if ( v6 != 130 )
  {
    v10 = -31;
    if ( v6 != 2 )
      return v10;
  }
  v17 = v5 + 1;
  if ( !v9 )
    return -31;
  v11 = v9 - 1;
  AsnLength = getAsnLength(&v17, v9 - 1, &v16);
  v10 = -31;
  if ( AsnLength < 0 )
    return v10;
  v13 = v16;
  if ( v11 < v16 )
    return -31;
  *a5 = v16;
  if ( v13 )
  {
    v15 = malloc(v13);
    *a4 = v15;
    if ( !v15 )
    {
      psTraceStr("psError %s", (int)"keyformat/x509.c");
      psTraceInt(":%d ", 4258);
      psError((int)"Memory allocation failure in getSerialNum\n");
      return -8;
    }
    memcpy(v15, v17, v16);
    v17 += v16;
    *a2 = v17;
  }
  else
  {
    *a2 = v17;
  }
  return 0;
}
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (004750A4) --------------------------------------------------------
int   sub_4750A4(int a1, unsigned __int8 **a2, unsigned __int16 a3, int a4, int *a5, _WORD *a6)
{
  unsigned __int8 *v6; // $a0
  int v8; // $t0
  int AsnLength; // $v0
  unsigned int v11; // $v1
  int v12; // $a1
  int v13; // $v0
  unsigned __int8 *v14; // [sp+18h] [-8h] BYREF

  v6 = *a2;
  v14 = *a2;
  v8 = -31;
  if ( a3 )
  {
    v8 = 0;
    if ( *v6 == (a4 | 0x80) )
    {
      v14 = v6 + 1;
      AsnLength = getAsnLength(&v14, a3, a6);
      v8 = -31;
      if ( AsnLength >= 0 )
      {
        v11 = (unsigned __int16)*a6;
        if ( v11 >= 2 )
        {
          v12 = *v14++;
          *a6 = v11 - 1;
          if ( v12 )
          {
            psTraceStr("psAssert %s", (int)"keyformat/x509.c");
            psTraceInt(":%d ", 4574);
            psError((int)"ignore_bits == 0");
          }
          v13 = malloc((unsigned __int16)*a6);
          *a5 = v13;
          if ( v13 )
          {
            memcpy(v13, v14, (unsigned __int16)*a6);
            v8 = 0;
            *a2 = &v14[(unsigned __int16)*a6];
          }
          else
          {
            psTraceStr("psError %s", (int)"keyformat/x509.c");
            psTraceInt(":%d ", 4579);
            psError((int)"Memory allocation error in getImplicitBitString\n");
            return -8;
          }
        }
      }
    }
  }
  return v8;
}
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00475268) --------------------------------------------------------
int   psX509GetSignature(int a1, unsigned __int8 **a2, unsigned __int16 a3, int *a4, _WORD *a5)
{
  unsigned __int8 *v5; // $a0
  unsigned __int8 *v8; // $s0
  int v9; // $v0
  int v10; // $a0
  int AsnLength; // $v0
  unsigned __int8 *v13; // $a1
  unsigned __int16 v14; // $t6
  int v15; // $v0
  unsigned __int16 v16; // [sp+18h] [-8h] BYREF
  unsigned __int8 *v17; // [sp+1Ch] [-4h] BYREF

  v5 = *a2;
  v17 = v5;
  v8 = &v5[a3];
  if ( !a3 )
    return -31;
  v9 = *v5;
  v17 = v5 + 1;
  if ( v9 != 3 )
    return -31;
  AsnLength = getAsnLength(&v17, a3 - 1, &v16);
  v10 = -31;
  if ( AsnLength < 0 )
    return v10;
  v13 = v17;
  if ( v8 - v17 < (unsigned int)v16 || v16 < 0x11u )
    return -31;
  if ( *v17 )
  {
    psTraceStr("psAssert %s", (int)"keyformat/x509.c");
    psTraceInt(":%d ", 2279);
    psError((int)"*p == 0");
    v13 = v17;
  }
  v14 = v16 - 1;
  v17 = v13 + 1;
  *a5 = v16 - 1;
  v15 = malloc(v14);
  *a4 = v15;
  if ( v15 )
  {
    memcpy(v15, v17, (unsigned __int16)*a5);
    v10 = 0;
    *a2 = &v17[(unsigned __int16)*a5];
  }
  else
  {
    psTraceStr("psError %s", (int)"keyformat/x509.c");
    psTraceInt(":%d ", 2286);
    psError((int)"Memory allocation error in getSignature\n");
    return -8;
  }
  return v10;
}
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00475458) --------------------------------------------------------
int   psX509FreeDNStruct(_DWORD *a1)
{
  _DWORD *v2; // $s1
  int v3; // $a0
  _DWORD *v4; // $s0
  int result; // $v0
  _DWORD *v6; // $s1
  int v7; // $a0
  _DWORD *v8; // $s2

  free2(a1[24]);
  free2(*a1);
  free2(a1[1]);
  v2 = (_DWORD *)a1[2];
  while ( v2 )
  {
    v3 = v2[1];
    v4 = v2;
    v2 = (_DWORD *)*v2;
    free2(v3);
    free2(v4);
  }
  free2(a1[3]);
  free2(a1[5]);
  free2(a1[6]);
  result = free2(a1[4]);
  v6 = (_DWORD *)a1[7];
  while ( 1 )
  {
    v8 = v6;
    if ( !v6 )
      break;
    v7 = v6[1];
    v6 = (_DWORD *)*v6;
    free2(v7);
    result = free2(v8);
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (004755C4) --------------------------------------------------------
int   x509FreeExtensions(_DWORD *a1)
{
  int v2; // $s1
  int v3; // $s1
  int v4; // $s2
  int v5; // $a0
  _DWORD *v6; // $s1
  _DWORD *v7; // $s3
  _DWORD *v8; // $a0
  int v9; // $a0
  int v10; // $s1
  int v11; // $s0
  int v12; // $a0
  int v13; // $s1
  int v14; // $s2
  int v15; // $a0
  int v16; // $s1
  int v17; // $s3
  int v18; // $a0
  int v19; // $a0
  int v20; // $a0
  int v21; // $a0
  int result; // $v0
  _DWORD *v23; // $s2
  _DWORD *v24; // $s3
  _DWORD *v25; // $s1
  _DWORD *v26; // $s0
  _DWORD *v27; // $a0
  _DWORD *v28; // $s1
  _DWORD *v29; // $s2
  _DWORD *v30; // $a0
  _DWORD *v31; // $a0
  int v32; // $s0
  int v33; // $a0

  if ( a1 )
  {
    v2 = a1[3];
    if ( v2 )
    {
      do
      {
        v32 = *(_DWORD *)(v2 + 64);
        free2(*(_DWORD *)(v2 + 56));
        v33 = v2;
        v2 = v32;
        free2(v33);
      }
      while ( v32 );
    }
    if ( a1[4] )
    {
      v3 = a1[4];
      do
      {
        v4 = *(_DWORD *)(v3 + 64);
        free2(*(_DWORD *)(v3 + 56));
        v5 = v3;
        v3 = v4;
        free2(v5);
      }
      while ( v4 );
    }
    if ( a1[52] )
    {
      v6 = (_DWORD *)a1[52];
      do
      {
        v7 = (_DWORD *)v6[3];
        free2(*v6);
        free2(v6[1]);
        v8 = v6;
        v6 = v7;
        free2(v8);
      }
      while ( v7 );
    }
    v9 = a1[55];
    if ( v9 )
      free2(v9);
    if ( a1[54] )
    {
      v10 = a1[54];
      do
      {
        v11 = *(_DWORD *)(v10 + 64);
        free2(*(_DWORD *)(v10 + 56));
        v12 = v10;
        v10 = v11;
        free2(v12);
      }
      while ( v11 );
    }
    if ( a1[47] )
    {
      v13 = a1[47];
      do
      {
        v14 = *(_DWORD *)(v13 + 64);
        free2(*(_DWORD *)(v13 + 56));
        v15 = v13;
        v13 = v14;
        free2(v15);
      }
      while ( v14 );
    }
    if ( a1[46] )
    {
      v16 = a1[46];
      do
      {
        v17 = *(_DWORD *)(v16 + 64);
        free2(*(_DWORD *)(v16 + 56));
        v18 = v16;
        v16 = v17;
        free2(v18);
      }
      while ( v17 );
    }
    v19 = a1[8];
    if ( v19 )
      free2(v19);
    v20 = a1[10];
    if ( v20 )
      free2(v20);
    v21 = a1[11];
    if ( v21 )
      free2(v21);
    result = psX509FreeDNStruct(a1 + 12);
    v23 = (_DWORD *)a1[48];
    if ( v23 )
    {
      do
      {
        v24 = (_DWORD *)v23[3];
        free2(*v23);
        v25 = (_DWORD *)v23[2];
        if ( v25 )
        {
          do
          {
            v26 = (_DWORD *)v25[12];
            free2(*v25);
            free2(v25[1]);
            free2(v25[2]);
            v27 = v25;
            v25 = v26;
            free2(v27);
          }
          while ( v26 );
        }
        result = free2(v23);
        v23 = v24;
      }
      while ( v24 );
    }
    v28 = (_DWORD *)a1[51];
    if ( v28 )
    {
      do
      {
        v29 = (_DWORD *)v28[3];
        free2(*v28);
        free2(v28[1]);
        v30 = v28;
        v28 = v29;
        result = free2(v30);
      }
      while ( v29 );
    }
    v31 = (_DWORD *)a1[53];
    if ( v31 )
    {
      if ( *v31 )
      {
        free2(*v31);
        v31 = (_DWORD *)a1[53];
      }
      return free2(v31);
    }
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00475A38) --------------------------------------------------------
int   psX509FreeCert(int a1)
{
  int v1; // $s1
  int v2; // $a0
  int v3; // $a0
  int v4; // $a0
  int v5; // $a0
  int v6; // $a0
  int v7; // $a0
  int v8; // $a0
  int v9; // $v1
  void (  *v10)(int); // $t9
  __int16 *v11; // $a0
  int v12; // $s0
  int result; // $v0

  v1 = a1;
  if ( a1 )
  {
    while ( 1 )
    {
      v2 = *(_DWORD *)(v1 + 784);
      if ( v2 )
        free2(v2);
      psX509FreeDNStruct((_DWORD *)(v1 + 164));
      psX509FreeDNStruct((_DWORD *)(v1 + 296));
      v3 = *(_DWORD *)(v1 + 156);
      if ( v3 )
        free2(v3);
      v4 = *(_DWORD *)(v1 + 436);
      if ( v4 )
        free2(v4);
      v5 = *(_DWORD *)(v1 + 440);
      if ( v5 )
        free2(v5);
      v6 = *(_DWORD *)(v1 + 16);
      if ( v6 )
        free2(v6);
      v7 = *(_DWORD *)(v1 + 448);
      if ( v7 )
        free2(v7);
      v8 = *(_DWORD *)(v1 + 452);
      if ( v8 )
        free2(v8);
      if ( !*(_BYTE *)(v1 + 150) )
        goto LABEL_21;
      v9 = *(_DWORD *)(v1 + 444);
      if ( v9 == 518 )
        break;
      v10 = psRsaClearKey;
      if ( v9 == 645 )
        goto LABEL_24;
      psTraceStr("psAssert %s", (int)"keyformat/x509.c");
      psTraceInt(":%d ", 2243);
      v10 = (void (  *)(int))psError;
      v11 = &word_4A0308;
LABEL_20:
      v10((int)v11);
      *(_BYTE *)(v1 + 150) = 0;
LABEL_21:
      x509FreeExtensions((_DWORD *)(v1 + 460));
      v12 = *(_DWORD *)(v1 + 796);
      result = free2(v1);
      v1 = v12;
      if ( !v12 )
        return result;
    }
    v10 = psEccClearKey;
LABEL_24:
    v11 = (__int16 *)(v1 + 40);
    goto LABEL_20;
  }
  return result;
}
// 4A0308: using guessed type __int16 word_4A0308;
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00475C94) --------------------------------------------------------
int   psX509ValidateGeneralName(unsigned __int8 *a1)
{
  int v1; // $v1
  int v2; // $t3
  unsigned __int8 *v3; // $a1
  int v4; // $a2
  int v5; // $t9
  unsigned __int8 v6; // $t6
  unsigned int v7; // $t5
  int v9; // $v0
  int v10; // $v0
  int v11; // $v0

  v1 = 0;
  if ( !a1 )
    return v1;
  v1 = -1;
  if ( !*a1 )
    return v1;
  v2 = 0;
  v3 = a1;
  v4 = *a1;
  do
  {
    while ( 1 )
    {
      v5 = v4 << 24;
      if ( v3 == a1 )
        goto LABEL_14;
      if ( (char)v4 != 46 )
        goto LABEL_9;
      v9 = (char)*(v3 - 1);
      if ( v9 == 46 )
        return -1;
      if ( (char)v4 != 46 )
        goto LABEL_9;
      if ( v9 == 45 )
        return -1;
      if ( (char)v4 == 46 )
      {
        if ( v9 == 64 )
          return -1;
        if ( (char)v4 != 45 )
          goto LABEL_10;
      }
      else
      {
LABEL_9:
        if ( (char)v4 != 45 )
          goto LABEL_10;
      }
      v10 = (char)*(v3 - 1);
      if ( v10 == 46 )
        return -1;
      if ( (char)v4 == 45 )
      {
        if ( v10 == 45 )
          return -1;
        if ( (char)v4 == 45 )
        {
          if ( v10 == 64 )
            return -1;
          if ( (char)v4 != 64 )
            goto LABEL_11;
          goto LABEL_34;
        }
      }
LABEL_10:
      if ( (char)v4 != 64 )
        goto LABEL_11;
LABEL_34:
      v11 = (char)*(v3 - 1);
      if ( v11 == 46 )
        return -1;
      if ( (char)v4 == 64 )
      {
        if ( v11 == 45 )
          return -1;
        if ( (char)v4 == 64 && v11 == 64 )
          return -1;
      }
LABEL_11:
      v5 = v4 << 24;
      if ( v3 != a1 )
      {
        if ( v3[1] )
        {
          v5 = v4 << 24;
          if ( (unsigned __int8)(v4 - 45) < 2u )
            goto LABEL_5;
        }
        else
        {
          v5 = v4 << 24;
        }
      }
LABEL_14:
      if ( v5 >> 24 == 64 )
      {
        ++v2;
        if ( v3 != a1 )
          break;
      }
      v6 = v4 - 48;
LABEL_16:
      v7 = v6;
LABEL_17:
      if ( v7 < 0xA || (unsigned __int8)(v4 - 65) < 0x1Au )
      {
LABEL_5:
        ++v3;
        goto LABEL_6;
      }
      ++v3;
      if ( (unsigned __int8)(v4 - 97) >= 0x1Au )
        return -1;
LABEL_6:
      v4 = *v3;
      if ( !*v3 )
        goto LABEL_44;
    }
    v6 = v4 - 48;
    if ( !v3[1] )
      goto LABEL_16;
    v7 = (unsigned __int8)(v4 - 48);
    if ( v2 != 1 )
      goto LABEL_17;
    v4 = *++v3;
  }
  while ( *v3 );
LABEL_44:
  if ( v2 )
  {
    v1 = -1;
    if ( (unsigned __int8)(*a1 - 48) < 0xAu )
      return v1;
  }
  return 0;
}

//----- (00475E88) --------------------------------------------------------
int   sub_475E88(int a1, unsigned __int8 **a2, unsigned __int16 a3, unsigned __int8 *a4, int *a5, __int16 a6)
{
  unsigned int v9; // $s1
  int v10; // $s3
  int v11; // $s5
  unsigned __int8 *v12; // $a0
  int v13; // $t0
  int v14; // $s0
  int v15; // $v0
  int v16; // $s0
  char v17; // $t5
  int v18; // $s2
  char *v19; // $a1
  unsigned __int8 *v20; // $s1
  unsigned int v21; // $a1
  unsigned __int8 *v22; // $v1
  __int16 v23; // $s1
  unsigned int v24; // $v1
  unsigned __int8 *v25; // $a1
  unsigned __int8 *v26; // $v1
  unsigned int v27; // $t3
  int v28; // $v0
  unsigned __int16 v29; // $t6
  int result; // $v0
  int v31; // $v0
  unsigned __int8 *v32; // $s7
  int v33; // $t0
  __int16 v34; // $a0
  unsigned int v35; // $a2
  __int16 v36; // $v1
  unsigned __int16 v37; // [sp+18h] [-10h] BYREF
  unsigned __int8 *v38; // [sp+1Ch] [-Ch] BYREF
  unsigned __int8 *v39; // [sp+20h] [-8h]

  LOWORD(v9) = a3;
  v10 = a6;
  v11 = 0;
  if ( *a5 )
    v11 = *a5;
  v12 = *a2;
  v13 = (int)&(*a2)[a3];
  v38 = *a2;
  v39 = (unsigned __int8 *)v13;
  if ( a3 < 4u )
  {
LABEL_28:
    *a2 = v12;
    return 0;
  }
  while ( 2 )
  {
    v14 = v11;
    if ( v11 )
    {
      while ( *(_DWORD *)(v14 + 64) )
        v14 = *(_DWORD *)(v14 + 64);
      v15 = malloc(68);
      *(_DWORD *)(v14 + 64) = v15;
      if ( !v15 )
        return -8;
      v16 = v15;
      memset(v15, 0, 68);
      *(_DWORD *)v16 = a1;
    }
    else
    {
      v31 = malloc(68);
      v16 = v31;
      v11 = v31;
      if ( !v31 )
        return -8;
      memset(v31, 0, 68);
      *(_DWORD *)v16 = a1;
      *a5 = v16;
    }
    v17 = *v38++;
    *(_DWORD *)(v16 + 4) = v17 & 0xF;
    v18 = (unsigned __int16)(v9 - 1);
    switch ( v17 & 0xF )
    {
      case 0:
        strncpy(v16 + 8, "other", 15);
        v32 = v38;
        if ( getAsnLength(&v38, (_WORD)a4 - (_WORD)v38, &v37) < 0 || !v37 || a4 - v38 < (unsigned int)v37 )
          return -31;
        v33 = *v38;
        v34 = (_WORD)v38++ + 1;
        if ( v33 != 6 )
          return -1;
        if ( getAsnLength(&v38, (_WORD)a4 - v34, (_WORD *)(v16 + 60)) < 0 )
          return -1;
        v35 = *(unsigned __int16 *)(v16 + 60);
        if ( a4 - v38 < v35 )
          return -1;
        result = -1;
        if ( v35 < 0x21 )
        {
          memcpy(v16 + 24, v38, v35);
          v38 += *(unsigned __int16 *)(v16 + 60);
          if ( a4 != v38 )
          {
            v36 = (_WORD)v38 + 1;
            if ( *v38 == 160 )
            {
              ++v38;
              if ( getAsnLength(&v38, (_WORD)a4 - v36, &v37) >= 0 )
              {
                if ( v37 )
                {
                  if ( a4 - v38 >= (unsigned int)v37 )
                  {
                    v20 = v38 + 1;
                    if ( a4 != v38 )
                    {
                      ++v38;
                      if ( v20 - v32 < v18 )
                      {
                        v18 = (unsigned __int16)(v18 - ((_WORD)v20 - (_WORD)v32));
                        goto LABEL_13;
                      }
                    }
                  }
                }
              }
            }
          }
          return -31;
        }
        return result;
      case 1:
        v19 = "email";
        goto LABEL_12;
      case 2:
        v19 = "DNS";
        goto LABEL_12;
      case 3:
        v19 = "x400Address";
        goto LABEL_12;
      case 4:
        v19 = "directoryName";
        goto LABEL_12;
      case 5:
        v19 = "ediPartyName";
        goto LABEL_12;
      case 6:
        v19 = (char *)&off_49FFD0;
        goto LABEL_12;
      case 7:
        v19 = "iPAddress";
        goto LABEL_12;
      case 8:
        v19 = "registeredID";
        goto LABEL_12;
      default:
        v19 = "unknown";
LABEL_12:
        strncpy(v16 + 8, v19, 15);
        v20 = v38;
LABEL_13:
        if ( getAsnLength(&v38, (_WORD)a4 - (_WORD)v20, (_WORD *)(v16 + 62)) < 0 )
          return -31;
        v21 = *(unsigned __int16 *)(v16 + 62);
        if ( !*(_WORD *)(v16 + 62) )
          return -31;
        v22 = (unsigned __int8 *)(v38 - v20);
        if ( a4 - v38 < v21 )
          return -31;
        if ( (int)v22 >= v18 )
          return -31;
        v23 = v18 - (_WORD)v22;
        if ( (unsigned __int16)(v18 - (_WORD)v22) < v21 )
          return -31;
        v24 = *(_DWORD *)(v16 + 4);
        if ( v24 == 6 )
          goto LABEL_21;
        if ( v24 >= 7 )
        {
          if ( v24 == 7 && v21 < 4 )
            return -31;
        }
        else if ( v24 - 1 < 2 )
        {
LABEL_21:
          v25 = &v38[*(unsigned __int16 *)(v16 + 62)];
          v26 = v38;
          while ( v26 < v25 )
          {
            v27 = (unsigned __int8)(*v26++ - 32);
            if ( v27 >= 0x5F )
              return -31;
          }
        }
        v28 = malloc(*(unsigned __int16 *)(v16 + 62) + 1);
        *(_DWORD *)(v16 + 56) = v28;
        if ( v28 )
        {
          memset(v28, 0, *(unsigned __int16 *)(v16 + 62) + 1);
          memcpy(*(_DWORD *)(v16 + 56), v38, *(unsigned __int16 *)(v16 + 62));
          v29 = *(_WORD *)(v16 + 62);
          v12 = &v38[v29];
          v38 = v12;
          v9 = (unsigned __int16)(v23 - v29);
          if ( v10 > 0 )
          {
            v10 = (__int16)(v10 - 1);
            result = 0;
            if ( !v10 )
            {
              *a2 = v39;
              return result;
            }
          }
          if ( v9 < 4 )
            goto LABEL_28;
          continue;
        }
        psTraceStr("psError %s", (int)"keyformat/x509.c");
        psTraceInt(":%d ", 2637);
        psError((int)"Memory allocation error: activeName->data\n");
        return -8;
    }
  }
}
// 49FFD0: using guessed type _UNKNOWN *off_49FFD0;
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FD8: using guessed type int   strncpy(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00476464) --------------------------------------------------------
int   sub_476464(int a1, unsigned __int8 *a2, __int16 a3, unsigned __int16 a4, int *a5, _WORD *a6)
{
  int *v7; // $s6
  unsigned int v8; // $s2
  unsigned __int8 *v9; // $s0
  int AsnSequence; // $v0
  int v11; // $a2
  unsigned __int8 *v12; // $a2
  int v13; // $a3
  int v14; // $a0
  unsigned int v15; // $s7
  int v16; // $t1
  unsigned int v18; // $v0
  int v19; // $s0
  int v20; // $t2
  int *v21; // $t1
  int v22; // $t3
  int v23; // $t0
  unsigned __int16 *v24; // $a1
  unsigned int *v25; // $a0
  int v26; // $t8
  int v27; // $t7
  int v28; // $a2
  int v29; // $a0
  unsigned __int8 *v30; // $v1
  int v31; // $v0
  unsigned __int8 *v32; // $a1
  int v33; // $v1
  int AsnLength; // $v0
  int v35; // $v0
  unsigned __int16 v36; // $s2
  unsigned __int8 *v37; // $a1
  int v38; // $v1
  int v39; // $s7
  int v40; // $v0
  int v41; // $v0
  unsigned __int16 v42; // $s2
  unsigned __int8 *v43; // $a1
  int v44; // $v0
  unsigned __int8 *v45; // $v1
  int v46; // $a0
  int v47; // $a0
  unsigned __int8 *v48; // $a1
  int v49; // $a2
  int v50; // $v0
  unsigned __int8 *v51; // $s4
  int v52; // $s1
  _DWORD *v53; // $s0
  int AsnInteger; // $v0
  unsigned int v55[16]; // [sp+18h] [-48h] BYREF
  unsigned __int16 v56; // [sp+58h] [-8h] BYREF
  int v57; // [sp+5Ch] [-4h] BYREF
  unsigned __int8 *v58; // [sp+8Ch] [+2Ch] BYREF

  v58 = a2;
  v7 = a5;
  v8 = a4;
  memset(v55, 0, sizeof(v55));
  v9 = v58;
  AsnSequence = getAsnSequence(&v58, a3 - (_WORD)v58, &v56);
  v11 = -31;
  if ( AsnSequence < 0 )
    return v11;
  v12 = v58;
  v13 = v56;
  v14 = (unsigned __int16)((_WORD)v58 - (_WORD)v9 + v56);
  *a6 = (_WORD)v58 - (_WORD)v9 + v56;
  v15 = (unsigned int)&v9[v14];
  if ( !v13 )
    return -31;
  v16 = *v12;
  v58 = v12 + 1;
  if ( v16 != 6 || getAsnLength(&v58, v8, &v56) < 0 )
    return -31;
  v11 = -31;
  if ( v8 < v56 )
    return v11;
  v18 = asnParseOid(v58, v56, v55);
  v19 = v18;
  v11 = -31;
  if ( !v18 )
    return v11;
  if ( v18 >= 0x11 )
  {
    psTraceStr("psAssert %s", (int)"keyformat/x509.c");
    psTraceInt(":%d ", 2670);
    psError((int)"oidlen <= MAX_OID_LEN");
  }
  v20 = 0;
  v21 = &dword_49FA44;
  v22 = 0;
  do
  {
    v23 = 0;
    if ( v19 > 0 )
    {
      v24 = (unsigned __int16 *)((char *)&unk_49FA24 + 36 * v20);
      v25 = v55;
      do
      {
        v26 = *v24;
        v27 = *(unsigned __int16 *)v25;
        v28 = ++v23;
        ++v25;
        ++v24;
        if ( v26 != v27 )
          break;
        if ( v28 == v19 )
        {
          v29 = *((_DWORD *)&unk_49FA24 + v22 + 8);
          goto LABEL_19;
        }
      }
      while ( v28 < v19 );
    }
    v21 += 9;
    ++v20;
    v22 += 9;
  }
  while ( *v21 );
  v29 = 0;
LABEL_19:
  v30 = &v58[v56];
  v58 = v30;
  if ( v29 != 28 )
  {
    v11 = -31;
    if ( v29 != 29 )
      return v11;
    v31 = getAsnSequence(&v58, a3 - (_WORD)v30, &v56);
    v11 = -31;
    if ( v31 < 0 )
      return v11;
    if ( !v56 )
      return 0;
    v32 = v58;
    if ( (unsigned int)v58 >= v15 )
      return 0;
    if ( *v58 != 48 )
      goto LABEL_25;
    v44 = getAsnSequence(&v58, a3 - (_WORD)v58, &v56);
    v11 = -31;
    if ( v44 < 0 )
      return v11;
    v45 = v58;
    v46 = *v58;
    if ( v46 != 12 && v46 != 26 && v46 != 30 && v46 != 22 )
      return v11;
    v7[11] = *v58;
    v58 = v45 + 1;
    if ( getAsnLength(&v58, v8, &v56) >= 0 && v8 >= v56 )
    {
      v47 = malloc(v56 + 1);
      v7[1] = v47;
      v11 = -8;
      if ( !v47 )
        return v11;
      v48 = v58;
      v49 = v56;
      *((_WORD *)v7 + 17) = v56;
      memcpy(v47, v48, v49);
      *(_BYTE *)(v7[1] + v56) = 0;
      v58 += v56;
      v50 = getAsnSequence(&v58, a3 - (_WORD)v58, &v56);
      v11 = -31;
      if ( v50 < 0 )
        return v11;
      v32 = v58;
      v51 = &v58[v56];
      v52 = 0;
      if ( v58 == v51 )
      {
LABEL_55:
        *((_WORD *)v7 + 19) = v52;
LABEL_25:
        v11 = 0;
        if ( (unsigned int)v32 < v15 )
        {
          v33 = *v32;
          if ( v33 == 12 || v33 == 26 || v33 == 30 || (v11 = -31, v33 == 22) )
          {
            v7[10] = *v32;
            v58 = v32 + 1;
            AsnLength = getAsnLength(&v58, v8, &v56);
            v11 = -31;
            if ( AsnLength >= 0 && v8 >= v56 )
            {
              v35 = malloc(v56 + 1);
              v7[2] = v35;
              v11 = -8;
              if ( v35 )
              {
                v36 = v56;
                v37 = v58;
                *((_WORD *)v7 + 18) = v56;
                memcpy(v35, v37, v36);
                v38 = v7[2];
LABEL_34:
                *(_BYTE *)(v38 + v56) = 0;
                v58 += v56;
                return 0;
              }
            }
          }
        }
        return v11;
      }
      v53 = v7 + 3;
      while ( v52 != 5 )
      {
        ++v52;
        AsnInteger = getAsnInteger((char **)&v58, v56, &v57);
        v11 = -31;
        if ( AsnInteger < 0 )
          return v11;
        v32 = v58;
        *v53++ = v57;
        if ( v32 == v51 )
          goto LABEL_55;
      }
    }
    return -31;
  }
  v39 = *v30;
  v58 = v30 + 1;
  v11 = -31;
  if ( v39 == 22 )
  {
    v40 = getAsnLength(&v58, v8, &v56);
    v11 = -31;
    if ( v40 >= 0 && v8 >= v56 )
    {
      v41 = malloc(v56 + 1);
      v42 = v56;
      v43 = v58;
      *v7 = v41;
      *((_WORD *)v7 + 16) = v42;
      memcpy(v41, v43, v42);
      v38 = *v7;
      goto LABEL_34;
    }
  }
  return v11;
}
// 49FA44: using guessed type int dword_49FA44;
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00476A3C) --------------------------------------------------------
int   sub_476A3C(
        int a1,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned __int16 a4,
        int a5,
        unsigned __int16 *a6)
{
  int v8; // $s5
  unsigned int v9; // $s3
  unsigned __int8 *v10; // $s0
  int AsnSequence; // $v0
  int v12; // $a0
  unsigned __int8 *v13; // $a3
  unsigned __int16 v14; // $t0
  int v15; // $v1
  unsigned __int8 *v16; // $s4
  int AsnLength; // $v0
  unsigned int v19; // $v0
  signed int v20; // $s0
  int v21; // $a2
  signed int i; // $a1
  int v23; // $a3
  unsigned int *v24; // $t0
  unsigned __int8 *v25; // $v1
  int v26; // $v0
  int *v27; // $v0
  unsigned __int8 *v28; // $s2
  unsigned __int8 *v29; // $a1
  int v30; // $v0
  int *v31; // $s1
  _DWORD *v32; // $v0
  int v33; // $v0
  unsigned int v34[16]; // [sp+20h] [-48h] BYREF
  unsigned __int16 v35; // [sp+60h] [-8h] BYREF
  _WORD v36[3]; // [sp+62h] [-6h] BYREF
  unsigned __int8 *v37; // [sp+94h] [+2Ch] BYREF

  v37 = a2;
  v8 = a5;
  v9 = a4;
  memset(v34, 0, sizeof(v34));
  v10 = v37;
  AsnSequence = getAsnSequence(&v37, a3 - (_WORD)v37, &v35);
  v12 = -31;
  if ( AsnSequence < 0 )
    return v12;
  v13 = v37;
  v14 = (_WORD)v37 - (_WORD)v10 + v35;
  *a6 = v14;
  v15 = *v13;
  v16 = &v10[v14];
  v37 = v13 + 1;
  v12 = -31;
  if ( v15 != 6 )
    return v12;
  AsnLength = getAsnLength(&v37, v9, &v35);
  v12 = -31;
  if ( AsnLength < 0 )
    return v12;
  if ( v9 < v35 )
    return v12;
  v19 = asnParseOid(v37, v35, v34);
  v20 = v19;
  v12 = -31;
  if ( !v19 )
    return v12;
  v37 += v35;
  if ( (unsigned __int8)(v19 - 1) >= 0x10u )
    return v12;
  v21 = malloc(4 * v19);
  *(_DWORD *)v8 = v21;
  v12 = -8;
  if ( !v21 )
    return v12;
  for ( i = 0; i < v20; *(_DWORD *)(v23 + v21) = *v24 )
  {
    v23 = 4 * i;
    v24 = &v34[i++];
  }
  v25 = v37;
  *(_WORD *)(v8 + 4) = v20;
  if ( v25 >= v16 || *v25 != 48 )
    return 0;
  v26 = getAsnSequence(&v37, a3 - (_WORD)v25, &v35);
  v12 = -31;
  if ( v26 < 0 )
    return v12;
  v28 = &v37[v35];
  v27 = (int *)malloc(52);
  *(_DWORD *)(v8 + 8) = v27;
  v12 = -8;
  if ( !v27 )
    return v12;
  v29 = v37;
  *v27 = 0;
  v27[1] = 0;
  v27[2] = 0;
  v27[3] = 0;
  v27[4] = 0;
  v27[5] = 0;
  v27[6] = 0;
  v27[7] = 0;
  v27[8] = 0;
  v27[9] = 0;
  v27[10] = 0;
  v27[11] = 0;
  v27[12] = 0;
  v31 = v27;
  v30 = sub_476464(a1, v29, a3, v9, v27, v36);
  v12 = -31;
  if ( v30 < 0 )
    return v12;
  v37 += v36[0];
  if ( v37 < v28 && (unsigned int)v37 < a3 && *v37 == 48 )
  {
    while ( 1 )
    {
      v32 = (_DWORD *)malloc(52);
      v31[12] = (int)v32;
      if ( !v32 )
        break;
      v32[12] = 0;
      *v32 = 0;
      v32[1] = 0;
      v32[2] = 0;
      v32[3] = 0;
      v32[4] = 0;
      v32[5] = 0;
      v32[6] = 0;
      v32[7] = 0;
      v32[8] = 0;
      v32[9] = 0;
      v32[10] = 0;
      v32[11] = 0;
      v31 = (int *)v31[12];
      v33 = sub_476464(a1, v37, a3, v9, v31, v36);
      v12 = -31;
      if ( v33 < 0 )
        return v12;
      v37 += v36[0];
      if ( v37 >= v28 || (unsigned int)v37 >= a3 || *v37 != 48 )
        return 0;
    }
    return -8;
  }
  return 0;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (00476E08) --------------------------------------------------------
int   psX509GetDNAttributes(int a1, unsigned __int8 **a2, unsigned __int16 a3, int a4, unsigned int a5)
{
  int AsnSequence; // $v0
  unsigned __int8 *v8; // $fp
  int v9; // $v1
  __int16 v10; // $s0
  unsigned __int8 *v11; // $s2
  BOOL v12; // $v0
  int v13; // $s5
  unsigned __int16 v14; // $t7
  unsigned __int8 *v15; // $s0
  unsigned __int8 *v16; // $a0
  int v17; // $v1
  unsigned __int8 *v18; // $a0
  unsigned __int8 *v19; // $a1
  unsigned __int16 v20; // $a3
  int v21; // $v1
  int v22; // $a0
  unsigned __int8 *v23; // $a2
  unsigned __int8 *v24; // $v1
  int v25; // $s6
  unsigned int v26; // $s3
  int v27; // $s0
  int v28; // $s1
  int v29; // $v0
  unsigned int i; // $a0
  _BYTE *v31; // $t2
  int v32; // $v0
  unsigned __int16 v33; // $a0
  bool v34; // dc
  int v35; // $v0
  BOOL v36; // $v0
  int v38; // $a0
  unsigned __int16 v39; // $a1
  int v40; // $v0
  unsigned __int16 v41; // $t5
  int v42; // $a0
  unsigned __int16 v43; // $t1
  unsigned __int16 v44; // $s3
  int v45; // $v0
  unsigned __int16 v46; // $a2
  int v47; // $a0
  int v48; // $a0
  unsigned __int16 v49; // $t3
  int v50; // $a0
  unsigned __int16 v51; // $t2
  int v52; // $v0
  int v53; // $a1
  unsigned __int16 v54; // [sp+28h] [-78h] BYREF
  unsigned __int16 v55; // [sp+2Ah] [-76h] BYREF
  unsigned __int16 v56; // [sp+2Ch] [-74h] BYREF
  __int64 v57[12]; // [sp+30h] [-70h] BYREF
  unsigned __int8 *v58; // [sp+90h] [-10h] BYREF
  int v59; // [sp+94h] [-Ch] BYREF
  unsigned int v60; // [sp+98h] [-8h] BYREF

  v58 = *a2;
  v8 = v58;
  AsnSequence = getAsnSequence(&v58, a3, &v54);
  v9 = -31;
  if ( AsnSequence < 0 )
    return v9;
  v10 = (__int16)v58;
  v11 = &v58[v54];
  if ( ((a5 >> 1) & 1) != 0 )
  {
    *(_WORD *)(a4 + 100) = (_WORD)v11 - (_WORD)v8;
    v52 = malloc((unsigned __int16)((_WORD)v11 - (_WORD)v8));
    *(_DWORD *)(a4 + 96) = v52;
    if ( !v52 )
    {
      psTraceStr("psError %s", (int)"keyformat/x509.c");
      v53 = 4632;
LABEL_96:
      psTraceInt(":%d ", v53);
      psError((int)"Memory allocation error in getDNAttributes\n");
      return -8;
    }
    memcpy(v52, v8, *(unsigned __int16 *)(a4 + 100));
    v10 = (__int16)v58;
    v12 = v58 < v11;
  }
  else
  {
    v12 = v58 < v11;
  }
  v13 = 0;
  if ( !v12 )
  {
LABEL_42:
    psSha1Init(v57);
    psSha1Update((int *)v57, (int)v8, v11 - v8);
    psSha1Final(v57, a4 + 32);
    v9 = 0;
    *a2 = v58;
    return v9;
  }
  v14 = (_WORD)v11 - v10;
LABEL_6:
  if ( getAsnSet(&v58, v14, &v55) >= 0 )
  {
    v15 = v58;
    while ( 1 )
    {
      if ( getAsnSequence(&v58, (_WORD)v11 - (_WORD)v15, &v54) < 0 )
        return -31;
      if ( v13 <= 0 )
      {
        v16 = v58;
        if ( v55 != v54 + v58 - v15 )
          v13 = v55 - (v58 - v15) - v54;
      }
      else
      {
        v16 = v58;
        v13 -= v54 + v58 - v15;
      }
      if ( v16 >= v11 )
        return -31;
      v17 = *v16;
      v18 = v16 + 1;
      v58 = v18;
      if ( v17 != 6 )
        return -31;
      if ( getAsnLength(&v58, (_WORD)v11 - (_WORD)v18, &v56) < 0 )
        return -31;
      v19 = v58;
      v20 = v56;
      v21 = v11 - v58;
      v22 = v56;
      v23 = v58;
      if ( v11 - v58 < (unsigned int)v56 )
        return -31;
      *a2 = v58;
      if ( v21 < 2 )
        return -9;
      if ( v22 == 10
        && *v19 == 9
        && v19[1] == 146
        && v19[2] == 38
        && v19[3] == 137
        && v19[4] == 147
        && v19[5] == 242
        && v19[6] == 44
        && v19[7] == 100
        && v19[8] == 1
        && (v24 = v19 + 10, v19[9] == 25) )
      {
        v25 = 25;
      }
      else
      {
        if ( *v23 != 85 || (v58 = v23 + 1, v23[1] != 4) )
        {
          if ( v11 - v19 < (unsigned int)v20 + 1 )
          {
            v9 = -9;
            v58 = v19;
            return v9;
          }
          v58 = &v19[v20 + 1];
          if ( getAsnLength(&v58, (_WORD)v11 - (v20 + (_WORD)v19 + 1), &v54) >= 0 )
          {
            v15 = &v58[v54];
            if ( v11 - v58 >= (unsigned int)v54 )
            {
              v36 = v15 < v11;
              v58 += v54;
LABEL_41:
              v14 = (_WORD)v11 - (_WORD)v15;
              if ( v36 )
                goto LABEL_6;
              goto LABEL_42;
            }
          }
          return -31;
        }
        v58 = v23 + 2;
        if ( v20 != 3 )
          return -9;
        v24 = v23 + 3;
        if ( v11 - (v23 + 2) < 2 )
          return -9;
        v25 = v23[2];
      }
      v58 = v24;
      v26 = *v24;
      v58 = v24 + 1;
      if ( getAsnLength(&v58, (_WORD)v11 - ((_WORD)v24 + 1), &v54) < 0 || v11 - v58 < (unsigned int)v54 )
        return -9;
      v27 = 0;
      if ( v26 >= 0x1F )
        return -10;
      if ( ((1 << v26) & 0x581000) != 0 )
      {
        v27 = 1;
      }
      else if ( ((1 << v26) & 8) == 0 )
      {
        if ( ((1 << v26) & 0x40000000) == 0 )
          return -10;
        v59 = 0;
        v9 = psToUtf8String(a1, (int)v58, v54, 0x1Eu, &v59, (int *)&v60, 2);
        if ( v9 )
          return v9;
        if ( v60 >= 0x7FFE )
        {
          free2(v59);
          return -9;
        }
        v15 = &v58[v54];
        v28 = v59;
        v54 = v60 + 2;
        v58 = v15;
LABEL_31:
        switch ( v25 )
        {
          case 3:
            v50 = *(_DWORD *)(a4 + 24);
            if ( v50 )
            {
              free2(v50);
              *(_WORD *)(a4 + 118) = v26;
              v51 = v54;
              v15 = v58;
            }
            else
            {
              *(_WORD *)(a4 + 118) = v26;
              v51 = v54;
            }
            *(_DWORD *)(a4 + 24) = v28;
            *(_WORD *)(a4 + 120) = v51;
            break;
          case 5:
            v48 = *(_DWORD *)(a4 + 16);
            if ( v48 )
            {
              free2(v48);
              *(_WORD *)(a4 + 122) = v26;
              v49 = v54;
              v15 = v58;
            }
            else
            {
              *(_WORD *)(a4 + 122) = v26;
              v49 = v54;
            }
            *(_DWORD *)(a4 + 16) = v28;
            *(_WORD *)(a4 + 124) = v49;
            break;
          case 6:
            if ( *(_DWORD *)a4 )
            {
              free2(*(_DWORD *)a4);
              *(_WORD *)(a4 + 102) = v26;
              v44 = v54;
              v15 = v58;
            }
            else
            {
              *(_WORD *)(a4 + 102) = v26;
              v44 = v54;
            }
            *(_DWORD *)a4 = v28;
            *(_WORD *)(a4 + 104) = v44;
            break;
          case 8:
            v42 = *(_DWORD *)(a4 + 20);
            if ( v42 )
            {
              free2(v42);
              *(_WORD *)(a4 + 106) = v26;
              v43 = v54;
              v15 = v58;
            }
            else
            {
              *(_WORD *)(a4 + 106) = v26;
              v43 = v54;
            }
            *(_DWORD *)(a4 + 20) = v28;
            *(_WORD *)(a4 + 108) = v43;
            break;
          case 10:
            v47 = *(_DWORD *)(a4 + 4);
            if ( v47 )
            {
              free2(v47);
              *(_WORD *)(a4 + 110) = v26;
              *(_DWORD *)(a4 + 4) = v28;
              v15 = v58;
            }
            else
            {
              *(_WORD *)(a4 + 110) = v26;
              *(_DWORD *)(a4 + 4) = v28;
            }
            *(_WORD *)(a4 + 112) = v54;
            break;
          case 11:
            v45 = malloc(12);
            *(_WORD *)(v45 + 8) = v26;
            v46 = v54;
            v15 = v58;
            *(_DWORD *)v45 = *(_DWORD *)(a4 + 8);
            *(_DWORD *)(v45 + 4) = v28;
            *(_WORD *)(v45 + 10) = v46;
            *(_DWORD *)(a4 + 8) = v45;
            break;
          case 25:
            v40 = malloc(12);
            *(_WORD *)(v40 + 8) = v26;
            v41 = v54;
            v15 = v58;
            *(_DWORD *)v40 = *(_DWORD *)(a4 + 28);
            *(_DWORD *)(v40 + 4) = v28;
            *(_WORD *)(v40 + 10) = v41;
            *(_DWORD *)(a4 + 28) = v40;
            break;
          case 46:
            v38 = *(_DWORD *)(a4 + 12);
            if ( v38 )
            {
              free2(v38);
              *(_WORD *)(a4 + 114) = v26;
              v39 = v54;
              v15 = v58;
            }
            else
            {
              *(_WORD *)(a4 + 114) = v26;
              v39 = v54;
            }
            *(_DWORD *)(a4 + 12) = v28;
            *(_WORD *)(a4 + 116) = v39;
            break;
          default:
            goto LABEL_39;
        }
        goto LABEL_40;
      }
      v29 = malloc(v54 + 2);
      v28 = v29;
      if ( !v29 )
      {
        psTraceStr("psError %s", (int)"keyformat/x509.c");
        v53 = 4847;
        goto LABEL_96;
      }
      memcpy(v29, v58, v54);
      for ( i = 0; i < 2; ++i )
      {
        v31 = (_BYTE *)(v54 + v28 + i);
        *v31 = 0;
      }
      if ( v27 )
      {
        v32 = strlen(v28);
        v33 = v54;
        v34 = v32 != v54;
        v35 = v54;
        if ( v34 )
        {
          free2(v28);
          return -31;
        }
      }
      else
      {
        v33 = v54;
        v35 = v54;
      }
      v15 = &v58[v35];
      v25 = (unsigned int)(v25 - 3) < 0x2C;
      v54 = v33 + 2;
      v58 += v35;
      if ( v25 )
        goto LABEL_31;
LABEL_39:
      free2(v28);
      v15 = v58;
LABEL_40:
      v36 = v15 < v11;
      if ( !v13 )
        goto LABEL_41;
    }
  }
  return -31;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00477754) --------------------------------------------------------
int   getExplicitExtensions(int a1, unsigned __int8 **a2, unsigned __int16 a3, int a4, int a5, char a6)
{
  unsigned __int8 *v6; // $a1
  unsigned __int8 *v8; // $s0
  int v9; // $a0
  unsigned __int8 *v11; // $a2
  unsigned __int8 *v12; // $s4
  unsigned __int8 *v13; // $s2
  __int16 v14; // $a0
  int v15; // $v1
  unsigned int v16; // $v0
  int v17; // $s0
  int v18; // $t0
  int *v19; // $a3
  int v20; // $t1
  int v21; // $a2
  unsigned __int16 *v22; // $a1
  unsigned int *v23; // $a0
  int v24; // $v0
  int v25; // $s1
  BOOL v26; // $s3
  unsigned __int8 *v27; // $a1
  unsigned __int8 *v28; // $v1
  int v29; // $t8
  unsigned __int8 *v30; // $s0
  int v31; // $a1
  unsigned __int8 *v32; // $s0
  __int16 v33; // $v1
  __int16 v34; // $t8
  int v35; // $a1
  unsigned __int8 *v36; // $s1
  int v37; // $t1
  unsigned int v38; // $v0
  int v39; // $s0
  int v40; // $a3
  int *v41; // $t0
  int v42; // $t1
  int v43; // $a2
  unsigned __int16 *v44; // $a1
  unsigned int *v45; // $a0
  int v46; // $v0
  int v47; // $a1
  int v48; // $s3
  unsigned __int8 *v49; // $a2
  int v50; // $t1
  unsigned __int8 *v51; // $s2
  int v52; // $s1
  BOOL v53; // $v0
  unsigned __int16 v54; // $t8
  int v55; // $a1
  __int16 v56; // $a0
  int v57; // $v0
  int v58; // $s0
  int v59; // $a3
  int *v60; // $t0
  int v61; // $t1
  int v62; // $a2
  unsigned __int16 *v63; // $a1
  unsigned int *v64; // $a0
  int v65; // $v0
  int v66; // $s0
  unsigned __int8 *v67; // $a0
  int v68; // $t9
  unsigned __int8 *v69; // $a0
  int v70; // $v0
  int v71; // $t1
  unsigned int v72; // $a0
  int v73; // $v0
  __int16 v74; // $a0
  int v75; // $v1
  int v76; // $s3
  unsigned __int8 *v77; // $a0
  unsigned __int8 *v78; // $s1
  unsigned __int8 v79; // $v1
  unsigned __int8 *v80; // $t5
  int v81; // $s0
  unsigned __int8 *v82; // $a0
  unsigned __int16 v83; // $a1
  int v84; // $v1
  unsigned __int8 *v85; // $s1
  unsigned __int8 *v86; // $a0
  unsigned __int8 *v87; // $s0
  unsigned __int8 *v88; // $a0
  unsigned __int8 *v89; // $v1
  __int16 v90; // $s0
  int *v91; // $v0
  int *v92; // $s0
  __int16 v93; // $s1
  int v94; // $s6
  unsigned __int8 *v95; // $a0
  int *v96; // $s2
  unsigned __int8 *v97; // $s3
  _DWORD *v98; // $v0
  unsigned __int8 *v99; // $s2
  unsigned __int16 v100; // $a3
  unsigned __int8 *v101; // $a1
  int v102; // $s0
  _DWORD *v103; // $v0
  int v104; // $t3
  unsigned __int8 *v105; // $a0
  unsigned __int16 v106; // $a2
  int v107; // $a1
  _DWORD *v108; // $v0
  _DWORD *v109; // $v0
  int v110; // $v0
  unsigned __int16 v111; // $ra
  _DWORD *v112; // $v0
  int v113; // $a0
  __int16 v114; // $v1
  unsigned __int16 v115; // $v0
  int v116; // $s1
  int v117; // $s0
  int v118; // $v0
  int v119; // $a1
  int v120; // $a2
  int v121; // $t8
  int v122; // $t4
  unsigned __int8 *v123; // $a2
  int v124; // $s1
  unsigned __int16 v125; // $v0
  int v126; // $s1
  int v127; // $s0
  int v128; // $v0
  int v129; // $a1
  int v130; // $a2
  int v131; // $t3
  int v132; // $t2
  int v133; // $t8
  unsigned __int8 *v134; // $a1
  __int16 v135; // $v1
  unsigned int v136; // $a0
  int v137; // $v0
  char *v138; // $a0
  unsigned __int16 v139; // [sp+20h] [-F0h] BYREF
  unsigned __int16 v140[3]; // [sp+22h] [-EEh] BYREF
  unsigned int v141[16]; // [sp+28h] [-E8h] BYREF
  unsigned __int16 v142; // [sp+68h] [-A8h] BYREF
  unsigned __int16 v143; // [sp+6Ah] [-A6h] BYREF
  __int16 v144; // [sp+6Ch] [-A4h] BYREF
  unsigned int v145[16]; // [sp+70h] [-A0h] BYREF
  _WORD v146[4]; // [sp+B0h] [-60h] BYREF
  unsigned int v147[16]; // [sp+B8h] [-58h] BYREF
  unsigned __int16 v148; // [sp+F8h] [-18h] BYREF
  unsigned __int8 *v149; // [sp+FCh] [-14h] BYREF
  unsigned __int8 *v150; // [sp+100h] [-10h] BYREF
  unsigned __int8 *v151; // [sp+104h] [-Ch] BYREF
  unsigned __int8 *v152; // [sp+108h] [-8h] BYREF
  int v153; // [sp+10Ch] [-4h]

  v6 = *a2;
  v149 = v6;
  v153 = 0;
  v8 = &v6[a3];
  v9 = -6;
  if ( !a3 )
    return v9;
  *(_DWORD *)(a5 + 4) = 127;
  *(_DWORD *)a5 = a1;
  if ( !a6 )
  {
    v9 = 0;
    if ( *v6 != (a4 | 0xA0) )
      return v9;
    v149 = v6 + 1;
    if ( getAsnLength(&v149, a3 - 1, &v139) < 0 )
      return -31;
    LOWORD(v6) = (_WORD)v149;
    if ( v8 - v149 < (unsigned int)v139 )
      return -31;
  }
  if ( getAsnSequence(&v149, (_WORD)v8 - (_WORD)v6, &v139) < 0 )
    return -31;
  v11 = v149;
  v12 = &v149[v139];
  if ( v8 - v149 < (unsigned int)v139 )
    return -31;
LABEL_9:
  while ( 2 )
  {
    if ( v11 == v12 || *v11 != 48 )
    {
      v9 = 0;
      *a2 = v11;
      return v9;
    }
    if ( getAsnSequence(&v149, (_WORD)v12 - (_WORD)v11, v140) < 0 )
      return -31;
    v13 = v149;
    v14 = (_WORD)v149 + 1;
    if ( v12 - v149 <= 0 )
      return -31;
    v15 = *v149++;
    if ( v15 != 6 )
      return -31;
    if ( getAsnLength(&v149, (_WORD)v12 - v14, &v139) < 0 )
      return -31;
    if ( v12 - v149 < (unsigned int)v139 )
      return -31;
    v16 = asnParseOid(v149, v139, v141);
    v17 = v16;
    if ( !v16 )
      return -31;
    if ( v16 >= 0x11 )
    {
      psTraceStr("psAssert %s", (int)"keyformat/x509.c");
      psTraceInt(":%d ", 2670);
      psError((int)"oidlen <= MAX_OID_LEN");
    }
    v18 = 0;
    v19 = &dword_49FA44;
    v20 = 0;
    do
    {
      v21 = 0;
      if ( v17 > 0 )
      {
        v22 = (unsigned __int16 *)((char *)&unk_49FA24 + 36 * v18);
        v23 = v141;
        do
        {
          v24 = v21 + 1;
          if ( *v22 != *(unsigned __int16 *)v23 )
            break;
          if ( v24 == v17 )
          {
            v25 = *((_DWORD *)&unk_49FA24 + v20 + 8);
            goto LABEL_27;
          }
          ++v21;
          ++v23;
          ++v22;
        }
        while ( v24 < v17 );
      }
      v19 += 9;
      ++v18;
      v20 += 9;
    }
    while ( *v19 );
    v25 = 0;
LABEL_27:
    v26 = 0;
    v149 += v139;
    v27 = v149;
    if ( v12 - v149 <= 0 )
      return -31;
    v28 = v149 + 1;
    if ( *v149 == 1 )
    {
      ++v149;
      if ( v12 - v28 < 2 || v27[1] != 1 )
        return -31;
      v149 = v27 + 2;
      v26 = v27[2] != 0;
      v27 += 3;
      v149 = v27;
    }
    if ( v12 - v27 <= 0 )
      return -31;
    v29 = *v27;
    v149 = v27 + 1;
    if ( v29 != 4 )
      return -31;
    if ( getAsnLength(&v149, (_WORD)v12 - ((_WORD)v27 + 1), &v139) < 0 )
      return -31;
    v30 = v149;
    if ( v12 - v149 < (unsigned int)v139 )
      return -31;
    if ( v26 )
      *(_DWORD *)(a5 + 20) |= 1 << v25;
    switch ( v25 )
    {
      case 1:
        if ( getAsnSequence(&v149, (_WORD)v12 - (_WORD)v30, &v139) < 0 )
          return -31;
        if ( !v139 )
          goto LABEL_172;
        v11 = v149;
        v74 = (_WORD)v149 + 1;
        if ( *v149 != 128 )
          goto LABEL_124;
        ++v149;
        if ( getAsnLength(&v149, (_WORD)v12 - v74, (_WORD *)(a5 + 180)) < 0 )
          return -31;
        v136 = *(unsigned __int16 *)(a5 + 180);
        if ( v12 - v149 < v136 )
          return -31;
        v137 = malloc(v136);
        *(_DWORD *)(a5 + 40) = v137;
        if ( v137 )
        {
          memcpy(v137, v149, *(unsigned __int16 *)(a5 + 180));
          v11 = &v149[*(unsigned __int16 *)(a5 + 180)];
          v149 = v11;
LABEL_124:
          if ( *v11 == 161 )
          {
            v149 = v11 + 1;
            if ( getAsnLength(&v149, (_WORD)v12 - ((_WORD)v11 + 1), &v139) < 0 )
              return -31;
            if ( !v139 )
              return -31;
            if ( v12 - v149 < (unsigned int)v139 )
              return -31;
            v135 = (_WORD)v149 + 1;
            if ( (*v149 ^ 0xA0) != 4 )
              return -31;
            ++v149;
            if ( getAsnLength(&v149, (_WORD)v12 - v135, &v139) < 0
              || v12 - v149 < (unsigned int)v139
              || psX509GetDNAttributes(a1, &v149, (_WORD)v12 - (_WORD)v149, a5 + 48, 0) < 0 )
            {
              return -31;
            }
            v11 = v149;
          }
          v75 = *v11;
          if ( v75 != 130 && v75 != 2 )
            continue;
          if ( getSerialNum(a1, &v149, (_WORD)v12 - (_WORD)v11, (int *)(a5 + 44), &v139) < 0 )
            return -31;
          v11 = v149;
          *(_WORD *)(a5 + 182) = v139;
          continue;
        }
        psTraceStr("psError %s", (int)"keyformat/x509.c");
        psTraceInt(":%d ", 4021);
        v138 = "Mem allocation err: extensions->ak.keyId\n";
LABEL_279:
        psError((int)v138);
        return -8;
      case 2:
        v71 = *v30;
        v149 = v30 + 1;
        if ( v71 != 4 )
          return -31;
        if ( getAsnLength(&v149, (_WORD)v12 - ((_WORD)v30 + 1), (_WORD *)(a5 + 36)) < 0 )
          return -31;
        v72 = *(unsigned __int16 *)(a5 + 36);
        if ( v12 - v149 < v72 )
          return -31;
        v73 = malloc(v72);
        *(_DWORD *)(a5 + 32) = v73;
        if ( !v73 )
        {
          psTraceStr("psError %s", (int)"keyformat/x509.c");
          psTraceInt(":%d ", 4090);
          v138 = "Memory allocation error extensions->sk.id\n";
          goto LABEL_279;
        }
        memcpy(v73, v149, *(unsigned __int16 *)(a5 + 36));
        v11 = &v149[*(unsigned __int16 *)(a5 + 36)];
LABEL_120:
        v149 = v11;
        continue;
      case 3:
        v104 = *v30;
        v149 = v30 + 1;
        if ( v104 != 3 )
          return -31;
        if ( getAsnLength(&v149, (_WORD)v12 - ((_WORD)v30 + 1), &v139) < 0 )
          return -31;
        v105 = v149;
        v106 = v139;
        if ( v12 - v149 < (unsigned int)v139 || v139 < 2u )
          return -31;
        if ( v139 >= 3u && v149[2] == 128 && *v149 == 7 )
        {
          v107 = *(_DWORD *)(a5 + 24) | 0x8000;
          *(_DWORD *)(a5 + 24) = v107;
        }
        else
        {
          v107 = *(_DWORD *)(a5 + 24);
        }
        v11 = &v105[v106];
        *(_DWORD *)(a5 + 24) = v107 | v105[1];
        v149 = v11;
        continue;
      case 4:
        if ( getAsnSequence(&v149, (_WORD)v12 - (_WORD)v30, &v139) < 0 )
          return -31;
        v99 = &v149[v139];
        v98 = (_DWORD *)malloc(16);
        v100 = v140[0];
        v101 = v149;
        *(_DWORD *)(a5 + 192) = v98;
        *v98 = 0;
        v98[1] = 0;
        v98[2] = 0;
        v98[3] = 0;
        v102 = (int)v98;
        if ( sub_476A3C(a1, v101, (unsigned int)v12, v100, (int)v98, &v139) < 0 )
          return -31;
        v149 += v139;
        v11 = v149;
        if ( v149 >= v99 || v149 >= v12 || *v149 != 48 )
          continue;
        while ( 1 )
        {
          v103 = (_DWORD *)malloc(16);
          *(_DWORD *)(v102 + 12) = v103;
          v103[3] = 0;
          *v103 = 0;
          v103[1] = 0;
          v103[2] = 0;
          v102 = *(_DWORD *)(v102 + 12);
          if ( sub_476A3C(a1, v149, (unsigned int)v12, v140[0], v102, &v139) < 0 )
            return -31;
          v149 += v139;
          v11 = v149;
          if ( v149 >= v99 || v149 >= v12 || *v149 != 48 )
            goto LABEL_9;
        }
      case 5:
        v91 = (int *)malloc(16);
        v152 = v149;
        *(_DWORD *)(a5 + 204) = v91;
        *v91 = 0;
        v91[1] = 0;
        v91[2] = 0;
        v91[3] = 0;
        v92 = v91;
        memset(v147, 0, sizeof(v147));
        v93 = (__int16)v152;
        v94 = 0;
        if ( getAsnSequence(&v152, (_WORD)v12 - (_WORD)v152, &v148) < 0 )
          return -31;
        v95 = v152;
        v96 = v92;
        v97 = &v152[v148];
        v139 = (_WORD)v97 - v93;
        if ( v152 >= v97 || *v152 != 48 )
          goto LABEL_179;
        do
        {
          v111 = (_WORD)v12 - (_WORD)v95;
          if ( v94 > 0 )
          {
            v112 = (_DWORD *)malloc(16);
            v96[3] = (int)v112;
            if ( !v112 )
              return -31;
            v112[3] = 0;
            *v112 = 0;
            v112[1] = 0;
            v112[2] = 0;
            v96 = (int *)v96[3];
            v111 = (_WORD)v12 - (_WORD)v152;
          }
          if ( getAsnSequence(&v152, v111, &v148) < 0 )
            return -31;
          v113 = *v152;
          v114 = (_WORD)v152++ + 1;
          if ( v113 != 6 )
            return -31;
          if ( getAsnLength(&v152, (_WORD)v97 - v114, &v148) < 0 )
            return -31;
          if ( v97 - v152 < (unsigned int)v148 )
            return -31;
          memset(v147, 0, sizeof(v147));
          v115 = asnParseOid(v152, v148, v147);
          v116 = v115;
          v117 = 4 * v115;
          if ( !v115 )
            return -31;
          v152 += v148;
          v118 = malloc(4 * v115);
          *v96 = v118;
          memset(v118, 0, v117);
          v119 = 0;
          v120 = *v96;
          do
          {
            v121 = 4 * v119;
            v122 = *(_DWORD *)&v140[2 * v119++ + 75];
            *(_DWORD *)(v121 + v120) = v122;
          }
          while ( v119 < v116 );
          v123 = v152;
          *((_WORD *)v96 + 4) = v116;
          v124 = *v123;
          v152 = v123 + 1;
          if ( v124 != 6 )
            return -31;
          if ( getAsnLength(&v152, (_WORD)v97 - ((_WORD)v123 + 1), &v148) < 0 )
            return -31;
          if ( v97 - v152 < (unsigned int)v148 )
            return -31;
          memset(v147, 0, sizeof(v147));
          v125 = asnParseOid(v152, v148, v147);
          v126 = v125;
          v127 = 4 * v125;
          if ( !v125 )
            return -31;
          v152 += v148;
          v128 = malloc(4 * v125);
          v96[1] = v128;
          memset(v128, 0, v127);
          v129 = 0;
          v130 = v96[1];
          do
          {
            v131 = 4 * v129;
            v132 = *(_DWORD *)&v140[2 * v129++ + 75];
            *(_DWORD *)(v131 + v130) = v132;
          }
          while ( v129 < v126 );
          v95 = v152;
          *((_WORD *)v96 + 5) = v126;
          ++v94;
        }
        while ( v95 < v97 && *v95 == 48 );
LABEL_179:
        if ( v95 != v97 )
          return -31;
        v84 = v139;
        goto LABEL_141;
      case 6:
        if ( getAsnSequence(&v149, (_WORD)v12 - (_WORD)v30, &v139) < 0
          || sub_475E88(a1, &v149, v139, v12, (int *)(a5 + 12), -1) < 0 )
        {
          return -31;
        }
        v11 = v149;
        continue;
      case 7:
        if ( getAsnSequence(&v149, (_WORD)v12 - (_WORD)v30, &v139) < 0
          || sub_475E88(a1, &v149, v139, v12, (int *)(a5 + 16), -1) < 0 )
        {
          return -31;
        }
        goto LABEL_172;
      case 9:
        if ( getAsnSequence(&v149, (_WORD)v12 - (_WORD)v30, &v139) < 0 )
          return -31;
        if ( v139 )
        {
          v11 = v149;
          if ( *v149 == 1 )
          {
            if ( v12 - v149 < 3 )
              return -31;
            ++v149;
            v133 = v11[1];
            v134 = v11 + 2;
            v149 = v11 + 2;
            if ( v133 != 1 )
              return -31;
            if ( v11[2] )
            {
              v11 += 3;
              *(_DWORD *)(a5 + 4) = 255;
            }
            else
            {
              v11 += 3;
              *(_DWORD *)(a5 + 4) = 0;
            }
            v149 = v134 + 1;
          }
          else
          {
            *(_DWORD *)(a5 + 4) = 0;
          }
          if ( *v11 == 2 )
          {
            if ( getAsnInteger((char **)&v149, v12 - v11, (int *)(a5 + 8)) >= 0 )
            {
              v11 = v149;
              continue;
            }
            return -31;
          }
          *(_DWORD *)(a5 + 8) = -1;
        }
        else
        {
          v11 = v149;
          *(_DWORD *)(a5 + 4) = 0;
        }
        continue;
      case 10:
        if ( v26 || getAsnSequence(&v149, (_WORD)v12 - (_WORD)v30, v140) < 0 )
          return -31;
        if ( !v140[0] )
          goto LABEL_172;
        while ( 1 )
        {
          v85 = v149;
          v86 = v149;
          if ( *v149 == 160 )
          {
            v86 = ++v149;
            v153 = 0;
          }
          if ( *v86 == 161 )
          {
            v149 = ++v86;
            v153 = 1;
          }
          v142 = 0;
          if ( getAsnLength(&v149, (_WORD)v12 - (_WORD)v86, &v142) < 0 )
            return -31;
          if ( !v142 )
            return -31;
          v87 = v149;
          v88 = (unsigned __int8 *)(v149 - v85);
          if ( v12 - v149 < (unsigned int)v142 || v140[0] < (int)&v88[v142] )
            return -31;
          v140[0] -= (_WORD)v88 + v142;
          if ( v153 )
            break;
          while ( 1 )
          {
            if ( getAsnSequence(&v149, (_WORD)v12 - (_WORD)v87, &v139) < 0 )
              return -31;
            if ( v142 < v139 + v149 - v87 )
              return -31;
            v142 -= (_WORD)v149 - (_WORD)v87 + v139;
            if ( sub_475E88(a1, &v149, v139, v12, (int *)(a5 + 184), -1) < 0 )
              return -31;
            if ( !v142 )
              break;
            v87 = v149;
          }
LABEL_255:
          if ( !v140[0] )
          {
            v11 = v149;
            goto LABEL_9;
          }
        }
        while ( getAsnSequence(&v149, (_WORD)v12 - (_WORD)v87, &v139) >= 0 )
        {
          v89 = (unsigned __int8 *)(v139 + v149 - v87);
          v90 = (_WORD)v149 - (_WORD)v87 + v139;
          if ( v142 < (int)v89 )
            break;
          v142 -= v90;
          if ( sub_475E88(a1, &v149, v139, v12, (int *)(a5 + 188), -1) < 0 )
            break;
          if ( !v142 )
            goto LABEL_255;
          v87 = v149;
        }
        return -31;
      case 11:
        v151 = v30;
        v76 = 0;
        if ( getAsnSequence(&v151, (_WORD)v12 - (_WORD)v30, v146) < 0 )
          return -31;
        v77 = v151;
        v78 = &v151[v146[0]];
        v139 = (_WORD)v78 - (_WORD)v30;
        if ( !v146[0] )
          goto LABEL_140;
        v79 = *v151;
        v80 = v151 + 1;
        if ( (unsigned __int8)(*v151 + 0x80) >= 2u )
          goto LABEL_139;
        do
        {
          v151 = v80;
          v81 = v79;
          if ( getAsnLength(&v151, (_WORD)v78 - (_WORD)v80, v146) < 0 )
            return -31;
          v82 = v151;
          v83 = v146[0];
          if ( v78 - v151 < (unsigned int)v146[0] || v146[0] != 1 )
            return -31;
          if ( v81 == 128 )
            *(_DWORD *)(a5 + 196) = *v151;
          else
            *(_DWORD *)(a5 + 200) = *v151;
          ++v76;
          v77 = &v82[v83];
          v151 = v77;
          if ( v76 >= 2 )
            break;
          v79 = *v77;
          v80 = v77 + 1;
        }
        while ( (unsigned __int8)(*v77 + 0x80) < 2u );
LABEL_139:
        if ( v77 != v78 )
          return -31;
LABEL_140:
        v84 = v139;
LABEL_141:
        v11 = &v149[v84];
        goto LABEL_120;
      case 12:
        if ( getAsnSequence(&v149, (_WORD)v12 - (_WORD)v30, v140) < 0 )
          return -31;
        v11 = v149;
        v35 = v140[0];
        v36 = v149;
LABEL_66:
        if ( !v35 )
          continue;
        v37 = *v11;
        v149 = v11 + 1;
        if ( v37 != 6 )
          return -31;
        if ( getAsnLength(&v149, v35, &v139) < 0 )
          return -31;
        if ( v140[0] < (unsigned int)v139 )
          return -31;
        v38 = asnParseOid(v149, v139, v141);
        v39 = v38;
        if ( !v38 )
          return -31;
        if ( v38 >= 0x11 )
        {
          psTraceStr("psAssert %s", (int)"keyformat/x509.c");
          psTraceInt(":%d ", 2670);
          psError((int)"oidlen <= MAX_OID_LEN");
        }
        v40 = 0;
        v41 = &dword_49FA44;
        v42 = 0;
        do
        {
          v43 = 0;
          if ( v39 > 0 )
          {
            v44 = (unsigned __int16 *)((char *)&unk_49FA24 + 36 * v40);
            v45 = v141;
            do
            {
              v46 = v43 + 1;
              if ( *v44 != *(unsigned __int16 *)v45 )
                break;
              if ( v46 == v39 )
              {
                v47 = *((_DWORD *)&unk_49FA24 + v42 + 8);
                goto LABEL_81;
              }
              ++v43;
              ++v45;
              ++v44;
            }
            while ( v46 < v39 );
          }
          v41 += 9;
          ++v40;
          v42 += 9;
        }
        while ( *v41 );
        v47 = 0;
LABEL_81:
        v149 += v139;
        v11 = v149;
        if ( v140[0] >= (unsigned int)(v149 - v36) )
        {
          v140[0] -= (_WORD)v149 - (_WORD)v36;
          v36 = v149;
          switch ( v47 )
          {
            case 21:
              *(_DWORD *)(a5 + 28) |= 1u;
              break;
            case 22:
              *(_DWORD *)(a5 + 28) |= 2u;
              break;
            case 23:
              *(_DWORD *)(a5 + 28) |= 4u;
              break;
            case 24:
              *(_DWORD *)(a5 + 28) |= 8u;
              break;
            case 25:
              *(_DWORD *)(a5 + 28) |= 0x10u;
              break;
            case 26:
              *(_DWORD *)(a5 + 28) |= 0x100u;
              break;
            case 27:
              *(_DWORD *)(a5 + 28) |= 0x200u;
              break;
            default:
              break;
          }
          v35 = v140[0];
          goto LABEL_66;
        }
        return -31;
      case 13:
        if ( getAsnSequence(&v149, (_WORD)v12 - (_WORD)v30, v140) < 0 )
          return -31;
        if ( v140[0] )
        {
          v11 = v149;
          while ( 1 )
          {
            v32 = v11;
            if ( getAsnSequence(&v149, (_WORD)v12 - (_WORD)v11, &v139) < 0 )
              return -31;
            v11 = v149;
            if ( v140[0] < v139 + v149 - v32 )
              return -31;
            v140[0] -= (_WORD)v149 - (_WORD)v32 + v139;
            v31 = *v149;
            if ( v31 == 160 )
            {
              ++v149;
              if ( getAsnLength(&v149, (_WORD)v12 - ((_WORD)v11 + 1), &v139) < 0 )
                return -31;
              if ( !v139 )
                return -31;
              v33 = (__int16)v149;
              if ( v12 - v149 < (unsigned int)v139 )
                return -31;
              if ( (*v149 & 0xF) != 0 )
              {
                v34 = (_WORD)v149 + 1;
                if ( (*v149 & 0xF) != 1 )
                  return -31;
                ++v149;
                if ( getAsnLength(&v149, (_WORD)v12 - v34, &v139) < 0 )
                  return -31;
                if ( !v139 )
                  return -31;
                v11 = &v149[v139];
                if ( v12 - v149 < (unsigned int)v139 )
                  return -31;
                v149 += v139;
              }
              else
              {
                ++v149;
                if ( getAsnLength(&v149, (_WORD)v12 - (v33 + 1), &v139) < 0
                  || !v139
                  || v12 - v149 < (unsigned int)v139
                  || sub_475E88(a1, &v149, v139, v12, (int *)(a5 + 216), -1) > 0 )
                {
                  return -31;
                }
                v11 = v149;
              }
              v31 = *v11;
            }
            if ( v31 == 161 )
            {
              v149 = v11 + 1;
              if ( getAsnLength(&v149, (_WORD)v12 - ((_WORD)v11 + 1), &v139) < 0 )
                return -31;
              if ( !v139 )
                return -31;
              v11 = &v149[v139];
              if ( v12 - v149 < (unsigned int)v139 )
                return -31;
              v149 += v139;
            }
            if ( *v11 == 162 )
            {
              v149 = v11 + 1;
              if ( getAsnLength(&v149, (_WORD)v12 - ((_WORD)v11 + 1), &v139) < 0 )
                return -31;
              if ( !v139 )
                return -31;
              v11 = &v149[v139];
              if ( v12 - v149 < (unsigned int)v139 )
                return -31;
              v149 += v139;
            }
            if ( !v140[0] )
              goto LABEL_9;
          }
        }
LABEL_172:
        v11 = v149;
        continue;
      case 14:
        if ( getSerialNum(a1, &v149, (_WORD)v12 - (_WORD)v30, (int *)(a5 + 220), &v139) < 0 )
          return -31;
        v11 = v149;
        *(_DWORD *)(a5 + 224) = v139;
        continue;
      case 15:
        goto LABEL_42;
      case 18:
        v150 = v30;
        memset(v145, 0, sizeof(v145));
        v48 = 0;
        if ( getAsnSequence(&v150, (_WORD)v12 - (_WORD)v30, &v143) < 0 )
          return -31;
        v49 = v150;
        v50 = *(_DWORD *)(a5 + 208);
        v51 = &v150[v143];
        v139 = (_WORD)v51 - (_WORD)v30;
        if ( v50 )
          goto LABEL_85;
        v108 = (_DWORD *)malloc(16);
        *(_DWORD *)(a5 + 208) = v108;
        if ( !v108 )
          return -31;
        v49 = v150;
        v48 = 1;
        v108[3] = 0;
        *v108 = 0;
        v108[1] = 0;
        v108[2] = 0;
LABEL_85:
        v52 = *(_DWORD *)(a5 + 208);
        v53 = v49 < v51;
        while ( 2 )
        {
          if ( !v53 || *v49 != 48 )
            goto LABEL_140;
          while ( *(_DWORD *)(v52 + 12) )
            v52 = *(_DWORD *)(v52 + 12);
          v54 = (_WORD)v12 - (_WORD)v49;
          if ( v48 )
          {
            v48 = 0;
          }
          else
          {
            v109 = (_DWORD *)malloc(16);
            *(_DWORD *)(v52 + 12) = v109;
            if ( !v109 )
              return -31;
            v109[3] = 0;
            *v109 = 0;
            v109[1] = 0;
            v109[2] = 0;
            v52 = *(_DWORD *)(v52 + 12);
            v54 = (_WORD)v12 - (_WORD)v150;
          }
          if ( getAsnSequence(&v150, v54, &v144) < 0 )
            return -31;
          v55 = *v150;
          v56 = (_WORD)v150++ + 1;
          if ( v55 != 6 )
            return -31;
          if ( getAsnLength(&v150, (_WORD)v51 - v56, &v143) < 0 )
            return -31;
          if ( v51 - v150 < (unsigned int)v143 )
            return -31;
          memset(v145, 0, sizeof(v145));
          v57 = (unsigned __int16)asnParseOid(v150, v143, v145);
          v58 = (unsigned __int8)v57;
          if ( !v57 )
            return -31;
          if ( (unsigned __int8)v57 >= 0x11u )
          {
            psTraceStr("psAssert %s", (int)"keyformat/x509.c");
            psTraceInt(":%d ", 2670);
            psError((int)"oidlen <= MAX_OID_LEN");
          }
          v59 = 0;
          v60 = &dword_49FA44;
          v61 = 0;
          do
          {
            v62 = 0;
            if ( v58 > 0 )
            {
              v63 = (unsigned __int16 *)((char *)&unk_49FA24 + 36 * v59);
              v64 = v145;
              do
              {
                v65 = v62 + 1;
                if ( *v63 != *(unsigned __int16 *)v64 )
                  break;
                if ( v65 == v58 )
                {
                  v66 = *((_DWORD *)&unk_49FA24 + v61 + 8);
                  goto LABEL_108;
                }
                ++v62;
                ++v64;
                ++v63;
              }
              while ( v65 < v58 );
            }
            v60 += 9;
            ++v59;
            v61 += 9;
          }
          while ( *v60 );
          v66 = 0;
LABEL_108:
          v67 = &v150[v143];
          v150 = v67;
          if ( (unsigned int)(v66 - 30) < 2 )
          {
            v68 = *v67;
            v69 = v67 + 1;
            v150 = v69;
            if ( v68 == 134
              && getAsnLength(&v150, (_WORD)v51 - (_WORD)v69, &v143) >= 0
              && v51 - v150 >= (unsigned int)v143 )
            {
              if ( v66 == 31 )
              {
                v110 = malloc(v143);
                *(_DWORD *)v52 = v110;
                if ( v110 )
                {
                  memcpy(v110, v150, v143);
                  v49 = &v150[v143];
                  v53 = v49 < v51;
                  *(_WORD *)(v52 + 8) = v143;
                  v150 = v49;
                  continue;
                }
              }
              else
              {
                v70 = malloc(v143);
                *(_DWORD *)(v52 + 4) = v70;
                if ( v70 )
                {
                  memcpy(v70, v150, v143);
                  v49 = &v150[v143];
                  v53 = v49 < v51;
                  *(_WORD *)(v52 + 10) = v143;
                  v150 = v49;
                  continue;
                }
              }
            }
          }
          return -31;
        }
      default:
        if ( v26 )
        {
          psTrace((int)"An unsupported critical extension was encountered.  X.509 specifications say connections must be "
                       "terminated in this case. Define ALLOW_UNKNOWN_CRITICAL_EXTENSIONS to bypass this rule if testing "
                       "and email Inside support to inquire about this extension.\n");
          return -31;
        }
LABEL_42:
        v11 = &v13[v140[0]];
        v149 = v11;
        continue;
    }
  }
}
// 49FA44: using guessed type int dword_49FA44;
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00479370) --------------------------------------------------------
int   psX509ParseCert(int a1, unsigned __int8 *a2, int a3, int *a4, unsigned int a5)
{
  int v6; // $v0
  int v8; // $s1
  unsigned __int8 *v9; // $s2
  unsigned __int8 *v10; // $s7
  int AsnSequence32; // $v0
  unsigned __int8 *v12; // $s3
  int v13; // $s5
  __int16 v14; // $v1
  unsigned __int8 *v15; // $a1
  int v16; // $v0
  int v17; // $s6
  unsigned __int8 *v18; // $a0
  int v19; // $a1
  int v20; // $v1
  int v21; // $s4
  BOOL v22; // $s4
  unsigned __int8 *v23; // $a0
  int v24; // $v0
  int AsnAlgorithmIdentifier; // $v0
  int v27; // $a1
  int DNAttributes; // $v0
  int *v29; // $s4
  int v30; // $a1
  unsigned __int8 *v31; // $s0
  int v32; // $t4
  unsigned __int8 *v33; // $v1
  unsigned __int16 v34; // $a1
  int v35; // $v0
  unsigned __int8 *v36; // $a2
  unsigned __int16 v37; // $t0
  int v38; // $v0
  int v39; // $t1
  int v40; // $v0
  char *v41; // $a0
  int *v42; // $a2
  int *v43; // $a3
  int v44; // $v0
  int v45; // $a1
  int v46; // $a0
  int v47; // $ra
  int v48; // $s4
  int v49; // $s0
  unsigned int v50; // $v0
  unsigned int v51; // $v0
  int *v52; // $a2
  int *v53; // $a3
  int v54; // $t8
  int v55; // $t7
  int v56; // $t6
  int v57; // $t5
  int v58; // $a0
  int v59; // $v0
  unsigned __int16 v60; // $a3
  int v61; // $v0
  __int16 v62; // $s0
  __int16 v63; // $t2
  unsigned __int16 v64; // $s2
  unsigned __int8 *v65; // $t3
  int v66; // $v1
  int v67; // $v0
  unsigned int v68; // $v0
  int v69; // $ra
  int v70; // $t8
  int v71; // $t7
  int v72; // $a1
  int v73; // $v1
  int v74; // $v0
  int v75; // $v0
  int v76; // $v0
  int EcPubKey; // $v0
  unsigned __int16 v78; // $v0
  int v79; // $s2
  int Signature; // $v0
  _DWORD v81[6]; // [sp+20h] [-208h] BYREF
  int v82[52]; // [sp+38h] [-1F0h] BYREF
  unsigned __int16 v83; // [sp+108h] [-120h] BYREF
  unsigned __int16 v84; // [sp+10Ah] [-11Eh] BYREF
  unsigned __int16 v85; // [sp+10Ch] [-11Ch] BYREF
  unsigned __int16 v86; // [sp+10Eh] [-11Ah] BYREF
  _WORD v87[4]; // [sp+110h] [-118h] BYREF
  _DWORD v88[8]; // [sp+118h] [-110h] BYREF
  char v89; // [sp+138h] [-F0h] BYREF
  _DWORD v90[12]; // [sp+148h] [-E0h] BYREF
  int v91[12]; // [sp+178h] [-B0h] BYREF
  int v92[8]; // [sp+1A8h] [-80h] BYREF
  char v93; // [sp+1C8h] [-60h] BYREF
  _DWORD v94[12]; // [sp+1D8h] [-50h] BYREF
  unsigned __int8 *v95; // [sp+208h] [-20h]
  unsigned __int8 *v96; // [sp+20Ch] [-1Ch] BYREF
  unsigned int v97; // [sp+210h] [-18h] BYREF
  unsigned __int8 *v98; // [sp+214h] [-14h] BYREF
  unsigned __int8 *v99; // [sp+218h] [-10h] BYREF
  int v100; // [sp+21Ch] [-Ch]
  unsigned int v101; // [sp+220h] [-8h]
  unsigned __int8 *v102; // [sp+224h] [-4h]

  v6 = malloc(800);
  v8 = v6;
  *a4 = v6;
  v100 = 0;
  if ( !v6 )
  {
    psTraceStr("psError %s", (int)"keyformat/x509.c");
    psTraceInt(":%d ", 1364);
    psError((int)"Memory allocation failure in psX509ParseCert\n");
    return -8;
  }
  memset(v6, 0, 800);
  v9 = a2;
  v10 = &a2[a3];
  v95 = a2;
  *(_DWORD *)(v8 + 4) = 1;
  *(_DWORD *)(v8 + 464) = 127;
  *(_DWORD *)v8 = a1;
  v96 = a2;
  AsnSequence32 = getAsnSequence32(&v96, a3, &v97, 0);
  v12 = &a2[a3];
  v13 = 0;
  if ( AsnSequence32 < 0 )
    goto LABEL_37;
LABEL_3:
  v14 = v97;
  if ( v97 > 0xFFFF )
  {
    psTraceStr("psAssert %s", (int)"keyformat/x509.c");
    psTraceInt(":%d ", 701);
    v13 = -1;
    psError((int)"oneCertLen <= 0xFFFF");
    v22 = v12 < v96;
    goto LABEL_27;
  }
  v15 = v96;
  v12 = &v96[v97];
  if ( (a5 & 1) != 0 )
  {
    *(_WORD *)(v8 + 788) = (_WORD)v96 - (_WORD)v9 + v97;
    v16 = malloc((unsigned __int16)((_WORD)v15 - (_WORD)v9 + v14));
    *(_DWORD *)(v8 + 784) = v16;
    if ( !v16 )
    {
      psTraceStr("psError %s", (int)"keyformat/x509.c");
      psTraceInt(":%d ", 717);
      v13 = -8;
      psError((int)"Memory allocation error in psX509ParseCert\n");
      v22 = v12 < v96;
LABEL_27:
      while ( !v22 )
      {
LABEL_28:
        v95 = v12;
        if ( v13 )
          goto LABEL_15;
LABEL_29:
        ++v100;
LABEL_30:
        if ( v95 == v10 || v95 >= v10 + 1 || v10 - v95 < 257 || !*v95 && !v95[1] )
        {
          v20 = -31;
          if ( v100 )
          {
            v20 = v100;
            if ( ((a5 >> 2) & 1) == 0 )
              return v95 - a2;
          }
          return v20;
        }
        v24 = malloc(800);
        *(_DWORD *)(v8 + 796) = v24;
        if ( !v24 )
        {
          psTraceStr("psError %s", (int)"keyformat/x509.c");
          psTraceInt(":%d ", 1425);
          psError((int)"Memory allocation error in psX509ParseCert\n");
          return -8;
        }
        v8 = v24;
        memset(v24, 0, 800);
        *(_DWORD *)v8 = a1;
        v9 = v95;
        *(_DWORD *)(v8 + 4) = 1;
        *(_DWORD *)(v8 + 464) = 127;
        *(_DWORD *)v8 = a1;
        v96 = v9;
        AsnSequence32 = getAsnSequence32(&v96, v10 - v9, &v97, 0);
        v12 = &v9[a3];
        v13 = 0;
        if ( AsnSequence32 >= 0 )
          goto LABEL_3;
LABEL_37:
        v18 = v96;
        v13 = AsnSequence32;
LABEL_23:
        v22 = v12 < v18;
      }
      goto LABEL_14;
    }
    memcpy(v16, v9, *(unsigned __int16 *)(v8 + 788));
    v15 = v96;
  }
  v17 = (int)v15;
  AsnSequence32 = getAsnSequence(&v96, (_WORD)v12 - (_WORD)v15, &v83);
  if ( AsnSequence32 < 0 )
    goto LABEL_37;
  v18 = v96;
  v19 = (unsigned __int16)((_WORD)v12 - (_WORD)v96);
  v101 = (unsigned __int16)(v83 + (_WORD)v96 - v17);
  v102 = &v96[v83];
  v98 = v96;
  if ( (_WORD)v12 == (_WORD)v96 )
    goto LABEL_22;
  if ( *v96 == 160 )
  {
    v21 = v19 - 1;
    v98 = v96 + 1;
    if ( getAsnLength(&v98, v19 - 1, &v85) >= 0
      && v21 >= v85
      && getAsnInteger((char **)&v98, v85, (int *)(v8 + 152)) >= 0 )
    {
      v18 = v98;
      v96 = v98;
      goto LABEL_11;
    }
    v18 = v96;
LABEL_22:
    v13 = -31;
    goto LABEL_23;
  }
  *(_DWORD *)(v8 + 152) = 0;
LABEL_11:
  if ( *(_DWORD *)(v8 + 152) != 2 )
  {
    v13 = -10;
    *(_DWORD *)(v8 + 4) = 3;
    goto LABEL_13;
  }
  AsnSequence32 = getSerialNum(a1, &v96, (_WORD)v12 - (_WORD)v18, (int *)(v8 + 156), (unsigned __int16 *)(v8 + 160));
  if ( AsnSequence32 < 0 )
    goto LABEL_37;
  AsnAlgorithmIdentifier = getAsnAlgorithmIdentifier((unsigned int **)&v96, v12 - v96, (int *)(v8 + 12), &v84);
  if ( AsnAlgorithmIdentifier < 0 )
  {
    v18 = v96;
    v13 = AsnAlgorithmIdentifier;
    *(_DWORD *)(v8 + 4) = 11;
    goto LABEL_23;
  }
  if ( v84 )
  {
    if ( *(_DWORD *)(v8 + 12) != 1678 )
    {
LABEL_42:
      v23 = v96;
      v13 = -10;
LABEL_26:
      v22 = v12 < v23;
      goto LABEL_27;
    }
    AsnSequence32 = getAsnSequence(&v96, (_WORD)v12 - (_WORD)v96, &v83);
    if ( AsnSequence32 < 0 )
      goto LABEL_37;
    v27 = v83;
    *(_DWORD *)(v8 + 28) = 2700;
    *(_WORD *)(v8 + 36) = 20;
    *(_DWORD *)(v8 + 24) = 0;
    if ( v27 )
    {
      AsnSequence32 = sub_474B4C(&v96, v27, v8, 0);
      if ( AsnSequence32 < 0 )
        goto LABEL_37;
    }
  }
  DNAttributes = psX509GetDNAttributes(a1, &v96, (_WORD)v12 - (_WORD)v96, v8 + 164, a5);
  v29 = (int *)(v8 + 440);
  if ( DNAttributes < 0 )
  {
    v18 = v96;
    v13 = DNAttributes;
    *(_DWORD *)(v8 + 4) = 12;
    goto LABEL_23;
  }
  v30 = (unsigned __int16)((_WORD)v12 - (_WORD)v96);
  v99 = v96;
  v31 = &v96[v30];
  if ( (_WORD)v12 == (_WORD)v96 )
    goto LABEL_77;
  v32 = *v96;
  v99 = v96 + 1;
  if ( v32 != 48 )
    goto LABEL_77;
  if ( getAsnLength(&v99, v30 - 1, &v86) < 0 )
    goto LABEL_77;
  v33 = v99;
  v34 = v86;
  if ( v31 - v99 < (unsigned int)v86 )
    goto LABEL_77;
  if ( v31 - v99 <= 0 )
    goto LABEL_77;
  if ( (unsigned __int8)(*v99 - 23) >= 2u )
    goto LABEL_77;
  *(_DWORD *)(v8 + 428) = *v99;
  v99 = v33 + 1;
  if ( getAsnLength(&v99, v34, v87) < 0 || v31 - v99 < (unsigned int)v87[0] || v87[0] >= 0x21u )
    goto LABEL_77;
  v35 = malloc(v87[0] + 1);
  *(_DWORD *)(v8 + 436) = v35;
  if ( !v35 )
  {
    psTraceStr("psError %s", (int)"keyformat/x509.c");
    psTraceInt(":%d ", 4503);
    v41 = "Memory allocation error in getTimeValidity for notBefore\n";
    goto LABEL_82;
  }
  memcpy(v35, v99, v87[0]);
  *(_BYTE *)(*(_DWORD *)(v8 + 436) + v87[0]) = 0;
  v99 += v87[0];
  v36 = v99;
  if ( v31 - v99 <= 0
    || (unsigned __int8)(*v99 - 23) >= 2u
    || (v37 = v86 - v87[0], *(_DWORD *)(v8 + 432) = *v99, v99 = v36 + 1, getAsnLength(&v99, v37, v87) < 0)
    || v31 - v99 < (unsigned int)v87[0]
    || v87[0] >= 0x21u )
  {
LABEL_77:
    v18 = v96;
    v13 = -31;
    goto LABEL_23;
  }
  v38 = malloc(v87[0] + 1);
  *v29 = v38;
  if ( !v38 )
  {
    psTraceStr("psError %s", (int)"keyformat/x509.c");
    psTraceInt(":%d ", 4529);
    v41 = "Memory allocation error in getTimeValidity for notAfter\n";
LABEL_82:
    psError((int)v41);
    v18 = v96;
    v13 = -8;
    goto LABEL_23;
  }
  memcpy(v38, v99, v87[0]);
  *(_BYTE *)(*v29 + v87[0]) = 0;
  v39 = *(_DWORD *)(v8 + 436);
  v96 = &v99[v87[0]];
  v99 = v96;
  if ( !v39 )
    goto LABEL_73;
  if ( !*(_DWORD *)(v8 + 440) )
    goto LABEL_73;
  if ( psGetBrokenDownGMTime(v88, 0) )
    goto LABEL_73;
  v42 = v88;
  v43 = v90;
  do
  {
    v44 = *v42;
    v45 = v42[1];
    v46 = v42[2];
    v47 = v42[3];
    v42 += 4;
    *v43 = v44;
    v43[1] = v45;
    v43[2] = v46;
    v43[3] = v47;
    v43 += 4;
  }
  while ( v42 != (int *)&v89 );
  v48 = v42[2];
  v49 = v42[1];
  *v43 = *v42;
  v43[2] = v48;
  v43[1] = v49;
  if ( psBrokenDownTimeAdd(v90, 86400) )
    goto LABEL_73;
  v50 = strlen(*(_DWORD *)(v8 + 436));
  if ( psBrokenDownTimeImport(v91, *(_BYTE **)(v8 + 436), v50, 2 * (*(_DWORD *)(v8 + 428) == 0x17)) )
    goto LABEL_73;
  v51 = strlen(*(_DWORD *)(v8 + 440));
  if ( psBrokenDownTimeImport(v92, *(_BYTE **)(v8 + 440), v51, 2 * (*(_DWORD *)(v8 + 432) == 0x17)) )
    goto LABEL_73;
  v52 = v92;
  v53 = v94;
  do
  {
    v54 = *v52;
    v55 = v52[1];
    v56 = v52[2];
    v57 = v52[3];
    v52 += 4;
    *v53 = v54;
    v53[1] = v55;
    v53[2] = v56;
    v53[3] = v57;
    v53 += 4;
  }
  while ( v52 != (int *)&v93 );
  v58 = v52[1];
  v59 = v52[2];
  *v53 = *v52;
  v53[1] = v58;
  v53[2] = v59;
  if ( psBrokenDownTimeAdd(v94, 86400) )
  {
LABEL_73:
    v18 = v96;
    v13 = -1;
    v40 = 8;
    goto LABEL_74;
  }
  if ( psBrokenDownTimeCmp((int)v91, (int)v90) > 0 || psBrokenDownTimeCmp((int)v88, (int)v94) > 0 )
    *(_DWORD *)(v8 + 692) |= 8u;
  v60 = (_WORD)v12 - (_WORD)v96;
  *(_WORD *)(v8 + 794) = (_WORD)v96 - (_WORD)v9;
  v61 = psX509GetDNAttributes(a1, &v96, v60, v8 + 296, a5);
  if ( v61 < 0 )
  {
    v18 = v96;
    v13 = v61;
    v40 = 14;
    goto LABEL_74;
  }
  v62 = (__int16)v96;
  v63 = (_WORD)v96 - (_WORD)v9;
  v64 = (_WORD)v12 - (_WORD)v96;
  *(_WORD *)(v8 + 790) = v63;
  AsnSequence32 = getAsnSequence(&v96, v64, &v83);
  if ( AsnSequence32 < 0 )
    goto LABEL_37;
  v65 = v96;
  *(_WORD *)(v8 + 792) = (_WORD)v96 - v62 + v83;
  AsnSequence32 = getAsnAlgorithmIdentifier((unsigned int **)&v96, v12 - v65, (int *)(v8 + 444), &v84);
  if ( AsnSequence32 < 0 )
    goto LABEL_37;
  v66 = *(_DWORD *)(v8 + 444);
  if ( v66 == 518 )
  {
    if ( v84 )
    {
      v23 = v96;
      if ( v12 - v96 < v84 )
      {
        v13 = -31;
        goto LABEL_26;
      }
      psInitPubKey(a1, v8 + 40, 3);
      EcPubKey = getEcPubKey(a1, &v96, (_WORD)v12 - (_WORD)v96, v8 + 40, (int)v81);
      if ( EcPubKey >= 0 )
      {
        v78 = psEccSize(v8 + 40);
        *(_WORD *)(v8 + 148) = v78;
        if ( v78 >= 0x18u )
          goto LABEL_104;
        psClearPubKey(v8 + 40);
        v18 = v96;
        v13 = -31;
LABEL_112:
        *(_DWORD *)(v8 + 4) = 2;
        goto LABEL_13;
      }
      if ( EcPubKey == -10 )
        *(_DWORD *)(v8 + 4) = 4;
    }
    v23 = v96;
    v13 = -31;
    goto LABEL_26;
  }
  if ( v66 != 645 )
  {
    v18 = v96;
    v13 = -10;
    *(_DWORD *)(v8 + 4) = 6;
    goto LABEL_13;
  }
  if ( v84 )
  {
    psTraceStr("psAssert %s", (int)"keyformat/x509.c");
    psTraceInt(":%d ", 995);
    psError((int)&unk_4A0300);
  }
  psInitPubKey(a1, v8 + 40, 1);
  v67 = psRsaParseAsnPubKey(a1, &v96, (_WORD)v12 - (_WORD)v96, v8 + 40, (int)v81);
  if ( v67 < 0 )
  {
    v18 = v96;
    v13 = v67;
    v40 = 10;
    goto LABEL_74;
  }
  v68 = psRsaSize(v8 + 40);
  *(_WORD *)(v8 + 148) = v68;
  if ( v68 < 0x80 )
  {
    psClearPubKey(v8 + 40);
    v18 = v96;
    v13 = -10;
    goto LABEL_112;
  }
LABEL_104:
  v69 = v81[2];
  v70 = v81[3];
  v71 = v81[4];
  v72 = v81[0];
  *(_DWORD *)(v8 + 768) = v81[1];
  *(_DWORD *)(v8 + 764) = v72;
  *(_DWORD *)(v8 + 772) = v69;
  *(_DWORD *)(v8 + 776) = v70;
  *(_DWORD *)(v8 + 780) = v71;
  v18 = v96;
  if ( *v96 != 48 )
  {
    if ( sub_4750A4(a1, &v96, (_WORD)v12 - (_WORD)v96, 1, (int *)(v8 + 448), (_WORD *)(v8 + 456)) < 0
      || sub_4750A4(a1, &v96, (_WORD)v12 - (_WORD)v96, 2, (int *)(v8 + 452), (_WORD *)(v8 + 458)) < 0
      || getExplicitExtensions(a1, &v96, (_WORD)v12 - (_WORD)v96, 3, v8 + 460, 0) < 0 )
    {
      v18 = v96;
      v13 = -31;
      *(_DWORD *)(v8 + 4) = 7;
      goto LABEL_13;
    }
    v18 = v96;
  }
  if ( v102 != v18 )
  {
    v13 = -9;
    *(_DWORD *)(v8 + 4) = 15;
    goto LABEL_13;
  }
  if ( !*(_DWORD *)(v8 + 320)
    && !*(_DWORD *)(v8 + 296)
    && !*(_DWORD *)(v8 + 316)
    && !*(_DWORD *)(v8 + 300)
    && !*(_DWORD *)(v8 + 304)
    && !*(_DWORD *)(v8 + 324)
    && !*(_DWORD *)(v8 + 472) )
  {
    v13 = -31;
    *(_DWORD *)(v8 + 4) = 9;
    goto LABEL_13;
  }
  AsnSequence32 = getAsnAlgorithmIdentifier((unsigned int **)&v96, v12 - v18, (int *)(v8 + 8), &v84);
  if ( AsnSequence32 < 0 )
    goto LABEL_37;
  if ( v84 )
  {
    if ( *(_DWORD *)(v8 + 8) != 1678 )
      goto LABEL_42;
    AsnSequence32 = getAsnSequence(&v96, (_WORD)v12 - (_WORD)v96, &v83);
    if ( AsnSequence32 < 0 )
      goto LABEL_37;
    if ( v83 )
    {
      v74 = sub_474B4C(&v96, v83, v8, 1);
      if ( v74 < 0 )
      {
        v18 = v96;
        v13 = v74;
        goto LABEL_23;
      }
    }
  }
  v73 = *(_DWORD *)(v8 + 12);
  if ( v73 != *(_DWORD *)(v8 + 8) )
  {
    v18 = v96;
    v13 = -31;
    *(_DWORD *)(v8 + 4) = 16;
    goto LABEL_13;
  }
  if ( v73 != 1678 )
  {
    if ( v73 >= 1679 )
    {
      if ( v73 != 1680 )
      {
        v75 = 1681;
        if ( v73 < 1680 )
          goto LABEL_152;
        goto LABEL_157;
      }
    }
    else if ( v73 != 525 )
    {
      v75 = 526;
      if ( v73 < 526 )
      {
        v76 = 524;
        goto LABEL_144;
      }
LABEL_157:
      if ( v73 != v75 )
        goto LABEL_145;
      psSha512Init(v82);
      psSha512Update(v82, v17, v101);
      v79 = v8 + 700;
      psSha512Final((int)v82, v8 + 700);
      goto LABEL_153;
    }
LABEL_159:
    psSha384Init(v82);
    psSha384Update(v82, v17, v101);
    v79 = v8 + 700;
    psSha384Final((int)v82, (_DWORD *)(v8 + 700));
    goto LABEL_153;
  }
  v73 = *(_DWORD *)(v8 + 24);
  if ( v73 == 3 )
    goto LABEL_159;
  if ( v73 >= 4 )
  {
    v75 = 4;
    goto LABEL_157;
  }
  v76 = 2;
LABEL_144:
  if ( v73 == v76 )
  {
LABEL_152:
    psSha256Init(v82);
    psSha256Update(v82, v17, v101);
    v79 = v8 + 700;
    psSha256Final((int)v82, v8 + 700);
LABEL_153:
    if ( !memcmp(v79, &unk_4A053C, 6) )
      goto LABEL_145;
    Signature = psX509GetSignature(a1, &v96, (_WORD)v12 - (_WORD)v96, (int *)(v8 + 16), (_WORD *)(v8 + 20));
    if ( Signature >= 0 )
    {
      v23 = v96;
      *(_DWORD *)(v8 + 4) = 0;
      if ( v23 != v12 )
      {
        psTraceStr("psAssert %s", (int)"keyformat/x509.c");
        psTraceInt(":%d ", 1322);
        psError((int)"p == end");
        v23 = v96;
      }
      goto LABEL_26;
    }
    v18 = v96;
    v13 = Signature;
    v40 = 13;
LABEL_74:
    *(_DWORD *)(v8 + 4) = v40;
    goto LABEL_23;
  }
LABEL_145:
  v18 = v96;
  v13 = -10;
  *(_DWORD *)(v8 + 4) = 5;
LABEL_13:
  if ( v12 >= v18 )
    goto LABEL_28;
LABEL_14:
  psTraceStr("psAssert %s", (int)"keyformat/x509.c");
  psTraceInt(":%d ", 1324);
  psError((int)"p <= end");
  v95 = v12;
  if ( !v13 )
    goto LABEL_29;
LABEL_15:
  if ( !*(_DWORD *)(v8 + 4) )
  {
    psTraceStr("psAssert %s", (int)"keyformat/x509.c");
    psTraceInt(":%d ", 1392);
    psError((int)"cert->parseStatus != PS_X509_PARSE_SUCCESS");
  }
  v20 = v13;
  if ( ((a5 >> 2) & 1) != 0 )
    goto LABEL_30;
  return v20;
}
// 47962C: conditional instruction was optimized away because $s5.4<0
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0047A748) --------------------------------------------------------
int   psX509ParseCertFile(int a1, char *a2, _DWORD *a3, unsigned int a4)
{
  int v4; // $v1
  _DWORD *v5; // $a0
  int v6; // $fp
  int FileBuf; // $s0
  int v8; // $s4
  int v9; // $s5
  _DWORD *v10; // $v0
  _DWORD *v11; // $s7
  int *v12; // $s1
  int v13; // $v0
  int v14; // $v0
  int v15; // $s0
  int v16; // $v0
  __int16 v17; // $s3
  int v18; // $s2
  int v19; // $s6
  int v20; // $v1
  unsigned __int8 *v21; // $s0
  int v22; // $v0
  _DWORD *v24; // $s1
  unsigned __int8 **i; // $a1
  int v26; // $v1
  _DWORD *v27; // $a0
  int *v28; // $v0
  int v29; // $v1
  int v30; // $a1
  _DWORD *v31; // [sp+20h] [-28h] BYREF
  int v32; // [sp+24h] [-24h] BYREF
  int v33; // [sp+28h] [-20h] BYREF
  _DWORD *v34; // [sp+2Ch] [-1Ch]
  int v35; // [sp+30h] [-18h] BYREF
  int *v36; // [sp+34h] [-14h]
  int v37; // [sp+38h] [-10h]
  int v38; // [sp+3Ch] [-Ch]
  int *v39; // [sp+40h] [-8h]
  int v40; // [sp+44h] [-4h]

  *a3 = 0;
  v4 = psParseList(a1, a2, 59, &v31);
  v38 = 0;
  if ( v4 < 0 )
    return v4;
  v5 = v31;
  v6 = 0;
  v36 = v31;
  v37 = 0;
  if ( v31 )
  {
    v40 = (a4 >> 2) & 1;
    while ( 1 )
    {
      FileBuf = psGetFileBuf(a1, *v36, &v32, &v33);
      if ( FileBuf < 0 )
        break;
      v8 = v32;
      v34 = 0;
      v9 = (unsigned __int16)v33;
      v39 = 0;
      if ( !v32 )
      {
        FileBuf = -6;
LABEL_28:
        psFreeList(v31);
        free2(v32);
        v4 = FileBuf;
        if ( !v37 )
          return v4;
        psX509FreeCert(v37);
        return FileBuf;
      }
      v10 = (_DWORD *)malloc(12);
      v11 = v10;
      v12 = v10;
      if ( !v10 )
      {
        psTraceStr("psError %s", (int)"keyformat/x509.c");
        psTraceInt(":%d ", 310);
        FileBuf = -8;
        psError((int)"Memory allocation error first pemCertFileBufToX509\n");
        goto LABEL_28;
      }
      *v10 = 0;
      v10[1] = 0;
      v10[2] = 0;
      while ( v9 )
      {
        if ( !strstr(v8, "-----BEGIN")
          || (v14 = strstr(v8, "CERTIFICATE-----"), (v15 = v14) == 0)
          || (v16 = strstr(v14, "-----END"), v17 = v16, !v16)
          || (v18 = strstr(v16, "CERTIFICATE-----")) == 0 )
        {
LABEL_27:
          psFreeList(v11);
          FileBuf = -31;
          goto LABEL_28;
        }
        v19 = v15 + 16;
        if ( !v12 )
        {
          v28 = (int *)malloc(12);
          v12 = v28;
          if ( !v28 )
          {
            psFreeList(v11);
            psTraceStr("psError %s", (int)"keyformat/x509.c");
            v30 = 332;
            goto LABEL_50;
          }
          *v28 = 0;
          v28[1] = 0;
          v28[2] = 0;
          v39[1] = (int)v28;
        }
        *((_WORD *)v12 + 4) = v17 - v19;
        v20 = *(unsigned __int8 *)(v18 + 16);
        v21 = (unsigned __int8 *)(v18 + 16);
        if ( v20 == 13 || v20 == 10 || v20 == 9 || v20 == 32 )
        {
LABEL_21:
          ++v21;
          do
          {
            v22 = *v21;
            if ( v22 == 13 || v22 == 10 || v22 == 9 )
              goto LABEL_21;
            ++v21;
          }
          while ( v22 == 32 );
          --v21;
        }
        v13 = malloc(*((unsigned __int16 *)v12 + 4));
        *v12 = v13;
        if ( !v13 )
        {
          psFreeList(v11);
          psTraceStr("psError %s", (int)"keyformat/x509.c");
          v30 = 356;
LABEL_50:
          psTraceInt(":%d ", v30);
          psError((int)"Memory allocation error: pemCertFileBufToX509\n");
          FileBuf = -8;
          goto LABEL_28;
        }
        memset(v13, 0, *((unsigned __int16 *)v12 + 4));
        v9 = (unsigned __int16)(v9 - ((_WORD)v21 - v8));
        v8 = (int)v21;
        if ( psBase64decode(v19, *((_WORD *)v12 + 4), *v12, (_WORD *)v12 + 4) )
          goto LABEL_27;
        v39 = v12;
        v12 = (int *)v12[1];
      }
      v34 = v11;
      free2(v32);
      v24 = v34;
      for ( i = (unsigned __int8 **)v34; v34; v35 = *(_DWORD *)(v26 + 796) )
      {
        FileBuf = psX509ParseCert(a1, *i, *((unsigned __int16 *)i + 4), &v35, a4);
        if ( FileBuf >= 0 )
        {
          ++v38;
        }
        else if ( !v40 )
        {
          psX509FreeCert(v35);
          psFreeList(v31);
          v27 = v24;
          goto LABEL_41;
        }
        v34 = (_DWORD *)v34[1];
        v26 = v35;
        if ( v37 )
          *(_DWORD *)(v6 + 796) = v35;
        else
          v37 = v35;
        i = (unsigned __int8 **)v34;
        v6 = v26;
      }
      v36 = (int *)v36[1];
      psFreeList(v24);
      if ( !v36 )
      {
        v5 = v31;
        goto LABEL_47;
      }
    }
    v27 = v31;
LABEL_41:
    psFreeList(v27);
    if ( !v37 )
      return FileBuf;
    psX509FreeCert(v37);
    return FileBuf;
  }
LABEL_47:
  psFreeList(v5);
  v29 = v38;
  *a3 = v37;
  return v29;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FEC: using guessed type int   strstr(_DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (0047AD74) --------------------------------------------------------
int   psX509AuthenticateCert(int a1, int a2, int a3, int *a4)
{
  int v5; // $s5
  int v6; // $v1
  int v7; // $s1
  int v8; // $s2
  int v9; // $v1
  int v10; // $s4
  int v11; // $v1
  int v12; // $s0
  int v13; // $a2
  int v14; // $a2
  unsigned int v15; // $v1
  _BYTE *v16; // $s0
  int v17; // $v1
  unsigned int v18; // $v0
  unsigned int v19; // $a0
  unsigned int v20; // $v1
  bool v21; // dc
  BOOL v22; // $a0
  int v23; // $v0
  int v25; // $v1
  int v26; // $v0
  unsigned __int8 *v27; // $s0
  int AsnSequence; // $v0
  _BYTE *v29; // $s0
  int v30; // $a0
  int AsnAlgorithmIdentifier; // $v0
  int v32; // $a2
  __int16 v33; // $a0
  unsigned __int8 *v34; // $v0
  _BYTE *v35; // $a2
  int v36; // $v0
  int v37; // $a2
  int AsnLength; // $v0
  int v39; // $v0
  unsigned __int16 v40; // $a2
  int v41; // $v1
  int v42; // $v0
  int v43; // $v0
  int v44; // $a1
  _BYTE v45[88]; // [sp+30h] [-E8h] BYREF
  unsigned __int16 v46[4]; // [sp+88h] [-90h] BYREF
  _BYTE v47[64]; // [sp+90h] [-88h] BYREF
  unsigned __int16 v48; // [sp+D0h] [-48h] BYREF
  __int16 v49[3]; // [sp+D2h] [-46h] BYREF
  int v50[4]; // [sp+D8h] [-40h] BYREF
  int v51; // [sp+E8h] [-30h]
  int v52; // [sp+ECh] [-2Ch]
  unsigned __int8 *v53; // [sp+108h] [-10h] BYREF
  int v54; // [sp+10Ch] [-Ch] BYREF
  int v55; // [sp+110h] [-8h] BYREF
  int v56; // [sp+114h] [-4h] BYREF

  v55 = 0;
  v5 = 0;
  v6 = -6;
  if ( !a2 )
    return v6;
  v7 = a2;
  if ( a3 )
  {
    *(_DWORD *)(a3 + 688) = 0;
    v8 = a3;
  }
  else
  {
    v39 = a2;
    do
    {
      *(_DWORD *)(v39 + 688) = 0;
      v39 = *(_DWORD *)(v39 + 796);
      v7 = a2;
    }
    while ( v39 );
    v8 = a2;
    if ( *(_DWORD *)(a2 + 796) )
      v8 = *(_DWORD *)(a2 + 796);
  }
  if ( !v8 )
    return 0;
  while ( 1 )
  {
    if ( *(int *)(v8 + 152) >= 2 && *(_DWORD *)(v8 + 464) != 255 && v7 != v8 )
    {
      v11 = -32;
      *(_DWORD *)(v7 + 688) = -32;
      return v11;
    }
    if ( memcmp(v7 + 196, v8 + 328, 20) )
    {
      v11 = -33;
      *(_DWORD *)(v7 + 688) = -33;
      return v11;
    }
    psCRL_determineRevokedStatus(v7);
    if ( *(_DWORD *)(v7 + 696) == 9 )
    {
      v11 = -35;
      *(_DWORD *)(v7 + 688) = -35;
      return v11;
    }
    v9 = *(_DWORD *)(v7 + 8);
    if ( v9 == 1678 )
    {
      v25 = *(_DWORD *)(v7 + 24);
      if ( v25 == 3 )
      {
        v5 = 48;
        v10 = 7;
      }
      else if ( v25 >= 4 )
      {
        v5 = 64;
        if ( v25 != 4 )
          return -10;
        v10 = 7;
      }
      else
      {
        v5 = 32;
        if ( v25 != 2 )
          return -10;
        v10 = 7;
      }
      goto LABEL_16;
    }
    if ( v9 >= 1679 )
    {
      if ( v9 == 1680 )
      {
        v5 = 67;
        v10 = 5;
        goto LABEL_17;
      }
      if ( v9 < 1680 )
      {
        v5 = 51;
        v10 = 5;
        goto LABEL_17;
      }
      v10 = -10;
      if ( v9 == 1681 )
      {
        v5 = 83;
        v10 = 5;
        goto LABEL_17;
      }
    }
    else if ( v9 == 525 )
    {
      v5 = 48;
      v10 = 6;
    }
    else if ( v9 >= 526 )
    {
      v10 = 6;
      if ( v9 != 526 )
      {
LABEL_15:
        v10 = -10;
        goto LABEL_16;
      }
      v5 = 64;
    }
    else
    {
      if ( v9 != 524 )
        goto LABEL_15;
      v5 = 32;
      v10 = 6;
    }
LABEL_16:
    v11 = -10;
    if ( v10 == -10 )
      goto LABEL_57;
LABEL_17:
    if ( v10 != 5 )
    {
      if ( v10 == 7 )
      {
        v34 = (unsigned __int8 *)malloc(*(unsigned __int16 *)(v7 + 20));
        v27 = v34;
        if ( !v34 )
        {
          psTraceStr("psError %s", (int)"keyformat/x509.c");
          v44 = 5499;
          goto LABEL_121;
        }
        v35 = *(_BYTE **)(v7 + 16);
        v46[0] = *(_WORD *)(v7 + 20);
        v55 = psRsaCrypt(0, v8 + 40, v35, v46[0], v34, v46, 1);
        if ( v55 < 0 )
          goto LABEL_119;
        if ( psPkcs1PssDecode(
               0,
               v7 + 700,
               v5,
               v27,
               v46[0],
               *(unsigned __int16 *)(v7 + 36),
               *(_DWORD *)(v7 + 24),
               8 * *(unsigned __int16 *)(v8 + 148),
               &v55) < 0 )
        {
          free2(v27);
          return -1;
        }
        free2(v27);
        if ( !v55 )
        {
          v55 = -1;
LABEL_20:
          v11 = v55;
          if ( v55 < 0 )
            goto LABEL_57;
          goto LABEL_21;
        }
      }
      goto LABEL_19;
    }
    v26 = malloc(*(unsigned __int16 *)(v7 + 20));
    v27 = (unsigned __int8 *)v26;
    if ( !v26 )
    {
      psTraceStr("psError %s", (int)"keyformat/x509.c");
      v44 = 5476;
LABEL_121:
      psTraceInt(":%d ", v44);
      psError((int)"Memory allocation error: psX509AuthenticateCert\n");
      return -8;
    }
    memcpy(v26, *(_DWORD *)(v7 + 16), *(unsigned __int16 *)(v7 + 20));
    v55 = psRsaDecryptPub(0, v8 + 40, v27, *(_WORD *)(v7 + 20), v45, v5);
    if ( v55 < 0 )
      break;
    free2(v27);
    v53 = v45;
    AsnSequence = getAsnSequence(&v53, v5, &v48);
    v29 = &v45[(unsigned __int16)v5];
    v30 = -31;
    if ( AsnSequence < 0 )
      goto LABEL_79;
    AsnAlgorithmIdentifier = getAsnAlgorithmIdentifier((unsigned int **)&v53, v29 - v53, &v54, v49);
    v30 = -31;
    if ( AsnAlgorithmIdentifier < 0 )
      goto LABEL_79;
    if ( v49[0] )
    {
      psTraceStr("psAssert %s", (int)"keyformat/x509.c");
      psTraceInt(":%d ", 5712);
      psError((int)&unk_4A0300);
      v37 = *v53;
      v33 = (_WORD)v53++ + 1;
      if ( v37 != 4 )
      {
LABEL_78:
        v30 = -31;
LABEL_79:
        v55 = v30;
        goto LABEL_19;
      }
    }
    else
    {
      v32 = *v53;
      v33 = (_WORD)v53++ + 1;
      if ( v32 != 4 )
        goto LABEL_78;
    }
    AsnLength = getAsnLength(&v53, (_WORD)v29 - v33, &v48);
    v30 = -31;
    if ( AsnLength < 0 || v29 - v53 < (unsigned int)v48 )
      goto LABEL_79;
    memcpy(v47, v53, v48);
    if ( v54 == 415 )
    {
      v40 = v48;
      v30 = -9;
      v41 = v48;
      v42 = 48;
    }
    else if ( v54 >= 416 )
    {
      if ( v54 != 416 )
      {
LABEL_101:
        v55 = -10;
        goto LABEL_19;
      }
      v40 = v48;
      v30 = -9;
      v41 = v48;
      v42 = 64;
    }
    else
    {
      v30 = -9;
      if ( v54 != 414 )
        goto LABEL_101;
      v40 = v48;
      v41 = v48;
      v42 = 32;
    }
    if ( v41 != v42 )
      goto LABEL_79;
    v43 = memcmpct((int)v47, v7 + 700, v40);
    v30 = -40;
    if ( v43 )
      goto LABEL_79;
    v55 = 0;
LABEL_19:
    if ( v10 != 6 )
      goto LABEL_20;
    v36 = psEccDsaVerify(0, v8 + 40, (_BYTE *)(v7 + 700), v5, *(unsigned __int8 **)(v7 + 16), *(_WORD *)(v7 + 20), &v56);
    v55 = v36;
    if ( v36 )
      goto LABEL_88;
    v36 = -1;
    if ( v56 == -1 )
    {
      v55 = -1;
LABEL_88:
      v11 = v36;
LABEL_57:
      *(_DWORD *)(v7 + 688) = -34;
      return v11;
    }
LABEL_21:
    v12 = *(unsigned __int16 *)(v7 + 640);
    if ( *(_WORD *)(v7 + 640) )
    {
      v13 = *(unsigned __int16 *)(v8 + 496);
      if ( v13 != v12 )
        goto LABEL_24;
    }
    else
    {
      if ( !*(_WORD *)(v8 + 496) )
        goto LABEL_26;
      v13 = *(unsigned __int16 *)(v8 + 496);
      if ( v13 != v12 )
      {
LABEL_24:
        v14 = *(unsigned __int16 *)(v7 + 20);
        if ( v14 == *(unsigned __int16 *)(v8 + 20) && !memcmp(*(_DWORD *)(v7 + 16), *(_DWORD *)(v8 + 16), v14) )
        {
          if ( v12 )
            *(_DWORD *)(v7 + 688) = -39;
        }
        else
        {
          *(_DWORD *)(v7 + 688) = -39;
        }
        goto LABEL_26;
      }
    }
    if ( memcmp(*(_DWORD *)(v8 + 492), *(_DWORD *)(v7 + 500), v13) )
      *(_DWORD *)(v7 + 688) = -39;
LABEL_26:
    v15 = *(_DWORD *)(v8 + 484);
    if ( ((v15 >> 2) & 1) != 0 )
      goto LABEL_39;
    if ( v15 )
    {
      v55 = 0;
LABEL_60:
      *(_DWORD *)(v7 + 692) |= 1u;
      *(_DWORD *)(v7 + 688) = -37;
      goto LABEL_39;
    }
    v16 = *(_BYTE **)(v8 + 436);
    v17 = -1;
    if ( !v16 )
      goto LABEL_36;
    v18 = strlen(*(_DWORD *)(v8 + 436));
    v17 = psBrokenDownTimeImport(v50, v16, v18, 2 * (*(_DWORD *)(v8 + 428) == 0x17));
    if ( v17 )
      goto LABEL_36;
    v19 = v52 + 1900;
    v20 = (unsigned __int16)(v51 + 1);
    if ( (unsigned int)(v52 + 1900) < 0x7CC || (_WORD)v51 == 0xFFFF || v20 >= 0xD )
    {
      v55 = -1;
    }
    else
    {
      if ( v19 >= 0x7D2 )
      {
        v21 = v19 == 2002;
        v22 = v20 < 4;
        if ( !v21 )
        {
          v17 = 0;
LABEL_36:
          v55 = v17;
          goto LABEL_37;
        }
        v17 = 0;
        if ( !v22 )
          goto LABEL_36;
      }
      v55 = 1;
    }
LABEL_37:
    if ( !v55 )
      goto LABEL_60;
    v6 = -31;
    if ( v55 < 0 )
      return v6;
LABEL_39:
    if ( !*(_DWORD *)(v7 + 688) )
    {
      v23 = 1;
      if ( ((*(_DWORD *)(v7 + 692) >> 3) & 1) != 0 )
        v23 = -37;
      *(_DWORD *)(v7 + 688) = v23;
    }
    if ( v8 == v7 || (v7 = v8, v8 == a3) )
    {
      *a4 = v8;
      return 0;
    }
    v8 = *(_DWORD *)(v8 + 796);
    if ( !v8 )
    {
      v8 = v7;
      *a4 = 0;
    }
  }
  *(_DWORD *)(v7 + 688) = -34;
LABEL_119:
  free2(v27);
  return v55;
}
// 47B030: conditional instruction was optimized away because $s1.4!=0
// 47B1DC: conditional instruction was optimized away because $s5.4 is in (==0|==20|==30|==33|==40|==43|==53)
// 47B2E8: conditional instruction was optimized away because $s4.4==5
// 47B3C4: conditional instruction was optimized away because $s4.4==7
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0047B770) --------------------------------------------------------
int   psOcspParseResponse(int a1, int a2, unsigned __int8 **a3, unsigned __int8 *a4, int a5)
{
  unsigned __int16 v5; // $a1
  int AsnSequence; // $v0
  int v10; // $a0
  int AsnEnumerated; // $v0
  unsigned __int8 *v13; // $a1
  unsigned __int8 *v14; // $t0
  int v15; // $v0
  int v16; // $a1
  int v17; // $t7
  unsigned __int8 *v18; // $a0
  int v19; // $s0
  unsigned __int8 *v20; // $v1
  unsigned __int16 v21; // $a0
  int v22; // $v0
  int v23; // $a2
  int v24; // $v0
  int v25; // $a1
  bool v26; // dc
  unsigned __int8 *v27; // $a1
  int v28; // $v1
  int v29; // $s1
  __int16 v30; // $a0
  int v31; // $s0
  unsigned __int8 *v32; // $a0
  int v33; // $t8
  unsigned __int8 *v34; // $v1
  unsigned __int8 *v35; // $a0
  int v36; // $t6
  int v37; // $v0
  unsigned __int16 v38; // $v1
  unsigned __int8 *v39; // $s0
  int v40; // $v0
  unsigned __int8 *v41; // $a2
  unsigned __int8 *v42; // $s1
  int v43; // $s6
  int v44; // $s0
  unsigned __int8 *v45; // $t2
  int v46; // $s6
  unsigned __int8 *v47; // $t8
  int v48; // $t7
  unsigned __int8 *v49; // $a0
  int v50; // $v1
  unsigned __int16 v51; // $a1
  unsigned __int8 *v52; // $t1
  unsigned __int8 *v53; // $v1
  int v54; // $a0
  unsigned __int8 *v55; // $v1
  unsigned __int16 v56; // $a1
  unsigned __int8 *v57; // $a0
  __int16 v58; // $v0
  unsigned __int8 *v59; // $s1
  int AsnAlgorithmIdentifier; // $v0
  int v61; // $v1
  int v62; // $v0
  unsigned __int8 *v63; // $a1
  unsigned int v64; // $a2
  int v65; // $ra
  int v66; // $t1
  int v67; // $t0
  unsigned int v68; // $v1
  unsigned __int8 *v69; // $a0
  unsigned __int16 v70; // $a1
  unsigned __int16 v71; // $ra
  int v72; // $a3
  __int16 v73; // $a0
  unsigned __int8 *v74; // $a1
  unsigned __int16 v75; // $t5
  unsigned __int8 *v76; // $a0
  int v77; // $v0
  unsigned __int16 v78; // $a2
  unsigned __int8 *v79; // $a1
  int v80; // $v0
  unsigned __int8 *v81; // $a3
  _WORD v82[4]; // [sp+20h] [-340h] BYREF
  __int64 v83[12]; // [sp+28h] [-338h] BYREF
  int v84[28]; // [sp+88h] [-2D8h] BYREF
  int v85[52]; // [sp+F8h] [-268h] BYREF
  int v86[52]; // [sp+1C8h] [-198h] BYREF
  unsigned __int16 v87; // [sp+298h] [-C8h] BYREF
  unsigned __int16 v88; // [sp+29Ah] [-C6h] BYREF
  unsigned __int16 v89; // [sp+29Ch] [-C4h] BYREF
  unsigned __int16 v90; // [sp+29Eh] [-C2h] BYREF
  _WORD v91[4]; // [sp+2A0h] [-C0h] BYREF
  _DWORD v92[8]; // [sp+2A8h] [-B8h] BYREF
  int v93[8]; // [sp+2C8h] [-98h] BYREF
  int v94[8]; // [sp+2E8h] [-78h] BYREF
  int v95[8]; // [sp+308h] [-58h] BYREF
  unsigned __int8 *v96; // [sp+328h] [-38h] BYREF
  int v97; // [sp+32Ch] [-34h] BYREF
  unsigned int v98; // [sp+330h] [-30h] BYREF
  int v99; // [sp+334h] [-2Ch] BYREF
  unsigned __int8 *v100; // [sp+338h] [-28h] BYREF
  int v101; // [sp+33Ch] [-24h] BYREF
  unsigned __int8 *v102; // [sp+340h] [-20h] BYREF
  unsigned int v103; // [sp+344h] [-1Ch] BYREF
  unsigned __int8 *v104; // [sp+348h] [-18h] BYREF
  unsigned __int8 *v105; // [sp+34Ch] [-14h] BYREF
  int v106; // [sp+350h] [-10h] BYREF
  int v107; // [sp+354h] [-Ch] BYREF
  unsigned __int8 *v108; // [sp+358h] [-8h]

  v5 = (_WORD)a4 - (unsigned __int16)*a3;
  v96 = *a3;
  AsnSequence = getAsnSequence(&v96, v5, v82);
  v10 = -31;
  if ( AsnSequence < 0 )
    return v10;
  AsnEnumerated = getAsnEnumerated((char **)&v96, a4 - v96, &v97);
  v10 = -31;
  if ( AsnEnumerated < 0 )
    return v10;
  if ( v97 )
  {
    if ( v97 < 7 )
    {
      v10 = v97 - 87;
      if ( v97 != 4 )
        return v10;
    }
    return -31;
  }
  v13 = v96;
  v14 = v96 + 1;
  if ( *v96 == 160 )
  {
    ++v96;
    if ( getAsnLength32(&v96, a4 - v14, &v98, 0) < 0 || a4 - v96 < v98 )
      return -31;
    v15 = getAsnSequence(&v96, (_WORD)a4 - (_WORD)v96, v82);
    v10 = -31;
    if ( v15 < 0 )
      return v10;
    v16 = a4 - v96;
    *(_DWORD *)(a5 + 272) = v96;
    if ( getAsnOID(&v96, v16, &v99, 1u, v82) < 0 )
    {
      v10 = -31;
      *(_DWORD *)(a5 + 272) = 0;
      return v10;
    }
    v17 = *v96;
    v18 = ++v96;
    if ( v17 != 4 || getAsnLength32(&v96, a4 - v18, &v98, 0) < 0 || a4 - v96 < v98 )
      return -31;
    v10 = -42;
    if ( v99 != 117 )
      return v10;
    v19 = *(_DWORD *)(a5 + 272);
    memset(a5, 0, 276);
    v20 = v96;
    v21 = (_WORD)a4 - (_WORD)v96;
    *(_DWORD *)(a5 + 272) = v19;
    v100 = v20;
    v22 = getAsnSequence(&v100, v21, &v87);
    v23 = -31;
    if ( v22 < 0 )
      return v23;
    v108 = v100;
    v24 = getAsnSequence(&v100, (_WORD)a4 - (_WORD)v100, &v87);
    v23 = -31;
    if ( v24 < 0 )
      return v23;
    v25 = (unsigned __int16)((_WORD)a4 - (_WORD)v100);
    v102 = v100;
    if ( (_WORD)a4 == (_WORD)v100 )
      return -31;
    if ( *v100 == 160 )
    {
      v31 = v25 - 1;
      v102 = v100 + 1;
      if ( getAsnLength(&v102, v25 - 1, &v89) < 0 )
        return -31;
      v10 = -31;
      if ( v31 < v89 )
        return v10;
      if ( getAsnInteger((char **)&v102, v89, &v101) < 0 )
        return -31;
      v100 = v102;
    }
    else
    {
      v101 = 0;
    }
    v23 = -43;
    v26 = v101 != 0;
    *(_DWORD *)(a5 + 268) = v101;
    if ( v26 )
      return v23;
    v27 = v100;
    v28 = *v100;
    if ( v28 == 161 )
    {
      ++v100;
      if ( getAsnLength32(&v100, a4 - (v27 + 1), &v103, 0) < 0 )
        return -31;
      v32 = v100;
      if ( a4 - v100 < v103 || !v103 )
        return -31;
      v104 = v100;
      v100 += v103;
      *(_DWORD *)a5 = v32;
      *(_DWORD *)(a5 + 4) = 0;
      v33 = *v32;
      v104 = v32 + 1;
      if ( v33 != 48
        || getAsnLength32(&v104, a4 - (v32 + 1), &v103, 0) < 0
        || (v35 = v100, v36 = a4 - v100, &v104[v103] != v100) )
      {
        v10 = -31;
        *(_DWORD *)a5 = 0;
        return v10;
      }
    }
    else
    {
      v23 = -31;
      if ( v28 != 162 )
        return v23;
      ++v100;
      if ( getAsnLength32(&v100, a4 - (v27 + 1), &v103, 0) < 0 || a4 - v100 < v103 )
        return -31;
      v29 = *v100;
      v30 = (_WORD)v100++ + 1;
      if ( v29 != 4 )
        return -1;
      if ( getAsnLength(&v100, (_WORD)a4 - v30, &v87) < 0 )
        return -1;
      v34 = v100;
      if ( a4 - v100 < (unsigned int)v87 || v87 != 20 )
        return -1;
      v35 = v100 + 20;
      *(_DWORD *)a5 = 0;
      *(_DWORD *)(a5 + 4) = v34;
      v100 = v34 + 20;
      v36 = a4 - (v34 + 20);
    }
    if ( v36 <= 0 )
      return -31;
    if ( *v35 != 24 )
      return -31;
    v100 = v35 + 1;
    if ( getAsnLength(&v100, (_WORD)a4 - ((_WORD)v35 + 1), &v87) < 0 || a4 - v100 < (unsigned int)v87 )
      return -31;
    v37 = psBrokenDownTimeImport(0, v100, v87, 0);
    v23 = -31;
    if ( v37 < 0 )
      return v23;
    v38 = v87;
    v39 = &v100[v87];
    *(_DWORD *)(a5 + 8) = v100;
    *(_WORD *)(a5 + 12) = v38;
    v100 = v39;
    v40 = getAsnSequence(&v100, (_WORD)a4 - (_WORD)v39, &v87);
    v23 = -31;
    if ( v40 < 0 )
      return v23;
    v41 = v100;
    v42 = &v100[v87];
    v88 = 0;
    if ( v100 < v42 )
    {
      do
      {
        v105 = v41;
        v43 = 52 * v88 + a5;
        v44 = v43 + 16;
        if ( getAsnSequence(&v105, (_WORD)v42 - (_WORD)v41, &v90) < 0
          || getAsnSequence(&v105, (_WORD)v42 - (_WORD)v105, &v90) < 0
          || getAsnAlgorithmIdentifier((unsigned int **)&v105, v42 - v105, &v106, v91) < 0 )
        {
          break;
        }
        if ( v91[0] )
        {
          psTraceStr("psAssert %s", (int)"keyformat/x509.c");
          psTraceInt(":%d ", 5906);
          psError((int)&unk_4A0300);
        }
        v45 = v105;
        *(_WORD *)(v43 + 16) = v106;
        v46 = *v45;
        v105 = v45 + 1;
        if ( v46 != 4 )
          break;
        if ( getAsnLength(&v105, (_WORD)v42 - ((_WORD)v45 + 1), &v90) < 0 )
          break;
        v47 = &v105[v90];
        if ( v42 - v105 < (unsigned int)v90 )
          break;
        *(_DWORD *)(v44 + 4) = v105;
        v105 = v47;
        v48 = *v47;
        v105 = v47 + 1;
        if ( v48 != 4 )
          break;
        if ( getAsnLength(&v105, (_WORD)v42 - ((_WORD)v47 + 1), &v90) < 0 )
          break;
        if ( v42 - v105 < (unsigned int)v90 )
          break;
        v49 = &v105[v90];
        *(_DWORD *)(v44 + 8) = v105;
        v105 = v49;
        v50 = *v49;
        if ( v50 != 130 && v50 != 2 )
          break;
        v105 = v49 + 1;
        if ( getAsnLength(&v105, (_WORD)v42 - ((_WORD)v49 + 1), &v90) < 0 )
          break;
        v51 = v90;
        v52 = &v105[v90];
        if ( v42 - v105 < (unsigned int)v90 )
          break;
        *(_DWORD *)(v44 + 12) = v105;
        v105 = v52;
        *(_DWORD *)(v44 + 20) = 0;
        *(_DWORD *)(v44 + 24) = 0;
        *(_DWORD *)(v44 + 28) = 0;
        *(_WORD *)(v44 + 32) = 0;
        *(_BYTE *)(v44 + 34) = 0;
        *(_BYTE *)(v44 + 35) = 0;
        v53 = v105;
        *(_WORD *)(v44 + 16) = v51;
        v54 = *v53;
        if ( v54 == 128 )
        {
          v55 = v53 + 2;
          *(_WORD *)(v44 + 18) = 0;
        }
        else if ( v54 == 161 )
        {
          *(_WORD *)(v44 + 18) = 1;
          v105 = v53 + 1;
          if ( getAsnLength(&v105, (_WORD)v42 - ((_WORD)v53 + 1), &v90) < 0 )
            return -31;
          v63 = v105;
          v64 = v90;
          v65 = v90;
          if ( v90 >= 0x11u )
          {
            if ( *v105 == 24 && v105[1] == 15 )
            {
              v66 = *(_DWORD *)(v105 + 6);
              v67 = *(_DWORD *)(v105 + 10);
              *(_DWORD *)(v44 + 20) = *(_DWORD *)(v105 + 2);
              *(_DWORD *)(v44 + 24) = v66;
              *(_DWORD *)(v44 + 28) = v67;
              *(_BYTE *)(v44 + 32) = v63[14];
              *(_BYTE *)(v44 + 33) = v63[15];
              *(_BYTE *)(v44 + 34) = v63[16];
              if ( v64 >= 0x14 && v63[17] == 160 && v63[18] == 3 && v63[19] == 10 && v63[20] == 1 )
              {
                v68 = v63[21];
                if ( v68 < 0xB && v68 != 7 )
                  *(_BYTE *)(v44 + 35) = v63[21];
              }
              v63 = v105;
              v65 = v90;
            }
            else
            {
              v65 = v90;
            }
          }
          v55 = &v63[v65];
        }
        else
        {
          v55 = v53 + 2;
          if ( v54 != 130 )
            return -31;
          *(_WORD *)(v44 + 18) = 2;
        }
        v105 = v55;
        if ( v42 - v55 <= 0 )
          break;
        if ( *v55 != 24 )
          break;
        v105 = v55 + 1;
        if ( getAsnLength(&v105, (_WORD)v42 - ((_WORD)v55 + 1), &v90) < 0 )
          break;
        v56 = v90;
        if ( v42 - v105 < (unsigned int)v90 )
          break;
        v57 = &v105[v90];
        *(_DWORD *)(v44 + 36) = v105;
        *(_WORD *)(v44 + 40) = v56;
        v105 = v57;
        *(_WORD *)(v44 + 48) = 0;
        *(_DWORD *)(v44 + 44) = 0;
        if ( (unsigned int)(v42 - v57) >= 2 && *v57 == 160 )
        {
          v105 = v57 + 1;
          if ( getAsnLength(&v105, (_WORD)v42 - ((_WORD)v57 + 1), &v90) < 0 )
            return -31;
          v69 = v105;
          v70 = v90;
          if ( v42 - v105 < (unsigned int)v90 )
            return -31;
          if ( *v105 == 24 )
          {
            v81 = v105 + 2;
            if ( v90 >= 3u )
            {
              *(_WORD *)(v44 + 48) = v90 - 2;
              *(_DWORD *)(v44 + 44) = v81;
            }
          }
          v57 = &v69[v70];
          v105 = v57;
        }
        if ( (unsigned int)(v42 - v57) >= 2 && *v57 == 161 )
        {
          v105 = v57 + 1;
          if ( getAsnLength(&v105, (_WORD)v42 - ((_WORD)v57 + 1), &v90) < 0 || v42 - v105 < (unsigned int)v90 )
            return -31;
          v57 = &v105[v90];
          v105 = v57;
        }
        v100 = v57;
        v41 = v57;
        v58 = ++v88;
        if ( v57 >= v42 )
          goto LABEL_86;
      }
      while ( v58 != 3 );
      return -31;
    }
LABEL_86:
    if ( *v41 == 161 )
    {
      *(_DWORD *)(a5 + 252) = 0;
      *(_DWORD *)(a5 + 256) = 0;
      *(_DWORD *)(a5 + 260) = 0;
      *(_DWORD *)(a5 + 264) = 0;
      if ( !psParseBufFromStaticData(v92, (int)v41, a4 - v41) && psParseBufTryReadTagSub((int)v92, (char *)v93, 0xA1u) )
      {
        do
        {
          if ( !psParseBufTryReadTagSub((int)v93, (char *)v94, 0x30u) )
            break;
          psParseBufReadTagSub(v94, (char *)v95, 0x30u);
          if ( psParseBufTrySkipBytes(v95, (int)&unk_4A03E0, 0xBu) )
            psParseBufReadTagRef(v95, (_DWORD *)(a5 + 252), 4u);
          psParseBufFinish(v95);
        }
        while ( !psParseBufFinish(v94) );
        psParseBufFinish(v93);
      }
      v71 = (_WORD)a4 - ((_WORD)v100++ + 1);
      if ( getAsnLength(&v100, v71, &v87) < 0 )
        return -31;
      v41 = &v100[v87];
      if ( a4 - v100 < (unsigned int)v87 )
        return -31;
      v100 += v87;
    }
    v59 = v41;
    AsnAlgorithmIdentifier = getAsnAlgorithmIdentifier((unsigned int **)&v100, a4 - v41, &v107, &v88);
    v23 = -31;
    if ( AsnAlgorithmIdentifier < 0 )
      return v23;
    if ( v88 )
      v100 += v88;
    v61 = v107;
    v26 = v107 == 526;
    *(_WORD *)(a5 + 172) = v107;
    if ( !v26 )
    {
      if ( v61 < 527 )
      {
        if ( v61 == 520 )
        {
LABEL_132:
          *(_WORD *)(a5 + 246) = 20;
          psSha1Init(v83);
          psSha1Update((int *)v83, (int)v108, v59 - v108);
          psSha1Final(v83, a5 + 182);
          goto LABEL_127;
        }
        if ( v61 < 521 )
        {
          v62 = 91;
          goto LABEL_95;
        }
        if ( v61 != 524 )
        {
          if ( v61 != 525 )
            return -10;
          goto LABEL_126;
        }
        goto LABEL_151;
      }
      if ( v61 == 1679 )
      {
LABEL_151:
        *(_WORD *)(a5 + 246) = 32;
        psSha256Init(v84);
        psSha256Update(v84, (int)v108, v59 - v108);
        psSha256Final((int)v84, a5 + 182);
        goto LABEL_127;
      }
      if ( v61 < 1680 )
      {
        v62 = 1673;
LABEL_95:
        if ( v61 != v62 )
          return -10;
        goto LABEL_132;
      }
      if ( v61 == 1680 )
      {
LABEL_126:
        *(_WORD *)(a5 + 246) = 48;
        psSha384Init(v85);
        psSha384Update(v85, (int)v108, v59 - v108);
        psSha384Final((int)v85, (_DWORD *)(a5 + 182));
        goto LABEL_127;
      }
      if ( v61 != 1681 )
        return -10;
    }
    *(_WORD *)(a5 + 246) = 64;
    psSha512Init(v86);
    psSha512Update(v86, (int)v108, v59 - v108);
    psSha512Final((int)v86, a5 + 182);
LABEL_127:
    v72 = *v100;
    v73 = (_WORD)v100++ + 1;
    v23 = -31;
    if ( v72 != 3 )
      return v23;
    if ( getAsnLength(&v100, (_WORD)a4 - v73, &v87) >= 0 && a4 - v100 >= (unsigned int)v87 )
    {
      v74 = v100 + 1;
      if ( *v100 )
      {
        v10 = -31;
        ++v100;
        return v10;
      }
      v76 = &v74[--v87];
      v75 = v87;
      *(_DWORD *)(a5 + 176) = v74;
      *(_WORD *)(a5 + 180) = v75;
      v100 = v76;
      if ( a4 == v76 )
      {
LABEL_148:
        if ( v76 != a4 )
        {
          psTraceStr("psAssert %s", (int)"keyformat/x509.c");
          psTraceInt(":%d ", 6387);
          psError((int)"p == end");
          v76 = v100;
        }
        v96 = v76;
        v13 = v76;
        goto LABEL_8;
      }
      v23 = -31;
      if ( *v76 != 160 )
        return v23;
      v100 = v76 + 1;
      if ( getAsnLength(&v100, (_WORD)a4 - ((_WORD)v76 + 1), &v87) >= 0 && a4 - v100 >= (unsigned int)v87 )
      {
        v77 = getAsnSequence(&v100, (_WORD)a4 - (_WORD)v100, &v87);
        v23 = -31;
        if ( v77 < 0 )
          return v23;
        v78 = v87;
        v79 = v100;
        if ( v87 != a4 - v100 )
        {
          psTraceStr("psAssert %s", (int)"keyformat/x509.c");
          psTraceInt(":%d ", 6375);
          psError((int)"glen == (end - p)");
          v79 = v100;
          v78 = v87;
        }
        v80 = psX509ParseCert(a1, v79, v78, (int *)(a5 + 248), 1u);
        if ( v80 >= 0 )
        {
          v76 = &v100[v80];
          v100 += v80;
          goto LABEL_148;
        }
        psX509FreeCert(*(_DWORD *)(a5 + 248));
      }
    }
    return -31;
  }
LABEL_8:
  if ( a4 != v13 )
  {
    psTraceStr("psAssert %s", (int)"keyformat/x509.c");
    psTraceInt(":%d ", 6524);
    psError((int)"end == p");
    v13 = v96;
  }
  *a3 = v13;
  return 0;
}
// 47C10C: conditional instruction was optimized away because $a0.4==1
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (0047C8F0) --------------------------------------------------------
int   psOcspResponseCheckDates(int a1, int a2, int *a3, int *a4, int *a5, int *a6, int a7)
{
  int *v9; // $s3
  int *v11; // $s5
  int *v12; // $s4
  int v13; // $v1
  int *v14; // $a2
  _DWORD *v15; // $a3
  int v16; // $t2
  int v17; // $t1
  int v18; // $a0
  int v19; // $a1
  int v20; // $t3
  int v21; // $t0
  int v22; // $v0
  int v23; // $v0
  int v24; // $a2
  int v25; // $s0
  _BYTE *v26; // $a1
  BOOL v27; // $s1
  _BYTE *v28; // $a1
  int *v29; // $a0
  int v30; // $s0
  int BrokenDownGMTime; // $v0
  int *v33; // $a2
  int *v34; // $a3
  int *v35; // $t0
  int v36; // $v0
  int v37; // $ra
  int v38; // $t8
  int v39; // $s4
  int v40; // $v1
  int v41; // $a1
  unsigned int v42; // $a2
  int v43; // $v0
  _DWORD v44[12]; // [sp+18h] [-120h] BYREF
  char v45; // [sp+48h] [-F0h] BYREF
  char v46; // [sp+78h] [-C0h] BYREF
  char v47; // [sp+A8h] [-90h] BYREF
  _DWORD v48[12]; // [sp+D8h] [-60h] BYREF
  _DWORD v49[12]; // [sp+108h] [-30h] BYREF

  v9 = a3;
  v11 = a5;
  v12 = a6;
  v13 = -6;
  if ( a2 >= 3 )
    return v13;
  if ( !a3 )
  {
    v9 = v44;
    memset(v44, 0, 44);
  }
  if ( !v9[5] )
  {
    BrokenDownGMTime = psGetBrokenDownGMTime(v9, 0);
    v13 = -1;
    if ( BrokenDownGMTime )
      return v13;
  }
  v14 = v9;
  v15 = v48;
  do
  {
    v16 = *v14;
    v17 = v14[1];
    v18 = v14[2];
    v19 = v14[3];
    v14 += 4;
    *v15 = v16;
    v15[1] = v17;
    v15[2] = v18;
    v15[3] = v19;
    v15 += 4;
  }
  while ( v14 != v9 + 8 );
  v20 = *v14;
  v21 = v14[1];
  v15[2] = v14[2];
  *v15 = v20;
  v15[1] = v21;
  v22 = psBrokenDownTimeAdd(v48, a7);
  v13 = -1;
  if ( v22 )
    return v13;
  if ( !a5 )
    v11 = (int *)&v45;
  if ( !a6 )
  {
    v12 = (int *)&v46;
    if ( a4 )
      goto LABEL_12;
LABEL_32:
    a4 = (int *)&v47;
    goto LABEL_12;
  }
  if ( !a4 )
    goto LABEL_32;
LABEL_12:
  v23 = psBrokenDownTimeImport(a4, *(_BYTE **)(a1 + 8), *(__int16 *)(a1 + 12), 0);
  v24 = 52 * a2 + a1;
  v25 = v24 + 16;
  v26 = *(_BYTE **)(v24 + 52);
  v27 = 0;
  if ( v26 )
  {
    v27 = v23 == 0;
    if ( psBrokenDownTimeImport(v11, v26, *(__int16 *)(v24 + 56), 0) )
      v27 = 0;
  }
  v28 = *(_BYTE **)(v25 + 44);
  v29 = v12;
  if ( v28 )
  {
    v42 = *(__int16 *)(v25 + 48);
    goto LABEL_26;
  }
  if ( v27 )
  {
    v42 = *(__int16 *)(v25 + 40);
    v28 = *(_BYTE **)(v25 + 36);
    v29 = v12;
LABEL_26:
    if ( psBrokenDownTimeImport(v29, v28, v42, 0) )
      return -31;
  }
  v30 = -31;
  if ( !v27 )
    return v30;
  v33 = v12;
  v34 = v49;
  v35 = v12 + 8;
  do
  {
    v36 = *v33;
    v37 = v33[1];
    v38 = v33[2];
    v39 = v33[3];
    v33 += 4;
    *v34 = v36;
    v34[1] = v37;
    v34[2] = v38;
    v34[3] = v39;
    v34 += 4;
  }
  while ( v33 != v35 );
  v40 = *v33;
  v41 = v33[1];
  v34[2] = v33[2];
  *v34 = v40;
  v34[1] = v41;
  v13 = psBrokenDownTimeAdd(v49, a7);
  if ( !v13 )
  {
    if ( psBrokenDownTimeCmp((int)v11, (int)v48) > 0 )
      return -13;
    v43 = psBrokenDownTimeCmp((int)v49, (int)v9);
    v13 = 0;
    if ( v43 >= 0 )
      return v13;
    return -13;
  }
  return v13;
}
// 47CB68: masking with 0x1 was optimized away because $s1.4 <= 0x1

//----- (0047CC30) --------------------------------------------------------
int   psOcspResponseValidate(int a1, int a2, int a3, _BYTE **a4, void *a5)
{
  void *v5; // $s5
  int v9; // $a1
  int v10; // $s6
  int v11; // $s0
  int v12; // $a1
  int v13; // $a0
  int v14; // $a2
  int i; // $s1
  int v16; // $s0
  int v17; // $a1
  int v18; // $a0
  int v19; // $a2
  int v20; // $s0
  int v21; // $a0
  int v22; // $a1
  int v23; // $a0
  int v24; // $a2
  int v26; // $v0
  int v27; // $a0
  int v28; // $t4
  int AsnTagLenUnsafe; // $v0
  int v30; // $a0
  int v31; // $s2
  int v32; // $v1
  int v33; // $s1
  int v34; // $s0
  int v35; // $s2
  _BYTE **v36; // $v0
  _BYTE **v37; // $s3
  int v38; // $t4
  int *v39; // $v0
  int v40; // $v0
  _DWORD *v41; // $s0
  int v42; // $v1
  int v43; // $v0
  int v44; // $s1
  int v45; // $v0
  int *v46; // $v0
  int *v47; // $a0
  _DWORD *v48; // $v1
  int v49; // $v0
  unsigned __int16 v50; // $s1
  int v51; // $v0
  int v52; // $v0
  int v53; // $v0
  int v54; // $a0
  int v55; // $t3
  _BYTE *v56; // $a1
  unsigned __int8 *v57; // [sp+10h] [-1B8h]
  unsigned __int16 v58; // [sp+14h] [-1B4h]
  _BYTE v59[64]; // [sp+28h] [-1A0h] BYREF
  int v60; // [sp+68h] [-160h] BYREF
  int v61; // [sp+6Ch] [-15Ch]
  int v62; // [sp+70h] [-158h]
  int v63; // [sp+74h] [-154h]
  int v64[8]; // [sp+78h] [-150h] BYREF
  int v65[8]; // [sp+98h] [-130h] BYREF
  int v66[8]; // [sp+B8h] [-110h] BYREF
  int v67[8]; // [sp+D8h] [-F0h] BYREF
  int v68[8]; // [sp+F8h] [-D0h] BYREF
  int v69[8]; // [sp+118h] [-B0h] BYREF
  int v70[8]; // [sp+138h] [-90h] BYREF
  int v71[8]; // [sp+158h] [-70h] BYREF
  int v72[8]; // [sp+178h] [-50h] BYREF
  int v73[8]; // [sp+198h] [-30h] BYREF
  int v74; // [sp+1B8h] [-10h] BYREF
  int v75; // [sp+1BCh] [-Ch] BYREF
  int v76; // [sp+1C0h] [-8h]
  int v77; // [sp+1C4h] [-4h]

  v5 = a5;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v63 = 0;
  v76 = 0;
  v77 = 0;
  if ( !a5 )
    v5 = &unk_4E9E60;
  v9 = *((_DWORD *)v5 + 5);
  if ( v9 )
  {
    v32 = psParseBufFromStaticData(v64, v9, *((_DWORD *)v5 + 6));
    if ( !v32 )
    {
      psParseBufReadTagSub(v64, (char *)v65, 0x30u);
      psParseBufReadTagSub(v65, (char *)v66, 0x30u);
      psParseBufTrySkipBytes(v66, (int)&unk_4A0544, 5u);
      psParseBufTrySkipTag((int)v66, 0xA1u);
      psParseBufReadTagSub(v66, (char *)v69, 0x30u);
      psParseBufReadTagSub(v69, (char *)v70, 0x30u);
      psParseBufReadTagSub(v70, (char *)v71, 0x30u);
      psParseBufReadTagSub(v71, (char *)v72, 0x30u);
      psParseBufFinish(v72);
      psParseBufFinish(v71);
      psParseBufFinish(v70);
      psParseBufFinish(v69);
      if ( psParseBufTryReadTagSub((int)v66, (char *)v67, 0xA2u) )
      {
        do
        {
          if ( !psParseBufTryReadTagSub((int)v67, (char *)v68, 0x30u) )
            break;
          psParseBufReadTagSub(v68, (char *)v73, 0x30u);
          if ( psParseBufTrySkipBytes(v73, (int)&unk_4A03E0, 0xBu) )
            psParseBufReadTagRef(v73, &v60, 4u);
          psParseBufFinish(v73);
        }
        while ( !psParseBufFinish(v68) );
        psParseBufFinish(v67);
      }
      psParseBufFinish(v66);
      v32 = psParseBufFinish(v65);
    }
    v21 = -6;
    if ( v32 )
      return v21;
  }
  v10 = 0;
  if ( !a4[62] )
  {
    v16 = a2;
    if ( !a2 )
      goto LABEL_25;
    while ( 1 )
    {
      v17 = v16 + 764;
      v18 = (int)a4[1];
      v19 = 20;
      if ( !v18 )
      {
        if ( !*a4 )
          goto LABEL_20;
        AsnTagLenUnsafe = getAsnTagLenUnsafe(*a4);
        if ( (unsigned int)(AsnTagLenUnsafe - 2) >= 0x3FF )
          goto LABEL_20;
        v30 = *(_DWORD *)(v16 + 784);
        v19 = AsnTagLenUnsafe;
        if ( !v30 )
          goto LABEL_20;
        v31 = *(unsigned __int16 *)(v16 + 794);
        v18 = v30 + v31;
        if ( *(unsigned __int16 *)(v16 + 788) < (unsigned int)(v31 + AsnTagLenUnsafe) )
          goto LABEL_20;
        v17 = (int)*a4;
      }
      if ( !memcmpct(v18, v17, v19) )
      {
        v10 = v16;
LABEL_24:
        if ( v10 )
          goto LABEL_47;
LABEL_25:
        v20 = *(_DWORD *)(a3 + 796);
        v21 = -1;
        if ( !v20 )
          return v21;
        while ( 2 )
        {
          v22 = v20 + 764;
          v23 = (int)a4[1];
          v24 = 20;
          if ( v23 )
          {
LABEL_30:
            if ( !memcmpct(v23, v22, v24) )
            {
              v10 = v20;
LABEL_32:
              if ( v10 )
                goto LABEL_47;
              return -1;
            }
          }
          else if ( *a4 )
          {
            v53 = getAsnTagLenUnsafe(*a4);
            if ( (unsigned int)(v53 - 2) < 0x3FF )
            {
              v54 = *(_DWORD *)(v20 + 784);
              v24 = v53;
              if ( v54 )
              {
                v55 = *(unsigned __int16 *)(v20 + 794);
                v23 = v54 + v55;
                if ( *(unsigned __int16 *)(v20 + 788) >= (unsigned int)(v55 + v53) )
                {
                  v22 = (int)*a4;
                  goto LABEL_30;
                }
              }
            }
          }
          v20 = *(_DWORD *)(v20 + 796);
          if ( !v20 )
            goto LABEL_32;
          continue;
        }
      }
LABEL_20:
      v16 = *(_DWORD *)(v16 + 796);
      if ( !v16 )
        goto LABEL_24;
    }
  }
  v11 = (int)a4[62];
  while ( 1 )
  {
    v12 = v11 + 764;
    v13 = (int)a4[1];
    v14 = 20;
    if ( !v13 )
    {
      if ( !*a4 )
        goto LABEL_7;
      v26 = getAsnTagLenUnsafe(*a4);
      if ( (unsigned int)(v26 - 2) >= 0x3FF )
        goto LABEL_7;
      v27 = *(_DWORD *)(v11 + 784);
      v14 = v26;
      if ( !v27 )
        goto LABEL_7;
      v28 = *(unsigned __int16 *)(v11 + 794);
      v13 = v27 + v28;
      if ( *(unsigned __int16 *)(v11 + 788) < (unsigned int)(v28 + v26) )
        goto LABEL_7;
      v12 = (int)*a4;
    }
    if ( !memcmpct(v13, v12, v14) )
      break;
LABEL_7:
    v11 = *(_DWORD *)(v11 + 796);
    if ( !v11 )
      goto LABEL_46;
  }
  v74 = a2;
  for ( i = a2; v74; i = v74 )
  {
    if ( !memcmp(i + 328, v11 + 196, 20) )
    {
      v10 = v11;
      if ( psX509AuthenticateCert(a1, v11, i, &v74) )
        return -1;
      v74 = 0;
    }
    else
    {
      v74 = *(_DWORD *)(i + 796);
    }
  }
LABEL_46:
  v21 = -1;
  if ( !v10 )
    return v21;
LABEL_47:
  v33 = *(unsigned __int16 *)(a3 + 160);
  v75 = 0;
  v34 = 0;
  v35 = 0;
  v36 = a4 + 4;
  while ( 2 )
  {
    v37 = v36;
    if ( v33 != *((__int16 *)v36 + 8) )
    {
      v38 = v35 + 1;
      goto LABEL_50;
    }
    v49 = memcmp(*(_DWORD *)(a3 + 156), v36[3], v33);
    v38 = v35 + 1;
    if ( v49 )
    {
LABEL_50:
      v34 = v38;
      v75 = v38;
      v35 = v38;
      v36 = v37 + 13;
      if ( v38 >= 3 )
        break;
      continue;
    }
    break;
  }
  v21 = -1;
  if ( v34 == 3 )
    return v21;
  v39 = (int *)*((_DWORD *)v5 + 7);
  if ( v39 )
  {
    *v39 = v34;
    v34 = v75;
  }
  if ( *((_WORD *)v37 + 9) )
  {
    if ( *((_WORD *)v37 + 9) == 1 )
    {
      v76 = 1;
      v77 = 1;
    }
  }
  else
  {
    v76 = 1;
    v77 = 0;
  }
  v40 = psOcspResponseCheckDates((int)a4, v34, 0, 0, 0, 0, 120);
  v21 = -1;
  if ( v40 )
    return v21;
  if ( v60 )
  {
    v41 = (_DWORD *)*((_DWORD *)v5 + 2);
    if ( v41 )
    {
      if ( a4[63] )
      {
        v56 = a4[64];
        *v41 = v62 - v61 == a4[65] - v56 && v61 && v56 && !memcmp(v61, v56, v62 - v61);
      }
      else
      {
        *v41 = 0;
      }
    }
  }
  v42 = *((unsigned __int16 *)a4 + 86);
  if ( v42 == 526 )
  {
    v50 = 64;
LABEL_68:
    v21 = -1;
    if ( *(_BYTE *)(v10 + 150) != 3 )
      return v21;
    v57 = a4[44];
    v58 = *((_WORD *)a4 + 90);
    v75 = 0;
    v45 = psEccDsaVerify(0, v10 + 40, (_BYTE *)a4 + 182, v50, v57, v58, &v75);
    v21 = -1;
    if ( v45 < 0 || v75 != 1 )
      return v21;
    goto LABEL_71;
  }
  if ( *((unsigned __int16 *)a4 + 86) >= 0x20Fu )
  {
    if ( v42 == 1679 )
    {
      v44 = 32;
    }
    else if ( *((unsigned __int16 *)a4 + 86) >= 0x690u )
    {
      if ( v42 == 1680 )
      {
        v44 = 48;
      }
      else
      {
        if ( v42 != 1681 )
          return -10;
        v44 = 64;
      }
    }
    else
    {
      v43 = 1673;
LABEL_65:
      v44 = 20;
      if ( v42 != v43 )
        return -10;
    }
    v21 = -1;
    if ( *(_BYTE *)(v10 + 150) != 1 )
      return v21;
    v51 = pubRsaDecryptSignedElement(0, v10 + 40, a4[44], *((_WORD *)a4 + 90), (int)v59, v44);
    v21 = -1;
    if ( v51 < 0 )
      return v21;
    v52 = memcmp((char *)a4 + 182, v59, v44);
    v21 = -1;
    if ( v52 )
      return v21;
LABEL_71:
    if ( *(_DWORD *)v5 )
      **(_DWORD **)v5 = v76;
    v21 = -1;
    if ( v76 )
    {
      v46 = (int *)*((_DWORD *)v5 + 1);
      if ( v46 )
        *v46 = v77;
      v47 = (int *)*((_DWORD *)v5 + 3);
      if ( v47 )
        psBrokenDownTimeImport(v47, (_BYTE *)v37 + 20, 0xFu, 0);
      v48 = (_DWORD *)*((_DWORD *)v5 + 4);
      if ( v48 )
        *v48 = *((unsigned __int8 *)v37 + 35);
      v21 = -35;
      if ( !v77 )
        return 0;
    }
    return v21;
  }
  if ( v42 == 520 )
  {
    v50 = 20;
    goto LABEL_68;
  }
  v43 = 91;
  if ( *((unsigned __int16 *)a4 + 86) < 0x209u )
    goto LABEL_65;
  if ( v42 == 524 )
  {
    v50 = 32;
    goto LABEL_68;
  }
  if ( v42 == 525 )
  {
    v50 = 48;
    goto LABEL_68;
  }
  return -10;
}
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);

//----- (0047D66C) --------------------------------------------------------
int   psOcspResponseValidateOld(int a1, int a2, int a3, _BYTE **a4)
{
  return psOcspResponseValidate(a1, a2, a3, a4, 0);
}

//----- (0047D6A8) --------------------------------------------------------
int   psCryptoOpen(int a1)
{
  int v2; // $a3

  v2 = 0;
  if ( byte_4E684C != 89 )
  {
    if ( !strncmp("YYNNNNNYYNY", a1, 7) )
    {
      if ( psCoreOpen(a1 + 7) < 0 )
      {
        psTraceStr("psError %s", (int)"layer/matrix.c");
        psTraceInt(":%d ", 66);
        psError((int)"pscore open failure\n");
        return -1;
      }
      else
      {
        psOpenPrng();
        psCrlOpen();
        strncpy(&byte_4E684C, "YYNNNNNYYNY", 31);
        return 0;
      }
    }
    else
    {
      psTraceStr("psError %s", (int)"layer/matrix.c");
      psTraceInt(":%d ", 61);
      psErrorStr("Crypto config mismatch.\nLibrary: YYNNNNNYYNY\nCurrent: %s\n", a1);
      return -1;
    }
  }
  return v2;
}
// 4E684C: using guessed type char byte_4E684C;
// 4E9FD8: using guessed type int   strncpy(_DWORD, _DWORD, _DWORD);
// 4E9FDC: using guessed type int   strncmp(_DWORD, _DWORD, _DWORD);

//----- (0047D854) --------------------------------------------------------
int psCryptoClose()
{
  int result; // $v0

  result = 89;
  if ( byte_4E684C == 89 )
  {
    byte_4E684C = 78;
    psClosePrng();
    psCoreClose();
    return psCrlClose();
  }
  return result;
}
// 4E684C: using guessed type char byte_4E684C;

//----- (0047D8CC) --------------------------------------------------------
int   pstm_init_size(int a1, int *a2, unsigned __int16 a3)
{
  unsigned int v3; // $s0
  int v6; // $v1
  int v7; // $v0
  unsigned int i; // $a0
  int v9; // $s2

  v3 = a3;
  v6 = -8;
  if ( a3 < 0x181u )
  {
    v7 = malloc(4 * a3);
    *a2 = v7;
    v6 = -8;
    if ( v7 )
    {
      a2[2] = a2[2] & 0xFE000000 | ((v3 & 0xFFF) << 12) & 0xFEFFFFFF;
      a2[1] = a1;
      for ( i = 0; i < v3; *(_DWORD *)(v9 + v7) = 0 )
      {
        v9 = 4 * i;
        i = (unsigned __int16)(i + 1);
      }
      return 0;
    }
  }
  return v6;
}
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (0047D9A4) --------------------------------------------------------
int   pstm_init(int a1, int *a2)
{
  return pstm_init_size(a1, a2, 0x60u);
}

//----- (0047D9C0) --------------------------------------------------------
int   pstm_grow(int *a1, unsigned __int16 a2)
{
  int v4; // $v1
  int v6; // $v0
  unsigned int v7; // $t3
  unsigned int v8; // $t0
  int v9; // $a0
  int v10; // $a1
  int v11; // $ra
  int v12; // $a0
  int v13; // $ra

  v4 = -8;
  if ( a2 < 0x181u )
  {
    if ( (int)(((unsigned int)a1[2] >> 12) & 0xFFF) < a2 )
    {
      v6 = realloc(*a1, 4 * a2);
      v4 = -8;
      if ( !v6 )
        return v4;
      v7 = a1[2];
      v8 = v7 & 0xFF000FFF | ((a2 & 0xFFF) << 12);
      v9 = (v7 >> 12) & 0xFFF;
      v10 = (v8 >> 12) & 0xFFF;
      a1[2] = v8;
      *a1 = v6;
      if ( v9 < v10 )
      {
        while ( 1 )
        {
          v11 = 4 * v9;
          v12 = (unsigned __int16)(v9 + 1);
          *(_DWORD *)(v11 + v6) = 0;
          if ( v12 >= v10 )
            break;
          v13 = 4 * v12;
          v9 = (unsigned __int16)(v12 + 1);
          *(_DWORD *)(v13 + v6) = 0;
          if ( v9 >= v10 )
            return 0;
        }
      }
    }
    return 0;
  }
  return v4;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);

//----- (0047DAC8) --------------------------------------------------------
int   pstm_copy(int a1, int *a2)
{
  int result; // $v0
  unsigned int v5; // $t1
  int v6; // $a0
  int v7; // $a1
  int v8; // $s0
  int v9; // $a3
  _DWORD *v10; // $a1
  _DWORD *v11; // $a2
  int v12; // $t0
  int v13; // $v1
  int v14; // $v0
  int v15; // $t4
  int v16; // $v0
  unsigned int v17; // $t2
  unsigned int v18; // $t0
  int v19; // $a0
  int v20; // $a1
  int v21; // $t8

  result = 0;
  if ( (int *)a1 == a2 )
    return result;
  v5 = a2[2];
  v6 = *(_DWORD *)(a1 + 8);
  v7 = (v5 >> 12) & 0xFFF;
  v8 = v6 & 0xFFF;
  if ( v7 < v8 )
  {
    if ( (unsigned int)v8 < 0x181 )
    {
      if ( v7 >= v8 )
      {
LABEL_14:
        v5 = a2[2];
        v6 = *(_DWORD *)(a1 + 8);
        v9 = v6 & 0xFFF;
        goto LABEL_4;
      }
      v16 = realloc(*a2, 4 * v8);
      if ( v16 )
      {
        v17 = a2[2];
        v18 = v17 & 0xFF000FFF | (v8 << 12);
        v19 = (v17 >> 12) & 0xFFF;
        v20 = (v18 >> 12) & 0xFFF;
        *a2 = v16;
        a2[2] = v18;
        if ( v19 < v20 )
        {
          do
          {
            v21 = 4 * v19;
            v19 = (unsigned __int16)(v19 + 1);
            *(_DWORD *)(v21 + v16) = 0;
          }
          while ( v19 < v20 );
          v5 = a2[2];
          v6 = *(_DWORD *)(a1 + 8);
          v9 = v6 & 0xFFF;
          goto LABEL_4;
        }
        goto LABEL_14;
      }
    }
    return -8;
  }
  v9 = v6 & 0xFFF;
LABEL_4:
  v10 = *(_DWORD **)a1;
  v11 = (_DWORD *)*a2;
  v12 = 0;
  if ( v9 )
  {
    v13 = v9;
    do
    {
      --v13;
      *v11++ = *v10++;
    }
    while ( v13 );
    v12 = v9;
  }
  v14 = (v5 & 0xFFF) - v12;
  if ( v12 < (unsigned __int16)(v5 & 0xFFF) )
  {
    do
    {
      --v14;
      *v11++ = 0;
    }
    while ( v14 );
  }
  v15 = a2[2];
  a2[2] = v15 & 0xFFFFF000 | v6 & 0xFFF;
  a2[2] = v15 & 0xFEFFF000 | v6 & 0xFFF | ((*(_BYTE *)(a1 + 11) & 1) << 24);
  return 0;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);

//----- (0047DC8C) --------------------------------------------------------
int   pstm_clamp(int *a1)
{
  unsigned int v2; // $a0
  int result; // $v0
  unsigned int v4; // $a1
  int v5; // $a2
  int v6; // $t4
  unsigned int v7; // $v1

  v2 = a1[2];
  result = v2 & 0xFFF;
  v4 = v2;
  if ( (v2 & 0xFFF) != 0 )
  {
    v5 = *a1;
    result = 4 * result + *a1;
    v6 = v2 & 0xFFF;
    if ( !*(_DWORD *)(result - 4) )
    {
      do
      {
        v7 = v4 & 0xFFFFF000 | (v6 - 1) & 0xFFF;
        result = 4 * ((v6 - 1) & 0xFFF) + v5;
        a1[2] = v7;
        v4 = v7;
        if ( (v7 & 0xFFF) == 0 )
          break;
        v6 = v7 & 0xFFF;
      }
      while ( !*(_DWORD *)(result - 4) );
      v2 = v7;
    }
  }
  if ( (v2 & 0xFFF) == 0 )
    a1[2] = v2 & 0xFEFFFFFF;
  return result;
}

//----- (0047DD20) --------------------------------------------------------
void   pstm_clear(_DWORD *a1)
{
  _DWORD *v2; // $a0
  int v3; // $v0
  _DWORD *i; // $v1

  if ( a1 )
  {
    v2 = (_DWORD *)*a1;
    if ( v2 )
    {
      v3 = a1[2] & 0xFFF;
      for ( i = v2; v3; ++i )
      {
        --v3;
        *i = 0;
      }
      free2(v2);
      a1[2] &= 0xFE000000;
      *a1 = 0;
    }
  }
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (0047DDC0) --------------------------------------------------------
void   pstm_clear_multi(
        _DWORD *a1,
        _DWORD *a2,
        _DWORD *a3,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6,
        _DWORD *a7,
        _DWORD *a8)
{
  if ( a1 )
  {
    pstm_clear(a1);
    if ( a2 )
    {
      pstm_clear(a2);
      if ( a3 )
      {
        pstm_clear(a3);
        if ( a4 )
        {
          pstm_clear(a4);
          if ( a5 )
          {
            pstm_clear(a5);
            if ( a6 )
            {
              pstm_clear(a6);
              if ( a7 )
              {
                pstm_clear(a7);
                if ( a8 )
                  pstm_clear(a8);
              }
            }
          }
        }
      }
    }
  }
}

//----- (0047DF2C) --------------------------------------------------------
int   pstm_cmp_mag(_DWORD *a1, _DWORD *a2)
{
  int v2; // $a2
  int v3; // $v1
  int v4; // $a3
  _DWORD *v5; // $a0
  int v6; // $t0
  _DWORD *v7; // $a1
  int v8; // $t1
  BOOL v9; // $t4
  BOOL v10; // $a2

  v2 = a1[2] & 0xFFF;
  v3 = a2[2] & 0xFFF;
  v4 = 1;
  if ( v3 < v2 )
    return v4;
  v4 = -1;
  if ( v2 < v3 )
    return v4;
  v5 = (_DWORD *)(*a1 + 4 * v2 - 4);
  LOWORD(v6) = 0;
  v7 = (_DWORD *)(*a2 + 4 * v2 - 4);
  if ( !v2 )
    return 0;
  v8 = v2;
  while ( 1 )
  {
    v6 = (unsigned __int16)(v6 + 1);
    v9 = *v7 < *v5;
    v10 = *v5-- < *v7--;
    if ( v9 )
      return 1;
    if ( v10 )
      break;
    if ( v6 >= v8 )
      return 0;
  }
  return -1;
}

//----- (0047DFD8) --------------------------------------------------------
int   pstm_cmp(_DWORD *a1, _DWORD *a2)
{
  unsigned int v2; // $a2
  int v4; // $v1
  int v5; // $a0
  int v7; // $t0
  int v8; // $a2
  int v9; // $a0
  int v10; // $v1
  _DWORD *v11; // $a0
  int v12; // $t0
  _DWORD *v13; // $a1
  int v14; // $t1
  BOOL v15; // $t3
  BOOL v16; // $a2
  _DWORD *v18; // $a1
  _DWORD *v19; // $a0
  int v20; // $t1
  BOOL v21; // $t6
  BOOL v22; // $a2

  v2 = a1[2];
  v4 = HIBYTE(v2) & 1;
  if ( v4 != (HIBYTE(a2[2]) & 1) )
  {
    v5 = -1;
    if ( v4 == 1 )
      return v5;
    return 1;
  }
  v7 = a2[2] & 0xFFF;
  if ( v4 != 1 )
  {
    v8 = a1[2] & 0xFFF;
    v9 = a2[2] & 0xFFF;
    v10 = 1;
    if ( v9 >= v8 )
    {
      v10 = -1;
      if ( v8 >= v9 )
      {
        v11 = (_DWORD *)(*a1 + 4 * v8 - 4);
        LOWORD(v12) = 0;
        v13 = (_DWORD *)(*a2 + 4 * v8 - 4);
        if ( v8 )
        {
          v14 = v8;
          while ( 1 )
          {
            v12 = (unsigned __int16)(v12 + 1);
            v15 = *v13 < *v11;
            v16 = *v11-- < *v13--;
            if ( v15 )
              return 1;
            if ( v16 )
              break;
            if ( v12 >= v14 )
              return 0;
          }
          return -1;
        }
        return 0;
      }
    }
    return v10;
  }
  v5 = 1;
  if ( (unsigned __int16)(v2 & 0xFFF) < v7 )
    return v5;
  v5 = -1;
  if ( v7 < (unsigned __int16)(v2 & 0xFFF) )
    return v5;
  v18 = (_DWORD *)(*a2 + 4 * v7 - 4);
  v19 = (_DWORD *)(*a1 + 4 * v7 - 4);
  LOWORD(v20) = 0;
  if ( v7 )
  {
    while ( 1 )
    {
      v20 = (unsigned __int16)(v20 + 1);
      v21 = *v19 < *v18;
      v22 = *v18-- < *v19--;
      if ( v21 )
        break;
      if ( v22 )
        return -1;
      if ( v20 >= v7 )
        return 0;
    }
    return 1;
  }
  return 0;
}

//----- (0047E154) --------------------------------------------------------
int   pstm_cmp_d(unsigned int **a1, unsigned int a2)
{
  unsigned int v3; // $v1
  int v4; // $a0
  unsigned int v6; // $v1

  if ( a2 )
  {
    v3 = (unsigned int)a1[2];
    if ( (v3 & 0xFFF) == 0 )
      return -1;
  }
  else
  {
    v3 = (unsigned int)a1[2];
  }
  v4 = 1;
  if ( (HIBYTE(v3) & 1) == 1 )
    return -1;
  if ( (v3 & 0xFFF) >= 2 )
    return v4;
  v6 = **a1;
  if ( a2 < v6 )
    return v4;
  return -(v6 < a2);
}

//----- (0047E1D0) --------------------------------------------------------
int   pstm_init_for_read_unsigned_bin(int a1, int *a2, unsigned __int16 a3)
{
  return pstm_init_size(a1, a2, (a3 >> 2) + 2);
}

//----- (0047E1F4) --------------------------------------------------------
int   pstm_read_unsigned_bin(int *a1, _BYTE *a2, unsigned __int16 a3)
{
  int v3; // $t0
  signed int v5; // $v1
  _BYTE *v6; // $s0
  int v7; // $s2
  _DWORD *v8; // $a0
  signed int v9; // $v0
  signed int v10; // $ra
  unsigned int v11; // $s1
  int v12; // $a0
  int v13; // $s1
  int v14; // $a2
  int v15; // $a1
  _BYTE *v16; // $t0
  unsigned int v17; // $a0
  unsigned int v18; // $a1
  int v19; // $a2
  int v20; // $s1
  int v21; // $t8
  unsigned int v22; // $v1
  int v24; // $v0
  unsigned int v25; // $t5
  unsigned int v26; // $t3
  int v27; // $a0
  int v28; // $a1
  int v29; // $a3
  int v30; // $a0
  int v31; // $a3

  v3 = a1[2];
  v5 = ((v3 & 0xFEFFF000) >> 12) & 0xFFF;
  a1[2] = v3 & 0xFEFFF000;
  v6 = a2;
  v7 = a3;
  v8 = (_DWORD *)*a1;
  LOWORD(v9) = 0;
  if ( v5 )
  {
    do
    {
      v9 = (unsigned __int16)(v9 + 1);
      *v8++ = 0;
    }
    while ( v9 < v5 );
  }
  if ( a3 >= 0x601u )
  {
    v6 = &a2[(unsigned __int16)(a3 - 1536)];
    v7 = 1536;
  }
  v10 = ((unsigned int)(v7 + 3) >> 2) & 0xFFF;
  v11 = a1[2] & 0xFFFFF000 | v10;
  v12 = (v11 >> 12) & 0xFFF;
  a1[2] = v11;
  if ( v12 >= v10 )
    goto LABEL_8;
  v13 = (unsigned __int16)v10;
  if ( (unsigned __int16)v10 >= 0x181u )
    return -8;
  if ( v12 >= (unsigned __int16)v10 )
    goto LABEL_8;
  v24 = realloc(*a1, 4 * (unsigned __int16)v10);
  if ( !v24 )
    return -8;
  v25 = a1[2];
  v26 = v25 & 0xFF000FFF | (v13 << 12);
  v27 = (v25 >> 12) & 0xFFF;
  v28 = (v26 >> 12) & 0xFFF;
  *a1 = v24;
  a1[2] = v26;
  if ( v27 < v28 )
  {
    while ( 1 )
    {
      v29 = 4 * v27;
      v30 = (unsigned __int16)(v27 + 1);
      *(_DWORD *)(v29 + v24) = 0;
      if ( v30 >= v28 )
        break;
      v31 = 4 * v30;
      v27 = (unsigned __int16)(v30 + 1);
      *(_DWORD *)(v31 + v24) = 0;
      if ( v27 >= v28 )
      {
        LOWORD(v14) = v7 - 1;
        goto LABEL_9;
      }
    }
  }
LABEL_8:
  LOWORD(v14) = v7 - 1;
LABEL_9:
  v15 = *a1;
  v14 = (__int16)v14;
  while ( v14 >= 0 )
  {
    v16 = (_BYTE *)(v14 + v15);
    v14 = (__int16)(v14 - 1);
    *v16 = *v6++;
  }
  v17 = a1[2];
  v18 = v17;
  if ( (v17 & 0xFFF) == 0 )
    goto LABEL_18;
  v19 = *a1;
  v20 = v17 & 0xFFF;
  if ( !*(_DWORD *)(4 * v20 + *a1 - 4) )
  {
    v21 = v17 & 0xFFF;
    do
    {
      v22 = v18 & 0xFFFFF000 | (v21 - 1) & 0xFFF;
      a1[2] = v22;
      v18 = v22;
      if ( (v22 & 0xFFF) == 0 )
        break;
      v21 = v22 & 0xFFF;
    }
    while ( !*(_DWORD *)(4 * v21 + v19 - 4) );
    v17 = v22;
LABEL_18:
    v20 = v17 & 0xFFF;
  }
  if ( !v20 )
    a1[2] = v17 & 0xFEFFFFFF;
  return 0;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);

//----- (0047E470) --------------------------------------------------------
int   pstm_read_asn(int a1, unsigned __int8 **a2, unsigned __int16 a3, int *a4)
{
  unsigned __int8 *v4; // $v1
  int v8; // $v0
  int v9; // $a0
  int v11; // $s0
  int AsnLength; // $v0
  int inited; // $v0
  unsigned int v14; // $a0
  int v15; // $a2
  unsigned __int8 *v16; // $s0
  unsigned int v17; // $s4
  _DWORD *v18; // $a1
  int v19; // $v0
  unsigned int v20; // $t1
  unsigned int v21; // $v0
  int v22; // $a0
  unsigned int v23; // $s1
  int v24; // $a1
  _BYTE *v25; // $t2
  unsigned int v26; // $a0
  unsigned int v27; // $a1
  int v28; // $a2
  int v29; // $s1
  unsigned int v30; // $v1
  int v31; // $t8
  int v32; // $a2
  unsigned int v33; // $t8
  unsigned int v34; // $t5
  int v35; // $a0
  int v36; // $a1
  int v37; // $t0
  unsigned __int16 v38; // [sp+18h] [-8h] BYREF
  unsigned __int8 *v39; // [sp+1Ch] [-4h] BYREF

  v4 = *a2;
  v39 = *a2;
  if ( !a3 )
    return -31;
  v8 = *v4;
  v39 = v4 + 1;
  if ( v8 != 2 )
    return -31;
  v11 = a3 - 1;
  AsnLength = getAsnLength(&v39, a3 - 1, &v38);
  v9 = -31;
  if ( AsnLength >= 0 && v11 >= v38 )
  {
    inited = pstm_init_size(a1, a4, (v38 >> 2) + 2);
    v9 = -8;
    if ( !inited )
    {
      v14 = a4[2] & 0xFEFFF000;
      v15 = *a4;
      v16 = v39;
      v17 = v38;
      v18 = (_DWORD *)*a4;
      LOWORD(v19) = 0;
      if ( ((v14 >> 12) & 0xFFF) != 0 )
      {
        a4[2] = v14;
        do
        {
          v19 = (unsigned __int16)(v19 + 1);
          *v18++ = 0;
        }
        while ( v19 < (int)((v14 >> 12) & 0xFFF) );
        v14 = a4[2];
      }
      v20 = v17 + 3;
      if ( v17 >= 0x601 )
      {
        v16 += (unsigned __int16)(v17 - 1536);
        LOWORD(v17) = 1536;
        v20 = 1539;
      }
      v21 = v14 & 0xFFFFF000 | (v20 >> 2) & 0xFFF;
      v22 = (v21 >> 12) & 0xFFF;
      a4[2] = v21;
      if ( v22 >= (unsigned __int16)(v21 & 0xFFF) )
        goto LABEL_18;
      v23 = v21 & 0xFFF;
      if ( v23 < 0x181 )
      {
        if ( v22 >= (unsigned __int16)(v21 & 0xFFF) )
        {
LABEL_17:
          v15 = *a4;
LABEL_18:
          LOWORD(v24) = v17 - 1;
LABEL_19:
          v24 = (__int16)v24;
          while ( v24 >= 0 )
          {
            v25 = (_BYTE *)(v24 + v15);
            v24 = (__int16)(v24 - 1);
            *v25 = *v16++;
          }
          v26 = a4[2];
          v27 = v26;
          if ( (v26 & 0xFFF) != 0 )
          {
            v28 = *a4;
            v29 = v26 & 0xFFF;
            if ( !*(_DWORD *)(4 * v29 + *a4 - 4) )
            {
              do
              {
                v30 = v27 & 0xFFFFF000 | (v29 - 1) & 0xFFF;
                v31 = (v29 - 1) & 0xFFF;
                v27 = v30;
                a4[2] = v30;
                if ( !v31 )
                  break;
                v29 = v30 & 0xFFF;
              }
              while ( !*(_DWORD *)(4 * v31 + v28 - 4) );
              v26 = v30;
            }
          }
          if ( (v26 & 0xFFF) == 0 )
            a4[2] = v26 & 0xFEFFFFFF;
          v9 = 0;
          *a2 = &v39[v38];
          return v9;
        }
        v32 = realloc(v15, 4 * v23);
        if ( v32 )
        {
          v33 = a4[2];
          v34 = v33 & 0xFF000FFF | (v23 << 12);
          v35 = (v33 >> 12) & 0xFFF;
          v36 = (v34 >> 12) & 0xFFF;
          *a4 = v32;
          a4[2] = v34;
          if ( v35 < v36 )
          {
            do
            {
              v37 = 4 * v35;
              v35 = (unsigned __int16)(v35 + 1);
              *(_DWORD *)(v37 + v32) = 0;
            }
            while ( v35 < v36 );
            v15 = *a4;
            LOWORD(v24) = v17 - 1;
            goto LABEL_19;
          }
          goto LABEL_17;
        }
      }
      pstm_clear(a4);
      return -31;
    }
  }
  return v9;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);

//----- (0047E77C) --------------------------------------------------------
signed int   pstm_set(int a1, int a2)
{
  int v2; // $t0
  signed int v4; // $v1
  _DWORD *v5; // $a0
  signed int result; // $v0

  v2 = *(_DWORD *)(a1 + 8);
  v4 = ((v2 & 0xFEFFF000) >> 12) & 0xFFF;
  *(_DWORD *)(a1 + 8) = v2 & 0xFEFFF000;
  v5 = *(_DWORD **)a1;
  result = 0;
  if ( v4 )
  {
    do
    {
      result = (unsigned __int16)(result + 1);
      *v5++ = 0;
    }
    while ( result < v4 );
  }
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 8) & 0xFFFFF000 | (a2 != 0);
  return result;
}

//----- (0047E7F0) --------------------------------------------------------
int   pstm_unsigned_bin_size(_DWORD *a1)
{
  int v1; // $a1
  unsigned __int16 v2; // $v1
  unsigned int v3; // $a0
  unsigned __int16 v4; // $v0
  int result; // $v0

  v1 = a1[2] & 0xFFF;
  v2 = 0;
  if ( v1 )
  {
    v3 = *(_DWORD *)(4 * v1 + *a1 - 4);
    v4 = 32 * v1 - 32;
    while ( v3 )
    {
      ++v4;
      v3 >>= 1;
    }
    v2 = v4;
  }
  result = (v2 >> 3) + 1;
  if ( (v2 & 7) == 0 )
    return v2 >> 3;
  return result;
}

//----- (0047E858) --------------------------------------------------------
int   pstm_sub_s(int *a1, int *a2, int *a3)
{
  int v3; // $t0
  int v4; // $a3
  int v8; // $v1
  unsigned int v9; // $a0
  int v10; // $a2
  int v11; // $s0
  int v12; // $t8
  int v13; // $s0
  __int64 v14; // $t2
  int v15; // $t4
  int v16; // $t7
  int v17; // $t6
  int v18; // $t5
  int v19; // $t0
  __int64 v20; // kr08_8
  int v21; // $t0
  int v22; // $t1
  int v23; // $a3
  int v24; // $s2
  unsigned int v25; // $ra
  _DWORD *v26; // $v1
  int v27; // $v0
  unsigned int v28; // $a0
  unsigned int v29; // $a1
  int v30; // $a2
  int v31; // $t8
  int v32; // $t9
  int v34; // $v0
  unsigned int v35; // $t5
  unsigned int v36; // $t0
  int v37; // $a0
  int v38; // $a1
  int v39; // $v1
  int v40; // $a0
  int v41; // $v1

  v3 = a2[2];
  v4 = a1[2];
  v8 = -9;
  if ( (v4 & 0xFFF) >= (v3 & 0xFFF) )
  {
    v9 = a3[2];
    v10 = (v9 >> 12) & 0xFFF;
    v11 = v4 & 0xFFF;
    if ( v10 < v11 )
    {
      v8 = -8;
      if ( (unsigned int)v11 >= 0x181 )
        return v8;
      if ( v10 < v11 )
      {
        v34 = realloc(*a3, 4 * v11);
        v8 = -8;
        if ( !v34 )
          return v8;
        v35 = a3[2];
        v36 = v35 & 0xFF000FFF | (v11 << 12);
        v37 = (v35 >> 12) & 0xFFF;
        v38 = (v36 >> 12) & 0xFFF;
        *a3 = v34;
        for ( a3[2] = v36; v37 < v38; *(_DWORD *)(v41 + v34) = 0 )
        {
          v39 = 4 * v37;
          v40 = (unsigned __int16)(v37 + 1);
          *(_DWORD *)(v39 + v34) = 0;
          if ( v40 >= v38 )
            break;
          v41 = 4 * v40;
          v37 = (unsigned __int16)(v40 + 1);
        }
      }
      v3 = a2[2];
      v4 = a1[2];
      v9 = a3[2];
    }
    v12 = v3 & 0xFFF;
    a3[2] = v9 & 0xFFFFF000 | v4 & 0xFFF;
    v13 = v9 & 0xFFF;
    v14 = 0;
    v15 = 0;
    if ( (v3 & 0xFFF) != 0 )
    {
      v16 = *a2;
      v17 = *a3;
      v18 = *a1;
      do
      {
        v19 = 4 * v15;
        v20 = *(unsigned int *)(4 * v15 + v18) - (*(unsigned int *)(4 * v15 + v16) + v14);
        ++v15;
        v14 = BYTE4(v20) & 1;
        *(_DWORD *)(v19 + v17) = v20;
      }
      while ( v15 < v12 );
    }
    v21 = a1[2] & 0xFFF;
    if ( v15 < v21 )
    {
      v22 = *a1;
      v23 = *a3;
      do
      {
        v24 = 4 * v15;
        v25 = *(_DWORD *)(4 * v15++ + v22);
        *(_DWORD *)(v24 + v23) = v25 - v14;
        LODWORD(v14) = ((unsigned __int64)v25 - v14) >> 32;
        HIDWORD(v14) = 0;
      }
      while ( v15 < v21 );
    }
    if ( v15 < v13 )
    {
      v26 = (_DWORD *)(4 * v15 + *a3);
      v27 = v13 - v15;
      do
      {
        --v27;
        *v26++ = 0;
      }
      while ( v27 );
    }
    v28 = a3[2];
    v29 = v28;
    if ( (v28 & 0xFFF) != 0 )
    {
      v30 = *a3;
      if ( !*(_DWORD *)(4 * (v28 & 0xFFF) + *a3 - 4) )
      {
        v31 = v28 & 0xFFF;
        do
        {
          v29 = v29 & 0xFFFFF000 | (v31 - 1) & 0xFFF;
          a3[2] = v29;
          if ( (v29 & 0xFFF) == 0 )
            break;
          v32 = *(_DWORD *)(4 * ((v31 - 1) & 0xFFF) + v30 - 4);
          v31 = v29 & 0xFFF;
        }
        while ( !v32 );
        v28 = v29;
      }
    }
    v8 = 0;
    if ( (v28 & 0xFFF) == 0 )
    {
      a3[2] = v28 & 0xFEFFFFFF;
      return 0;
    }
  }
  return v8;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);

//----- (0047EB54) --------------------------------------------------------
int   sub_47EB54(_DWORD *a1, _DWORD *a2, int *a3)
{
  int v4; // $v1
  int v5; // $s1
  int v8; // $t0
  unsigned int v9; // $t1
  int v10; // $a2
  int v11; // $s7
  unsigned int v12; // $s0
  int v14; // $s2
  int v15; // $s0
  int v16; // $t6
  int v17; // $t5
  int v18; // $t4
  int v19; // $a0
  int v20; // $t0
  BOOL v21; // $t9
  int v22; // $a2
  _DWORD *v23; // $a0
  unsigned int v24; // $a0
  unsigned int v25; // $a1
  int v26; // $a2
  int v27; // $t9
  unsigned int v28; // $v1
  unsigned int v29; // $a2
  int v30; // $v1
  int v31; // $t2
  int *v32; // $a0
  int v33; // $a2
  unsigned int v34; // $s2
  unsigned int v35; // $t6
  int v36; // $a0
  int v37; // $a1
  int v38; // $t0
  int v39; // $a0
  int v40; // $t0
  int v41; // $s1
  int v42; // $a2
  unsigned int v43; // $ra
  unsigned int v44; // $t3
  int v45; // $a0
  int v46; // $a1
  int v47; // $s6

  v4 = a2[2] & 0xFFF;
  v5 = a1[2] & 0xFFF;
  if ( v5 < v4 )
    v5 = (__int16)v4;
  v8 = a3[2];
  v9 = v8 & 0xFFFFF000 | v5;
  v10 = (v9 >> 12) & 0xFFF;
  a3[2] = v9;
  v11 = v8 & 0xFFF;
  if ( v10 < (v5 & 0xFFF) )
  {
    v12 = v5 & 0xFFF;
    if ( v12 >= 0x181 )
      return -8;
    if ( v10 < (v5 & 0xFFF) )
    {
      v33 = realloc(*a3, 4 * v12);
      if ( !v33 )
        return -8;
      v34 = a3[2];
      v35 = v34 & 0xFF000FFF | (v12 << 12);
      v36 = (v34 >> 12) & 0xFFF;
      v37 = (v35 >> 12) & 0xFFF;
      *a3 = v33;
      a3[2] = v35;
      if ( v36 < v37 )
      {
        while ( 1 )
        {
          v38 = 4 * v36;
          v39 = (unsigned __int16)(v36 + 1);
          *(_DWORD *)(v38 + v33) = 0;
          if ( v39 >= v37 )
            break;
          v40 = 4 * v39;
          v36 = (unsigned __int16)(v39 + 1);
          *(_DWORD *)(v40 + v33) = 0;
          if ( v36 >= v37 )
          {
            v14 = 0;
            goto LABEL_8;
          }
        }
      }
    }
  }
  v14 = 0;
LABEL_8:
  v15 = 0;
  if ( v5 )
  {
    v16 = *a3;
    v17 = a1[2] & 0xFFF;
    v18 = a2[2] & 0xFFF;
    do
    {
      v19 = 4 * v15;
      v20 = 0;
      if ( v15 < v17 )
        v20 = *(_DWORD *)(v19 + *a1);
      v21 = v15 < v18;
      v15 = (__int16)(v15 + 1);
      v22 = 0;
      if ( v21 )
        v22 = *(_DWORD *)(v19 + *a2);
      *(_DWORD *)(v19 + v16) = v14 + v20 + v22;
      v14 = __CFADD__(v20, v22) + __CFADD__(v14, v20 + v22);
    }
    while ( v15 < v5 );
  }
  if ( v14 && v15 < 384 )
  {
    v29 = a3[2];
    v30 = v29 & 0xFFF;
    v31 = v30;
    if ( v30 == ((v29 >> 12) & 0xFFF) )
    {
      v41 = v30 + 1;
      if ( (unsigned int)(v30 + 1) >= 0x181 )
        return -8;
      if ( v30 >= v30 + 1 )
        goto LABEL_37;
      v42 = realloc(*a3, 4 * v41);
      if ( !v42 )
        return -8;
      v43 = a3[2];
      v44 = v43 & 0xFF000FFF | ((v41 & 0xFFF) << 12);
      v45 = (v43 >> 12) & 0xFFF;
      v46 = (v44 >> 12) & 0xFFF;
      *a3 = v42;
      a3[2] = v44;
      if ( v45 >= v46 )
      {
LABEL_37:
        v29 = a3[2];
        v31 = v29 & 0xFFF;
      }
      else
      {
        do
        {
          v47 = 4 * v45;
          v45 = (unsigned __int16)(v45 + 1);
          *(_DWORD *)(v47 + v42) = 0;
        }
        while ( v45 < v46 );
        v29 = a3[2];
        v31 = v29 & 0xFFF;
      }
    }
    v32 = (int *)(4 * v31 + *a3);
    v15 = (__int16)(v15 + 1);
    a3[2] = v29 & 0xFFFFF000 | (v31 + 1) & 0xFFF;
    *v32 = v14;
  }
  a3[2] = a3[2] & 0xFFFFF000 | v15 & 0xFFF;
  if ( v15 < v11 )
  {
    v23 = (_DWORD *)(4 * v15 + *a3);
    do
    {
      v15 = (__int16)(v15 + 1);
      *v23++ = 0;
    }
    while ( v15 < v11 );
  }
  v24 = a3[2];
  v25 = v24;
  if ( (v24 & 0xFFF) != 0 )
  {
    v26 = *a3;
    v27 = v24 & 0xFFF;
    if ( !*(_DWORD *)(4 * v27 + *a3 - 4) )
    {
      do
      {
        v28 = v25 & 0xFFFFF000 | (v27 - 1) & 0xFFF;
        a3[2] = v28;
        v25 = v28;
        if ( (v28 & 0xFFF) == 0 )
          break;
        v27 = v28 & 0xFFF;
      }
      while ( !*(_DWORD *)(4 * v27 + v26 - 4) );
      v24 = v28;
    }
  }
  if ( (v24 & 0xFFF) == 0 )
    a3[2] = v24 & 0xFEFFFFFF;
  return 0;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);

//----- (0047EF7C) --------------------------------------------------------
int   pstm_add(int *a1, int *a2, int *a3)
{
  int v3; // $a3
  int v4; // $t4
  int v8; // $t1
  int v9; // $a0
  _DWORD *v10; // $a2
  _DWORD *v11; // $a1
  int v12; // $t2
  BOOL v13; // $v0
  BOOL v14; // $t0
  int *v15; // $a0
  int *v16; // $a1
  int v17; // $v0
  int v18; // $v1

  v3 = HIBYTE(a1[2]) & 1;
  v4 = HIBYTE(a2[2]) & 1;
  if ( v3 == v4 )
  {
    a3[2] = a3[2] & 0xFEFFFFFF | (v3 << 24);
    v17 = sub_47EB54(a1, a2, a3);
  }
  else
  {
    v8 = a1[2] & 0xFFF;
    v9 = 1;
    if ( (a2[2] & 0xFFF) >= v8 )
    {
      v9 = -1;
      if ( v8 >= (a2[2] & 0xFFF) )
      {
        v10 = (_DWORD *)(*a1 + 4 * v8 - 4);
        v11 = (_DWORD *)(*a2 + 4 * v8 - 4);
        LOWORD(v12) = 0;
        if ( v8 )
        {
          while ( 1 )
          {
            v12 = (unsigned __int16)(v12 + 1);
            v13 = *v11 < *v10;
            v14 = *v10-- < *v11--;
            if ( v13 )
            {
              v9 = 1;
              goto LABEL_9;
            }
            if ( v14 )
              break;
            if ( v12 >= v8 )
              goto LABEL_8;
          }
          v9 = -1;
        }
        else
        {
LABEL_8:
          v9 = 0;
        }
      }
    }
LABEL_9:
    if ( v9 == -1 )
    {
      v15 = a2;
      v16 = a1;
      a3[2] = a3[2] & 0xFEFFFFFF | (v4 << 24);
    }
    else
    {
      a3[2] = a3[2] & 0xFEFFFFFF | (v3 << 24);
      v15 = a1;
      v16 = a2;
    }
    v17 = pstm_sub_s(v15, v16, a3);
  }
  v18 = v17;
  if ( !v17 )
    return 0;
  return v18;
}

//----- (0047F104) --------------------------------------------------------
int   pstm_read_radix(int a1, int *a2, unsigned __int8 *a3, unsigned __int16 a4, unsigned __int8 a5)
{
  unsigned __int8 *v7; // $s4
  int v8; // $s5
  int v9; // $v1
  int v10; // $fp
  unsigned int v11; // $v1
  int v12; // $a0
  _DWORD *v13; // $a1
  int v14; // $v0
  unsigned int v15; // $a2
  int i; // $a0
  int v17; // $s0
  int v18; // $v1
  int v19; // $s1
  unsigned int v20; // $t6
  int v21; // $t4
  int v22; // $t5
  int v23; // $t7
  __int64 v24; // $t2
  int v25; // $t1
  int v26; // $a3
  int v27; // $t0
  int v28; // $a1
  unsigned int v29; // $a2
  int v30; // $a1
  int v31; // $t8
  _DWORD *v32; // $a0
  unsigned int v33; // $a1
  int v34; // $a2
  __int16 v35; // $t9
  int v36; // $s1
  int inited; // $v0
  __int16 v38; // $t0
  signed int v39; // $v1
  _DWORD *v40; // $a0
  signed int v41; // $v0
  int v43; // $a2
  unsigned int v44; // $t7
  unsigned int v45; // $t4
  int v46; // $a0
  int v47; // $a1
  int v48; // $t1
  int v49[2]; // [sp+18h] [-10h] BYREF
  unsigned int v50; // [sp+20h] [-8h]

  v7 = a3;
  v8 = a4;
  v9 = -6;
  if ( (unsigned int)a5 - 2 >= 0x3F )
    return v9;
  v10 = 0;
  if ( *a3 == 45 )
  {
    v11 = a2[2] & 0xFEFFF000;
    v12 = (v11 >> 12) & 0xFFF;
    v7 = a3 + 1;
    v8 = (unsigned __int16)(a4 - 1);
    v10 = 1;
    a2[2] = v11;
    v13 = (_DWORD *)*a2;
    LOWORD(v14) = 0;
    if ( v12 )
    {
LABEL_4:
      v15 = v11;
      do
      {
        v14 = (unsigned __int16)(v14 + 1);
        *v13++ = 0;
      }
      while ( v14 < v12 );
      goto LABEL_6;
    }
  }
  else
  {
    v11 = a2[2] & 0xFEFFF000;
    v12 = (v11 >> 12) & 0xFFF;
    a2[2] = v11;
    v13 = (_DWORD *)*a2;
    LOWORD(v14) = 0;
    if ( v12 )
      goto LABEL_4;
  }
  v15 = a2[2];
LABEL_6:
  if ( v8 )
  {
    if ( a5 >= 0x24u )
      goto LABEL_41;
LABEL_8:
    for ( i = toupper(*v7); ; i = *v7 )
    {
      v17 = 0;
      while ( 1 )
      {
        v18 = (unsigned __int8)a0123456789abcd[v17++];
        if ( v18 == i )
          break;
        if ( v17 >= 64 )
          goto LABEL_13;
      }
      --v17;
LABEL_13:
      if ( v17 >= a5 )
        break;
      v19 = (unsigned __int16)((v15 & 0xFFF) + 1);
      if ( (int)((v15 >> 12) & 0xFFF) < (int)((v15 & 0xFFF) + 1) )
      {
        if ( (unsigned int)v19 >= 0x181 )
          goto LABEL_35;
        if ( (int)((v15 >> 12) & 0xFFF) < v19 )
        {
          v43 = realloc(*a2, 4 * v19);
          if ( !v43 )
            goto LABEL_35;
          v44 = a2[2];
          v45 = v44 & 0xFF000FFF | ((v19 & 0xFFF) << 12);
          v46 = (v44 >> 12) & 0xFFF;
          v47 = (v45 >> 12) & 0xFFF;
          *a2 = v43;
          for ( a2[2] = v45; v46 < v47; *(_DWORD *)(v48 + v43) = 0 )
          {
            v48 = 4 * v46;
            v46 = (unsigned __int16)(v46 + 1);
          }
        }
        v15 = a2[2];
      }
      v20 = v15 & 0xFFFFF000 | a2[2] & 0xFFF;
      v21 = a2[2] & 0xFFF;
      v22 = v20;
      a2[2] = v20;
      v23 = v15 & 0xFFF;
      v24 = 0;
      v25 = 0;
      if ( v21 )
      {
        v26 = *a2;
        v27 = *a2;
        do
        {
          v28 = 4 * v25;
          v29 = *(_DWORD *)(4 * v25 + v27);
          v25 = (__int16)(v25 + 1);
          v27 = v26;
          *(_DWORD *)(v28 + v26) = v24 + v29 * a5;
          LODWORD(v24) = (v24 + v29 * (unsigned __int64)a5) >> 32;
          HIDWORD(v24) = 0;
        }
        while ( v25 < v21 );
      }
      v30 = v20 & 0xFFF;
      if ( v24 && v30 != 384 )
      {
        v31 = *a2;
        a2[2] = v20 & 0xFFFFF000 | ((_WORD)v30 + 1) & 0xFFF;
        v22 = a2[2];
        *(_DWORD *)(4 * v30 + v31) = v24;
        v25 = (__int16)(v25 + 1);
      }
      if ( v25 < v23 )
      {
        v32 = (_DWORD *)(4 * v25 + *a2);
        do
        {
          v25 = (__int16)(v25 + 1);
          *v32++ = 0;
        }
        while ( v25 < v23 );
      }
      v33 = v22;
      if ( (v22 & 0xFFF) != 0 )
      {
        v34 = *a2;
        if ( !*(_DWORD *)(4 * (v22 & 0xFFF) + *a2 - 4) )
        {
          v35 = v22 & 0xFFF;
          do
          {
            v33 = v33 & 0xFFFFF000 | (v35 - 1) & 0xFFF;
            a2[2] = v33;
            if ( (v33 & 0xFFF) == 0 )
              break;
            v36 = *(_DWORD *)(4 * ((v35 - 1) & 0xFFF) + v34 - 4);
            v35 = v33 & 0xFFF;
          }
          while ( !v36 );
          v22 = v33;
        }
      }
      if ( (v22 & 0xFFF) == 0 )
        a2[2] = v22 & 0xFEFFFFFF;
LABEL_35:
      inited = pstm_init_size(a1, v49, 4u);
      v38 = v8 - 1;
      if ( !inited )
      {
        v39 = ((v50 & 0xFEFFF000) >> 12) & 0xFFF;
        v50 &= 0xFEFFF000;
        v40 = (_DWORD *)v49[0];
        LOWORD(v41) = 0;
        if ( v39 )
        {
          do
          {
            v41 = (unsigned __int16)(v41 + 1);
            *v40++ = 0;
          }
          while ( v41 < v39 );
        }
        *(_DWORD *)v49[0] = v17;
        v50 = v50 & 0xFFFFF000 | (v17 != 0);
        pstm_add(a2, v49, a2);
        pstm_clear(v49);
        v38 = v8 - 1;
      }
      LOWORD(v8) = v38;
      ++v7;
      if ( !v38 )
      {
        v15 = a2[2];
        break;
      }
      v15 = a2[2];
      if ( a5 < 0x24u )
        goto LABEL_8;
LABEL_41:
      ;
    }
  }
  v9 = 0;
  if ( (v15 & 0xFFF) != 0 )
    a2[2] = v15 & 0xFEFFFFFF | (v10 << 24);
  return v9;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);
// 4EA050: using guessed type int _ctype_toupper;

//----- (0047F60C) --------------------------------------------------------
int   pstm_sub(int *a1, int *a2, int *a3)
{
  int v3; // $a3
  int v7; // $v0
  int v8; // $v1
  int v10; // $t1
  int v11; // $a0
  _DWORD *v12; // $a2
  _DWORD *v13; // $a1
  int v14; // $t2
  BOOL v15; // $t9
  BOOL v16; // $t0

  v3 = HIBYTE(a1[2]) & 1;
  if ( v3 == (HIBYTE(a2[2]) & 1) )
  {
    v10 = a1[2] & 0xFFF;
    v11 = 1;
    if ( (a2[2] & 0xFFF) >= v10 )
    {
      v11 = -1;
      if ( v10 >= (a2[2] & 0xFFF) )
      {
        v12 = (_DWORD *)(*a1 + 4 * v10 - 4);
        v13 = (_DWORD *)(*a2 + 4 * v10 - 4);
        LOWORD(v14) = 0;
        if ( v10 )
        {
          while ( 1 )
          {
            v14 = (unsigned __int16)(v14 + 1);
            v15 = *v13 < *v12;
            v16 = *v12-- < *v13--;
            if ( v15 )
            {
              v11 = 1;
              goto LABEL_13;
            }
            if ( v16 )
              break;
            if ( v14 >= v10 )
              goto LABEL_12;
          }
          v11 = -1;
        }
        else
        {
LABEL_12:
          v11 = 0;
        }
      }
    }
LABEL_13:
    if ( v11 == -1 )
    {
      a3[2] = a3[2] & 0xFEFFFFFF | ((v3 ^ 1) << 24);
      v7 = pstm_sub_s(a2, a1, a3);
    }
    else
    {
      a3[2] = a3[2] & 0xFEFFFFFF | (v3 << 24);
      v7 = pstm_sub_s(a1, a2, a3);
    }
  }
  else
  {
    a3[2] = a3[2] & 0xFEFFFFFF | (v3 << 24);
    v7 = sub_47EB54(a1, a2, a3);
  }
  v8 = v7;
  if ( !v7 )
    return 0;
  return v8;
}

//----- (0047F7A4) --------------------------------------------------------
int   pstm_montgomery_setup(int **a1, _DWORD *a2)
{
  int v2; // $a0
  int v3; // $t0
  int v4; // $t4

  v2 = **a1;
  v3 = -6;
  if ( ((v2 ^ 1) & 1) == 0 )
  {
    v3 = 0;
    v4 = (2 * ((v2 + 2) & 4) + v2)
       * (2 - v2 * (2 * ((v2 + 2) & 4) + v2))
       * (2 - v2 * (2 * ((v2 + 2) & 4) + v2) * (2 - v2 * (2 * ((v2 + 2) & 4) + v2)));
    *a2 = -(v4 * (2 - v2 * v4));
  }
  return v3;
}

//----- (0047F83C) --------------------------------------------------------
int   pstm_montgomery_calc_normalization(int *a1, int *a2)
{
  int v2; // $a2
  char v5; // $v0
  unsigned int v6; // $a0
  __int16 v7; // $s0
  __int16 v8; // $a1
  int v9; // $t7
  int v10; // $a2
  signed int v11; // $v1
  int v12; // $s2
  _DWORD *v13; // $a0
  signed int v14; // $v0
  unsigned int v15; // $s3
  int result; // $v0
  unsigned int v17; // $v0
  int v18; // $a0
  unsigned int v19; // $s4
  int v20; // $a1
  int *v21; // $s3
  int v22; // $a2
  unsigned int v23; // $s2
  unsigned int v24; // $s0
  _DWORD *v25; // $a2
  _DWORD *v26; // $a0
  int v27; // $v0
  unsigned int v28; // $a0
  int v29; // $a1
  unsigned int v30; // $s0
  unsigned int v31; // $t2
  int *v32; // $t3
  int v33; // $t1
  unsigned int v34; // $t4
  int v35; // $t5
  int *v36; // $a1
  int *v37; // $a2
  unsigned int v38; // $t0
  int v39; // $a3
  int v40; // $a0
  int v41; // $a3
  __int16 v42; // $a1
  BOOL v43; // $v1
  int *i; // $a0
  __int16 v45; // $t2
  int v46; // $a3
  int v47; // $v1
  int v48; // $a0
  bool v49; // dc
  int v50; // $a3
  unsigned int v51; // $t7
  unsigned int v52; // $t5
  int v53; // $a2
  int v54; // $a1
  BOOL v55; // $v0
  _DWORD *v56; // $t0
  unsigned __int16 v57; // $v0
  _DWORD *v58; // $a2
  _DWORD *v59; // $a1
  int v60; // $t1
  BOOL v61; // $t3
  BOOL v62; // $a3
  int v63; // $a2
  unsigned int v64; // $s6
  unsigned int v65; // $t6
  int v66; // $a0
  int v67; // $a1
  int v68; // $t1

  v2 = a2[2];
  v5 = 0;
  if ( (v2 & 0xFFF) != 0 )
  {
    v6 = *(_DWORD *)(4 * (a2[2] & 0xFFF) + *a2 - 4);
    v5 = 32 * v2 - 32;
    while ( v6 )
    {
      ++v5;
      v6 >>= 1;
    }
  }
  v7 = v5 & 0x1F;
  v8 = v2 & 0xFFF;
  if ( (v5 & 0x1F) == 0 )
    v7 = 32;
  if ( (v2 & 0xFFFu) < 2 )
  {
    v24 = a1[2] & 0xFEFFF000;
    v25 = (_DWORD *)*a1;
    a1[2] = v24;
    v26 = v25;
    LOWORD(v27) = 0;
    if ( ((v24 >> 12) & 0xFFF) != 0 )
    {
      do
      {
        v27 = (unsigned __int16)(v27 + 1);
        *v26++ = 0;
      }
      while ( v27 < (int)((v24 >> 12) & 0xFFF) );
    }
    *v25 = 1;
    a1[2] = a1[2] & 0xFFFFF000 | 1;
    v7 = 1;
LABEL_23:
    v23 = (unsigned __int16)(v7 - 1);
    result = 0;
    if ( v23 >= 0x20 )
      return result;
    while ( 1 )
    {
LABEL_24:
      v28 = a1[2];
      v29 = (v28 >> 12) & 0xFFF;
      if ( v29 < (int)((v28 & 0xFFF) + 1) )
      {
        v30 = (unsigned __int16)((v28 & 0xFFF) + 1);
        if ( v30 >= 0x181 )
          return -8;
        if ( v29 < (int)v30 )
        {
          v50 = realloc(*a1, 4 * v30);
          if ( !v50 )
            return -8;
          v51 = a1[2];
          v52 = v51 & 0xFF000FFF | ((v30 & 0xFFF) << 12);
          v53 = (v51 >> 12) & 0xFFF;
          v54 = (v52 >> 12) & 0xFFF;
          v55 = v53 < v54;
          *a1 = v50;
          a1[2] = v52;
          while ( 1 )
          {
            v49 = v55;
            v57 = v53 + 1;
            if ( !v49 )
              break;
            v56 = (_DWORD *)(4 * v53 + v50);
            v53 = (unsigned __int16)(v53 + 1);
            v55 = v57 < v54;
            *v56 = 0;
          }
        }
        v28 = a1[2];
      }
      v31 = v28 & 0xFFFFF000 | a1[2] & 0xFFF;
      v32 = (int *)*a1;
      v33 = a1[2] & 0xFFF;
      v34 = v31;
      a1[2] = v31;
      v35 = v28 & 0xFFF;
      v36 = v32;
      v37 = v32;
      v38 = 0;
      LOWORD(v39) = 0;
      if ( v33 )
      {
        do
        {
          v40 = *v36;
          v39 = (__int16)(v39 + 1);
          *v37++ = (2 * *v36++) | v38;
          v38 = (unsigned int)v40 >> 31;
        }
        while ( v39 < v33 );
        v41 = v31 & 0xFFF;
        if ( v40 >= 0 || (v31 & 0xFFF) == 0x17F )
          goto LABEL_34;
        *v37 = 1;
        v34 = v31 & 0xFFFFF000 | ((v31 & 0xFFF) + 1) & 0xFFF;
        a1[2] = v34;
      }
      v41 = v34 & 0xFFF;
LABEL_34:
      v42 = v41;
      v43 = (__int16)v41 < v35;
      for ( i = &v32[v41]; ; ++i )
      {
        v45 = v42 + 1;
        if ( !v43 )
          break;
        ++v42;
        *i = 0;
        v43 = v45 < v35;
      }
      a1[2] = a1[2] & 0xFEFFFFFF | v34 & 0x1000000;
      v46 = a1[2] & 0xFFF;
      v47 = a2[2] & 0xFFF;
      v48 = 1;
      if ( v47 >= v46 )
      {
        v48 = -1;
        if ( v46 >= v47 )
        {
          v58 = (_DWORD *)(*a1 + 4 * v46 - 4);
          v59 = (_DWORD *)(*a2 + 4 * v46 - 4);
          LOWORD(v60) = 0;
          if ( v46 )
          {
            while ( 1 )
            {
              v60 = (unsigned __int16)(v60 + 1);
              v61 = *v59 < *v58;
              v62 = *v58-- < *v59--;
              if ( v61 )
              {
                v48 = 1;
                goto LABEL_38;
              }
              if ( v62 )
                break;
              if ( v60 >= (a1[2] & 0xFFF) )
                goto LABEL_53;
            }
            v48 = -1;
          }
          else
          {
LABEL_53:
            v48 = 0;
          }
        }
      }
LABEL_38:
      if ( v48 == -1 || (v49 = pstm_sub_s(a1, a2, a1) != 0, result = -8, !v49) )
      {
        v23 = (unsigned __int16)(v23 + 1);
        result = 0;
        if ( v23 < 0x20 )
          continue;
      }
      return result;
    }
  }
  v9 = a1[2];
  v10 = *a1;
  v11 = ((v9 & 0xFEFFF000) >> 12) & 0xFFF;
  v12 = (__int16)(32 * v8 + v7 - 33);
  a1[2] = v9 & 0xFEFFF000;
  v13 = (_DWORD *)v10;
  LOWORD(v14) = 0;
  if ( v11 )
  {
    do
    {
      v14 = (unsigned __int16)(v14 + 1);
      *v13++ = 0;
    }
    while ( v14 < v11 );
  }
  if ( v12 < 0 )
    goto LABEL_23;
  v15 = (unsigned __int16)((__int16)(32 * v8 + v7 - 33) >> 5);
  result = 65527;
  if ( v15 >= 0x180 )
    return result;
  v17 = a1[2] & 0xFFFFF000 | (v15 + 1) & 0xFFF;
  v18 = (v17 >> 12) & 0xFFF;
  a1[2] = v17;
  if ( v18 >= (int)((v15 + 1) & 0xFFF) )
    goto LABEL_16;
  v19 = ((_WORD)v15 + 1) & 0xFFF;
  if ( v19 >= 0x181 )
    return 65528;
  if ( v18 < (unsigned __int16)((v15 + 1) & 0xFFF) )
  {
    v63 = realloc(v10, 4 * v19);
    if ( v63 )
    {
      v64 = a1[2];
      v65 = v64 & 0xFF000FFF | (v19 << 12);
      v66 = (v64 >> 12) & 0xFFF;
      v67 = (v65 >> 12) & 0xFFF;
      *a1 = v63;
      a1[2] = v65;
      if ( v66 < v67 )
      {
        do
        {
          v68 = 4 * v66;
          v66 = (unsigned __int16)(v66 + 1);
          *(_DWORD *)(v68 + v63) = 0;
        }
        while ( v66 < v67 );
        v10 = *a1;
        v20 = 4 * v15;
        goto LABEL_17;
      }
      goto LABEL_15;
    }
    return 65528;
  }
LABEL_15:
  v10 = *a1;
LABEL_16:
  v20 = 4 * v15;
LABEL_17:
  v21 = (int *)(v20 + v10);
  v22 = 1 << v12;
  v23 = (unsigned __int16)(v7 - 1);
  *v21 = v22;
  if ( v23 < 0x20 )
    goto LABEL_24;
  return 0;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);

//----- (0047FDB8) --------------------------------------------------------
int   sub_47FDB8(int a1, __int16 a2, int *a3)
{
  int v5; // $s2
  unsigned int v6; // $t1
  int v7; // $a0
  int v8; // $a1
  int v9; // $s0
  int v10; // $a3
  _DWORD *v11; // $a1
  _DWORD *v12; // $a2
  int v13; // $t0
  int v14; // $v1
  int v15; // $v0
  int v16; // $t4
  unsigned int v17; // $s0
  unsigned int v18; // $a2
  int v19; // $a0
  int v20; // $t4
  unsigned int v21; // $s3
  unsigned int v22; // $a2
  _DWORD *v23; // $t0
  int v24; // $v1
  unsigned int v25; // $a3
  _DWORD *v26; // $a0
  _DWORD *i; // $a2
  _DWORD *v28; // $a0
  unsigned int v29; // $v0
  char v30; // $a3
  unsigned int v31; // $t1
  unsigned int v32; // $s0
  int v33; // $a2
  int v34; // $t0
  unsigned int *v35; // $a0
  unsigned int v36; // $a1
  int v37; // $v0
  int v38; // $v1
  int v39; // $t3
  unsigned int *v40; // $a2
  unsigned int v41; // $a1
  int v42; // $a2
  int v43; // $t6
  unsigned int v44; // $v1
  int result; // $v0
  int v46; // $v0
  unsigned int v47; // $t2
  unsigned int v48; // $t0
  int v49; // $a0
  int v50; // $a1
  int v51; // $t8
  int v52; // $v0
  unsigned int v53; // $a1
  unsigned int v54; // $a3
  int v55; // $a0
  int v56; // $a1
  int v57; // $t8
  int v58; // $s2
  int v59; // $a2
  unsigned int v60; // $s3
  unsigned int v61; // $t8
  int v62; // $a0
  int v63; // $a1
  int v64; // $t7

  v5 = a2;
  if ( (int *)a1 == a3 )
    goto LABEL_12;
  v6 = a3[2];
  v7 = *(_DWORD *)(a1 + 8);
  v8 = (v6 >> 12) & 0xFFF;
  v9 = v7 & 0xFFF;
  if ( v8 < v9 )
  {
    if ( (unsigned int)v9 < 0x181 )
    {
      if ( v8 >= v9 )
      {
LABEL_32:
        v6 = a3[2];
        v7 = *(_DWORD *)(a1 + 8);
        v10 = v7 & 0xFFF;
        goto LABEL_4;
      }
      v46 = realloc(*a3, 4 * v9);
      if ( v46 )
      {
        v47 = a3[2];
        v48 = v47 & 0xFF000FFF | (v9 << 12);
        v49 = (v47 >> 12) & 0xFFF;
        v50 = (v48 >> 12) & 0xFFF;
        *a3 = v46;
        a3[2] = v48;
        if ( v49 < v50 )
        {
          do
          {
            v51 = 4 * v49;
            v49 = (unsigned __int16)(v49 + 1);
            *(_DWORD *)(v51 + v46) = 0;
          }
          while ( v49 < v50 );
          v6 = a3[2];
          v7 = *(_DWORD *)(a1 + 8);
          v10 = v7 & 0xFFF;
          goto LABEL_4;
        }
        goto LABEL_32;
      }
    }
    return -8;
  }
  v10 = v7 & 0xFFF;
LABEL_4:
  v11 = *(_DWORD **)a1;
  v12 = (_DWORD *)*a3;
  v13 = 0;
  if ( v10 )
  {
    v14 = v10;
    do
    {
      --v14;
      *v12++ = *v11++;
    }
    while ( v14 );
    v13 = v10;
  }
  if ( v13 < (unsigned __int16)(v6 & 0xFFF) )
  {
    v15 = (v6 & 0xFFF) - v13;
    do
    {
      --v15;
      *v12++ = 0;
    }
    while ( v15 );
  }
  v16 = a3[2];
  a3[2] = v16 & 0xFFFFF000 | v7 & 0xFFF;
  a3[2] = v16 & 0xFEFFF000 | v7 & 0xFFF | ((*(_BYTE *)(a1 + 11) & 1) << 24);
LABEL_12:
  if ( v5 < 32 )
    goto LABEL_22;
  v17 = (unsigned __int16)(v5 / 32);
  if ( !(unsigned __int16)(v5 / 32) )
    goto LABEL_22;
  v18 = a3[2];
  v19 = (v18 >> 12) & 0xFFF;
  v20 = v18 & 0xFFF;
  if ( v19 < (int)(v20 + v17) )
  {
    v21 = (unsigned __int16)((v18 & 0xFFF) + v17);
    if ( v21 < 0x181 )
    {
      if ( v19 >= (int)v21 )
      {
LABEL_17:
        v18 = a3[2];
        v20 = v18 & 0xFFF;
        goto LABEL_18;
      }
      v52 = realloc(*a3, 4 * v21);
      if ( v52 )
      {
        v53 = a3[2];
        v54 = v53 & 0xFF000FFF | ((v21 & 0xFFF) << 12);
        v55 = (v53 >> 12) & 0xFFF;
        v56 = (v54 >> 12) & 0xFFF;
        *a3 = v52;
        a3[2] = v54;
        if ( v55 < v56 )
        {
          do
          {
            v57 = 4 * v55;
            v55 = (unsigned __int16)(v55 + 1);
            *(_DWORD *)(v57 + v52) = 0;
          }
          while ( v55 < v56 );
          v18 = a3[2];
          v20 = v18 & 0xFFF;
          goto LABEL_18;
        }
        goto LABEL_17;
      }
    }
    return -8;
  }
LABEL_18:
  v22 = v18 & 0xFFFFF000 | (v20 + v17) & 0xFFF;
  v23 = (_DWORD *)*a3;
  v24 = *a3 + 4 * (v22 & 0xFFF);
  v25 = (unsigned __int16)((v22 & 0xFFF) - 1);
  a3[2] = v22;
  v26 = (_DWORD *)(v24 - 4);
  for ( i = (_DWORD *)(v24 - 4 * v17 - 4); v25 >= v17; --v26 )
  {
    v25 = (unsigned __int16)(v25 - 1);
    *v26 = *i--;
  }
  v28 = v23;
  LOWORD(v29) = 0;
  if ( (unsigned __int16)(v5 / 32) )
  {
    do
    {
      v29 = (unsigned __int16)(v29 + 1);
      *v28++ = 0;
    }
    while ( v29 < v17 );
  }
LABEL_22:
  v30 = v5 % 32;
  if ( (unsigned __int16)(v5 % 32) )
  {
    v31 = a3[2];
    v32 = 0;
    v33 = 0;
    if ( (v31 & 0xFFF) != 0 )
    {
      v34 = *a3;
      do
      {
        v35 = (unsigned int *)(4 * v33 + v34);
        v36 = *v35;
        v33 = (unsigned __int16)(v33 + 1);
        *v35 = (*v35 << v30) + v32;
        v32 = v36 >> (32 - v30);
      }
      while ( v33 < (unsigned __int16)(v31 & 0xFFF) );
      v37 = v31 & 0xFFF;
      if ( !v32 || (unsigned int)v33 >= 0x180 )
        goto LABEL_35;
      v38 = v31 & 0xFFF;
      v39 = v38;
      if ( v38 == ((v31 >> 12) & 0xFFF) )
      {
        v58 = v38 + 1;
        result = -8;
        if ( (unsigned int)(v38 + 1) >= 0x181 )
          return result;
        if ( v38 >= v58 )
          goto LABEL_56;
        v59 = realloc(*a3, 4 * v58);
        if ( !v59 )
          return -8;
        v60 = a3[2];
        v61 = v60 & 0xFF000FFF | ((v58 & 0xFFF) << 12);
        v62 = (v60 >> 12) & 0xFFF;
        v63 = (v61 >> 12) & 0xFFF;
        *a3 = v59;
        a3[2] = v61;
        if ( v62 >= v63 )
        {
LABEL_56:
          v31 = a3[2];
          v39 = v31 & 0xFFF;
        }
        else
        {
          do
          {
            v64 = 4 * v62;
            v62 = (unsigned __int16)(v62 + 1);
            *(_DWORD *)(v64 + v59) = 0;
          }
          while ( v62 < v63 );
          v31 = a3[2];
          v39 = v31 & 0xFFF;
        }
      }
      v40 = (unsigned int *)(4 * v39 + *a3);
      v31 = v31 & 0xFFFFF000 | (v39 + 1) & 0xFFF;
      a3[2] = v31;
      *v40 = v32;
    }
  }
  else
  {
    v31 = a3[2];
  }
  v37 = v31 & 0xFFF;
LABEL_35:
  v41 = v31;
  if ( v37 > 0 )
  {
    v42 = *a3;
    if ( !*(_DWORD *)(4 * v37 + *a3 - 4) )
    {
      v43 = v31 & 0xFFF;
      do
      {
        v44 = v41 & 0xFFFFF000 | (v43 - 1) & 0xFFF;
        a3[2] = v44;
        v41 = v44;
        if ( (v44 & 0xFFF) == 0 )
          break;
        v43 = v44 & 0xFFF;
      }
      while ( !*(_DWORD *)(4 * v43 + v42 - 4) );
      v31 = v44;
    }
  }
  result = 0;
  if ( (v31 & 0xFFF) == 0 )
    a3[2] = v31 & 0xFEFFFFFF;
  return result;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);

//----- (0048031C) --------------------------------------------------------
int   pstm_div_2d(int a1, int a2, __int16 a3, int *a4, int *a5)
{
  int v5; // $s2
  BOOL v8; // $t7
  unsigned int v9; // $t1
  int v10; // $a0
  int v11; // $a1
  int v12; // $s1
  int v13; // $a3
  _DWORD *v14; // $a1
  _DWORD *v15; // $a2
  int v16; // $t0
  int v17; // $v1
  int v18; // $v0
  int v19; // $t5
  int v20; // $t2
  int v21; // $t0
  int v22; // $v1
  signed int v23; // $a0
  _DWORD *v24; // $a1
  signed int v25; // $v0
  unsigned int v26; // $t3
  int v27; // $v0
  char v28; // $t0
  int v29; // $t2
  int v30; // $v0
  unsigned int v31; // $a1
  int v32; // $a2
  int v33; // $t9
  int v34; // $v0
  int v35; // $s1
  int result; // $v0
  unsigned int v37; // $t1
  int v38; // $a0
  int v39; // $a1
  int v40; // $s0
  _DWORD *v41; // $a1
  _DWORD *v42; // $a2
  int v43; // $t0
  int v44; // $v1
  int v45; // $v0
  int v46; // $a3
  int v47; // $a0
  unsigned int v48; // $a2
  int v49; // $a3
  int v50; // $t8
  unsigned int v51; // $a1
  int v52; // $t8
  int v53; // $ra
  int v54; // $t4
  int v55; // $a3
  int *v56; // $a2
  int v57; // $v1
  int v58; // $a1
  unsigned int v59; // $t1
  int v60; // $a0
  int v61; // $a1
  int v62; // $s1
  int v63; // $a3
  _DWORD *v64; // $a1
  _DWORD *v65; // $a2
  int v66; // $t0
  int v67; // $v1
  int v68; // $v0
  int v69; // $t3
  unsigned int v70; // $s0
  _DWORD *v71; // $a0
  int v72; // $v0
  int v73; // $a2
  int v74; // $a3
  int v75; // $t4
  int v76; // $a1
  __int16 v77; // $a0
  int v78; // $a0
  int v79; // $t9
  unsigned int v80; // $t2
  int v81; // $a1
  int v82; // $t6
  unsigned int v83; // $s3
  _DWORD *v84; // $a0
  int v85; // $v0
  int v86; // $v0
  unsigned int v87; // $t2
  unsigned int v88; // $t0
  int v89; // $a0
  int v90; // $a1
  int v91; // $t8
  int v92; // $a2
  unsigned int v93; // $t4
  unsigned int v94; // $ra
  int v95; // $a0
  int v96; // $a1
  int v97; // $t0
  int v98; // $v0
  unsigned int v99; // $t2
  unsigned int v100; // $t0
  int v101; // $a0
  int v102; // $a1
  int v103; // $t8

  v5 = a3;
  if ( a3 <= 0 )
  {
    if ( (int *)a2 == a4 )
    {
LABEL_82:
      if ( a5 )
      {
        v70 = a5[2] & 0xFEFFF000;
        a5[2] = v70;
        v71 = (_DWORD *)*a5;
        LOWORD(v72) = 0;
        if ( ((v70 >> 12) & 0xFFF) != 0 )
        {
          do
          {
            v72 = (unsigned __int16)(v72 + 1);
            *v71++ = 0;
          }
          while ( v72 < (int)((v70 >> 12) & 0xFFF) );
        }
      }
      return 0;
    }
    v59 = a4[2];
    v60 = *(_DWORD *)(a2 + 8);
    v61 = (v59 >> 12) & 0xFFF;
    if ( v61 >= (v60 & 0xFFF) )
      goto LABEL_73;
    v62 = v60 & 0xFFF;
    if ( (unsigned int)v62 < 0x181 )
    {
      if ( v61 >= v62 )
      {
LABEL_72:
        v59 = a4[2];
        v60 = *(_DWORD *)(a2 + 8);
LABEL_73:
        v63 = v60 & 0xFFF;
LABEL_74:
        v64 = *(_DWORD **)a2;
        v65 = (_DWORD *)*a4;
        v66 = 0;
        if ( v63 )
        {
          v67 = v63;
          do
          {
            --v67;
            *v65++ = *v64++;
          }
          while ( v67 );
          v66 = v63;
        }
        if ( v66 < (unsigned __int16)(v59 & 0xFFF) )
        {
          v68 = (v59 & 0xFFF) - v66;
          do
          {
            --v68;
            *v65++ = 0;
          }
          while ( v68 );
        }
        v69 = a4[2];
        a4[2] = v69 & 0xFFFFF000 | v60 & 0xFFF;
        a4[2] = v69 & 0xFEFFF000 | v60 & 0xFFF | ((*(_BYTE *)(a2 + 11) & 1) << 24);
        goto LABEL_82;
      }
      v98 = realloc(*a4, 4 * v62);
      if ( v98 )
      {
        v99 = a4[2];
        v100 = v99 & 0xFF000FFF | (v62 << 12);
        v101 = (v99 >> 12) & 0xFFF;
        v102 = (v100 >> 12) & 0xFFF;
        *a4 = v98;
        a4[2] = v100;
        if ( v101 < v102 )
        {
          do
          {
            v103 = 4 * v101;
            v101 = (unsigned __int16)(v101 + 1);
            *(_DWORD *)(v103 + v98) = 0;
          }
          while ( v101 < v102 );
          v59 = a4[2];
          v60 = *(_DWORD *)(a2 + 8);
          v63 = v60 & 0xFFF;
          goto LABEL_74;
        }
        goto LABEL_72;
      }
    }
    return -8;
  }
  v8 = a3 < 32;
  if ( (int *)a2 != a4 )
  {
    v9 = a4[2];
    v10 = *(_DWORD *)(a2 + 8);
    v11 = (v9 >> 12) & 0xFFF;
    v12 = v10 & 0xFFF;
    if ( v11 >= v12 )
    {
      v13 = v10 & 0xFFF;
LABEL_5:
      v14 = *(_DWORD **)a2;
      v15 = (_DWORD *)*a4;
      v16 = 0;
      if ( v13 )
      {
        v17 = v13;
        do
        {
          --v17;
          *v15++ = *v14++;
        }
        while ( v17 );
        v16 = v13;
      }
      if ( v16 < (unsigned __int16)(v9 & 0xFFF) )
      {
        v18 = (v9 & 0xFFF) - v16;
        do
        {
          --v18;
          *v15++ = 0;
        }
        while ( v18 );
      }
      v19 = a4[2];
      a4[2] = v19 & 0xFFFFF000 | v10 & 0xFFF;
      a4[2] = v19 & 0xFEFFF000 | v10 & 0xFFF | ((*(_BYTE *)(a2 + 11) & 1) << 24);
      v8 = v5 < 32;
      goto LABEL_13;
    }
    if ( (unsigned int)v12 < 0x181 )
    {
      if ( v11 >= v12 )
      {
LABEL_59:
        v9 = a4[2];
        v10 = *(_DWORD *)(a2 + 8);
        v13 = v10 & 0xFFF;
        goto LABEL_5;
      }
      v86 = realloc(*a4, 4 * v12);
      if ( v86 )
      {
        v87 = a4[2];
        v88 = v87 & 0xFF000FFF | (v12 << 12);
        v89 = (v87 >> 12) & 0xFFF;
        v90 = (v88 >> 12) & 0xFFF;
        *a4 = v86;
        a4[2] = v88;
        if ( v89 < v90 )
        {
          do
          {
            v91 = 4 * v89;
            v89 = (unsigned __int16)(v89 + 1);
            *(_DWORD *)(v91 + v86) = 0;
          }
          while ( v89 < v90 );
          v9 = a4[2];
          v10 = *(_DWORD *)(a2 + 8);
          v13 = v10 & 0xFFF;
          goto LABEL_5;
        }
        goto LABEL_59;
      }
    }
    v35 = -8;
    goto LABEL_28;
  }
LABEL_13:
  if ( v8 )
    goto LABEL_60;
  v20 = a4[2];
  v21 = (unsigned __int16)(v5 / 32);
  v22 = v20 & 0xFFF;
  if ( v21 < v22 )
  {
    v73 = 0;
    if ( v22 - v21 > 0 )
    {
      v74 = *a4;
      do
      {
        v75 = 4 * v73;
        v76 = *(_DWORD *)(4 * (v73 + v21) + v74);
        v73 = (unsigned __int16)(v73 + 1);
        *(_DWORD *)(v75 + v74) = v76;
      }
      while ( v73 < v22 - v21 );
    }
    v77 = v20 & 0xFFF;
    if ( v73 < (v20 & 0xFFF) )
    {
      v78 = *a4;
      do
      {
        v79 = 4 * v73;
        v73 = (unsigned __int16)(v73 + 1);
        *(_DWORD *)(v79 + v78) = 0;
      }
      while ( v73 < (v20 & 0xFFF) );
      v77 = v20 & 0xFFF;
    }
    v80 = v20 & 0xFFFFF000 | (v77 - (_WORD)v21) & 0xFFF;
    a4[2] = v80;
    if ( (v80 & 0xFFF) != 0 )
    {
      v81 = *a4;
      if ( !*(_DWORD *)(4 * (v80 & 0xFFF) + *a4 - 4) )
      {
        do
        {
          v82 = ((a4[2] & 0xFFF) - 1) & 0xFFF;
          a4[2] = a4[2] & 0xFFFFF000 | v82;
        }
        while ( v82 && !*(_DWORD *)(4 * v82 + v81 - 4) );
      }
    }
    v26 = a4[2];
    if ( (v26 & 0xFFF) == 0 )
    {
      v26 &= ~0x1000000u;
      a4[2] = v26;
    }
LABEL_61:
    v27 = v5;
    if ( v5 < 0 )
      goto LABEL_19;
    goto LABEL_62;
  }
  v23 = ((v20 & 0xFEFFF000) >> 12) & 0xFFF;
  a4[2] = v20 & 0xFEFFF000;
  v24 = (_DWORD *)*a4;
  LOWORD(v25) = 0;
  if ( !v23 )
  {
LABEL_60:
    v26 = a4[2];
    goto LABEL_61;
  }
  v26 = v20 & 0xFEFFF000;
  do
  {
    v25 = (unsigned __int16)(v25 + 1);
    *v24++ = 0;
  }
  while ( v25 < v23 );
  v27 = v5;
  if ( v5 < 0 )
  {
LABEL_19:
    v28 = v5 - 32 * ((v5 + 31) >> 5);
    v29 = v26 & 0xFFF;
    if ( (_WORD)v5 == 32 * (unsigned __int16)((v5 + 31) >> 5) )
    {
      v30 = v26 & 0xFFF;
      goto LABEL_21;
    }
LABEL_64:
    v55 = (__int16)(v29 - 1);
    v56 = (int *)(*a4 + 4 * v29 - 4);
    v57 = 0;
    while ( v55 >= 0 )
    {
      v58 = *v56;
      v55 = (__int16)(v55 - 1);
      *v56 = ((unsigned int)*v56 >> v28) | (v57 << (32 - v28));
      v57 = v58 & ((1 << v28) - 1);
      --v56;
    }
    v30 = v26 & 0xFFF;
    goto LABEL_21;
  }
LABEL_62:
  v54 = 32 * (v27 >> 5);
  v28 = v5 - v54;
  v30 = v26 & 0xFFF;
  if ( (_WORD)v5 != (_WORD)v54 )
  {
    v29 = v26 & 0xFFF;
    goto LABEL_64;
  }
LABEL_21:
  v31 = v26;
  if ( v30 > 0 )
  {
    v32 = *a4;
    v33 = v26 & 0xFFF;
    if ( !*(_DWORD *)(4 * v30 + *a4 - 4) )
    {
      do
      {
        v31 = v31 & 0xFFFFF000 | (v33 - 1) & 0xFFF;
        a4[2] = v31;
        if ( (v31 & 0xFFF) == 0 )
          break;
        v34 = *(_DWORD *)(4 * ((v33 - 1) & 0xFFF) + v32 - 4);
        v33 = v31 & 0xFFF;
      }
      while ( !v34 );
      v26 = v31;
    }
  }
  v35 = 0;
  if ( (v26 & 0xFFF) == 0 )
    a4[2] = v26 & 0xFEFFFFFF;
LABEL_28:
  result = v35;
  if ( !a5 )
    return result;
  if ( v5 <= 0 )
  {
    v83 = a5[2] & 0xFEFFF000;
    a5[2] = v83;
    v84 = (_DWORD *)*a5;
    LOWORD(v85) = 0;
    if ( ((v83 >> 12) & 0xFFF) == 0 )
      return v35;
    do
    {
      v85 = (unsigned __int16)(v85 + 1);
      *v84++ = 0;
    }
    while ( v85 < (int)((v83 >> 12) & 0xFFF) );
    return v35;
  }
  if ( (int *)a2 != a5 )
  {
    v37 = a5[2];
    v38 = *(_DWORD *)(a2 + 8);
    v39 = (v37 >> 12) & 0xFFF;
    if ( v39 >= (v38 & 0xFFF) )
    {
LABEL_35:
      v41 = *(_DWORD **)a2;
      v42 = (_DWORD *)*a5;
      v43 = 0;
      if ( (v38 & 0xFFF) != 0 )
      {
        v44 = v38 & 0xFFF;
        do
        {
          --v44;
          *v42++ = *v41++;
        }
        while ( v44 );
        v43 = v38 & 0xFFF;
      }
      v45 = (v37 & 0xFFF) - v43;
      if ( v43 < (unsigned __int16)(v37 & 0xFFF) )
      {
        do
        {
          --v45;
          *v42++ = 0;
        }
        while ( v45 );
      }
      v46 = a5[2];
      a5[2] = v46 & 0xFFFFF000 | v38 & 0xFFF;
      a5[2] = v46 & 0xFEFFF000 | v38 & 0xFFF | ((*(_BYTE *)(a2 + 11) & 1) << 24);
      goto LABEL_42;
    }
    v40 = *(_DWORD *)(a2 + 8) & 0xFFF;
    if ( (unsigned int)v40 < 0x181 )
    {
      if ( v39 >= v40 )
      {
LABEL_34:
        v38 = *(_DWORD *)(a2 + 8);
        v37 = a5[2];
        goto LABEL_35;
      }
      v92 = realloc(*a5, 4 * v40);
      if ( v92 )
      {
        v93 = a5[2];
        v94 = v93 & 0xFF000FFF | (v40 << 12);
        v95 = (v93 >> 12) & 0xFFF;
        v96 = (v94 >> 12) & 0xFFF;
        *a5 = v92;
        for ( a5[2] = v94; v95 < v96; *(_DWORD *)(v97 + v92) = 0 )
        {
          v97 = 4 * v95;
          v95 = (unsigned __int16)(v95 + 1);
        }
        goto LABEL_34;
      }
    }
    return -8;
  }
LABEL_42:
  result = v35;
  if ( v5 < 32 * (*(_DWORD *)(a2 + 8) & 0xFFF) )
  {
    v47 = (unsigned __int16)(v5 / 32);
    if ( (v5 & 0x1F) != 0 )
      v47 = (unsigned __int16)(v5 / 32 + 1);
    v48 = a5[2];
    if ( v47 >= (unsigned __int16)(v48 & 0xFFF) )
    {
      v49 = *a5;
    }
    else
    {
      v49 = *a5;
      do
      {
        v50 = 4 * v47;
        v47 = (unsigned __int16)(v47 + 1);
        *(_DWORD *)(v50 + v49) = 0;
      }
      while ( v47 < (unsigned __int16)(v48 & 0xFFF) );
    }
    *(_DWORD *)(4 * (v5 / 32) + v49) &= 0xFFFFFFFF >> -(char)v5;
    v51 = v48;
    if ( (v48 & 0xFFF) != 0 )
    {
      v52 = v48 & 0xFFF;
      if ( !*(_DWORD *)(4 * v52 + v49 - 4) )
      {
        do
        {
          v51 = v51 & 0xFFFFF000 | (v52 - 1) & 0xFFF;
          a5[2] = v51;
          if ( (v51 & 0xFFF) == 0 )
            break;
          v53 = *(_DWORD *)(4 * ((v52 - 1) & 0xFFF) + v49 - 4);
          v52 = v51 & 0xFFF;
        }
        while ( !v53 );
        v48 = v51;
      }
    }
    result = v35;
    if ( (v48 & 0xFFF) == 0 )
    {
      a5[2] = v48 & 0xFEFFFFFF;
      return v35;
    }
  }
  return result;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);

//----- (00480CBC) --------------------------------------------------------
int   pstm_div_2(int a1, int *a2)
{
  unsigned int v3; // $a1
  int v5; // $a0
  int v6; // $a2
  int v7; // $s1
  int v9; // $t2
  int v10; // $t1
  int v11; // $a0
  int *v12; // $a3
  int v13; // $t0
  int *v14; // $a2
  int v15; // $v1
  int v16; // $a1
  int v17; // $t9
  int v18; // $a1
  BOOL v19; // $v1
  _DWORD *v20; // $a0
  int v21; // $t4
  int v22; // $ra
  int v23; // $v1
  int v24; // $v0
  unsigned int v25; // $t3
  unsigned int v26; // $t0
  int v27; // $a0
  int v28; // $a1
  int v29; // $ra
  int v30; // $a0
  int v31; // $ra

  v3 = a2[2];
  v5 = *(_DWORD *)(a1 + 8);
  v6 = (v3 >> 12) & 0xFFF;
  if ( v6 < (v5 & 0xFFF) )
  {
    v7 = v5 & 0xFFF;
    if ( (unsigned int)v7 >= 0x181 )
      return -8;
    if ( v6 < v7 )
    {
      v24 = realloc(*a2, 4 * v7);
      if ( !v24 )
        return -8;
      v25 = a2[2];
      v26 = v25 & 0xFF000FFF | (v7 << 12);
      v27 = (v25 >> 12) & 0xFFF;
      v28 = (v26 >> 12) & 0xFFF;
      *a2 = v24;
      for ( a2[2] = v26; v27 < v28; *(_DWORD *)(v31 + v24) = 0 )
      {
        v29 = 4 * v27;
        v30 = (unsigned __int16)(v27 + 1);
        *(_DWORD *)(v29 + v24) = 0;
        if ( v30 >= v28 )
          break;
        v31 = 4 * v30;
        v27 = (unsigned __int16)(v30 + 1);
      }
    }
    v3 = a2[2];
    v5 = *(_DWORD *)(a1 + 8);
  }
  a2[2] = v3 & 0xFFFFF000 | v5 & 0xFFF;
  v9 = v5 & 0xFFF;
  v10 = *a2;
  v11 = (__int16)((v5 & 0xFFF) - 1);
  v12 = (int *)(*(_DWORD *)a1 + 4 * v9 - 4);
  v13 = v3 & 0xFFF;
  v14 = (int *)(*a2 + 4 * v9 - 4);
  v15 = 0;
  while ( v11 >= 0 )
  {
    v16 = *v12;
    *v14 = ((unsigned int)*v12 >> 1) | (v15 << 31);
    v11 = (__int16)(v11 - 1);
    --v12;
    --v14;
    v15 = v16 & 1;
  }
  v17 = a2[2] & 0xFFF;
  LOWORD(v18) = v17;
  v19 = (__int16)v17 < v13;
  v20 = (_DWORD *)(v10 + 4 * v17);
  while ( v19 )
  {
    v18 = (__int16)(v18 + 1);
    *v20 = 0;
    v19 = v18 < v13;
    ++v20;
  }
  v21 = a2[2];
  a2[2] = v21 & 0xFEFFFFFF | ((*(_BYTE *)(a1 + 11) & 1) << 24);
  if ( (v21 & 0xFFF) != 0 && !*(_DWORD *)(4 * (v21 & 0xFFF) + v10 - 4) )
  {
    do
    {
      v22 = ((a2[2] & 0xFFF) - 1) & 0xFFF;
      a2[2] = a2[2] & 0xFFFFF000 | v22;
    }
    while ( v22 && !*(_DWORD *)(4 * v22 + v10 - 4) );
  }
  v23 = a2[2];
  if ( (v23 & 0xFFF) == 0 )
    a2[2] = v23 & 0xFEFFFFFF;
  return 0;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);

//----- (00480F60) --------------------------------------------------------
int   pstm_init_copy(int a1, int *a2, int a3, char a4)
{
  int inited; // $v1
  unsigned int v7; // $v1
  int v8; // $a2
  unsigned int v9; // $t1
  int v10; // $a0
  int v11; // $a1
  int v12; // $s2
  int v13; // $a3
  _DWORD *v14; // $a1
  _DWORD *v15; // $a2
  int v16; // $t0
  int v17; // $v1
  int v18; // $v0
  int v19; // $t8
  int v21; // $v1
  int v22; // $a2
  unsigned int v23; // $t6
  unsigned int v24; // $t3
  int v25; // $a0
  int v26; // $a1
  int v27; // $v1

  inited = 0;
  if ( a2 != (int *)a3 )
  {
    v7 = *(_DWORD *)(a3 + 8);
    v8 = (v7 >> 12) & 0xFFF;
    if ( a4 )
    {
      v21 = 2 * (v7 & 0xFFF);
      if ( v21 + 2 >= v8 )
        LOWORD(v8) = v21 + 3;
    }
    inited = pstm_init_size(a1, a2, v8);
    if ( !inited && (int *)a3 != a2 )
    {
      v9 = a2[2];
      v10 = *(_DWORD *)(a3 + 8);
      v11 = (v9 >> 12) & 0xFFF;
      v12 = v10 & 0xFFF;
      if ( v11 < v12 )
      {
        inited = -8;
        if ( (unsigned int)v12 >= 0x181 )
          return inited;
        if ( v11 >= v12 )
          goto LABEL_19;
        v22 = realloc(*a2, 4 * v12);
        inited = -8;
        if ( !v22 )
          return inited;
        v23 = a2[2];
        v24 = v23 & 0xFF000FFF | (v12 << 12);
        v25 = (v23 >> 12) & 0xFFF;
        v26 = (v24 >> 12) & 0xFFF;
        *a2 = v22;
        a2[2] = v24;
        if ( v25 >= v26 )
        {
LABEL_19:
          v10 = *(_DWORD *)(a3 + 8);
          v9 = a2[2];
          v13 = v10 & 0xFFF;
        }
        else
        {
          do
          {
            v27 = 4 * v25;
            v25 = (unsigned __int16)(v25 + 1);
            *(_DWORD *)(v27 + v22) = 0;
          }
          while ( v25 < v26 );
          v10 = *(_DWORD *)(a3 + 8);
          v9 = a2[2];
          v13 = v10 & 0xFFF;
        }
      }
      else
      {
        v13 = v10 & 0xFFF;
      }
      v14 = *(_DWORD **)a3;
      v15 = (_DWORD *)*a2;
      v16 = 0;
      if ( v13 )
      {
        v17 = v13;
        do
        {
          --v17;
          *v15++ = *v14++;
        }
        while ( v17 );
        v16 = v13;
      }
      v18 = (v9 & 0xFFF) - v16;
      if ( v16 < (unsigned __int16)(v9 & 0xFFF) )
      {
        do
        {
          --v18;
          *v15++ = 0;
        }
        while ( v18 );
      }
      v19 = a2[2];
      a2[2] = v19 & 0xFFFFF000 | v10 & 0xFFF;
      a2[2] = v19 & 0xFEFFF000 | v10 & 0xFFF | ((*(_BYTE *)(a3 + 11) & 1) << 24);
      return 0;
    }
  }
  return inited;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);

//----- (00481178) --------------------------------------------------------
int   pstm_div(int a1, int a2, int a3, int *a4, int *a5)
{
  int v6; // $v1
  int inited; // $a0
  int v11; // $t2
  int v12; // $a3
  int v13; // $a0
  _DWORD *v14; // $a2
  _DWORD *v15; // $a1
  int v16; // $t1
  BOOL v17; // $t4
  BOOL v18; // $a3
  int v19; // $a2
  int v20; // $v0
  unsigned int v21; // $t0
  int v22; // $a0
  int v23; // $s0
  int v24; // $a2
  _DWORD *v25; // $a0
  _DWORD *v26; // $a1
  int v27; // $a3
  int v28; // $v1
  int v29; // $v0
  unsigned int v30; // $s0
  unsigned int v31; // $s1
  _DWORD *v32; // $a1
  int v33; // $v0
  int v35; // $s0
  int v37; // $s0
  unsigned int v38; // $t4
  _DWORD *v39; // $a0
  int v40; // $v0
  int v41; // $t0
  int v42; // $a1
  unsigned __int16 v43; // $v1
  unsigned int v44; // $a0
  unsigned __int16 v45; // $v0
  int v46; // $a1
  int v47; // $v0
  unsigned int v48; // $a0
  int v49; // $a0
  int v50; // $s0
  _DWORD *v51; // $a0
  _DWORD *v52; // $a1
  int v53; // $a3
  int v54; // $v1
  unsigned int v55; // $v0
  int v56; // $t0
  int v57; // $a0
  int v58; // $s0
  _DWORD *v59; // $a0
  _DWORD *v60; // $a1
  int v61; // $a3
  int v62; // $v1
  unsigned int v63; // $v0
  __int16 v64; // $s0
  int *v65; // $a0
  int v66; // $a2
  unsigned int v67; // $ra
  unsigned int v68; // $s7
  int v69; // $a0
  int v70; // $a1
  int v71; // $t4
  int v72; // $a2
  int v73; // $a1
  signed int v74; // $t5
  int v75; // $a2
  int v76; // $a0
  int v77; // $ra
  int v78; // $a2
  int v79; // $a1
  signed int v80; // $t1
  int v81; // $a2
  int v82; // $a0
  int v83; // $fp
  int v84; // $s0
  int v85; // $v0
  int v87; // $v1
  int v88; // $a2
  int v89; // $a1
  int v90; // $v1
  _DWORD *v91; // $a0
  _DWORD *v92; // $a2
  int v93; // $a3
  BOOL v94; // $t2
  BOOL v95; // $a1
  char v96; // $s6
  BOOL v97; // $t1
  int v98; // $fp
  int v99; // $t4
  int v100; // $a2
  int v101; // $t3
  int v102; // $v1
  int v103; // $s0
  int v104; // $a0
  unsigned int v105; // $t8
  int v106; // $t9
  int v107; // $t0
  unsigned int v108; // $ra
  int v109; // $s2
  int v110; // $s4
  int v111; // $a0
  int v112; // $a0
  _DWORD *v113; // $a0
  _DWORD *v114; // $a1
  int v115; // $a3
  BOOL v116; // $t3
  BOOL v117; // $a2
  _DWORD *v118; // [sp+20h] [-58h] BYREF
  int v119; // [sp+24h] [-54h]
  unsigned int v120; // [sp+28h] [-50h]
  int v121[2]; // [sp+30h] [-48h] BYREF
  unsigned int v122; // [sp+38h] [-40h]
  int v123[2]; // [sp+40h] [-38h] BYREF
  unsigned int v124; // [sp+48h] [-30h]
  int v125; // [sp+50h] [-28h] BYREF
  int v126; // [sp+54h] [-24h]
  int v127; // [sp+58h] [-20h]
  int v128; // [sp+60h] [-18h]
  int v129; // [sp+64h] [-14h]
  unsigned int v130; // [sp+68h] [-10h]
  int v131; // [sp+70h] [-8h]
  int v132; // [sp+74h] [-4h]

  v6 = *(_DWORD *)(a3 + 8) & 0xFFF;
  inited = -9;
  if ( !v6 )
    return inited;
  v11 = *(_DWORD *)(a2 + 8);
  v12 = v11 & 0xFFF;
  v13 = 1;
  if ( v6 >= v12 )
  {
    v13 = -1;
    if ( v12 >= v6 )
    {
      v14 = (_DWORD *)(*(_DWORD *)a2 + 4 * v12 - 4);
      v15 = (_DWORD *)(*(_DWORD *)a3 + 4 * v12 - 4);
      LOWORD(v16) = 0;
      if ( (v11 & 0xFFF) != 0 )
      {
        while ( 1 )
        {
          v16 = (unsigned __int16)(v16 + 1);
          v17 = *v15 < *v14;
          v18 = *v14-- < *v15--;
          if ( v17 )
          {
            v13 = 1;
            goto LABEL_9;
          }
          if ( v18 )
            break;
          if ( v16 >= (v11 & 0xFFF) )
            goto LABEL_8;
        }
        v13 = -1;
      }
      else
      {
LABEL_8:
        v13 = 0;
      }
    }
  }
LABEL_9:
  if ( v13 == -1 )
  {
    v19 = 0;
    if ( !a5 )
      goto LABEL_22;
    v20 = 0;
    if ( (int *)a2 != a5 )
    {
      v21 = a5[2];
      v22 = (v21 >> 12) & 0xFFF;
      v23 = v11 & 0xFFF;
      if ( v22 >= v23 )
      {
        v24 = v11 & 0xFFF;
LABEL_14:
        v25 = *(_DWORD **)a2;
        v26 = (_DWORD *)*a5;
        v27 = 0;
        if ( v24 )
        {
          v28 = v24;
          do
          {
            --v28;
            *v26++ = *v25++;
          }
          while ( v28 );
          v27 = v24;
        }
        v29 = (v21 & 0xFFF) - v27;
        if ( v27 < (unsigned __int16)(v21 & 0xFFF) )
        {
          do
          {
            --v29;
            *v26++ = 0;
          }
          while ( v29 );
        }
        v30 = a5[2] & 0xFFFFF000 | v11 & 0xFFF;
        a5[2] = v30;
        a5[2] = v30 & 0xFEFFFFFF | ((*(_BYTE *)(a2 + 11) & 1) << 24);
        v20 = 0;
        goto LABEL_21;
      }
      if ( (unsigned int)v23 < 0x181 )
      {
        if ( v22 >= v23 )
        {
LABEL_33:
          v11 = *(_DWORD *)(a2 + 8);
          v21 = a5[2];
          v24 = v11 & 0xFFF;
          goto LABEL_14;
        }
        v66 = realloc(*a5, 4 * v23);
        if ( v66 )
        {
          v67 = a5[2];
          v68 = v67 & 0xFF000FFF | (v23 << 12);
          v69 = (v67 >> 12) & 0xFFF;
          v70 = (v68 >> 12) & 0xFFF;
          *a5 = v66;
          a5[2] = v68;
          if ( v69 < v70 )
          {
            do
            {
              v71 = 4 * v69;
              v69 = (unsigned __int16)(v69 + 1);
              *(_DWORD *)(v71 + v66) = 0;
            }
            while ( v69 < v70 );
            v11 = *(_DWORD *)(a2 + 8);
            v21 = a5[2];
            v24 = v11 & 0xFFF;
            goto LABEL_14;
          }
          goto LABEL_33;
        }
      }
      v20 = -8;
    }
LABEL_21:
    v19 = v20;
LABEL_22:
    if ( a4 )
    {
      v31 = a4[2] & 0xFEFFF000;
      a4[2] = v31;
      v32 = (_DWORD *)*a4;
      LOWORD(v33) = 0;
      if ( ((v31 >> 12) & 0xFFF) != 0 )
      {
        do
        {
          v33 = (unsigned __int16)(v33 + 1);
          *v32++ = 0;
        }
        while ( v33 < (int)((v31 >> 12) & 0xFFF) );
      }
    }
    return v19;
  }
  inited = pstm_init_size(a1, (int *)&v118, 0x60u);
  if ( inited )
    return inited;
  v35 = pstm_init_size(a1, v121, 0x60u);
  if ( !v35 )
  {
    v37 = pstm_init_size(a1, v123, 0x60u);
    if ( v37 )
    {
      pstm_clear(&v118);
      v65 = v121;
    }
    else
    {
      v37 = pstm_init_size(a1, &v125, 0x60u);
      if ( !v37 )
      {
        v38 = (v124 & 0xFEFFF000) >> 12;
        v124 &= 0xFEFFF000;
        v39 = (_DWORD *)v123[0];
        LOWORD(v40) = 0;
        if ( (v38 & 0xFFF) != 0 )
        {
          do
          {
            v40 = (unsigned __int16)(v40 + 1);
            *v39++ = 0;
          }
          while ( v40 < (unsigned __int16)(v38 & 0xFFF) );
        }
        *(_DWORD *)v123[0] = 1;
        v41 = *(_DWORD *)(a2 + 8);
        v42 = v41 & 0xFFF;
        v124 = v124 & 0xFFFFF000 | 1;
        v43 = 0;
        if ( (v41 & 0xFFF) != 0 )
        {
          v44 = *(_DWORD *)(4 * v42 + *(_DWORD *)a2 - 4);
          v45 = 32 * v42 - 32;
          while ( v44 )
          {
            ++v45;
            v44 >>= 1;
          }
          v43 = v45;
        }
        v46 = *(_DWORD *)(a3 + 8) & 0xFFF;
        v47 = 0;
        if ( v46 )
        {
          v48 = *(_DWORD *)(4 * v46 + *(_DWORD *)a3 - 4);
          LOWORD(v47) = 32 * v46 - 32;
          while ( v48 )
          {
            LOWORD(v47) = v47 + 1;
            v48 >>= 1;
          }
          v47 = (unsigned __int16)v47;
        }
        v131 = v43 - v47;
        if ( (_DWORD **)a2 == &v118 )
          goto LABEL_61;
        v49 = (v120 >> 12) & 0xFFF;
        if ( v49 >= (v41 & 0xFFF) )
        {
LABEL_54:
          v51 = *(_DWORD **)a2;
          v52 = v118;
          v53 = 0;
          if ( (v41 & 0xFFF) != 0 )
          {
            v54 = v41 & 0xFFF;
            do
            {
              --v54;
              *v52++ = *v51++;
            }
            while ( v54 );
            v53 = v41 & 0xFFF;
          }
          v55 = (v120 & 0xFFF) - v53;
          if ( v53 < (unsigned __int16)(v120 & 0xFFF) )
          {
            do
            {
              --v55;
              *v52++ = 0;
            }
            while ( v55 );
          }
          v120 = v120 & 0xFEFFF000 | v41 & 0xFFF | v41 & 0x1000000;
LABEL_61:
          v120 &= ~0x1000000u;
          if ( (int *)a3 == v121 )
            goto LABEL_73;
          v56 = *(_DWORD *)(a3 + 8);
          v57 = (v122 >> 12) & 0xFFF;
          if ( v57 >= (v56 & 0xFFF) )
          {
LABEL_66:
            v59 = *(_DWORD **)a3;
            v60 = (_DWORD *)v121[0];
            v61 = 0;
            if ( (v56 & 0xFFF) != 0 )
            {
              v62 = v56 & 0xFFF;
              do
              {
                --v62;
                *v60++ = *v59++;
              }
              while ( v62 );
              v61 = v56 & 0xFFF;
            }
            v63 = (v122 & 0xFFF) - v61;
            if ( v61 < (unsigned __int16)(v122 & 0xFFF) )
            {
              do
              {
                --v63;
                *v60++ = 0;
              }
              while ( v63 );
            }
            v122 = v122 & 0xFEFFF000 | v56 & 0xFFF | v56 & 0x1000000;
LABEL_73:
            v64 = v131;
            v122 &= ~0x1000000u;
            v132 = sub_47FDB8((int)v121, v131, v121);
            if ( !v132 )
            {
              v132 = sub_47FDB8((int)v123, v64, v123);
              if ( !v132 )
              {
                v84 = v131 - 1;
                if ( v131 >= 0 )
                {
                  do
                  {
                    v87 = HIBYTE(v122) & 1;
                    if ( v87 == (HIBYTE(v120) & 1) )
                    {
                      v88 = v120 & 0xFFF;
                      if ( v87 == 1 )
                      {
                        v112 = 1;
                        if ( (unsigned __int16)(v122 & 0xFFF) < v88 )
                          goto LABEL_132;
                        v112 = -1;
                        if ( v88 < (unsigned __int16)(v122 & 0xFFF) )
                          goto LABEL_132;
                        v113 = &v118[v88 - 1];
                        v114 = (_DWORD *)(v121[0] + 4 * v88 - 4);
                        LOWORD(v115) = 0;
                        if ( (v120 & 0xFFF) == 0 )
                        {
LABEL_131:
                          v112 = 0;
LABEL_132:
                          v85 = v112;
                          goto LABEL_99;
                        }
                        while ( 1 )
                        {
                          v115 = (unsigned __int16)(v115 + 1);
                          v116 = *v114 < *v113;
                          v117 = *v113-- < *v114--;
                          if ( v116 )
                            break;
                          if ( v117 )
                          {
                            v85 = -1;
                            goto LABEL_99;
                          }
                          if ( v115 >= (unsigned __int16)(v120 & 0xFFF) )
                            goto LABEL_131;
                        }
                        v85 = 1;
                      }
                      else
                      {
                        v89 = v122 & 0xFFF;
                        v90 = 1;
                        if ( (unsigned __int16)(v120 & 0xFFF) < v89 )
                          goto LABEL_114;
                        v90 = -1;
                        if ( v89 < (unsigned __int16)(v120 & 0xFFF) )
                          goto LABEL_114;
                        v91 = (_DWORD *)(v121[0] + 4 * v89 - 4);
                        v92 = &v118[v89 - 1];
                        LOWORD(v93) = 0;
                        if ( (v122 & 0xFFF) == 0 )
                        {
LABEL_113:
                          v90 = 0;
LABEL_114:
                          v85 = v90;
                          goto LABEL_99;
                        }
                        while ( 1 )
                        {
                          v93 = (unsigned __int16)(v93 + 1);
                          v94 = *v92 < *v91;
                          v95 = *v91-- < *v92--;
                          if ( v94 )
                            break;
                          if ( v95 )
                          {
                            v85 = -1;
                            goto LABEL_99;
                          }
                          if ( v93 >= (unsigned __int16)(v122 & 0xFFF) )
                            goto LABEL_113;
                        }
                        v85 = 1;
                      }
                    }
                    else
                    {
                      v85 = -1;
                      if ( v87 != 1 )
                        v85 = 1;
                    }
LABEL_99:
                    if ( v85 != 1 )
                    {
                      v132 = pstm_sub((int *)&v118, v121, (int *)&v118);
                      if ( v132 )
                        goto LABEL_74;
                      v132 = pstm_add(&v125, v123, &v125);
                      if ( v132 )
                        goto LABEL_74;
                    }
                    v132 = pstm_div_2d(a1, (int)v121, 1, v121, 0);
                    if ( v132 )
                      goto LABEL_74;
                    v132 = pstm_div_2d(a1, (int)v123, 1, v123, 0);
                    if ( v132 )
                      goto LABEL_74;
                  }
                  while ( v84-- >= 0 );
                }
                v96 = *(_BYTE *)(a2 + 11);
                v97 = (v96 & 1) != (*(_BYTE *)(a3 + 11) & 1);
                if ( a4 )
                {
                  v98 = v127;
                  v99 = *a4;
                  v100 = a4[1];
                  v101 = a4[2];
                  v102 = v126;
                  v103 = v127 & 0xFFF;
                  *a4 = v125;
                  a4[1] = v102;
                  v104 = v97;
                  v125 = v99;
                  v126 = v100;
                  v127 = v101;
                  v128 = v99;
                  v129 = v100;
                  v130 = v101;
                  a4[2] = v98;
                  if ( !v103 )
                    v104 = 0;
                  a4[2] = a4[2] & 0xFEFFFFFF | (v104 << 24);
                }
                if ( a5 )
                {
                  v105 = v120;
                  v106 = *a5;
                  v107 = a5[1];
                  v108 = a5[2];
                  v109 = (int)v118;
                  v110 = v120 & 0xFFF;
                  a5[1] = v119;
                  *a5 = v109;
                  v111 = v96 & 1;
                  v118 = (_DWORD *)v106;
                  v119 = v107;
                  v120 = v108;
                  v128 = v106;
                  v129 = v107;
                  v130 = v108;
                  a5[2] = v105;
                  if ( !v110 )
                    v111 = 0;
                  a5[2] = a5[2] & 0xFEFFFFFF | (v111 << 24);
                }
              }
            }
            goto LABEL_74;
          }
          v58 = *(_DWORD *)(a3 + 8) & 0xFFF;
          if ( (unsigned int)v58 < 0x181 )
          {
            if ( v57 >= v58 )
            {
LABEL_65:
              v56 = *(_DWORD *)(a3 + 8);
              goto LABEL_66;
            }
            v72 = realloc(v121[0], 4 * v58);
            if ( v72 )
            {
              v73 = (v122 >> 12) & 0xFFF;
              v74 = ((v122 & 0xFF000FFF | (v58 << 12)) >> 12) & 0xFFF;
              v121[0] = v72;
              v122 = v122 & 0xFF000FFF | (v58 << 12);
              if ( v73 < v74 )
              {
                v75 = v121[0];
                v76 = (v122 >> 12) & 0xFFF;
                do
                {
                  v77 = 4 * v73;
                  v73 = (unsigned __int16)(v73 + 1);
                  *(_DWORD *)(v77 + v75) = 0;
                }
                while ( v73 < v76 );
              }
              goto LABEL_65;
            }
          }
          v132 = -8;
LABEL_74:
          pstm_clear(&v118);
          pstm_clear(v121);
          pstm_clear(v123);
          pstm_clear(&v125);
          return v132;
        }
        v50 = v41 & 0xFFF;
        if ( (unsigned int)v50 < 0x181 )
        {
          if ( v49 >= v50 )
          {
LABEL_53:
            v41 = *(_DWORD *)(a2 + 8);
            goto LABEL_54;
          }
          v78 = realloc(v118, 4 * v50);
          if ( v78 )
          {
            v79 = (v120 >> 12) & 0xFFF;
            v80 = ((v120 & 0xFF000FFF | (v50 << 12)) >> 12) & 0xFFF;
            v118 = (_DWORD *)v78;
            v120 = v120 & 0xFF000FFF | (v50 << 12);
            if ( v79 < v80 )
            {
              v81 = (int)v118;
              v82 = (v120 >> 12) & 0xFFF;
              do
              {
                v83 = 4 * v79;
                v79 = (unsigned __int16)(v79 + 1);
                *(_DWORD *)(v83 + v81) = 0;
              }
              while ( v79 < v82 );
            }
            goto LABEL_53;
          }
        }
        v132 = -8;
        goto LABEL_74;
      }
      pstm_clear(&v118);
      pstm_clear(v121);
      v65 = v123;
    }
    pstm_clear(v65);
    return v37;
  }
  pstm_clear(&v118);
  return v35;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);

//----- (00481DB8) --------------------------------------------------------
int   pstm_mod(int a1, int a2, int a3, int *a4)
{
  int result; // $v0
  int v9; // $s2
  int v10; // $a0
  int v11; // $a1
  int v12; // $t5
  int v13; // $t4
  int v14; // $t3
  int v15; // [sp+20h] [-20h] BYREF
  int v16; // [sp+24h] [-1Ch]
  unsigned int v17; // [sp+28h] [-18h]
  int v18; // [sp+30h] [-10h]
  int v19; // [sp+34h] [-Ch]
  unsigned int v20; // [sp+38h] [-8h]

  result = pstm_init_size(a1, &v15, (*(_DWORD *)(a3 + 8) >> 12) & 0xFFF);
  if ( !result )
  {
    v9 = pstm_div(a1, a2, a3, 0, &v15);
    if ( !v9 )
    {
      if ( (HIBYTE(v17) & 1) == (*(_BYTE *)(a3 + 11) & 1) )
      {
        v10 = a4[2];
        v11 = v15;
        v12 = *a4;
        v13 = a4[1];
        v14 = v16;
        v20 = v17;
        a4[2] = v17;
        *a4 = v11;
        v17 = v10;
        v15 = v12;
        v16 = v13;
        a4[1] = v14;
        v18 = v11;
        v19 = v14;
      }
      else
      {
        v9 = pstm_add(&v15, (int *)a3, a4);
      }
    }
    pstm_clear(&v15);
    return v9;
  }
  return result;
}

//----- (00481F30) --------------------------------------------------------
int   pstm_mulmod(int a1, int *a2, int *a3, int a4, int *a5)
{
  unsigned int v5; // $t1
  int v8; // $a2
  int result; // $v0
  int v12; // $s0
  int v13[4]; // [sp+20h] [-10h] BYREF

  v5 = a2[2];
  v8 = (v5 & 0xFFF) + (a3[2] & 0xFFF) + 1;
  if ( a2 == a5 && v8 < (int)((v5 >> 12) & 0xFFF) )
    LOWORD(v8) = (v5 >> 12) & 0xFFF;
  result = pstm_init_size(a1, v13, v8);
  if ( !result )
  {
    v12 = pstm_mul_comba(a1, a2, a3, v13, 0, 0);
    if ( !v12 )
      v12 = pstm_mod(a1, (int)v13, a4, a5);
    pstm_clear(v13);
    return v12;
  }
  return result;
}

//----- (0048209C) --------------------------------------------------------
int   pstm_exptmod(int a1, int *a2, _DWORD *a3, int *a4, int *a5)
{
  int v5; // $t2
  int v7; // $a3
  __int16 v11; // $v0
  unsigned int v12; // $a0
  int v13; // $v1
  int v14; // $v0
  int inited; // $v1
  int v17; // $a1
  __int16 v18; // $v1
  unsigned int v19; // $a0
  __int16 v20; // $v0
  int v21; // $t1
  int v22; // $s6
  int v23; // $t3
  int v24; // $s0
  int v25; // $t0
  int v26; // $t2
  int v27; // $a3
  int v28; // $a0
  _DWORD *v29; // $a2
  _DWORD *v30; // $a1
  int v31; // $t1
  BOOL v32; // $s0
  BOOL v33; // $a3
  int v34; // $a2
  int v35; // $a1
  int *v36; // $s0
  int v37; // $a0
  int v38; // $a2
  int v39; // $v1
  unsigned int v40; // $t1
  int v41; // $a0
  int v42; // $s2
  __int16 v43; // $a0
  _DWORD *v44; // $a1
  int v45; // $a3
  _DWORD *v46; // $a2
  int v47; // $t0
  int v48; // $v1
  int v49; // $v0
  int v50; // $t0
  int v51; // $v0
  int v52; // $s4
  int *v53; // $s2
  unsigned __int16 v54; // $s7
  int v55; // $ra
  int v56; // $s4
  _BYTE *v57; // $s7
  int *v58; // $s2
  __int16 v59; // $v0
  int v60; // $s2
  int v61; // $s4
  unsigned __int16 v62; // $s7
  int *v63; // $s2
  int v64; // $s2
  int v65; // $s4
  int v66; // $v0
  int v67; // $a0
  int v68; // $s2
  int v69; // $s2
  int *v70; // $s1
  int v71; // $a2
  unsigned int v72; // $a1
  unsigned int v73; // $v0
  int v74; // $a0
  int v75; // $a1
  int v76; // $t6
  int v77; // $a0
  int v78; // $a2
  int v79; // $s0
  _DWORD *v80; // $v1
  _DWORD *v81; // $a1
  int v82; // $a0
  int v83; // $a0
  int v84; // $v0
  bool v85; // dc
  int v86; // $v0
  int v87; // $a2
  int v88; // $a1
  int v89; // $a0
  int v90; // $t8
  int v91; // $s1
  int *v92; // $s2
  __int16 v93; // $s2
  __int16 v94; // $t1
  int v95; // $v0
  unsigned int v96; // $t0
  int v97; // $a0
  int v98; // $s0
  int v99; // $t1
  _DWORD *v100; // $a0
  int v101; // $a2
  _DWORD *v102; // $a1
  int v103; // $a3
  int v104; // $v1
  int v105; // $v0
  int v106; // $a2
  unsigned int v107; // $s4
  unsigned int v108; // $ra
  int v109; // $a0
  int v110; // $a1
  int v111; // $s2
  int v112[3]; // [sp+20h] [-1D0h] BYREF
  int v113[2]; // [sp+2Ch] [-1C4h] BYREF
  unsigned int v114; // [sp+34h] [-1BCh]
  int v115[2]; // [sp+1A0h] [-50h] BYREF
  int v116; // [sp+1A8h] [-48h]
  int v117[4]; // [sp+1B0h] [-40h] BYREF
  int v118; // [sp+1C0h] [-30h]
  _DWORD *v119; // [sp+1C4h] [-2Ch]
  int v120; // [sp+1C8h] [-28h]
  int v121; // [sp+1CCh] [-24h]
  int v122; // [sp+1D0h] [-20h]
  int v123; // [sp+1D4h] [-1Ch]
  int v124; // [sp+1D8h] [-18h]
  int v125; // [sp+1DCh] [-14h]
  int v126; // [sp+1E0h] [-10h]
  int v127; // [sp+1E4h] [-Ch]
  int v128; // [sp+1E8h] [-8h]

  v5 = a4[2];
  v7 = v5 & 0xFFF;
  v11 = 0;
  if ( (v5 & 0xFFF) != 0 )
  {
    v12 = *(_DWORD *)(4 * v7 + *a4 - 4);
    v11 = 32 * v7 - 32;
    while ( v12 )
    {
      ++v11;
      v12 >>= 1;
    }
  }
  v13 = v11;
  if ( v11 == 1536 )
    goto LABEL_14;
  if ( v11 >= 1537 )
  {
    if ( v11 == 3072 )
      goto LABEL_14;
    v14 = 4096;
    if ( v13 < 3073 )
    {
      if ( v13 != 2048 )
        return -1;
      goto LABEL_14;
    }
  }
  else
  {
    v14 = 1024;
    if ( v13 == 512 )
      goto LABEL_14;
  }
  if ( v13 != v14 )
    return -1;
LABEL_14:
  v17 = a3[2] & 0xFFF;
  v18 = 0;
  if ( v17 )
  {
    v19 = *(_DWORD *)(4 * v17 + *a3 - 4);
    v20 = 32 * v17 - 32;
    while ( v19 )
    {
      ++v20;
      v19 >>= 1;
    }
    v18 = v20;
  }
  v21 = *(_DWORD *)*a4;
  v22 = (v18 >= 50) + 2;
  inited = -6;
  if ( ((v21 ^ 1) & 1) != 0 )
    return inited;
  v23 = (2 * ((v21 + 2) & 4) + v21)
      * (2 - v21 * (2 * ((v21 + 2) & 4) + v21))
      * (2 - v21 * (2 * ((v21 + 2) & 4) + v21) * (2 - v21 * (2 * ((v21 + 2) & 4) + v21)));
  v118 = -(v23 * (2 - v21 * v23));
  inited = pstm_init_size(a1, v115, 2 * (v5 & 0xFFF) + 1);
  if ( inited )
    return inited;
  v24 = pstm_montgomery_calc_normalization(v115, a4);
  if ( v24 )
    goto LABEL_93;
  v24 = pstm_init_size(a1, v113, v116 & 0xFFF);
  if ( v24 )
    goto LABEL_93;
  v25 = a4[2];
  v26 = a2[2];
  v27 = v25 & 0xFFF;
  v28 = 1;
  if ( (v26 & 0xFFF) >= v27 )
  {
    v28 = -1;
    if ( v27 >= (v26 & 0xFFF) )
    {
      v29 = (_DWORD *)(*a4 + 4 * v27 - 4);
      v30 = (_DWORD *)(*a2 + 4 * v27 - 4);
      LOWORD(v31) = 0;
      if ( (v25 & 0xFFF) != 0 )
      {
        while ( 1 )
        {
          v31 = (unsigned __int16)(v31 + 1);
          v32 = *v30 < *v29;
          v33 = *v29-- < *v30--;
          if ( v32 )
            break;
          if ( v33 )
          {
            v28 = -1;
            goto LABEL_30;
          }
          if ( v31 >= (v25 & 0xFFF) )
            goto LABEL_29;
        }
        v28 = 1;
      }
      else
      {
LABEL_29:
        v28 = 0;
      }
    }
  }
LABEL_30:
  if ( v28 != 1 )
  {
    v24 = pstm_mod(a1, (int)a2, (int)a4, v113);
    goto LABEL_32;
  }
  if ( a2 == v113 )
    goto LABEL_33;
  v77 = (v114 >> 12) & 0xFFF;
  v78 = v26 & 0xFFF;
  if ( v77 >= v78 )
  {
LABEL_103:
    v80 = (_DWORD *)*a2;
    v81 = (_DWORD *)v113[0];
    v82 = 0;
    if ( v78 )
    {
      v83 = v78;
      do
      {
        --v83;
        *v81++ = *v80++;
      }
      while ( v83 );
      v82 = v78;
    }
    v84 = v114 & 0xFFF;
    v85 = v82 >= v84;
    v86 = v84 - v82;
    if ( !v85 )
    {
      do
      {
        --v86;
        *v81++ = 0;
      }
      while ( v86 );
    }
    v114 = v114 & 0xFEFFF000 | v26 & 0xFFF | v26 & 0x1000000;
    goto LABEL_33;
  }
  v79 = a2[2] & 0xFFF;
  if ( (unsigned int)v79 < 0x181 )
  {
    if ( v77 >= v79 )
    {
LABEL_102:
      v26 = a2[2];
      v78 = v26 & 0xFFF;
      goto LABEL_103;
    }
    v87 = realloc(v113[0], 4 * v79);
    if ( v87 )
    {
      v88 = (v114 >> 12) & 0xFFF;
      v113[0] = v87;
      v114 = v114 & 0xFF000FFF | (v79 << 12);
      if ( v88 < (int)((v114 >> 12) & 0xFFF) )
      {
        v89 = (v114 >> 12) & 0xFFF;
        do
        {
          v90 = 4 * v88;
          v88 = (unsigned __int16)(v88 + 1);
          *(_DWORD *)(v90 + v87) = 0;
        }
        while ( v88 < v89 );
      }
      goto LABEL_102;
    }
  }
  v24 = -8;
LABEL_32:
  if ( v24 )
    goto LABEL_92;
LABEL_33:
  v34 = (v114 & 0xFFF) + (v116 & 0xFFF) + 1;
  if ( v34 < (int)((v114 >> 12) & 0xFFF) )
    LOWORD(v34) = (v114 >> 12) & 0xFFF;
  v24 = pstm_init_size(a1, v117, v34);
  if ( !v24 )
  {
    v24 = pstm_mul_comba(a1, v113, v115, v117, 0, 0);
    if ( !v24 )
      v24 = pstm_mod(a1, (int)v117, (int)a4, v113);
    pstm_clear(v117);
  }
  if ( v24 )
    goto LABEL_92;
  v124 = 8 * (v114 & 0xFFF) + 24;
  v119 = (_DWORD *)malloc(v124);
  v24 = -8;
  if ( !v119 )
    goto LABEL_92;
  v35 = 12 << (v22 - 1);
  v36 = (int *)((char *)v112 + v35);
  v128 = v22 - 1;
  if ( (int *)((char *)v112 + v35) == v113 )
    goto LABEL_56;
  v37 = 2 * (v114 & 0xFFF);
  v38 = (v114 >> 12) & 0xFFF;
  if ( v37 + 2 >= v38 )
    LOWORD(v38) = v37 + 3;
  v39 = pstm_init_size(a1, (int *)((char *)v112 + v35), v38);
  if ( !v39 && v113 != v36 )
  {
    v40 = v36[2];
    v41 = (v40 >> 12) & 0xFFF;
    if ( v41 >= (unsigned __int16)(v114 & 0xFFF) )
    {
LABEL_47:
      v43 = v114;
      v44 = (_DWORD *)v113[0];
      v45 = v114 & 0xFFF;
      v46 = (_DWORD *)*v36;
      v47 = 0;
      if ( (v114 & 0xFFF) != 0 )
      {
        v48 = v114 & 0xFFF;
        do
        {
          --v48;
          *v46++ = *v44++;
        }
        while ( v48 );
        v47 = v45;
      }
      v49 = (v40 & 0xFFF) - v47;
      if ( v47 < (unsigned __int16)(v40 & 0xFFF) )
      {
        do
        {
          --v49;
          *v46++ = 0;
        }
        while ( v49 );
      }
      v50 = v36[2];
      v36[2] = v50 & 0xFFFFF000 | v43 & 0xFFF;
      v36[2] = v50 & 0xFEFFF000 | v43 & 0xFFF | ((HIBYTE(v114) & 1) << 24);
      v51 = 0;
      goto LABEL_54;
    }
    v42 = v114 & 0xFFF;
    if ( (unsigned int)v42 < 0x181 )
    {
      if ( v41 >= v42 )
      {
LABEL_46:
        v40 = v36[2];
        goto LABEL_47;
      }
      v71 = realloc(*v36, 4 * v42);
      if ( v71 )
      {
        v72 = v36[2];
        v73 = v72 & 0xFF000FFF | (v42 << 12);
        v74 = (v72 >> 12) & 0xFFF;
        v75 = (v73 >> 12) & 0xFFF;
        *v36 = v71;
        for ( v36[2] = v73; v74 < v75; *(_DWORD *)(v76 + v71) = 0 )
        {
          v76 = 4 * v74;
          v74 = (unsigned __int16)(v74 + 1);
        }
        goto LABEL_46;
      }
    }
    v51 = -8;
LABEL_54:
    v39 = v51;
  }
  v24 = -8;
  if ( v39 )
    goto LABEL_91;
LABEL_56:
  LOWORD(v52) = 0;
  if ( v128 > 0 )
  {
    v53 = (int *)((char *)v112 + (12 << v128));
    v54 = v124;
    do
    {
      v24 = pstm_sqr_comba(a1, v53, v53, (int)v119, v54);
      if ( !v24 )
      {
        v24 = pstm_montgomery_reduce(a1, v53, a4, v118, v119, v54);
        v52 = (__int16)(v52 + 1);
        if ( !v24 )
          continue;
      }
      goto LABEL_91;
    }
    while ( v52 < v128 );
  }
  v55 = (1 << v128) + 1;
  v56 = (__int16)v55;
  if ( (__int16)v55 < 1 << v22 )
  {
    v57 = (char *)v112 + (12 << v128);
    v126 = 1 << v128;
    v125 = 1 << v22;
    v58 = &v112[3 * (__int16)v55];
    do
    {
      v24 = pstm_init_size(a1, v58, ((16 * (unsigned __int8)v57[10]) | ((unsigned __int8)v57[9] >> 4)) + 1);
      v59 = v56 + 1;
      v58 += 3;
      if ( v24 )
      {
        LOWORD(v91) = v126;
        if ( (__int16)v126 < v56 )
        {
          v92 = &v112[3 * (__int16)v126];
          do
          {
            pstm_clear(v92);
            v91 = (__int16)(v91 + 1);
            v92 += 3;
          }
          while ( v91 < v56 );
        }
        goto LABEL_91;
      }
      v56 = v59;
    }
    while ( v59 < v125 );
  }
  v60 = (1 << v128) + 1;
  LOWORD(v61) = v60;
  if ( (__int16)v60 >= 1 << v22 )
  {
    v62 = v124;
  }
  else
  {
    v62 = v124;
    v127 = 1 << v22;
    v63 = &v112[3 * (__int16)v60];
    do
    {
      v24 = pstm_mul_comba(a1, v63 - 3, v113, v63, (int)v119, v62);
      if ( v24 )
        goto LABEL_88;
      v24 = pstm_montgomery_reduce(a1, v63, a4, v118, v119, v62);
      v61 = (__int16)(v61 + 1);
      if ( v24 )
        goto LABEL_88;
      v63 += 3;
    }
    while ( v61 < v127 );
  }
  v64 = 0;
  v123 = (__int16)((a3[2] & 0xFFF) - 1);
  v122 = 1;
  v65 = 0;
  v121 = 0;
  v120 = 0;
  while ( 1 )
  {
    v66 = (__int16)(v122 - 1);
    v122 = v66;
    if ( v66 )
      goto LABEL_74;
    if ( v123 == -1 )
      break;
    v65 = *(_DWORD *)(4 * v123 + *a3);
    v123 = (__int16)(v123 - 1);
    v122 = 32;
LABEL_74:
    v67 = v65 < 0;
    v65 *= 2;
    if ( v64 || v67 )
    {
      if ( v64 != 1 || v67 )
      {
        v121 = (__int16)(v121 + 1);
        v120 |= v67 << (v22 - v121);
        v64 = 2;
        if ( v121 == v22 )
        {
          LOWORD(v68) = 0;
          if ( v22 )
          {
            do
            {
              v24 = pstm_sqr_comba(a1, v115, v115, (int)v119, v62);
              if ( v24 )
                goto LABEL_88;
              v24 = pstm_montgomery_reduce(a1, v115, a4, v118, v119, v62);
              v68 = (__int16)(v68 + 1);
              if ( v24 )
                goto LABEL_88;
            }
            while ( v68 < v22 );
          }
          v24 = pstm_mul_comba(a1, v115, &v112[3 * v120], v115, (int)v119, v62);
          if ( v24 )
            goto LABEL_88;
          v24 = pstm_montgomery_reduce(a1, v115, a4, v118, v119, v62);
          if ( v24 )
            goto LABEL_88;
          v64 = 1;
          v121 = 0;
          v120 = 0;
        }
      }
      else
      {
        v24 = pstm_sqr_comba(a1, v115, v115, (int)v119, v62);
        if ( v24 )
          goto LABEL_88;
        v24 = pstm_montgomery_reduce(a1, v115, a4, v118, v119, v62);
        if ( v24 )
          goto LABEL_88;
      }
    }
  }
  if ( v64 != 2 || (v93 = 0, v121 <= 0) )
  {
LABEL_138:
    v24 = pstm_montgomery_reduce(a1, v115, a4, v118, v119, v62);
    if ( v24 )
      goto LABEL_88;
    v95 = 0;
    if ( v115 == a5 )
      goto LABEL_151;
    v96 = a5[2];
    v97 = (v96 >> 12) & 0xFFF;
    if ( v97 >= (v116 & 0xFFF) )
      goto LABEL_144;
    v98 = v116 & 0xFFF;
    if ( (unsigned int)v98 < 0x181 )
    {
      if ( v97 >= v98 )
      {
LABEL_143:
        v96 = a5[2];
LABEL_144:
        v99 = v116;
        v100 = (_DWORD *)v115[0];
        v101 = v116 & 0xFFF;
        v102 = (_DWORD *)*a5;
        v103 = 0;
        if ( (v116 & 0xFFF) != 0 )
        {
          v104 = v116 & 0xFFF;
          do
          {
            --v104;
            *v102++ = *v100++;
          }
          while ( v104 );
          v103 = v101;
        }
        v105 = (v96 & 0xFFF) - v103;
        if ( v103 < (unsigned __int16)(v96 & 0xFFF) )
        {
          do
          {
            --v105;
            *v102++ = 0;
          }
          while ( v105 );
        }
        a5[2] = a5[2] & 0xFEFFF000 | v99 & 0xFFF | v99 & 0x1000000;
        v95 = 0;
        goto LABEL_151;
      }
      v106 = realloc(*a5, 4 * v98);
      if ( v106 )
      {
        v107 = a5[2];
        v108 = v107 & 0xFF000FFF | (v98 << 12);
        v109 = (v107 >> 12) & 0xFFF;
        v110 = (v108 >> 12) & 0xFFF;
        *a5 = v106;
        for ( a5[2] = v108; v109 < v110; *(_DWORD *)(v111 + v106) = 0 )
        {
          v111 = 4 * v109;
          v109 = (unsigned __int16)(v109 + 1);
        }
        goto LABEL_143;
      }
    }
    v95 = -8;
LABEL_151:
    v24 = v95;
    goto LABEL_88;
  }
  while ( 1 )
  {
    v120 *= 2;
    v24 = pstm_sqr_comba(a1, v115, v115, (int)v119, v62);
    if ( v24 )
      break;
    v24 = pstm_montgomery_reduce(a1, v115, a4, v118, v119, v62);
    if ( v24 )
      break;
    v94 = v93 + 1;
    if ( ((v120 >> v22) & 1) != 0 )
    {
      v24 = pstm_mul_comba(a1, v115, v113, v115, (int)v119, v62);
      if ( v24 )
        break;
      v24 = pstm_montgomery_reduce(a1, v115, a4, v118, v119, v62);
      if ( v24 )
        break;
      v94 = v93 + 1;
    }
    v93 = v94;
    if ( v94 >= v121 )
      goto LABEL_138;
  }
LABEL_88:
  v69 = (__int16)(1 << v128);
  if ( v69 < 1 << v22 )
  {
    v70 = &v112[3 * v69];
    do
    {
      pstm_clear(v70);
      v69 = (__int16)(v69 + 1);
      v70 += 3;
    }
    while ( v69 < 1 << v22 );
  }
LABEL_91:
  free2(v119);
LABEL_92:
  pstm_clear(v113);
LABEL_93:
  pstm_clear(v115);
  return v24;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (00483014) --------------------------------------------------------
int   pstm_to_unsigned_bin(int a1, int *a2, int a3)
{
  int inited; // $v1
  int result; // $v0
  int v8; // $s1
  int v9; // $s0
  unsigned int v10; // $a3
  unsigned int v11; // $t0
  _BYTE *v12; // $a1
  _BYTE *v13; // $t1
  char v14; // $t2
  char v15; // $t3
  __int16 v16; // $t0
  int v17; // $t1
  int v18; // $a0
  int v19; // $s2
  int v20; // $a2
  _DWORD *v21; // $a1
  _DWORD *v22; // $a0
  int v23; // $a3
  int v24; // $v1
  int v25; // $v0
  int v26; // $v0
  int v27; // $a0
  signed int v28; // $a1
  int v29; // $v1
  int v30[2]; // [sp+20h] [-10h] BYREF
  unsigned int v31; // [sp+28h] [-8h]

  v30[0] = 0;
  v30[1] = 0;
  v31 = 0;
  if ( v30 != a2 )
  {
    inited = pstm_init_size(a1, v30, ((unsigned int)a2[2] >> 12) & 0xFFF);
    if ( !inited && a2 != v30 )
    {
      v16 = v31;
      v17 = a2[2];
      v18 = (v31 >> 12) & 0xFFF;
      v19 = v17 & 0xFFF;
      if ( v18 < v19 )
      {
        inited = -8;
        if ( (unsigned int)v19 >= 0x181 )
          goto LABEL_3;
        if ( v18 >= v19 )
          goto LABEL_25;
        v26 = realloc(v30[0], 4 * v19);
        inited = -8;
        if ( !v26 )
          goto LABEL_3;
        v27 = (v31 >> 12) & 0xFFF;
        v28 = ((v31 & 0xFF000FFF | (v19 << 12)) >> 12) & 0xFFF;
        v30[0] = v26;
        v31 = v31 & 0xFF000FFF | (v19 << 12);
        if ( v27 >= v28 )
        {
LABEL_25:
          v17 = a2[2];
          v16 = v31;
          v20 = v17 & 0xFFF;
        }
        else
        {
          do
          {
            v29 = 4 * v27;
            v27 = (unsigned __int16)(v27 + 1);
            *(_DWORD *)(v29 + v26) = 0;
          }
          while ( v27 < v28 );
          v17 = a2[2];
          v16 = v31;
          v20 = v17 & 0xFFF;
        }
      }
      else
      {
        v20 = v17 & 0xFFF;
      }
      v21 = (_DWORD *)*a2;
      v22 = (_DWORD *)v30[0];
      v23 = 0;
      if ( v20 )
      {
        v24 = v20;
        do
        {
          --v24;
          *v22++ = *v21++;
        }
        while ( v24 );
        v23 = v20;
      }
      if ( v23 < (v16 & 0xFFF) )
      {
        v25 = (v16 & 0xFFF) - v23;
        do
        {
          --v25;
          *v22++ = 0;
        }
        while ( v25 );
      }
      v31 = v31 & 0xFEFFF000 | v17 & 0xFFF | v17 & 0x1000000;
      inited = 0;
    }
LABEL_3:
    result = inited;
    if ( inited )
      return result;
  }
  v8 = 0;
  if ( (v31 & 0xFFF) != 0 )
  {
    do
    {
      *(_BYTE *)(v8 + a3) = *(_DWORD *)v30[0];
      v8 = (unsigned __int16)(v8 + 1);
      v9 = pstm_div_2d(a1, (int)v30, 8, v30, 0);
      if ( v9 )
      {
        pstm_clear(v30);
        return v9;
      }
    }
    while ( (v31 & 0xFFF) != 0 );
    if ( v8 )
    {
      v10 = (unsigned __int16)(v8 - 1);
      v11 = 0;
      if ( (_WORD)v8 != 1 )
      {
        do
        {
          v12 = (_BYTE *)(v11 + a3);
          v13 = (_BYTE *)(v10 + a3);
          v14 = *(_BYTE *)(v11 + a3);
          v15 = *(_BYTE *)(v10 + a3);
          v11 = (unsigned __int16)(v11 + 1);
          v10 = (unsigned __int16)(v10 - 1);
          *v12 = v15;
          *v13 = v14;
        }
        while ( v11 < v10 );
      }
    }
  }
  pstm_clear(v30);
  return 0;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);

//----- (0048331C) --------------------------------------------------------
int   pstm_invmod(int a1, int a2, int *a3, int *a4)
{
  unsigned int v5; // $a2
  int v8; // $v1
  __int16 v9; // $t0
  int v10; // $t1
  int v11; // $a0
  int v12; // $a2
  int v13; // $s0
  _DWORD *v14; // $a0
  _DWORD *v15; // $a1
  int v16; // $a3
  int v17; // $v1
  int v18; // $v0
  int result; // $v0
  int v20; // $v1
  int v21; // $a2
  int v22; // $s0
  int v23; // $t0
  int v24; // $a0
  int v25; // $a2
  _DWORD *v26; // $a0
  _DWORD *v27; // $a1
  int v28; // $a3
  int v29; // $v1
  unsigned int v30; // $v0
  int v31; // $v1
  __int16 v32; // $t1
  __int16 v33; // $a0
  int v34; // $a1
  int v35; // $s0
  int v36; // $a3
  _DWORD *v37; // $a1
  _DWORD *v38; // $a2
  int v39; // $t0
  int v40; // $v1
  int v41; // $v0
  int v42; // $v1
  __int16 v43; // $t1
  __int16 v44; // $a0
  int v45; // $a1
  int v46; // $s0
  int v47; // $a3
  _DWORD *v48; // $a1
  _DWORD *v49; // $a2
  int v50; // $t0
  int v51; // $v1
  int v52; // $v0
  unsigned int v53; // $t5
  _DWORD *v54; // $a0
  BOOL v55; // $v1
  int v56; // $v0
  __int16 v57; // $a0
  unsigned int v58; // $s5
  bool v59; // dc
  BOOL v60; // $a0
  BOOL v61; // $a0
  int v62; // $s0
  int inited; // $v0
  int v64; // $s0
  int v65; // $v1
  __int16 v66; // $a3
  int v67; // $t1
  int v68; // $a0
  int v69; // $a2
  int v70; // $s1
  _DWORD *v71; // $a0
  _DWORD *v72; // $a1
  int v73; // $t0
  int v74; // $v1
  int v75; // $v0
  int v76; // $v0
  BOOL v77; // $a0
  int v78; // $v1
  __int16 v79; // $t1
  __int16 v80; // $a0
  int v81; // $a1
  int v82; // $a3
  int v83; // $s0
  _DWORD *v84; // $a1
  _DWORD *v85; // $a2
  int v86; // $t0
  int v87; // $v1
  int v88; // $v0
  int v89; // $v0
  int v90; // $v1
  __int16 v91; // $t1
  __int16 v92; // $a0
  int v93; // $a1
  int v94; // $a3
  int v95; // $s0
  _DWORD *v96; // $a1
  _DWORD *v97; // $a2
  int v98; // $t0
  int v99; // $v1
  int v100; // $v0
  int v101; // $v0
  unsigned int v102; // $t8
  _DWORD *v103; // $a0
  BOOL v104; // $v1
  __int16 v105; // $v0
  unsigned __int16 v106; // $s0
  unsigned int v107; // $a1
  _DWORD *v108; // $a0
  int v109; // $a2
  int v110; // $a1
  __int16 v111; // $v1
  BOOL v112; // $a0
  BOOL v113; // $a0
  BOOL v114; // $a0
  int v115; // $v0
  int v116; // $a0
  signed int v117; // $a1
  int v118; // $t0
  int v119; // $a2
  int v120; // $a0
  signed int v121; // $a1
  int v122; // $t6
  int v123; // $v0
  int v124; // $a0
  signed int v125; // $a1
  int v126; // $ra
  int v127; // $v0
  int v128; // $a0
  signed int v129; // $a1
  int v130; // $s2
  int v131; // $a2
  int v132; // $a0
  signed int v133; // $a1
  int v134; // $t1
  int v135; // $v0
  int v136; // $a0
  signed int v137; // $a1
  int v138; // $v1
  int v139; // $a2
  int v140; // $a0
  signed int v141; // $a1
  int v142; // $t3
  BOOL v143; // $a2
  BOOL v144; // $a0
  int v145; // $v1
  int v146; // $a0
  int *v147; // $a0
  int *v148; // $a1
  int *v149; // $a2
  BOOL v150; // $a0
  int v151; // $a1
  int v152; // $v1
  _DWORD *v153; // $a0
  _DWORD *v154; // $a2
  int v155; // $a3
  BOOL v156; // $t8
  BOOL v157; // $a1
  BOOL v158; // $a0
  BOOL v159; // $a0
  BOOL v160; // $a0
  int v161; // $a1
  _DWORD *v162; // $a0
  _DWORD *v163; // $a2
  int v164; // $a3
  BOOL v165; // $v0
  BOOL v166; // $a1
  __int16 v167; // $a2
  int v168; // $s1
  unsigned int v169; // $t0
  int v170; // $a0
  int v171; // $s0
  unsigned int v172; // $t1
  _DWORD *v173; // $a0
  _DWORD *v174; // $a1
  int v175; // $a3
  int v176; // $v1
  int v177; // $v0
  int v178; // $v1
  int v179; // $a0
  int *v180; // $a0
  int *v181; // $a1
  int *v182; // $a2
  int v183; // $a1
  int v184; // $v1
  _DWORD *v185; // $a0
  _DWORD *v186; // $a2
  int v187; // $a3
  BOOL v188; // $s5
  BOOL v189; // $a1
  __int16 v190; // $t2
  int v191; // $v1
  int v192; // $a1
  int v193; // $v0
  int v194; // $a0
  _DWORD *v195; // $a0
  _DWORD *v196; // $a2
  int v197; // $a3
  BOOL v198; // $t7
  BOOL v199; // $a1
  int v200; // $a1
  _DWORD *v201; // $a0
  _DWORD *v202; // $a2
  int v203; // $a3
  BOOL v204; // $t7
  BOOL v205; // $a1
  int v206; // $v0
  unsigned int v207; // $t0
  int v208; // $a0
  int v209; // $s0
  unsigned int v210; // $t1
  int v211; // $a2
  _DWORD *v212; // $a0
  _DWORD *v213; // $a1
  int v214; // $a3
  int v215; // $v1
  int v216; // $v0
  int v217; // $v0
  unsigned int v218; // $t4
  unsigned int v219; // $t3
  int v220; // $a0
  int v221; // $a1
  int v222; // $s6
  int v223; // $a2
  unsigned int v224; // $s5
  unsigned int v225; // $v0
  int v226; // $a0
  int v227; // $a1
  int v228; // $t6
  int v229[2]; // [sp+18h] [-E0h] BYREF
  unsigned int v230; // [sp+20h] [-D8h]
  int v231[2]; // [sp+28h] [-D0h] BYREF
  unsigned int v232; // [sp+30h] [-C8h]
  int v233[2]; // [sp+38h] [-C0h] BYREF
  unsigned int v234; // [sp+40h] [-B8h]
  int v235[2]; // [sp+48h] [-B0h] BYREF
  unsigned int v236; // [sp+50h] [-A8h]
  int v237[2]; // [sp+58h] [-A0h] BYREF
  int v238; // [sp+60h] [-98h]
  int v239[2]; // [sp+68h] [-90h] BYREF
  unsigned int v240; // [sp+70h] [-88h]
  int v241[2]; // [sp+78h] [-80h] BYREF
  unsigned int v242; // [sp+80h] [-78h]
  int v243[2]; // [sp+88h] [-70h] BYREF
  unsigned int k; // [sp+90h] [-68h]
  int v245[2]; // [sp+98h] [-60h] BYREF
  unsigned int j; // [sp+A0h] [-58h]
  int v247[2]; // [sp+A8h] [-50h] BYREF
  unsigned int i; // [sp+B0h] [-48h]
  int v249[2]; // [sp+B8h] [-40h] BYREF
  unsigned int v250; // [sp+C0h] [-38h]
  int v251[2]; // [sp+C8h] [-30h] BYREF
  int v252; // [sp+D0h] [-28h]
  int v253[2]; // [sp+D8h] [-20h] BYREF
  unsigned int v254; // [sp+E0h] [-18h]
  int v255[2]; // [sp+E8h] [-10h] BYREF
  unsigned int v256; // [sp+F0h] [-8h]

  v5 = a3[2];
  if ( (v5 & 0xFFF) != 0 && ((*(_DWORD *)*a3 ^ 1) & 1) != 0 )
  {
    v20 = -9;
    if ( (HIBYTE(v5) & 1) == 1 )
      return v20;
    v21 = v5 & 0xFFF;
    if ( !v21 )
      return v20;
    inited = pstm_init_size(a1, v241, v21);
    v20 = -8;
    if ( inited )
      return v20;
    v64 = pstm_mod(a1, a2, (int)a3, v241);
    if ( v64 )
      goto LABEL_170;
    if ( v243 == a3 )
      goto LABEL_102;
    v65 = pstm_init_size(a1, v243, ((unsigned int)a3[2] >> 12) & 0xFFF);
    if ( v65 || a3 == v243 )
    {
LABEL_101:
      if ( v65 )
      {
LABEL_170:
        pstm_clear(v241);
        return v64;
      }
LABEL_102:
      v77 = 0;
      if ( (v242 & 0xFFF) != 0 )
        v77 = ((*(_DWORD *)v241[0] ^ 1) & 1) != 0;
      if ( v77 )
      {
        v150 = 0;
        if ( (k & 0xFFF) != 0 )
          v150 = ((*(_DWORD *)v243[0] ^ 1) & 1) != 0;
        v64 = -1;
        if ( v150 )
          goto LABEL_169;
      }
      if ( v245 == v241 )
        goto LABEL_121;
      v78 = pstm_init_size(a1, v245, (v242 >> 12) & 0xFFF);
      if ( v78 || v241 == v245 )
      {
LABEL_120:
        v64 = v78;
        if ( v78 )
        {
LABEL_169:
          pstm_clear(v243);
          goto LABEL_170;
        }
LABEL_121:
        if ( v247 == v243 )
          goto LABEL_137;
        v90 = pstm_init_size(a1, v247, (k >> 12) & 0xFFF);
        if ( v90 || v243 == v247 )
        {
LABEL_136:
          v64 = v90;
          if ( v90 )
          {
LABEL_168:
            pstm_clear(v245);
            goto LABEL_169;
          }
LABEL_137:
          v64 = pstm_init_size(a1, v249, 4u);
          if ( v64 )
          {
LABEL_167:
            pstm_clear(v247);
            goto LABEL_168;
          }
          v64 = pstm_init_size(a1, v255, 4u);
          if ( v64 )
          {
LABEL_166:
            pstm_clear(v249);
            goto LABEL_167;
          }
          v102 = (v250 & 0xFEFFF000) >> 12;
          v250 &= 0xFEFFF000;
          v103 = (_DWORD *)v249[0];
          v104 = (v102 & 0xFFF) != 0;
          v105 = 0;
          while ( 1 )
          {
            v106 = v105 + 1;
            if ( !v104 )
              break;
            ++v105;
            *v103 = 0;
            v104 = v106 < (int)(v102 & 0xFFF);
            ++v103;
          }
          *(_DWORD *)v249[0] = 1;
          v250 = v250 & 0xFFFFF000 | 1;
          v107 = ((v256 & 0xFEFFF000) >> 12) & 0xFFF;
          v256 &= 0xFEFFF000;
          v108 = (_DWORD *)v255[0];
          LOWORD(v109) = 0;
          if ( v107 )
          {
            v110 = (v256 >> 12) & 0xFFF;
            do
            {
              v109 = (unsigned __int16)(v109 + 1);
              *v108++ = 0;
            }
            while ( v109 < v110 );
          }
          *(_DWORD *)v255[0] = 1;
          v256 = v256 & 0xFFFFF000 | 1;
          v64 = pstm_init_size(a1, v251, 0x60u);
          if ( v64 )
            goto LABEL_164;
          v64 = pstm_init_size(a1, v253, 0x60u);
          if ( v64 )
          {
LABEL_165:
            pstm_clear(v251);
            goto LABEL_166;
          }
          v111 = j;
          do
          {
            while ( 1 )
            {
              v112 = 0;
              if ( (v111 & 0xFFF) != 0 )
                v112 = ((*(_DWORD *)v245[0] ^ 1) & 1) != 0;
              if ( !v112 )
                break;
              v64 = pstm_div_2((int)v245, v245);
              if ( v64 )
                goto LABEL_163;
              v113 = 0;
              if ( (v250 & 0xFFF) != 0 )
                v113 = (*(_DWORD *)v249[0] & 1) != 0;
              if ( v113 )
                goto LABEL_378;
              v114 = 0;
              if ( (v252 & 0xFFF) != 0 )
                v114 = (*(_DWORD *)v251[0] & 1) != 0;
              if ( v114 )
              {
LABEL_378:
                v64 = pstm_add(v249, v243, v249);
                if ( v64 )
                  goto LABEL_163;
                v64 = pstm_sub(v251, v241, v251);
                if ( v64 )
                  goto LABEL_163;
              }
              v64 = pstm_div_2((int)v249, v249);
              if ( v64 )
                goto LABEL_163;
              v64 = pstm_div_2((int)v251, v251);
              if ( v64 )
                goto LABEL_163;
              v111 = j;
            }
            while ( 1 )
            {
              v158 = 0;
              if ( (i & 0xFFF) != 0 )
                v158 = ((*(_DWORD *)v247[0] ^ 1) & 1) != 0;
              if ( !v158 )
                break;
              v64 = pstm_div_2((int)v247, v247);
              if ( !v64 )
              {
                v159 = 0;
                if ( (v254 & 0xFFF) != 0 )
                  v159 = (*(_DWORD *)v253[0] & 1) != 0;
                if ( !v159 )
                {
                  v160 = 0;
                  if ( (v256 & 0xFFF) != 0 )
                    v160 = (*(_DWORD *)v255[0] & 1) != 0;
                  if ( !v160 )
                    goto LABEL_377;
                }
                v64 = pstm_add(v253, v243, v253);
                if ( !v64 )
                {
                  v64 = pstm_sub(v255, v241, v255);
                  if ( !v64 )
                  {
LABEL_377:
                    v64 = pstm_div_2((int)v253, v253);
                    if ( !v64 )
                    {
                      v64 = pstm_div_2((int)v255, v255);
                      if ( !v64 )
                        continue;
                    }
                  }
                }
              }
              goto LABEL_163;
            }
            v178 = HIBYTE(j) & 1;
            if ( v178 == (HIBYTE(i) & 1) )
            {
              v183 = j & 0xFFF;
              if ( v178 == 1 )
              {
                v200 = i & 0xFFF;
                v179 = 1;
                if ( (unsigned __int16)(j & 0xFFF) >= v200 )
                {
                  v179 = -1;
                  if ( v200 >= (unsigned __int16)(j & 0xFFF) )
                  {
                    v201 = (_DWORD *)(v247[0] + 4 * v200 - 4);
                    v202 = (_DWORD *)(v245[0] + 4 * v200 - 4);
                    LOWORD(v203) = 0;
                    if ( (i & 0xFFF) != 0 )
                    {
                      while ( 1 )
                      {
                        v203 = (unsigned __int16)(v203 + 1);
                        v204 = *v202 < *v201;
                        v205 = *v201-- < *v202--;
                        if ( v204 )
                          goto LABEL_295;
                        if ( v205 )
                          break;
                        if ( v203 >= (unsigned __int16)(i & 0xFFF) )
                          goto LABEL_339;
                      }
                      v179 = -1;
                    }
                    else
                    {
LABEL_339:
                      v179 = 0;
                    }
                  }
                }
              }
              else
              {
                v184 = 1;
                if ( (unsigned __int16)(i & 0xFFF) >= v183 )
                {
                  v184 = -1;
                  if ( v183 >= (unsigned __int16)(i & 0xFFF) )
                  {
                    v185 = (_DWORD *)(v245[0] + 4 * v183 - 4);
                    v186 = (_DWORD *)(v247[0] + 4 * v183 - 4);
                    LOWORD(v187) = 0;
                    if ( (j & 0xFFF) != 0 )
                    {
                      while ( 1 )
                      {
                        v187 = (unsigned __int16)(v187 + 1);
                        v188 = *v186 < *v185;
                        v189 = *v185-- < *v186--;
                        if ( v188 )
                          break;
                        v184 = -1;
                        if ( v189 )
                          goto LABEL_324;
                        if ( v187 >= (unsigned __int16)(j & 0xFFF) )
                          goto LABEL_316;
                      }
                      v184 = 1;
                    }
                    else
                    {
LABEL_316:
                      v184 = 0;
                    }
                  }
                }
LABEL_324:
                v179 = v184;
              }
            }
            else
            {
              v179 = -1;
              if ( v178 != 1 )
LABEL_295:
                v179 = 1;
            }
            if ( v179 == -1 )
            {
              v64 = pstm_sub(v247, v245, v247);
              if ( v64 )
                goto LABEL_163;
              v64 = pstm_sub(v253, v249, v253);
              if ( v64 )
                goto LABEL_163;
              v180 = v255;
              v181 = v251;
              v182 = v255;
            }
            else
            {
              v64 = pstm_sub(v245, v247, v245);
              if ( v64 )
                goto LABEL_163;
              v64 = pstm_sub(v249, v253, v249);
              if ( v64 )
                goto LABEL_163;
              v180 = v251;
              v181 = v255;
              v182 = v251;
            }
            v64 = pstm_sub(v180, v181, v182);
            if ( v64 )
              goto LABEL_163;
            v111 = j;
          }
          while ( (j & 0xFFF) != 0 );
          if ( (i & 0xFFF) == 0 || (HIBYTE(i) & 1) == 1 || (i & 0xFFF) >= 2 )
          {
            v64 = -1;
LABEL_163:
            pstm_clear(v253);
LABEL_164:
            pstm_clear(v255);
            goto LABEL_165;
          }
          v64 = -1;
          if ( *(_DWORD *)v247[0] != 1 )
            goto LABEL_163;
          while ( 1 )
          {
            v190 = v254;
            v191 = -1;
            if ( (HIBYTE(v254) & 1) != 1 )
            {
              v191 = 1;
              if ( (v254 & 0xFFF) < 2 )
                v191 = *(_DWORD *)v253[0] != 0;
            }
            if ( v191 != -1 )
              break;
            v64 = pstm_add(v253, a3, v253);
            if ( v64 )
              goto LABEL_163;
          }
          while ( 1 )
          {
            v192 = v190 & 0xFFF;
            v193 = a3[2] & 0xFFF;
            v194 = 1;
            if ( v193 >= v192 )
            {
              v194 = -1;
              if ( v192 >= v193 )
              {
                v195 = (_DWORD *)(v253[0] + 4 * v192 - 4);
                v196 = (_DWORD *)(*a3 + 4 * v192 - 4);
                LOWORD(v197) = 0;
                if ( (v190 & 0xFFF) == 0 )
                {
LABEL_332:
                  v194 = 0;
                  goto LABEL_341;
                }
                while ( 1 )
                {
                  v197 = (unsigned __int16)(v197 + 1);
                  v198 = *v196 < *v195;
                  v199 = *v195-- < *v196--;
                  if ( v198 )
                    break;
                  if ( v199 )
                  {
                    v194 = -1;
                    goto LABEL_341;
                  }
                  if ( v197 >= (unsigned __int16)(v254 & 0xFFF) )
                    goto LABEL_332;
                }
                v194 = 1;
              }
            }
LABEL_341:
            if ( v194 == -1 )
              break;
            v64 = pstm_sub(v253, a3, v253);
            if ( v64 )
              goto LABEL_163;
            v190 = v254;
          }
          v206 = 0;
          if ( v253 != a4 )
          {
            v207 = a4[2];
            v208 = (v207 >> 12) & 0xFFF;
            if ( v208 >= (v190 & 0xFFF) )
            {
LABEL_350:
              v210 = v254;
              v211 = v254 & 0xFFF;
              v212 = (_DWORD *)v253[0];
              v213 = (_DWORD *)*a4;
              v214 = 0;
              if ( (v254 & 0xFFF) != 0 )
              {
                v215 = v254 & 0xFFF;
                do
                {
                  --v215;
                  *v213++ = *v212++;
                }
                while ( v215 );
                v214 = v211;
              }
              if ( v214 < (unsigned __int16)(v207 & 0xFFF) )
              {
                v216 = (v207 & 0xFFF) - v214;
                do
                {
                  --v216;
                  *v213++ = 0;
                }
                while ( v216 );
              }
              a4[2] = a4[2] & 0xFEFFF000 | v210 & 0xFFF | v210 & 0x1000000;
              v206 = 0;
              goto LABEL_358;
            }
            v209 = v190 & 0xFFF;
            if ( (unsigned int)v209 < 0x181 )
            {
              if ( v208 >= v209 )
              {
LABEL_349:
                v207 = a4[2];
                goto LABEL_350;
              }
              v217 = realloc(*a4, 4 * v209);
              if ( v217 )
              {
                v218 = a4[2];
                v219 = v218 & 0xFF000FFF | (v209 << 12);
                v220 = (v218 >> 12) & 0xFFF;
                v221 = (v219 >> 12) & 0xFFF;
                *a4 = v217;
                for ( a4[2] = v219; v220 < v221; *(_DWORD *)(v222 + v217) = 0 )
                {
                  v222 = 4 * v220;
                  v220 = (unsigned __int16)(v220 + 1);
                }
                goto LABEL_349;
              }
            }
            v206 = -8;
          }
LABEL_358:
          v64 = v206;
          goto LABEL_163;
        }
        v91 = i;
        v92 = k;
        v93 = (i >> 12) & 0xFFF;
        v94 = k & 0xFFF;
        if ( v93 >= v94 )
          goto LABEL_128;
        v95 = k & 0xFFF;
        if ( (unsigned int)v95 < 0x181 )
        {
          if ( v93 >= v95 )
          {
LABEL_127:
            v91 = i;
            v92 = k;
            v94 = k & 0xFFF;
LABEL_128:
            v96 = (_DWORD *)v243[0];
            v97 = (_DWORD *)v247[0];
            v98 = 0;
            if ( v94 )
            {
              v99 = v94;
              do
              {
                --v99;
                *v97++ = *v96++;
              }
              while ( v99 );
              v98 = v94;
            }
            v100 = (v91 & 0xFFF) - v98;
            if ( v98 < (v91 & 0xFFF) )
            {
              do
              {
                --v100;
                *v97++ = 0;
              }
              while ( v100 );
            }
            i = i & 0xFEFFF000 | v92 & 0xFFF | ((HIBYTE(k) & 1) << 24);
            v101 = 0;
            goto LABEL_135;
          }
          v135 = realloc(v247[0], 4 * v95);
          if ( v135 )
          {
            v136 = (i >> 12) & 0xFFF;
            v137 = ((i & 0xFF000FFF | (v95 << 12)) >> 12) & 0xFFF;
            v247[0] = v135;
            for ( i = i & 0xFF000FFF | (v95 << 12); v136 < v137; *(_DWORD *)(v138 + v135) = 0 )
            {
              v138 = 4 * v136;
              v136 = (unsigned __int16)(v136 + 1);
            }
            goto LABEL_127;
          }
        }
        v101 = -8;
LABEL_135:
        v90 = v101;
        goto LABEL_136;
      }
      v79 = j;
      v80 = v242;
      v81 = (j >> 12) & 0xFFF;
      v82 = v242 & 0xFFF;
      if ( v81 >= v82 )
        goto LABEL_112;
      v83 = v242 & 0xFFF;
      if ( (unsigned int)v83 < 0x181 )
      {
        if ( v81 >= v83 )
        {
LABEL_111:
          v79 = j;
          v80 = v242;
          v82 = v242 & 0xFFF;
LABEL_112:
          v84 = (_DWORD *)v241[0];
          v85 = (_DWORD *)v245[0];
          v86 = 0;
          if ( v82 )
          {
            v87 = v82;
            do
            {
              --v87;
              *v85++ = *v84++;
            }
            while ( v87 );
            v86 = v82;
          }
          v88 = (v79 & 0xFFF) - v86;
          if ( v86 < (v79 & 0xFFF) )
          {
            do
            {
              --v88;
              *v85++ = 0;
            }
            while ( v88 );
          }
          j = j & 0xFEFFF000 | v80 & 0xFFF | ((HIBYTE(v242) & 1) << 24);
          v89 = 0;
          goto LABEL_119;
        }
        v139 = realloc(v245[0], 4 * v83);
        if ( v139 )
        {
          v140 = (j >> 12) & 0xFFF;
          v141 = ((j & 0xFF000FFF | (v83 << 12)) >> 12) & 0xFFF;
          v245[0] = v139;
          for ( j = j & 0xFF000FFF | (v83 << 12); v140 < v141; *(_DWORD *)(v142 + v139) = 0 )
          {
            v142 = 4 * v140;
            v140 = (unsigned __int16)(v140 + 1);
          }
          goto LABEL_111;
        }
      }
      v89 = -8;
LABEL_119:
      v78 = v89;
      goto LABEL_120;
    }
    v66 = k;
    v67 = a3[2];
    v68 = (k >> 12) & 0xFFF;
    v69 = v67 & 0xFFF;
    if ( v68 >= v69 )
      goto LABEL_93;
    v70 = a3[2] & 0xFFF;
    if ( (unsigned int)v70 < 0x181 )
    {
      if ( v68 >= v70 )
      {
LABEL_92:
        v67 = a3[2];
        v66 = k;
        v69 = v67 & 0xFFF;
LABEL_93:
        v71 = (_DWORD *)*a3;
        v72 = (_DWORD *)v243[0];
        v73 = 0;
        if ( v69 )
        {
          v74 = v69;
          do
          {
            --v74;
            *v72++ = *v71++;
          }
          while ( v74 );
          v73 = v69;
        }
        v75 = (v66 & 0xFFF) - v73;
        if ( v73 < (v66 & 0xFFF) )
        {
          do
          {
            --v75;
            *v72++ = 0;
          }
          while ( v75 );
        }
        k = k & 0xFEFFF000 | v67 & 0xFFF | v67 & 0x1000000;
        v76 = 0;
        goto LABEL_100;
      }
      v131 = realloc(v243[0], 4 * v70);
      if ( v131 )
      {
        v132 = (k >> 12) & 0xFFF;
        v133 = ((k & 0xFF000FFF | (v70 << 12)) >> 12) & 0xFFF;
        v243[0] = v131;
        for ( k = k & 0xFF000FFF | (v70 << 12); v132 < v133; *(_DWORD *)(v134 + v131) = 0 )
        {
          v134 = 4 * v132;
          v132 = (unsigned __int16)(v132 + 1);
        }
        goto LABEL_92;
      }
    }
    v76 = -8;
LABEL_100:
    v65 = v76;
    goto LABEL_101;
  }
  if ( v229 == a3 )
    goto LABEL_23;
  v8 = pstm_init_size(a1, v229, (v5 >> 12) & 0xFFF);
  if ( !v8 && a3 != v229 )
  {
    v9 = v230;
    v10 = a3[2];
    v11 = (v230 >> 12) & 0xFFF;
    v12 = v10 & 0xFFF;
    if ( v11 < v12 )
    {
      v13 = a3[2] & 0xFFF;
      v8 = -8;
      if ( (unsigned int)v13 >= 0x181 )
        goto LABEL_18;
      if ( v11 >= v13 )
        goto LABEL_9;
      v119 = realloc(v229[0], 4 * v13);
      v8 = -8;
      if ( !v119 )
        goto LABEL_18;
      v120 = (v230 >> 12) & 0xFFF;
      v121 = ((v230 & 0xFF000FFF | (v13 << 12)) >> 12) & 0xFFF;
      v229[0] = v119;
      v230 = v230 & 0xFF000FFF | (v13 << 12);
      if ( v120 >= v121 )
      {
LABEL_9:
        v10 = a3[2];
        v9 = v230;
        v12 = v10 & 0xFFF;
      }
      else
      {
        do
        {
          v122 = 4 * v120;
          v120 = (unsigned __int16)(v120 + 1);
          *(_DWORD *)(v122 + v119) = 0;
        }
        while ( v120 < v121 );
        v10 = a3[2];
        v9 = v230;
        v12 = v10 & 0xFFF;
      }
    }
    v14 = (_DWORD *)*a3;
    v15 = (_DWORD *)v229[0];
    v16 = 0;
    if ( v12 )
    {
      v17 = v12;
      do
      {
        --v17;
        *v15++ = *v14++;
      }
      while ( v17 );
      v16 = v12;
    }
    if ( v16 < (v9 & 0xFFF) )
    {
      v18 = (v9 & 0xFFF) - v16;
      do
      {
        --v18;
        *v15++ = 0;
      }
      while ( v18 );
    }
    v230 = v230 & 0xFEFFF000 | v10 & 0xFFF | v10 & 0x1000000;
    v8 = 0;
  }
LABEL_18:
  result = v8;
  if ( v8 )
    return result;
LABEL_23:
  v22 = pstm_init_size(a1, v231, (*(_DWORD *)(a2 + 8) >> 12) & 0xFFF);
  if ( v22 )
    goto LABEL_80;
  if ( (int *)a2 != v231 )
  {
    v23 = *(_DWORD *)(a2 + 8);
    v24 = (v232 >> 12) & 0xFFF;
    v25 = v23 & 0xFFF;
    if ( v24 >= v25 )
    {
LABEL_26:
      v26 = *(_DWORD **)a2;
      v27 = (_DWORD *)v231[0];
      v28 = 0;
      if ( v25 )
      {
        v29 = v25;
        do
        {
          --v29;
          *v27++ = *v26++;
        }
        while ( v29 );
        v28 = v25;
      }
      v30 = (v232 & 0xFFF) - v28;
      if ( v28 < (unsigned __int16)(v232 & 0xFFF) )
      {
        do
        {
          --v30;
          *v27++ = 0;
        }
        while ( v30 );
      }
      v232 = v232 & 0xFEFFF000 | v23 & 0xFFF | v23 & 0x1000000;
      goto LABEL_33;
    }
    v62 = *(_DWORD *)(a2 + 8) & 0xFFF;
    if ( (unsigned int)v62 < 0x181 )
    {
      if ( v24 >= v62 )
      {
LABEL_83:
        v23 = *(_DWORD *)(a2 + 8);
        v25 = v23 & 0xFFF;
        goto LABEL_26;
      }
      v115 = realloc(v231[0], 4 * v62);
      if ( v115 )
      {
        v116 = (v232 >> 12) & 0xFFF;
        v117 = ((v232 & 0xFF000FFF | (v62 << 12)) >> 12) & 0xFFF;
        v231[0] = v115;
        v232 = v232 & 0xFF000FFF | (v62 << 12);
        if ( v116 < v117 )
        {
          do
          {
            v118 = 4 * v116;
            v116 = (unsigned __int16)(v116 + 1);
            *(_DWORD *)(v118 + v115) = 0;
          }
          while ( v116 < v117 );
          v23 = *(_DWORD *)(a2 + 8);
          v25 = v23 & 0xFFF;
          goto LABEL_26;
        }
        goto LABEL_83;
      }
    }
    v22 = -8;
    goto LABEL_80;
  }
LABEL_33:
  v232 &= ~0x1000000u;
  if ( v233 == v229 )
    goto LABEL_46;
  v31 = pstm_init_size(a1, v233, (v230 >> 12) & 0xFFF);
  if ( !v31 && v229 != v233 )
  {
    v32 = v234;
    v33 = v230;
    v34 = (v234 >> 12) & 0xFFF;
    v35 = v230 & 0xFFF;
    if ( v34 < v35 )
    {
      v31 = -8;
      if ( (unsigned int)v35 >= 0x181 )
        goto LABEL_45;
      if ( v34 >= v35 )
        goto LABEL_175;
      v123 = realloc(v233[0], 4 * v35);
      v31 = -8;
      if ( !v123 )
        goto LABEL_45;
      v124 = (v234 >> 12) & 0xFFF;
      v125 = ((v234 & 0xFF000FFF | (v35 << 12)) >> 12) & 0xFFF;
      v233[0] = v123;
      v234 = v234 & 0xFF000FFF | (v35 << 12);
      if ( v124 >= v125 )
      {
LABEL_175:
        v32 = v234;
        v33 = v230;
        v36 = v230 & 0xFFF;
      }
      else
      {
        do
        {
          v126 = 4 * v124;
          v124 = (unsigned __int16)(v124 + 1);
          *(_DWORD *)(v126 + v123) = 0;
        }
        while ( v124 < v125 );
        v32 = v234;
        v33 = v230;
        v36 = v230 & 0xFFF;
      }
    }
    else
    {
      v36 = v230 & 0xFFF;
    }
    v37 = (_DWORD *)v229[0];
    v38 = (_DWORD *)v233[0];
    v39 = 0;
    if ( v36 )
    {
      v40 = v36;
      do
      {
        --v40;
        *v38++ = *v37++;
      }
      while ( v40 );
      v39 = v36;
    }
    v41 = (v32 & 0xFFF) - v39;
    if ( v39 < (v32 & 0xFFF) )
    {
      do
      {
        --v41;
        *v38++ = 0;
      }
      while ( v41 );
    }
    v234 = v234 & 0xFEFFF000 | v33 & 0xFFF | ((HIBYTE(v230) & 1) << 24);
    v31 = 0;
  }
LABEL_45:
  v22 = v31;
  if ( v31 )
    goto LABEL_79;
LABEL_46:
  if ( v235 != v231 )
  {
    v42 = pstm_init_size(a1, v235, (v232 >> 12) & 0xFFF);
    if ( !v42 && v231 != v235 )
    {
      v43 = v236;
      v44 = v232;
      v45 = (v236 >> 12) & 0xFFF;
      v46 = v232 & 0xFFF;
      if ( v45 < v46 )
      {
        v42 = -8;
        if ( (unsigned int)v46 >= 0x181 )
          goto LABEL_58;
        if ( v45 >= v46 )
          goto LABEL_178;
        v127 = realloc(v235[0], 4 * v46);
        v42 = -8;
        if ( !v127 )
          goto LABEL_58;
        v128 = (v236 >> 12) & 0xFFF;
        v129 = ((v236 & 0xFF000FFF | (v46 << 12)) >> 12) & 0xFFF;
        v235[0] = v127;
        v236 = v236 & 0xFF000FFF | (v46 << 12);
        if ( v128 >= v129 )
        {
LABEL_178:
          v43 = v236;
          v44 = v232;
          v47 = v232 & 0xFFF;
        }
        else
        {
          do
          {
            v130 = 4 * v128;
            v128 = (unsigned __int16)(v128 + 1);
            *(_DWORD *)(v130 + v127) = 0;
          }
          while ( v128 < v129 );
          v43 = v236;
          v44 = v232;
          v47 = v232 & 0xFFF;
        }
      }
      else
      {
        v47 = v232 & 0xFFF;
      }
      v48 = (_DWORD *)v231[0];
      v49 = (_DWORD *)v235[0];
      v50 = 0;
      if ( v47 )
      {
        v51 = v47;
        do
        {
          --v51;
          *v49++ = *v48++;
        }
        while ( v51 );
        v50 = v47;
      }
      v52 = (v43 & 0xFFF) - v50;
      if ( v50 < (v43 & 0xFFF) )
      {
        do
        {
          --v52;
          *v49++ = 0;
        }
        while ( v52 );
      }
      v236 = v236 & 0xFEFFF000 | v44 & 0xFFF | ((HIBYTE(v232) & 1) << 24);
      v42 = 0;
    }
LABEL_58:
    v22 = v42;
    if ( v42 )
      goto LABEL_78;
  }
  v22 = pstm_init_size(a1, v237, 0x60u);
  if ( v22 )
    goto LABEL_77;
  v22 = pstm_init_size(a1, v239, 0x60u);
  if ( v22 )
    goto LABEL_76;
  v53 = (v240 & 0xFEFFF000) >> 12;
  v54 = (_DWORD *)v239[0];
  v55 = (v53 & 0xFFF) != 0;
  LOWORD(v56) = 0;
  v240 &= 0xFEFFF000;
  while ( v55 )
  {
    v56 = (unsigned __int16)(v56 + 1);
    *v54 = 0;
    v55 = v56 < (unsigned __int16)(v53 & 0xFFF);
    ++v54;
  }
  *(_DWORD *)v239[0] = 1;
  v57 = v234;
  v58 = 0;
  v240 = v240 & 0xFFFFF000 | 1;
  do
  {
    while ( 1 )
    {
      v59 = (v57 & 0xFFF) == 0;
      v60 = 0;
      if ( !v59 )
        v60 = ((*(_DWORD *)v233[0] ^ 1) & 1) != 0;
      if ( !v60 )
        break;
      v22 = pstm_div_2((int)v233, v233);
      if ( v22 )
        goto LABEL_75;
      v61 = 0;
      if ( (v238 & 0xFFF) != 0 )
        v61 = (*(_DWORD *)v237[0] & 1) != 0;
      if ( v61 )
      {
        v22 = pstm_sub(v237, v229, v237);
        if ( v22 )
          goto LABEL_75;
      }
      v22 = pstm_div_2((int)v237, v237);
      if ( v22 )
        goto LABEL_75;
      v57 = v234;
    }
    while ( 1 )
    {
      v143 = 0;
      if ( (v236 & 0xFFF) != 0 )
        v143 = ((*(_DWORD *)v235[0] ^ 1) & 1) != 0;
      if ( !v143 )
        break;
      v22 = pstm_div_2((int)v235, v235);
      if ( !v22 )
      {
        v144 = 0;
        if ( (v240 & 0xFFF) != 0 )
          v144 = (*(_DWORD *)v239[0] & 1) != 0;
        if ( !v144 || (v22 = pstm_sub(v239, v229, v239)) == 0 )
        {
          v22 = pstm_div_2((int)v239, v239);
          if ( !v22 )
            continue;
        }
      }
      goto LABEL_75;
    }
    v145 = HIBYTE(v234) & 1;
    if ( v145 == (HIBYTE(v236) & 1) )
    {
      v151 = v234 & 0xFFF;
      if ( v145 == 1 )
      {
        v161 = v236 & 0xFFF;
        v146 = 1;
        if ( (unsigned __int16)(v234 & 0xFFF) >= v161 )
        {
          v146 = -1;
          if ( v161 >= (unsigned __int16)(v234 & 0xFFF) )
          {
            v162 = (_DWORD *)(v235[0] + 4 * v161 - 4);
            v163 = (_DWORD *)(v233[0] + 4 * v161 - 4);
            LOWORD(v164) = 0;
            if ( (v236 & 0xFFF) != 0 )
            {
              while ( 1 )
              {
                v164 = (unsigned __int16)(v164 + 1);
                v165 = *v163 < *v162;
                v166 = *v162-- < *v163--;
                if ( v165 )
                {
                  v146 = 1;
                  goto LABEL_223;
                }
                if ( v166 )
                  break;
                if ( v164 >= (unsigned __int16)(v236 & 0xFFF) )
                  goto LABEL_366;
              }
              v146 = -1;
            }
            else
            {
LABEL_366:
              v146 = 0;
            }
          }
        }
      }
      else
      {
        v152 = 1;
        if ( (unsigned __int16)(v236 & 0xFFF) < v151 )
          goto LABEL_247;
        v152 = -1;
        if ( v151 < (unsigned __int16)(v236 & 0xFFF) )
          goto LABEL_247;
        v153 = (_DWORD *)(v233[0] + 4 * v151 - 4);
        v154 = (_DWORD *)(v235[0] + 4 * v151 - 4);
        LOWORD(v155) = 0;
        if ( (v234 & 0xFFF) == 0 )
        {
LABEL_246:
          v152 = 0;
LABEL_247:
          v146 = v152;
          goto LABEL_223;
        }
        while ( 1 )
        {
          v155 = (unsigned __int16)(v155 + 1);
          v156 = *v154 < *v153;
          v157 = *v153-- < *v154--;
          if ( v156 )
            break;
          if ( v157 )
          {
            v146 = -1;
            goto LABEL_223;
          }
          if ( v155 >= (unsigned __int16)(v234 & 0xFFF) )
            goto LABEL_246;
        }
        v146 = 1;
      }
    }
    else
    {
      v146 = -1;
      if ( v145 != 1 )
        v146 = 1;
    }
LABEL_223:
    if ( v146 == -1 )
    {
      v22 = pstm_sub(v235, v233, v235);
      if ( v22 )
        goto LABEL_75;
      v147 = v239;
      v148 = v237;
      v149 = v239;
    }
    else
    {
      v22 = pstm_sub(v233, v235, v233);
      if ( v22 )
        goto LABEL_75;
      v147 = v237;
      v148 = v239;
      v149 = v237;
    }
    v22 = pstm_sub(v147, v148, v149);
    if ( v22 )
      goto LABEL_75;
    v59 = v58 >= 0x1001;
    v58 = (unsigned __int16)(v58 + 1);
    if ( v59 )
    {
      v22 = -9;
      goto LABEL_75;
    }
    v57 = v234;
  }
  while ( (v234 & 0xFFF) != 0 );
  if ( (v236 & 0xFFF) == 0 || (HIBYTE(v236) & 1) == 1 || (v236 & 0xFFF) >= 2 )
  {
    v22 = -1;
    goto LABEL_75;
  }
  v22 = -1;
  if ( *(_DWORD *)v235[0] == 1 )
  {
    v167 = v240;
    v168 = *(_BYTE *)(a2 + 11) & 1;
    if ( (HIBYTE(v240) & 1) != 1 )
    {
LABEL_277:
      v22 = 0;
      if ( v239 != a4 )
      {
        v169 = a4[2];
        v170 = (v169 >> 12) & 0xFFF;
        if ( v170 < (v167 & 0xFFF) )
        {
          v171 = v167 & 0xFFF;
          if ( (unsigned int)v171 >= 0x181 )
            goto LABEL_371;
          if ( v170 >= v171 )
            goto LABEL_281;
          v223 = realloc(*a4, 4 * v171);
          if ( !v223 )
          {
LABEL_371:
            v22 = -8;
            goto LABEL_75;
          }
          v224 = a4[2];
          v225 = v224 & 0xFF000FFF | (v171 << 12);
          v226 = (v224 >> 12) & 0xFFF;
          v227 = (v225 >> 12) & 0xFFF;
          *a4 = v223;
          for ( a4[2] = v225; v226 < v227; *(_DWORD *)(v228 + v223) = 0 )
          {
            v228 = 4 * v226;
            v226 = (unsigned __int16)(v226 + 1);
          }
LABEL_281:
          v169 = a4[2];
        }
        v172 = v240;
        v173 = (_DWORD *)v239[0];
        v174 = (_DWORD *)*a4;
        v175 = 0;
        if ( (v240 & 0xFFF) != 0 )
        {
          v176 = v240 & 0xFFF;
          do
          {
            --v176;
            *v174++ = *v173++;
          }
          while ( v176 );
          v175 = v172 & 0xFFF;
        }
        v177 = (v169 & 0xFFF) - v175;
        if ( v175 < (unsigned __int16)(v169 & 0xFFF) )
        {
          do
          {
            --v177;
            *v174++ = 0;
          }
          while ( v177 );
        }
        a4[2] = a4[2] & 0xFEFFF000 | v172 & 0xFFF | v172 & 0x1000000;
        v22 = 0;
      }
      a4[2] = a4[2] & 0xFEFFFFFF | (v168 << 24);
      goto LABEL_75;
    }
    while ( 1 )
    {
      v22 = pstm_add(v239, a3, v239);
      if ( v22 )
        break;
      v167 = v240;
      if ( (HIBYTE(v240) & 1) != 1 )
        goto LABEL_277;
    }
  }
LABEL_75:
  pstm_clear(v239);
LABEL_76:
  pstm_clear(v237);
LABEL_77:
  pstm_clear(v235);
LABEL_78:
  pstm_clear(v233);
LABEL_79:
  pstm_clear(v231);
LABEL_80:
  pstm_clear(v229);
  return v22;
}
// 4E9FD0: using guessed type int   realloc(_DWORD, _DWORD);

//----- (00485268) --------------------------------------------------------
int   pstm_montgomery_reduce(int a1, int *a2, int *a3, int a4, _DWORD *a5, unsigned __int16 a6)
{
  int v8; // $s1
  int v10; // $v1
  _DWORD *v11; // $s2
  int v12; // $v0
  int v13; // $t7
  int v14; // $a1
  int v15; // $t6
  int v16; // $t5
  _DWORD *v17; // $s0
  BOOL v18; // $s0
  unsigned int *v19; // $t8
  _DWORD *v20; // $t1
  int v21; // $t3
  unsigned int v22; // $a3
  _DWORD *v23; // $a0
  int v24; // $a1
  unsigned int *v25; // $t0
  int v26; // $a2
  unsigned int v27; // $v1
  unsigned __int64 v28; // $t4
  unsigned int v29; // $t2
  _DWORD *v30; // $a2
  _DWORD *v31; // $a1
  int v32; // $v1
  int v33; // $v1
  int v34; // $v0
  int v35; // $s0

  v8 = a3[2] & 0xFFF;
  v10 = -9;
  if ( (int)(((unsigned int)a2[2] >> 12) & 0xFFF) < v8 )
    return v10;
  if ( a5 && (v11 = a5, a6 >= (unsigned int)(8 * v8 + 4)) )
  {
    memset(a5, 0, a6);
    v13 = a2[2] & 0xFFF;
    v14 = 0;
    if ( v13 )
    {
LABEL_6:
      v15 = *a2;
      do
      {
        v16 = v14;
        v17 = (_DWORD *)(4 * v14++ + v15);
        v11[v16] = *v17;
      }
      while ( v14 < v13 );
      v18 = v8 > 0;
      goto LABEL_9;
    }
  }
  else
  {
    v12 = malloc(8 * v8 + 4);
    v11 = (_DWORD *)v12;
    v10 = -8;
    if ( !v12 )
      return v10;
    memset(v12, 0, 8 * v8 + 4);
    v13 = a2[2] & 0xFFF;
    v14 = 0;
    if ( v13 )
      goto LABEL_6;
  }
  v15 = *a2;
  v18 = v8 > 0;
LABEL_9:
  if ( v18 )
  {
    v19 = (unsigned int *)*a3;
    v20 = v11;
    v21 = v8;
    do
    {
      v22 = 0;
      v23 = v20;
      v24 = *v20 * a4;
      v25 = v19;
      v26 = v8;
      do
      {
        --v26;
        v27 = *v25++;
        v28 = (unsigned int)v24 * (unsigned __int64)v27;
        LODWORD(v28) = v28 + v22;
        HIDWORD(v28) += (unsigned int)v28 < v22;
        LODWORD(v28) = v28 + *v23;
        v22 = HIDWORD(v28) + ((unsigned int)v28 < *v23);
        *v23++ = v28;
      }
      while ( v26 );
      for ( ; v22; ++v23 )
      {
        v29 = *v23 + v22;
        *v23 = v29;
        v22 = v29 < v22;
      }
      --v21;
      ++v20;
    }
    while ( v21 );
  }
  v30 = &v11[v8];
  v31 = (_DWORD *)v15;
  v32 = v8 + 1;
  do
  {
    --v32;
    *v31++ = *v30++;
  }
  while ( v32 );
  v33 = v8 + 1;
  v34 = v13 - v33;
  if ( v33 < v13 )
  {
    do
    {
      --v34;
      *v31++ = 0;
    }
    while ( v34 );
  }
  a2[2] = a2[2] & 0xFFFFF000 | ((_WORD)v8 + 1) & 0xFFF;
  pstm_clamp(a2);
  v35 = 0;
  if ( pstm_cmp_mag(a2, a3) != -1 && pstm_sub_s(a2, a3, a2) )
    v35 = -8;
  v10 = v35;
  if ( v11 && v11 != a5 )
  {
    free2(v11);
    return v35;
  }
  return v10;
}
// 485380: conditional instruction was optimized away because $s0.4==1
// 485418: conditional instruction was optimized away because $s1.4<1000u
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (00485550) --------------------------------------------------------
int   pstm_mul_comba(int a1, int *a2, int *a3, int *a4, int a5, unsigned __int16 a6)
{
  int v6; // $t1
  int v8; // $t0
  int v11; // $s3
  __int64 v12; // $s0
  int v13; // $a2
  int v14; // $s5
  int v15; // $t2
  int v16; // $s2
  int v17; // $t7
  int v18; // $t6
  int v19; // $t3
  unsigned int *v20; // $t1
  int v21; // $v1
  int v22; // $a1
  unsigned int *v23; // $a3
  unsigned int *v24; // $a2
  unsigned int v25; // $a0
  unsigned int v26; // $t0
  unsigned __int64 v27; // $t4
  int v28; // $t6
  int v29; // $a3
  _DWORD *v30; // $a2
  int v31; // $a1
  _DWORD *v32; // $a0
  int v33; // $v1
  int v34; // $v0
  int v35; // $v1
  int v37; // [sp+18h] [-8h]

  v6 = a2[2];
  v8 = a3[2];
  v11 = (v6 & 0xFFF) + (v8 & 0xFFF);
  v12 = 0;
  v37 = 0;
  if ( (int)(((unsigned int)a4[2] >> 12) & 0xFFF) >= v11 || !pstm_grow(a4, (v6 & 0xFFF) + (v8 & 0xFFF)) )
  {
    if ( a5 )
    {
      v13 = a6;
      if ( a6 >= (unsigned int)(4 * v11) )
      {
        v14 = a5;
        goto LABEL_5;
      }
      v14 = malloc(4 * v11);
      v37 = 1;
    }
    else
    {
      v14 = malloc(4 * v11);
    }
    v35 = -8;
    if ( !v14 )
      return v35;
    v13 = 4 * v11;
LABEL_5:
    memset(v14, 0, v13);
    v15 = 0;
    if ( v11 > 0 )
    {
      v16 = *a2;
      v17 = *a3;
      v18 = a3[2] & 0xFFF;
      v19 = a2[2] & 0xFFF;
      v20 = (unsigned int *)v14;
      do
      {
        v21 = v18 - 1;
        if ( v15 < v18 - 1 )
          v21 = v15;
        v22 = v21 + 1;
        v23 = (unsigned int *)(v16 + 4 * (v15 - v21));
        v24 = (unsigned int *)(v17 + 4 * v21);
        if ( v19 - (v15 - v21) < v21 + 1 )
          v22 = v19 - (v15 - v21);
        v25 = v12;
        v12 = HIDWORD(v12);
        if ( v22 > 0 )
        {
          do
          {
            --v22;
            v26 = *v23++;
            v27 = v26 * (unsigned __int64)*v24;
            v25 += v27;
            LODWORD(v27) = v25 < (unsigned int)v27;
            LODWORD(v12) = v12 + HIDWORD(v27);
            HIDWORD(v27) = (unsigned int)v12 < HIDWORD(v27);
            v12 += v27;
            --v24;
          }
          while ( v22 );
        }
        ++v15;
        *v20++ = v25;
      }
      while ( v15 < v11 );
    }
    v28 = a4[2];
    a4[2] = v28 & 0xFFFFF000 | v11 & 0xFFF;
    a4[2] = v28 & 0xFEFFF000
          | v11 & 0xFFF
          | (((*((unsigned __int8 *)a3 + 11) ^ *((unsigned __int8 *)a2 + 11)) & 1) << 24);
    v29 = v28 & 0xFFF;
    v30 = (_DWORD *)*a4;
    v31 = 0;
    if ( v11 > 0 )
    {
      v32 = (_DWORD *)v14;
      v33 = v11;
      do
      {
        --v33;
        *v30++ = *v32++;
      }
      while ( v33 );
      v31 = v11;
    }
    v34 = v29 - v31;
    if ( v31 < v29 )
    {
      do
      {
        --v34;
        *v30++ = 0;
      }
      while ( v34 );
    }
    pstm_clamp(a4);
    if ( a5 && v37 != 1 )
      return 0;
    free2(v14);
    return 0;
  }
  return -8;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (00485888) --------------------------------------------------------
int   pstm_sqr_comba(int a1, int *a2, int *a3, int a4, unsigned __int16 a5)
{
  int v6; // $t0
  int v8; // $s3
  __int64 v10; // $s0
  int v11; // $s5
  int v12; // $a2
  int v13; // $t8
  int v14; // $a1
  int v15; // $s2
  unsigned int *v16; // $t9
  int v17; // $a2
  int v18; // $t1
  int v19; // $t2
  unsigned int *v20; // $t0
  unsigned int *v21; // $a3
  int v22; // $s6
  unsigned int v23; // $a0
  int v24; // $a2
  unsigned int v25; // $v1
  unsigned __int64 v26; // $t4
  unsigned int v27; // $a0
  BOOL v28; // $t7
  BOOL v29; // $t7
  unsigned __int64 v30; // kr00_8
  __int64 v31; // $t4
  int v32; // $s0
  int v33; // $a2
  _DWORD *v34; // $a1
  int v35; // $v1
  _DWORD *v36; // $a0
  int v37; // $v1
  int v38; // $v0
  int v39; // $v1
  int v41; // [sp+18h] [-8h]

  v6 = a2[2];
  v8 = 2 * (v6 & 0xFFF);
  v41 = 0;
  v10 = 0;
  if ( (int)(((unsigned int)a3[2] >> 12) & 0xFFF) >= v8 || !pstm_grow(a3, 2 * (v6 & 0xFFF)) )
  {
    if ( a4 )
    {
      v11 = a4;
      if ( a5 >= (unsigned int)(4 * v8) )
      {
        v12 = a5;
        goto LABEL_5;
      }
      v11 = malloc(4 * v8);
      v41 = 1;
    }
    else
    {
      v11 = malloc(4 * v8);
    }
    v39 = -8;
    if ( !v11 )
      return v39;
    v12 = 4 * v8;
LABEL_5:
    memset(v11, 0, v12);
    v13 = 0;
    if ( v8 > 0 )
    {
      v14 = *a2;
      v15 = a2[2] & 0xFFF;
      v16 = (unsigned int *)v11;
      do
      {
        v17 = v15 - 1;
        v18 = v13 - (v15 - 1);
        if ( v13 < v15 - 1 )
        {
          v17 = v13;
          v18 = 0;
        }
        v19 = v17 + 1;
        v20 = (unsigned int *)(v14 + 4 * v18);
        v21 = (unsigned int *)(v14 + 4 * v17);
        if ( v15 - v18 < v17 + 1 )
          v19 = v15 - v18;
        v22 = v17 - v18 + 1;
        v23 = v10;
        if ( v22 >> 1 < v19 )
          v19 = v22 >> 1;
        v10 = HIDWORD(v10);
        if ( v19 > 0 )
        {
          v24 = v19;
          do
          {
            --v24;
            v25 = *v20++;
            v26 = v25 * (unsigned __int64)*v21;
            v27 = v23 + v26;
            LODWORD(v10) = v10 + HIDWORD(v26);
            v28 = (unsigned int)v10 < HIDWORD(v26);
            LODWORD(v10) = v10 + (v27 < (unsigned int)v26);
            HIDWORD(v10) += v28 + (__PAIR64__(v10, v27) < (unsigned int)v26);
            v23 = v27 + v26;
            LODWORD(v10) = v10 + HIDWORD(v26);
            v29 = (unsigned int)v10 < HIDWORD(v26);
            LODWORD(v10) = v10 + (v23 < (unsigned int)v26);
            HIDWORD(v10) += v29 + (__PAIR64__(v10, v23) < (unsigned int)v26);
            --v21;
          }
          while ( v24 );
        }
        if ( ((v13 ^ 1) & 1) != 0 )
        {
          v30 = *(unsigned int *)(4 * (v13 >> 1) + v14) * (unsigned __int64)*(unsigned int *)(4 * (v13 >> 1) + v14);
          v23 += v30;
          LODWORD(v31) = v23 < (unsigned int)v30;
          LODWORD(v10) = v10 + HIDWORD(v30);
          HIDWORD(v31) = (unsigned int)v10 < HIDWORD(v30);
          v10 += v31;
        }
        ++v13;
        *v16++ = v23;
      }
      while ( v13 < v8 );
    }
    v32 = a3[2];
    a3[2] = v32 & 0xFFFFF000 | v8 & 0xFFF;
    v33 = v32 & 0xFFF;
    v34 = (_DWORD *)*a3;
    v35 = 0;
    if ( v8 > 0 )
    {
      v36 = (_DWORD *)v11;
      v37 = v8;
      do
      {
        --v37;
        *v34++ = *v36++;
      }
      while ( v37 );
      v35 = v8;
    }
    v38 = v33 - v35;
    if ( v35 < v33 )
    {
      do
      {
        --v38;
        *v34++ = 0;
      }
      while ( v38 );
    }
    pstm_clamp(a3);
    if ( a4 && v41 != 1 )
      return 0;
    free2(v11);
    return 0;
  }
  return -8;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (00485BFC) --------------------------------------------------------
int psOpenPrng()
{
  int result; // $v0

  psCreateMutex((int)&unk_4E9E80, 0);
  result = 5111808;
  word_4E686C = 1;
  dword_4E9E98 = 0;
  return result;
}
// 4E686C: using guessed type __int16 word_4E686C;
// 4E9E98: using guessed type int dword_4E9E98;

//----- (00485C4C) --------------------------------------------------------
int psClosePrng()
{
  return psDestroyMutex();
}

//----- (00485C6C) --------------------------------------------------------
int   psGetPrngLocked(int a1, unsigned __int16 a2)
{
  int v3; // $s0
  int result; // $v0
  int Entropy; // $s0

  v3 = a2;
  result = -1;
  if ( word_4E686C )
  {
    psLockMutex();
    dword_4E9E98 += v3;
    Entropy = psGetEntropy(a1, v3);
    psUnlockMutex();
    return Entropy;
  }
  return result;
}
// 4E686C: using guessed type __int16 word_4E686C;
// 4E9E98: using guessed type int dword_4E9E98;

//----- (00485D2C) --------------------------------------------------------
int   psEccInitKey(int a1, _DWORD *a2, int a3)
{
  int result; // $v0

  result = -8;
  if ( a2 )
  {
    memset(a2, 0, 64);
    a2[13] = a3;
    a2[12] = a1;
    a2[14] = a1;
    return 0;
  }
  return result;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (00485DA8) --------------------------------------------------------
void   psEccClearKey(int a1)
{
  if ( !a1 )
  {
    psTraceStr("psAssert %s", (int)"pubkey/ecc.c");
    psTraceInt(":%d ", 255);
    psError((int)"key");
  }
  pstm_clear((_DWORD *)a1);
  pstm_clear_multi((_DWORD *)(a1 + 12), (_DWORD *)(a1 + 24), (_DWORD *)(a1 + 36), 0, 0, 0, 0, 0);
  *(_BYTE *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 48) = 0;
}

//----- (00485E8C) --------------------------------------------------------
int   psEccNewKey(int a1, int *a2, int a3)
{
  int v6; // $s0
  int result; // $v0

  v6 = malloc(64);
  result = -8;
  if ( v6 )
  {
    *(_BYTE *)(v6 + 60) = 0;
    memset(v6, 0, 64);
    *a2 = v6;
    *(_DWORD *)(v6 + 48) = a1;
    *(_DWORD *)(v6 + 52) = a3;
    *(_DWORD *)(v6 + 56) = a1;
    return 0;
  }
  return result;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (00485F28) --------------------------------------------------------
int   psEccCopyKey(int a1, int a2)
{
  int v3; // $a0
  int v5; // $v0
  char v6; // $v1
  int inited; // $s0
  int result; // $v0

  v3 = *(_DWORD *)(a1 + 56);
  if ( v3 )
  {
    *(_DWORD *)(a1 + 48) = v3;
  }
  else
  {
    v3 = *(_DWORD *)(a2 + 56);
    v5 = *(_DWORD *)(a2 + 48);
    *(_DWORD *)(a1 + 56) = v3;
    *(_DWORD *)(a1 + 48) = v5;
  }
  v6 = *(_BYTE *)(a2 + 60);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  *(_BYTE *)(a1 + 60) = v6;
  inited = pstm_init_copy(v3, (int *)(a1 + 12), a2 + 12, 0);
  if ( !inited )
  {
    inited = pstm_init_copy(*(_DWORD *)(a1 + 56), (int *)(a1 + 24), a2 + 24, 0);
    if ( !inited )
    {
      inited = pstm_init_copy(*(_DWORD *)(a1 + 56), (int *)(a1 + 36), a2 + 36, 0);
      if ( !inited )
      {
        result = 0;
        if ( *(_BYTE *)(a1 + 60) != 2 )
          return result;
        inited = pstm_init_copy(*(_DWORD *)(a1 + 56), (int *)a1, a2, 0);
      }
    }
  }
  result = inited;
  if ( inited < 0 )
  {
    if ( !a2 )
    {
      psTraceStr("psAssert %s", (int)"pubkey/ecc.c");
      psTraceInt(":%d ", 255);
      psError((int)"key");
    }
    pstm_clear((_DWORD *)a2);
    pstm_clear_multi((_DWORD *)(a2 + 12), (_DWORD *)(a2 + 24), (_DWORD *)(a2 + 36), 0, 0, 0, 0, 0);
    result = inited;
    *(_BYTE *)(a2 + 60) = 0;
    *(_DWORD *)(a2 + 52) = 0;
    *(_DWORD *)(a2 + 56) = 0;
    *(_DWORD *)(a2 + 48) = 0;
  }
  return result;
}

//----- (00486124) --------------------------------------------------------
int   psEccDeleteKey(int *a1)
{
  int v2; // $s0
  int result; // $v0

  v2 = *a1;
  if ( !*a1 )
  {
    psTraceStr("psAssert %s", (int)"pubkey/ecc.c");
    psTraceInt(":%d ", 255);
    psError((int)"key");
  }
  pstm_clear((_DWORD *)v2);
  pstm_clear_multi((_DWORD *)(v2 + 12), (_DWORD *)(v2 + 24), (_DWORD *)(v2 + 36), 0, 0, 0, 0, 0);
  *(_DWORD *)(v2 + 52) = 0;
  *(_DWORD *)(v2 + 56) = 0;
  *(_DWORD *)(v2 + 48) = 0;
  *(_BYTE *)(v2 + 60) = 0;
  result = free2(v2);
  *a1 = 0;
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00486228) --------------------------------------------------------
int   psEccSize(int a1)
{
  _BYTE *v1; // $a0

  if ( a1 && (v1 = *(_BYTE **)(a1 + 52)) != 0 )
    return (unsigned __int8)(2 * *v1);
  else
    return 0;
}

//----- (0048625C) --------------------------------------------------------
int   getEccParamByOid(int a1, char **a2)
{
  int result; // $v0
  char *v3; // $v1

  result = -1;
  if ( byte_4E6870 )
  {
    v3 = &byte_4E6870;
    while ( 1 )
    {
      result = 0;
      if ( *((_DWORD *)v3 + 2) == a1 )
        break;
      v3 += 40;
      result = -1;
      if ( !*v3 )
        goto LABEL_5;
    }
    *a2 = v3;
  }
  else
  {
LABEL_5:
    *a2 = 0;
  }
  return result;
}
// 4E6870: using guessed type char byte_4E6870;

//----- (004862B8) --------------------------------------------------------
int   getEccParamById(unsigned __int16 a1, char **a2)
{
  int result; // $v0
  char *v3; // $v1
  char *v4; // $a2
  int v5; // $a3

  if ( a1 )
  {
    if ( byte_4E6870 )
    {
      v3 = &byte_4E6870;
      v4 = &byte_4E6870;
      while ( 1 )
      {
        v5 = *((unsigned __int16 *)v3 + 1);
        v3 += 40;
        if ( v5 == a1 )
          break;
        v4 += 40;
        if ( !*v3 )
          goto LABEL_7;
      }
      result = 0;
      *a2 = v4;
    }
    else
    {
LABEL_7:
      result = -1;
      *a2 = 0;
    }
  }
  else
  {
    *a2 = &byte_4E6870;
    return 0;
  }
  return result;
}
// 4E6870: using guessed type char byte_4E6870;

//----- (00486348) --------------------------------------------------------
int   psGetEccCurveIdList(int a1, _BYTE *a2)
{
  int result; // $v0
  int v4; // $t2
  int v5; // $t1
  int v6; // $a0
  int v7; // $t3
  _BYTE *v8; // $a2
  _BYTE *v9; // $t0
  __int16 v10; // $t6

  result = (unsigned __int8)byte_4E6870[0];
  v4 = 0;
  v5 = 0;
  if ( byte_4E6870[0] )
  {
    v6 = 0;
    do
    {
      result = v5 + 1;
      v7 = v6 + v5;
      v5 = (unsigned __int16)(v5 + 1);
      v8 = (_BYTE *)(v4 + a1);
      v9 = (_BYTE *)((unsigned __int16)(v4 + 1) + a1);
      if ( v4 < (unsigned __int8)*a2 - 2 )
      {
        v10 = *(_WORD *)&byte_4E6870[8 * v7 + 2];
        v4 = (unsigned __int16)(v4 + 2);
        *v8 = HIBYTE(v10);
        *v9 = v10;
      }
      v6 = 4 * v5;
    }
    while ( byte_4E6870[40 * v5] );
  }
  *a2 = v4;
  return result;
}

//----- (004863E8) --------------------------------------------------------
int   userSuppliedEccList(_BYTE *a1, _BYTE *a2, unsigned int a3)
{
  int v4; // $a3
  char *v5; // $v1
  unsigned int v6; // $a0
  char *v7; // $v1
  unsigned int v8; // $t7
  char *v9; // $v1
  unsigned int v10; // $t2
  char *v11; // $v1
  unsigned int v12; // $a0
  char *v13; // $v1
  unsigned int v14; // $t8
  char *v15; // $v1
  unsigned int v16; // $t3
  char *v17; // $v1
  int result; // $v0
  int v19; // $t5
  char *v20; // $v1
  char *v21; // $v1
  unsigned int v22; // $t5
  unsigned int v23; // $t4

  v4 = 0;
  if ( ((a3 >> 4) & 1) != 0 && byte_4E6870[0] )
  {
    v5 = byte_4E6870;
    while ( *((_WORD *)v5 + 1) != 25 )
    {
      v5 += 40;
      if ( !*v5 )
        goto LABEL_6;
    }
    if ( (unsigned __int8)*a2 - 2 > 0 )
    {
      v4 = 2;
      *a1 = HIBYTE(*((_WORD *)v5 + 1));
      a1[1] = *((_WORD *)v5 + 1);
    }
  }
LABEL_6:
  v6 = a3 >> 3;
  if ( ((a3 >> 19) & 1) != 0 )
  {
    if ( byte_4E6870[0] )
    {
      v7 = byte_4E6870;
      while ( *((_WORD *)v7 + 1) != 28 )
      {
        v7 += 40;
        if ( !*v7 )
          goto LABEL_11;
      }
      if ( v4 < (unsigned __int8)*a2 - 2 )
      {
        a1[v4] = HIBYTE(*((_WORD *)v7 + 1));
        a1[(unsigned __int8)(v4 + 1)] = *((_WORD *)v7 + 1);
        v4 = (unsigned __int8)(v4 + 2);
      }
    }
LABEL_11:
    v6 = a3 >> 3;
  }
  v8 = a3 >> 18;
  if ( (v6 & 1) != 0 && byte_4E6870[0] )
  {
    v9 = byte_4E6870;
    while ( *((_WORD *)v9 + 1) != 24 )
    {
      v9 += 40;
      if ( !*v9 )
        goto LABEL_17;
    }
    if ( v4 < (unsigned __int8)*a2 - 2 )
    {
      a1[v4] = HIBYTE(*((_WORD *)v9 + 1));
      a1[(unsigned __int8)(v4 + 1)] = *((_WORD *)v9 + 1);
      v4 = (unsigned __int8)(v4 + 2);
    }
LABEL_17:
    v8 = a3 >> 18;
  }
  v10 = a3 >> 2;
  if ( (v8 & 1) != 0 && byte_4E6870[0] )
  {
    v11 = byte_4E6870;
    while ( *((_WORD *)v11 + 1) != 27 )
    {
      v11 += 40;
      if ( !*v11 )
        goto LABEL_23;
    }
    if ( v4 < (unsigned __int8)*a2 - 2 )
    {
      a1[v4] = HIBYTE(*((_WORD *)v11 + 1));
      a1[(unsigned __int8)(v4 + 1)] = *((_WORD *)v11 + 1);
      v4 = (unsigned __int8)(v4 + 2);
    }
LABEL_23:
    v10 = a3 >> 2;
  }
  v12 = a3 >> 17;
  if ( (v10 & 1) != 0 )
  {
    if ( byte_4E6870[0] )
    {
      v13 = byte_4E6870;
      while ( *((_WORD *)v13 + 1) != 23 )
      {
        v13 += 40;
        if ( !*v13 )
          goto LABEL_29;
      }
      if ( v4 < (unsigned __int8)*a2 - 2 )
      {
        a1[v4] = HIBYTE(*((_WORD *)v13 + 1));
        a1[(unsigned __int8)(v4 + 1)] = *((_WORD *)v13 + 1);
        v4 = (unsigned __int8)(v4 + 2);
      }
    }
LABEL_29:
    v12 = a3 >> 17;
  }
  v14 = a3 >> 1;
  if ( (v12 & 1) != 0 && byte_4E6870[0] )
  {
    v15 = byte_4E6870;
    while ( *((_WORD *)v15 + 1) != 26 )
    {
      v15 += 40;
      if ( !*v15 )
        goto LABEL_35;
    }
    if ( v4 < (unsigned __int8)*a2 - 2 )
    {
      a1[v4] = HIBYTE(*((_WORD *)v15 + 1));
      a1[(unsigned __int8)(v4 + 1)] = *((_WORD *)v15 + 1);
      v4 = (unsigned __int8)(v4 + 2);
    }
LABEL_35:
    v14 = a3 >> 1;
  }
  v16 = HIWORD(a3);
  if ( (v14 & 1) != 0 && byte_4E6870[0] )
  {
    v17 = byte_4E6870;
    while ( *((_WORD *)v17 + 1) != 21 )
    {
      v17 += 40;
      if ( !*v17 )
        goto LABEL_41;
    }
    if ( v4 < (unsigned __int8)*a2 - 2 )
    {
      a1[v4] = HIBYTE(*((_WORD *)v17 + 1));
      a1[(unsigned __int8)(v4 + 1)] = *((_WORD *)v17 + 1);
      v4 = (unsigned __int8)(v4 + 2);
    }
LABEL_41:
    v16 = HIWORD(a3);
  }
  result = v16 & 1;
  v19 = a3 & 1;
  if ( (v16 & 1) != 0 && byte_4E6870[0] )
  {
    v20 = byte_4E6870;
    while ( *((_WORD *)v20 + 1) != 255 )
    {
      v20 += 40;
      if ( !*v20 )
        goto LABEL_47;
    }
    if ( v4 < (unsigned __int8)*a2 - 2 )
    {
      v23 = *((unsigned __int16 *)v20 + 1);
      result = v23 >> 8;
      a1[v4] = BYTE1(v23);
      a1[(unsigned __int8)(v4 + 1)] = *((_WORD *)v20 + 1);
      v4 = (unsigned __int8)(v4 + 2);
    }
LABEL_47:
    v19 = a3 & 1;
  }
  if ( !v19 || !byte_4E6870[0] )
    goto LABEL_53;
  v21 = byte_4E6870;
  while ( *((_WORD *)v21 + 1) != 19 )
  {
    v21 += 40;
    if ( !*v21 )
      goto LABEL_53;
  }
  if ( v4 < (unsigned __int8)*a2 - 2 )
  {
    v22 = *((unsigned __int16 *)v21 + 1);
    result = v22 >> 8;
    a1[v4] = BYTE1(v22);
    a1[(unsigned __int8)(v4 + 1)] = *((_WORD *)v21 + 1);
    *a2 = v4 + 2;
  }
  else
  {
LABEL_53:
    *a2 = v4;
  }
  return result;
}

//----- (00486954) --------------------------------------------------------
int compiledInEcFlags()
{
  return 31;
}

//----- (0048695C) --------------------------------------------------------
int *  sub_48695C(int a1, int a2)
{
  int v3; // $s1
  int *v4; // $s0
  int v5; // $s1
  int *result; // $v0
  _DWORD *v7; // $s3
  int inited; // $v0
  bool v9; // dc

  v3 = a2 << 16;
  v4 = (int *)malloc(40);
  v5 = v3 >> 16;
  result = 0;
  if ( v4 )
  {
    v4[9] = a1;
    if ( v5 )
    {
      v7 = v4 + 3;
      if ( !pstm_init_size(a1, v4, v5) )
      {
        if ( !pstm_init_size(a1, v4 + 3, v5) )
        {
          inited = pstm_init_size(a1, v4 + 6, v5);
          goto LABEL_9;
        }
LABEL_12:
        pstm_clear(v4);
      }
    }
    else
    {
      v7 = v4 + 3;
      if ( !pstm_init(a1, v4) )
      {
        if ( !pstm_init(a1, v4 + 3) )
        {
          inited = pstm_init(a1, v4 + 6);
LABEL_9:
          v9 = inited != 0;
          result = v4;
          if ( !v9 )
            return result;
          pstm_clear(v7);
          goto LABEL_12;
        }
        goto LABEL_12;
      }
    }
    free2(v4);
    return 0;
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (00486AE4) --------------------------------------------------------
int   psEccX963ImportKey(int a1, _BYTE *a2, unsigned __int16 a3, int a4, unsigned __int8 *a5)
{
  int v5; // $s0
  int v9; // $t0
  int v10; // $v1
  int v11; // $s6
  unsigned __int16 v12; // $s0
  int unsigned_bin; // $v0
  int radix; // $s4
  int v16; // $v1
  int i; // $s0
  unsigned __int16 v18; // $s0
  int v19; // $v0
  int v20; // $s5
  unsigned __int16 v21; // $s4
  int *v22; // $a0
  int v23[2]; // [sp+28h] [-48h] BYREF
  int v24; // [sp+30h] [-40h]
  int v25[4]; // [sp+38h] [-38h] BYREF
  unsigned int *v26[4]; // [sp+48h] [-28h] BYREF
  int v27[4]; // [sp+58h] [-18h] BYREF
  _DWORD *v28; // [sp+68h] [-8h]

  v5 = a3;
  if ( a3 < 0x31u || ((a3 ^ 1) & 1) != 0 )
    return -6;
  v9 = a3 - 1;
  if ( *(_BYTE *)(a4 + 60) != 2 )
  {
    v10 = -8;
    if ( !a4 )
      return v10;
    memset(a4, 0, 64);
    *(_BYTE *)(a4 + 60) = 1;
    *(_DWORD *)(a4 + 56) = a1;
    *(_DWORD *)(a4 + 48) = a1;
    *(_DWORD *)(a4 + 52) = a5;
    v9 = v5 - 1;
  }
  v11 = v9 >> 1;
  v12 = v9 >> 1;
  unsigned_bin = pstm_init_for_read_unsigned_bin(a1, (int *)(a4 + 12), v12);
  v10 = -8;
  if ( unsigned_bin < 0 )
    return v10;
  if ( pstm_init_for_read_unsigned_bin(a1, (int *)(a4 + 24), v12) < 0 )
  {
    pstm_clear((_DWORD *)(a4 + 12));
    return -8;
  }
  v28 = (_DWORD *)(a4 + 36);
  if ( pstm_init_size(a1, (int *)(a4 + 36), 1u) < 0 )
  {
    pstm_clear((_DWORD *)(a4 + 12));
    pstm_clear((_DWORD *)(a4 + 24));
    return -8;
  }
  radix = -10;
  if ( *a2 == 4 )
  {
    radix = pstm_read_unsigned_bin((int *)(a4 + 12), a2 + 1, v12);
    if ( !radix )
    {
      radix = pstm_read_unsigned_bin((int *)(a4 + 24), &a2[v11 + 1], v12);
      if ( !radix )
      {
        pstm_set((int)v28, 1);
        v10 = 0;
        if ( !a5 || !a5[4] )
          return v10;
        radix = pstm_init_for_read_unsigned_bin(a1, v23, *a5);
        if ( radix >= 0 )
        {
          radix = pstm_init_for_read_unsigned_bin(a1, v25, *a5);
          if ( radix < 0 )
          {
            pstm_clear(v23);
            goto LABEL_10;
          }
          radix = pstm_read_radix(a1, v23, *((unsigned __int8 **)a5 + 4), 2 * *a5, 0x10u);
          if ( radix < 0 )
            goto LABEL_44;
          radix = pstm_read_radix(a1, v25, *((unsigned __int8 **)a5 + 6), 2 * *a5, 0x10u);
          if ( radix < 0 )
            goto LABEL_44;
          v16 = pstm_init(a1, (int *)v26);
          if ( v16 >= 0 )
          {
            i = pstm_init(a1, v27);
            if ( i < 0 )
            {
              v22 = (int *)v26;
            }
            else
            {
              v18 = 8 * (v24 & 0xFFF) + 4;
              v19 = malloc(8 * (v24 & 0xFFF) + 4);
              v20 = v19;
              if ( !v19 )
              {
                pstm_clear(v26);
                radix = -8;
                pstm_clear(v27);
LABEL_44:
                pstm_clear(v23);
                pstm_clear(v25);
                goto LABEL_10;
              }
              v21 = v18;
              i = pstm_sqr_comba(a1, (int *)(a4 + 24), (int *)v26, v19, v18);
              if ( i >= 0 )
              {
                i = pstm_sqr_comba(a1, (int *)(a4 + 12), v27, v20, v21);
                if ( i >= 0 )
                {
                  i = pstm_mod(a1, (int)v27, (int)v23, v27);
                  if ( i >= 0 )
                  {
                    i = pstm_mul_comba(a1, (int *)(a4 + 12), v27, v27, v20, v21);
                    if ( i >= 0 )
                    {
                      i = pstm_sub((int *)v26, v27, (int *)v26);
                      if ( i >= 0 )
                      {
                        i = pstm_add((int *)v26, (int *)(a4 + 12), (int *)v26);
                        if ( i >= 0 )
                        {
                          i = pstm_add((int *)v26, (int *)(a4 + 12), (int *)v26);
                          if ( i >= 0 )
                          {
                            i = pstm_add((int *)v26, (int *)(a4 + 12), (int *)v26);
                            if ( i >= 0 )
                            {
                              for ( i = pstm_mod(a1, (int)v26, (int)v23, (int *)v26);
                                    i >= 0;
                                    i = pstm_add((int *)v26, v23, (int *)v26) )
                              {
                                if ( pstm_cmp_d(v26, 0) != -1 )
                                {
                                  while ( pstm_cmp(v26, v23) != -1 )
                                  {
                                    i = pstm_sub((int *)v26, v23, (int *)v26);
                                    if ( i < 0 )
                                      goto LABEL_38;
                                  }
                                  i = -9;
                                  if ( !pstm_cmp(v26, v25) )
                                    i = 0;
                                  break;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
LABEL_38:
              free2(v20);
              pstm_clear(v26);
              v22 = v27;
            }
            pstm_clear(v22);
            v16 = i;
          }
          radix = v16;
          if ( v16 >= 0 )
          {
            pstm_clear(v23);
            pstm_clear(v25);
            return 0;
          }
          goto LABEL_44;
        }
      }
    }
  }
LABEL_10:
  if ( !a4 )
  {
    psTraceStr("psAssert %s", (int)"pubkey/ecc.c");
    psTraceInt(":%d ", 255);
    psError((int)"key");
  }
  pstm_clear((_DWORD *)a4);
  pstm_clear_multi((_DWORD *)(a4 + 12), (_DWORD *)(a4 + 24), v28, 0, 0, 0, 0, 0);
  *(_BYTE *)(a4 + 60) = 0;
  *(_DWORD *)(a4 + 52) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(_DWORD *)(a4 + 48) = 0;
  return radix;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (00487204) --------------------------------------------------------
int   psEccParsePrivKey(int a1, unsigned __int8 *a2, unsigned __int16 a3, int a4, char *a5)
{
  unsigned __int8 *v6; // $s0
  int AsnSequence; // $v0
  int v9; // $v1
  int v11; // $t1
  __int16 v12; // $a0
  int AsnLength; // $v0
  unsigned __int16 v14; // $a2
  int v15; // $s3
  unsigned __int8 *v16; // $a1
  int v17; // $a2
  unsigned __int16 v18; // $v1
  int v19; // $t3
  unsigned __int8 *v20; // $t4
  int v21; // $t4
  __int16 v22; // $a0
  int v23; // $a2
  int v24; // $a3
  int v25; // $v1
  char *v26; // $v1
  char *v27; // $a0
  int v28; // $t0
  int v29; // $t6
  __int16 v30; // $a0
  unsigned __int16 v31; // $a2
  int v32; // $v0
  unsigned __int8 *v33; // $a1
  unsigned __int16 v34; // [sp+28h] [-10h] BYREF
  unsigned __int8 *v35; // [sp+2Ch] [-Ch] BYREF
  int v36; // [sp+30h] [-8h] BYREF
  char *v37; // [sp+34h] [-4h]

  v35 = a2;
  v6 = &a2[a3];
  AsnSequence = getAsnSequence(&v35, a3, &v34);
  v9 = -1;
  if ( AsnSequence >= 0 )
  {
    if ( getAsnInteger((char **)&v35, (unsigned __int16)((_WORD)v6 - (_WORD)v35), &v36) < 0 )
      return -1;
    if ( v36 != 1 )
      return -1;
    v11 = *v35;
    v12 = (_WORD)v35++ + 1;
    if ( v11 != 4 )
      return -1;
    AsnLength = getAsnLength(&v35, (_WORD)v6 - v12, &v34);
    v9 = -1;
    if ( AsnLength >= 0 )
    {
      v14 = v34;
      v15 = v34;
      if ( (unsigned __int16)((_WORD)v6 - (_WORD)v35) >= (unsigned int)v34 && v34 >= 0x18u )
      {
        if ( a4 )
        {
          memset(a4, 0, 64);
          v14 = v34;
          *(_DWORD *)(a4 + 56) = a1;
          *(_DWORD *)(a4 + 48) = a1;
          *(_DWORD *)(a4 + 52) = a5;
        }
        if ( pstm_init_for_read_unsigned_bin(a1, (int *)a4, v14) || pstm_read_unsigned_bin((int *)a4, v35, v34) )
          goto LABEL_37;
        v16 = &v35[v34];
        *(_BYTE *)(a4 + 60) = 2;
        v35 = v16;
        if ( *v16 == 160 )
        {
          v35 = v16 + 1;
          if ( getAsnLength(&v35, (_WORD)v6 - ((_WORD)v16 + 1), &v34) < 0 )
            goto LABEL_37;
          if ( (unsigned __int16)((_WORD)v6 - (_WORD)v35) < (unsigned int)v34 )
            goto LABEL_37;
          if ( !v34 )
            goto LABEL_37;
          v21 = *v35;
          v22 = (_WORD)v35++ + 1;
          if ( v21 != 6 )
            goto LABEL_37;
          if ( getAsnLength(&v35, (_WORD)v6 - v22, &v34) < 0 )
            goto LABEL_37;
          v16 = v35;
          v23 = v34;
          if ( (unsigned __int16)((_WORD)v6 - (_WORD)v35) < (unsigned int)v34 )
            goto LABEL_37;
          v24 = 0;
          if ( v34 )
          {
            do
            {
              v25 = *v16++;
              --v23;
              v24 += v25;
              v35 = v16;
              v34 = v23;
            }
            while ( (_WORD)v23 );
          }
          v37 = 0;
          if ( !byte_4E6870[0] )
            goto LABEL_37;
          v26 = byte_4E6870;
          v27 = byte_4E6870;
          while ( 1 )
          {
            v28 = *((_DWORD *)v26 + 2);
            v26 += 40;
            if ( v28 == v24 )
              break;
            v27 += 40;
            if ( !*v26 )
              goto LABEL_37;
          }
          v37 = v27;
          if ( a5 )
          {
            if ( a5 != v27 )
              goto LABEL_37;
            *(_DWORD *)(a4 + 52) = v27;
          }
          else
          {
            *(_DWORD *)(a4 + 52) = v37;
          }
        }
        else
        {
          if ( !a5 )
            goto LABEL_37;
          *(_DWORD *)(a4 + 52) = a5;
        }
        if ( *v16 == 161 )
        {
          v35 = v16 + 1;
          if ( getAsnLength(&v35, (_WORD)v6 - ((_WORD)v16 + 1), &v34) < 0 )
            goto LABEL_37;
          if ( (unsigned __int16)((_WORD)v6 - (_WORD)v35) < (unsigned int)v34 )
            goto LABEL_37;
          if ( !v34 )
            goto LABEL_37;
          v29 = *v35;
          v30 = (_WORD)v35++ + 1;
          if ( v29 != 3 )
            goto LABEL_37;
          if ( getAsnLength(&v35, (_WORD)v6 - v30, &v34) < 0 )
            goto LABEL_37;
          if ( (unsigned __int16)((_WORD)v6 - (_WORD)v35) < (unsigned int)v34 )
            goto LABEL_37;
          v31 = v34 - 1;
          if ( !v34 )
            goto LABEL_37;
          v32 = *v35;
          v33 = ++v35;
          --v34;
          if ( v32 || psEccX963ImportKey(a1, v33, v31, a4, *(unsigned __int8 **)(a4 + 52)) < 0 )
            goto LABEL_37;
          v16 = &v35[v34];
          v35 = v16;
        }
        if ( v16 >= v6 )
          goto LABEL_20;
        v17 = v6 - v16;
        if ( *v16 != 4 || v17 - 1 != 2 * v15 )
          goto LABEL_20;
        if ( psEccX963ImportKey(a1, v16, v17, a4, *(unsigned __int8 **)(a4 + 52)) >= 0 )
        {
          v16 = v6;
          v35 = v6;
LABEL_20:
          if ( v6 == v16 )
            return 0;
          v18 = (_WORD)v6 - (_WORD)v16;
          v34 = (_WORD)v6 - (_WORD)v16;
          if ( v16 >= v6 )
            return 0;
          while ( 1 )
          {
            v19 = *v16;
            v20 = ++v16;
            if ( v19 != v18 )
              break;
            v35 = v20;
            if ( v20 >= v6 )
              return 0;
          }
        }
LABEL_37:
        if ( !a4 )
        {
          psTraceStr("psAssert %s", (int)"pubkey/ecc.c");
          psTraceInt(":%d ", 255);
          psError((int)"key");
        }
        pstm_clear((_DWORD *)a4);
        pstm_clear_multi((_DWORD *)(a4 + 12), (_DWORD *)(a4 + 24), (_DWORD *)(a4 + 36), 0, 0, 0, 0, 0);
        *(_BYTE *)(a4 + 60) = 0;
        *(_DWORD *)(a4 + 52) = 0;
        *(_DWORD *)(a4 + 56) = 0;
        *(_DWORD *)(a4 + 48) = 0;
        return -1;
      }
    }
  }
  return v9;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (00487768) --------------------------------------------------------
int   psEccParsePrivFile(int a1, int a2, int a3, int a4)
{
  int v7; // $v1
  int v9; // $s1
  int v10; // $a0
  int v11; // $v1
  char v12; // $a1
  int inited; // $v0
  unsigned __int16 v14[4]; // [sp+28h] [-80h] BYREF
  _DWORD v15[3]; // [sp+30h] [-78h] BYREF
  _DWORD v16[3]; // [sp+3Ch] [-6Ch] BYREF
  _DWORD v17[3]; // [sp+48h] [-60h] BYREF
  _DWORD v18[3]; // [sp+54h] [-54h] BYREF
  int v19; // [sp+60h] [-48h]
  int v20; // [sp+64h] [-44h]
  int v21; // [sp+68h] [-40h]
  char v22; // [sp+6Ch] [-3Ch]
  unsigned __int8 *v23; // [sp+A0h] [-8h] BYREF

  v7 = psPkcs1DecodePrivFile(a1, a2, a3, (unsigned int **)&v23, v14);
  if ( v7 >= 0 )
  {
    if ( psEccParsePrivKey(a1, v23, v14[0], a4, 0) >= 0 )
    {
LABEL_3:
      free2(v23);
      return 0;
    }
    v9 = psPkcs8ParsePrivBin(a1, v23, v14[0], a3, (int)v15);
    if ( v9 < 0 )
    {
      free2(v23);
      return v9;
    }
    v10 = *(_DWORD *)(a4 + 56);
    if ( v10 )
    {
      *(_DWORD *)(a4 + 48) = v10;
    }
    else
    {
      v10 = v21;
      v11 = v19;
      *(_DWORD *)(a4 + 56) = v21;
      *(_DWORD *)(a4 + 48) = v11;
    }
    v12 = v22;
    *(_DWORD *)(a4 + 52) = v20;
    *(_BYTE *)(a4 + 60) = v12;
    inited = pstm_init_copy(v10, (int *)(a4 + 12), (int)v16, 0);
    if ( !inited )
    {
      inited = pstm_init_copy(*(_DWORD *)(a4 + 56), (int *)(a4 + 24), (int)v17, 0);
      if ( !inited )
      {
        inited = pstm_init_copy(*(_DWORD *)(a4 + 56), (int *)(a4 + 36), (int)v18, 0);
        if ( !inited )
        {
          if ( *(_BYTE *)(a4 + 60) != 2 )
          {
LABEL_14:
            psClearPubKey((int)v15);
            goto LABEL_3;
          }
          inited = pstm_init_copy(*(_DWORD *)(a4 + 56), (int *)a4, (int)v15, 0);
        }
      }
    }
    if ( inited < 0 )
    {
      if ( !v15 )
      {
        psTraceStr("psAssert %s", (int)"pubkey/ecc.c");
        psTraceInt(":%d ", 255);
        psError((int)"key");
      }
      pstm_clear(v15);
      pstm_clear_multi(v16, v17, v18, 0, 0, 0, 0, 0);
      v20 = 0;
      v21 = 0;
      v19 = 0;
      v22 = 0;
    }
    goto LABEL_14;
  }
  return v7;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00487A00) --------------------------------------------------------
int   getEcPubKey(int a1, unsigned __int8 **a2, __int16 a3, int a4, int a5)
{
  unsigned __int8 *v5; // $v0
  __int16 v10; // $s1
  int v11; // $v1
  int v12; // $a0
  int AsnLength; // $v0
  unsigned __int8 *v15; // $a0
  unsigned __int16 v16; // $v1
  int v17; // $a2
  char *v18; // $v1
  unsigned __int8 *i; // $a1
  int v20; // $t4
  int v21; // $t2
  int v22; // $v0
  int v23; // $v0
  int v24; // $v0
  unsigned __int8 *v25; // $s4
  __int64 v26[26]; // [sp+20h] [-E0h] BYREF
  unsigned __int16 v27; // [sp+F0h] [-10h] BYREF
  unsigned __int8 *v28; // [sp+F4h] [-Ch] BYREF
  unsigned __int8 *v29; // [sp+F8h] [-8h]

  v5 = *a2;
  v28 = v5;
  v10 = a3 + (_WORD)v5;
  if ( !a3 )
    return -31;
  v11 = *v5;
  v28 = v5 + 1;
  if ( v11 != 6 )
    return -31;
  AsnLength = getAsnLength(&v28, a3 - 1, &v27);
  v12 = -31;
  if ( AsnLength < 0 )
    return v12;
  v15 = v28;
  v16 = v27;
  if ( (unsigned __int16)(v10 - (_WORD)v28) < (unsigned int)v27 )
    return -31;
  v17 = 0;
  if ( v27 )
  {
    while ( 1 )
    {
      v21 = *v15++;
      v17 += v21;
      v28 = v15;
      v27 = v16 - 1;
      if ( v16 == 1 )
        break;
      --v16;
    }
  }
  v29 = 0;
  if ( !byte_4E6870[0] )
    return -10;
  v18 = byte_4E6870;
  for ( i = (unsigned __int8 *)byte_4E6870; ; i += 40 )
  {
    v20 = *((_DWORD *)v18 + 2);
    v18 += 40;
    if ( v20 == v17 )
      break;
    if ( !*v18 )
      return -10;
  }
  v29 = i;
  if ( v10 == (__int16)v15 )
    return -31;
  v22 = *v15;
  v28 = v15 + 1;
  if ( v22 != 3 )
    return -31;
  v23 = getAsnLength(&v28, a3 - 1, &v27);
  v12 = -31;
  if ( v23 < 0 )
    return v12;
  if ( (unsigned __int16)(v10 - (_WORD)v28) < (unsigned int)v27 || !v27 )
    return -31;
  ++v28;
  --v27;
  psSha1Init(v26);
  psSha1Update((int *)v26, (int)v28, v27);
  psSha1Final(v26, a5);
  v24 = psEccX963ImportKey(a1, v28, v27, a4, v29);
  v12 = -31;
  if ( v24 >= 0 )
  {
    v12 = 0;
    v25 = &v28[v27];
    *a2 = v25;
    v28 = v25;
  }
  return v12;
}

//----- (00487C6C) --------------------------------------------------------
int   psEccX963ExportKey(int a1, int a2, _BYTE *a3, _WORD *a4)
{
  int v6; // $s1
  unsigned int v7; // $s3
  BOOL v8; // $v1
  int *v11; // $s2
  int v12; // $a3
  _DWORD *v13; // $a0
  int v14; // $v0
  int *v15; // $s0
  int v17; // $v0
  _BYTE v18[256]; // [sp+18h] [-100h] BYREF

  v6 = **(unsigned __int8 **)(a2 + 52);
  v7 = 2 * v6 + 1;
  v8 = (unsigned __int16)*a4 < v7;
  v11 = (int *)(a2 + 12);
  v12 = -9;
  if ( v8 )
  {
    *a4 = v7;
  }
  else
  {
    *a3 = 4;
    memset(v18, 0, sizeof(v18));
    v13 = (_DWORD *)(a2 + 12);
    v15 = (int *)(a2 + 24);
    v14 = pstm_unsigned_bin_size(v13);
    v12 = pstm_to_unsigned_bin(a1, v11, (int)&v18[v6 - v14]);
    if ( !v12 )
    {
      memcpy(a3 + 1, v18, v6);
      memset(v18, 0, sizeof(v18));
      v17 = pstm_unsigned_bin_size(v15);
      v12 = pstm_to_unsigned_bin(a1, v15, (int)&v18[v6 - v17]);
      if ( !v12 )
      {
        memcpy(&a3[v6 + 1], v18, v6);
        v12 = 0;
        *a4 = v7;
      }
    }
  }
  return v12;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00487E0C) --------------------------------------------------------
int   sub_487E0C(int a1, int a2, int *a3, int *a4, int *a5, int *a6)
{
  int v10; // $v0
  int v11; // $v1
  int v12; // $v0
  int v13; // $v0
  int v14; // $a0
  int v15; // $a3
  __int16 v16; // $t0
  unsigned __int16 v17; // $s2
  int inited; // $v0
  int v19; // $s0
  int v20; // $v0
  _DWORD *v21; // $s3
  int v22; // $s1
  int v23; // $v0
  int v25[4]; // [sp+28h] [-48h] BYREF
  unsigned int *v26[2]; // [sp+38h] [-38h] BYREF
  int v27; // [sp+40h] [-30h]
  int v28[4]; // [sp+48h] [-28h] BYREF
  int v29[4]; // [sp+58h] [-18h] BYREF
  int *v30; // [sp+68h] [-8h]

  if ( (int *)a2 == a3
    || (v10 = pstm_copy(a2, a3), v11 = -8, v10 >= 0)
    && (v12 = pstm_copy(a2 + 12, a3 + 3), v11 = -8, v12 >= 0)
    && (v13 = pstm_copy(a2 + 24, a3 + 6), v11 = -8, v13 >= 0) )
  {
    v14 = a3[2] & 0xFFF;
    if ( v14 < (a3[5] & 0xFFF) )
      v14 = a3[5] & 0xFFF;
    v15 = a3[8];
    v16 = 2 * v14;
    if ( v14 < (v15 & 0xFFF) )
      v16 = 2 * (v15 & 0xFFF);
    v17 = v16 + 1;
    inited = pstm_init_size(a1, v25, v16 + 1);
    v11 = -8;
    if ( inited >= 0 )
    {
      if ( pstm_init_size(a1, (int *)v26, v17) < 0 )
      {
        pstm_clear(v25);
        return -8;
      }
      v19 = 8 * (a4[2] & 0xFFF) + 4;
      v20 = malloc(v19);
      v21 = (_DWORD *)v20;
      v22 = -8;
      if ( !v20 )
        goto LABEL_63;
      v22 = pstm_sqr_comba(a1, a3 + 6, v25, v20, v19);
      if ( v22 )
        goto LABEL_63;
      v22 = pstm_montgomery_reduce(a1, v25, a4, *a5, v21, v19);
      if ( v22 )
        goto LABEL_63;
      v30 = a3 + 3;
      v22 = pstm_mul_comba(a1, a3 + 6, a3 + 3, a3 + 6, (int)v21, v19);
      if ( v22 )
        goto LABEL_63;
      v22 = pstm_montgomery_reduce(a1, a3 + 6, a4, *a5, v21, v19);
      if ( v22 )
        goto LABEL_63;
      v22 = pstm_add(a3 + 6, a3 + 6, a3 + 6);
      if ( v22 )
        goto LABEL_63;
      if ( pstm_cmp(a3 + 6, a4) != -1 )
      {
        v22 = pstm_sub(a3 + 6, a4, a3 + 6);
        if ( v22 )
          goto LABEL_63;
      }
      if ( a6 )
      {
        v23 = pstm_init_size(a1, v28, v17);
        v11 = -8;
        if ( v23 < 0 )
          return v11;
        if ( pstm_init_size(a1, v29, v17) < 0 )
        {
          pstm_clear(v28);
          return -8;
        }
        v22 = pstm_sqr_comba(a1, a3, v28, (int)v21, v19);
        if ( v22 )
          goto LABEL_63;
        v22 = pstm_montgomery_reduce(a1, v28, a4, *a5, v21, v19);
        if ( v22 )
          goto LABEL_63;
        v22 = pstm_add(v28, v28, v29);
        if ( v22 )
          goto LABEL_63;
        if ( pstm_cmp(v29, a4) != -1 )
        {
          v22 = pstm_sub(v29, a4, v29);
          if ( v22 )
            goto LABEL_63;
        }
        v22 = pstm_add(v28, v29, v28);
        if ( v22 )
          goto LABEL_63;
        if ( pstm_cmp(v28, a4) != -1 )
        {
          v22 = pstm_sub(v28, a4, v28);
          if ( v22 )
            goto LABEL_63;
        }
        v22 = pstm_sqr_comba(a1, v25, v29, (int)v21, v19);
        if ( v22 )
          goto LABEL_63;
        v22 = pstm_mod(a1, (int)v29, (int)a4, v29);
        if ( v22 )
          goto LABEL_63;
        v22 = pstm_mul_comba(a1, v29, a6, v29, (int)v21, v19);
        if ( v22 )
          goto LABEL_63;
        v22 = pstm_montgomery_reduce(a1, v29, a4, *a5, v21, v19);
        if ( v22 )
          goto LABEL_63;
        v22 = pstm_add(v28, v29, v25);
        if ( v22 )
          goto LABEL_63;
        if ( pstm_cmp(v25, a4) != -1 )
        {
          v22 = pstm_sub(v25, a4, v25);
          if ( v22 )
            goto LABEL_63;
        }
        pstm_clear_multi(v28, v29, 0, 0, 0, 0, 0, 0);
      }
      else
      {
        v22 = pstm_sub(a3, v25, (int *)v26);
        if ( v22 )
          goto LABEL_63;
        if ( pstm_cmp_d(v26, 0) == -1 )
        {
          v22 = pstm_add((int *)v26, a4, (int *)v26);
          if ( v22 )
            goto LABEL_63;
        }
        v22 = pstm_add(v25, a3, v25);
        if ( v22 )
          goto LABEL_63;
        if ( pstm_cmp(v25, a4) != -1 )
        {
          v22 = pstm_sub(v25, a4, v25);
          if ( v22 )
            goto LABEL_63;
        }
        if ( (v22 = pstm_mul_comba(a1, v25, (int *)v26, (int *)v26, (int)v21, v19)) != 0
          || (v22 = pstm_montgomery_reduce(a1, (int *)v26, a4, *a5, v21, v19)) != 0
          || (v22 = pstm_add((int *)v26, (int *)v26, v25)) != 0
          || pstm_cmp(v25, a4) != -1 && (v22 = pstm_sub(v25, a4, v25)) != 0
          || (v22 = pstm_add(v25, (int *)v26, v25)) != 0
          || pstm_cmp(v25, a4) != -1 && (v22 = pstm_sub(v25, a4, v25)) != 0 )
        {
LABEL_63:
          pstm_clear_multi(v25, v26, 0, 0, 0, 0, 0, 0);
          v11 = v22;
          if ( v21 )
          {
            free2(v21);
            return v22;
          }
          return v11;
        }
      }
      v22 = pstm_add(v30, v30, v30);
      if ( !v22 && (pstm_cmp(v30, a4) == -1 || (v22 = pstm_sub(v30, a4, v30)) == 0) )
      {
        v22 = pstm_sqr_comba(a1, v30, v30, (int)v21, v19);
        if ( !v22 )
        {
          v22 = pstm_montgomery_reduce(a1, v30, a4, *a5, v21, v19);
          if ( !v22 )
          {
            v22 = pstm_sqr_comba(a1, v30, (int *)v26, (int)v21, v19);
            if ( !v22 )
            {
              v22 = pstm_montgomery_reduce(a1, (int *)v26, a4, *a5, v21, v19);
              if ( !v22
                && ((v27 & 0xFFF) == 0 || (*v26[0] & 1) == 0 || (v22 = pstm_add((int *)v26, a4, (int *)v26)) == 0) )
              {
                v22 = pstm_div_2((int)v26, (int *)v26);
                if ( !v22 )
                {
                  v22 = pstm_mul_comba(a1, v30, a3, v30, (int)v21, v19);
                  if ( !v22 )
                  {
                    v22 = pstm_montgomery_reduce(a1, v30, a4, *a5, v21, v19);
                    if ( !v22 )
                    {
                      v22 = pstm_sqr_comba(a1, v25, a3, (int)v21, v19);
                      if ( !v22 )
                      {
                        v22 = pstm_montgomery_reduce(a1, a3, a4, *a5, v21, v19);
                        if ( !v22 )
                        {
                          v22 = pstm_sub(a3, v30, a3);
                          if ( !v22 && (pstm_cmp_d((unsigned int **)a3, 0) != -1 || (v22 = pstm_add(a3, a4, a3)) == 0) )
                          {
                            v22 = pstm_sub(a3, v30, a3);
                            if ( !v22 && (pstm_cmp_d((unsigned int **)a3, 0) != -1 || (v22 = pstm_add(a3, a4, a3)) == 0) )
                            {
                              v22 = pstm_sub(v30, a3, v30);
                              if ( !v22
                                && (pstm_cmp_d((unsigned int **)v30, 0) != -1 || (v22 = pstm_add(v30, a4, v30)) == 0) )
                              {
                                v22 = pstm_mul_comba(a1, v30, v25, v30, (int)v21, v19);
                                if ( !v22 )
                                {
                                  v22 = pstm_montgomery_reduce(a1, v30, a4, *a5, v21, v19);
                                  if ( !v22 )
                                  {
                                    v22 = pstm_sub(v30, (int *)v26, v30);
                                    if ( !v22
                                      && (pstm_cmp_d((unsigned int **)v30, 0) != -1
                                       || (v22 = pstm_add(v30, a4, v30)) == 0) )
                                    {
                                      v22 = 0;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      goto LABEL_63;
    }
  }
  return v11;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (004889CC) --------------------------------------------------------
int   sub_4889CC(int a1, _DWORD *a2, _DWORD *a3, int *a4, int *a5, int *a6, int *a7)
{
  int inited; // $v0
  _DWORD *v11; // $s6
  int v12; // $v1
  int v13; // $s1
  int v15; // $s0
  int v16; // $v0
  int v17[4]; // [sp+28h] [-58h] BYREF
  unsigned int *v18[4]; // [sp+38h] [-48h] BYREF
  unsigned int *v19[4]; // [sp+48h] [-38h] BYREF
  unsigned int *v20[2]; // [sp+58h] [-28h] BYREF
  int v21; // [sp+60h] [-20h]
  int v22[4]; // [sp+68h] [-18h] BYREF
  int *v23; // [sp+78h] [-8h]
  int v24; // [sp+7Ch] [-4h]

  inited = pstm_init_size(a1, v17, (a2[2] >> 12) & 0xFFF);
  v11 = 0;
  v12 = -8;
  if ( inited >= 0 )
  {
    v13 = -8;
    if ( pstm_init_size(a1, (int *)v18, (a2[2] >> 12) & 0xFFF) >= 0 )
    {
      if ( pstm_init_size(a1, (int *)v19, (a2[2] >> 12) & 0xFFF) >= 0 )
      {
        if ( pstm_init_size(a1, (int *)v20, (a2[5] >> 12) & 0xFFF) >= 0 )
        {
          if ( pstm_init_size(a1, v22, (a2[8] >> 12) & 0xFFF) >= 0 )
          {
            v13 = pstm_sub(a5, a3 + 3, v17);
            if ( !v13 )
            {
              if ( !pstm_cmp(a2, a3)
                && !pstm_cmp(a2 + 6, a3 + 6)
                && (!pstm_cmp(a2 + 3, a3 + 3) || !pstm_cmp(a2 + 3, v17)) )
              {
                pstm_clear_multi(v17, v18, v19, v20, v22, 0, 0, 0);
                return sub_487E0C(a1, (int)a2, a4, a5, a6, a7);
              }
              v13 = pstm_copy((int)a2, (int *)v19);
              if ( !v13 )
              {
                v13 = pstm_copy((int)(a2 + 3), (int *)v20);
                if ( !v13 )
                {
                  v13 = pstm_copy((int)(a2 + 6), v22);
                  if ( !v13 )
                  {
                    v15 = 8 * (a5[2] & 0xFFF) + 4;
                    v11 = (_DWORD *)malloc(v15);
                    v13 = -8;
                    if ( v11 )
                    {
                      v23 = a3 + 6;
                      v16 = pstm_cmp_d((unsigned int **)a3 + 6, 1u);
                      v24 = (unsigned __int16)v15;
                      if ( !v16 )
                        goto LABEL_21;
                      v13 = pstm_sqr_comba(a1, v23, v17, (int)v11, v15);
                      if ( !v13 )
                      {
                        v13 = pstm_montgomery_reduce(a1, v17, a5, *a6, v11, v24);
                        if ( !v13 )
                        {
                          v13 = pstm_mul_comba(a1, v17, (int *)v19, (int *)v19, (int)v11, v24);
                          if ( !v13 )
                          {
                            v13 = pstm_montgomery_reduce(a1, (int *)v19, a5, *a6, v11, v24);
                            if ( !v13 )
                            {
                              v13 = pstm_mul_comba(a1, v23, v17, v17, (int)v11, v24);
                              if ( !v13 )
                              {
                                v13 = pstm_montgomery_reduce(a1, v17, a5, *a6, v11, v24);
                                if ( !v13 )
                                {
                                  v13 = pstm_mul_comba(a1, v17, (int *)v20, (int *)v20, (int)v11, v24);
                                  if ( !v13 )
                                  {
                                    v13 = pstm_montgomery_reduce(a1, (int *)v20, a5, *a6, v11, v24);
                                    if ( !v13 )
                                    {
LABEL_21:
                                      v13 = pstm_sqr_comba(a1, v22, v17, (int)v11, v24);
                                      if ( !v13 )
                                      {
                                        v13 = pstm_montgomery_reduce(a1, v17, a5, *a6, v11, v24);
                                        if ( !v13 )
                                        {
                                          v13 = pstm_mul_comba(a1, a3, v17, (int *)v18, (int)v11, v24);
                                          if ( !v13 )
                                          {
                                            v13 = pstm_montgomery_reduce(a1, (int *)v18, a5, *a6, v11, v24);
                                            if ( !v13 )
                                            {
                                              v13 = pstm_mul_comba(a1, v22, v17, v17, (int)v11, v24);
                                              if ( !v13 )
                                              {
                                                v13 = pstm_montgomery_reduce(a1, v17, a5, *a6, v11, v24);
                                                if ( !v13 )
                                                {
                                                  v13 = pstm_mul_comba(a1, a3 + 3, v17, v17, (int)v11, v24);
                                                  if ( !v13 )
                                                  {
                                                    v13 = pstm_montgomery_reduce(a1, v17, a5, *a6, v11, v24);
                                                    if ( !v13 )
                                                    {
                                                      v13 = pstm_sub((int *)v20, v17, (int *)v20);
                                                      if ( !v13
                                                        && (pstm_cmp_d(v20, 0) != -1
                                                         || (v13 = pstm_add((int *)v20, a5, (int *)v20)) == 0) )
                                                      {
                                                        v13 = pstm_add(v17, v17, v17);
                                                        if ( !v13
                                                          && (pstm_cmp(v17, a5) == -1
                                                           || (v13 = pstm_sub(v17, a5, v17)) == 0) )
                                                        {
                                                          v13 = pstm_add(v17, (int *)v20, v17);
                                                          if ( !v13
                                                            && (pstm_cmp(v17, a5) == -1
                                                             || (v13 = pstm_sub(v17, a5, v17)) == 0) )
                                                          {
                                                            v13 = pstm_sub((int *)v19, (int *)v18, (int *)v19);
                                                            if ( !v13
                                                              && (pstm_cmp_d(v19, 0) != -1
                                                               || (v13 = pstm_add((int *)v19, a5, (int *)v19)) == 0) )
                                                            {
                                                              v13 = pstm_add((int *)v18, (int *)v18, (int *)v18);
                                                              if ( !v13
                                                                && (pstm_cmp(v18, a5) == -1
                                                                 || (v13 = pstm_sub((int *)v18, a5, (int *)v18)) == 0) )
                                                              {
                                                                v13 = pstm_add((int *)v18, (int *)v19, (int *)v18);
                                                                if ( !v13
                                                                  && (pstm_cmp(v18, a5) == -1
                                                                   || (v13 = pstm_sub((int *)v18, a5, (int *)v18)) == 0)
                                                                  && (!pstm_cmp_d((unsigned int **)v23, 1u)
                                                                   || (v13 = pstm_mul_comba(
                                                                               a1,
                                                                               v22,
                                                                               v23,
                                                                               v22,
                                                                               (int)v11,
                                                                               v24)) == 0
                                                                   && (v13 = pstm_montgomery_reduce(
                                                                               a1,
                                                                               v22,
                                                                               a5,
                                                                               *a6,
                                                                               v11,
                                                                               v24)) == 0) )
                                                                {
                                                                  v13 = pstm_mul_comba(
                                                                          a1,
                                                                          v22,
                                                                          (int *)v19,
                                                                          v22,
                                                                          (int)v11,
                                                                          v24);
                                                                  if ( !v13 )
                                                                  {
                                                                    v13 = pstm_montgomery_reduce(
                                                                            a1,
                                                                            v22,
                                                                            a5,
                                                                            *a6,
                                                                            v11,
                                                                            v24);
                                                                    if ( !v13 )
                                                                    {
                                                                      v13 = pstm_mul_comba(
                                                                              a1,
                                                                              v17,
                                                                              (int *)v19,
                                                                              v17,
                                                                              (int)v11,
                                                                              v24);
                                                                      if ( !v13 )
                                                                      {
                                                                        v13 = pstm_montgomery_reduce(
                                                                                a1,
                                                                                v17,
                                                                                a5,
                                                                                *a6,
                                                                                v11,
                                                                                v24);
                                                                        if ( !v13 )
                                                                        {
                                                                          v13 = pstm_sqr_comba(
                                                                                  a1,
                                                                                  (int *)v19,
                                                                                  (int *)v19,
                                                                                  (int)v11,
                                                                                  v24);
                                                                          if ( !v13 )
                                                                          {
                                                                            v13 = pstm_montgomery_reduce(
                                                                                    a1,
                                                                                    (int *)v19,
                                                                                    a5,
                                                                                    *a6,
                                                                                    v11,
                                                                                    v24);
                                                                            if ( !v13 )
                                                                            {
                                                                              v13 = pstm_mul_comba(
                                                                                      a1,
                                                                                      (int *)v18,
                                                                                      (int *)v19,
                                                                                      (int *)v18,
                                                                                      (int)v11,
                                                                                      v24);
                                                                              if ( !v13 )
                                                                              {
                                                                                v13 = pstm_montgomery_reduce(
                                                                                        a1,
                                                                                        (int *)v18,
                                                                                        a5,
                                                                                        *a6,
                                                                                        v11,
                                                                                        v24);
                                                                                if ( !v13 )
                                                                                {
                                                                                  v13 = pstm_mul_comba(
                                                                                          a1,
                                                                                          v17,
                                                                                          (int *)v19,
                                                                                          v17,
                                                                                          (int)v11,
                                                                                          v24);
                                                                                  if ( !v13 )
                                                                                  {
                                                                                    v13 = pstm_montgomery_reduce(
                                                                                            a1,
                                                                                            v17,
                                                                                            a5,
                                                                                            *a6,
                                                                                            v11,
                                                                                            v24);
                                                                                    if ( !v13 )
                                                                                    {
                                                                                      v13 = pstm_sqr_comba(
                                                                                              a1,
                                                                                              (int *)v20,
                                                                                              (int *)v19,
                                                                                              (int)v11,
                                                                                              v24);
                                                                                      if ( !v13 )
                                                                                      {
                                                                                        v13 = pstm_montgomery_reduce(
                                                                                                a1,
                                                                                                (int *)v19,
                                                                                                a5,
                                                                                                *a6,
                                                                                                v11,
                                                                                                v24);
                                                                                        if ( !v13 )
                                                                                        {
                                                                                          v13 = pstm_sub(
                                                                                                  (int *)v19,
                                                                                                  (int *)v18,
                                                                                                  (int *)v19);
                                                                                          if ( !v13
                                                                                            && (pstm_cmp_d(v19, 0) != -1
                                                                                             || (v13 = pstm_add((int *)v19, a5, (int *)v19)) == 0) )
                                                                                          {
                                                                                            v13 = pstm_sub(
                                                                                                    (int *)v18,
                                                                                                    (int *)v19,
                                                                                                    (int *)v18);
                                                                                            if ( !v13
                                                                                              && (pstm_cmp_d(v18, 0) != -1
                                                                                               || (v13 = pstm_add((int *)v18, a5, (int *)v18)) == 0) )
                                                                                            {
                                                                                              v13 = pstm_sub((int *)v18, (int *)v19, (int *)v18);
                                                                                              if ( !v13
                                                                                                && (pstm_cmp_d(v18, 0) != -1
                                                                                                 || (v13 = pstm_add((int *)v18, a5, (int *)v18)) == 0) )
                                                                                              {
                                                                                                v13 = pstm_mul_comba(a1, (int *)v18, (int *)v20, (int *)v18, (int)v11, v24);
                                                                                                if ( !v13 )
                                                                                                {
                                                                                                  v13 = pstm_montgomery_reduce(a1, (int *)v18, a5, *a6, v11, v24);
                                                                                                  if ( !v13 )
                                                                                                  {
                                                                                                    v13 = pstm_sub((int *)v18, v17, (int *)v20);
                                                                                                    if ( !v13 && (pstm_cmp_d(v20, 0) != -1 || (v13 = pstm_add((int *)v20, a5, (int *)v20)) == 0) && ((v21 & 0xFFF) == 0 || (*v20[0] & 1) == 0 || (v13 = pstm_add((int *)v20, a5, (int *)v20)) == 0) )
                                                                                                    {
                                                                                                      v13 = pstm_div_2((int)v20, (int *)v20);
                                                                                                      if ( !v13 )
                                                                                                      {
                                                                                                        v13 = pstm_copy((int)v19, a4);
                                                                                                        if ( !v13 )
                                                                                                        {
                                                                                                          v13 = pstm_copy((int)v20, a4 + 3);
                                                                                                          if ( !v13 )
                                                                                                            v13 = pstm_copy((int)v22, a4 + 6);
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            pstm_clear(v22);
          }
          pstm_clear(v20);
        }
        pstm_clear(v19);
      }
      pstm_clear(v18);
    }
    pstm_clear(v17);
    v12 = v13;
    if ( v11 )
    {
      free2(v11);
      return v13;
    }
  }
  return v12;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (00489818) --------------------------------------------------------
int   sub_489818(int a1, int *a2, int *a3, int *a4)
{
  int inited; // $v0
  int v9; // $v1
  int v10; // $s0
  _DWORD *v11; // $v0
  _DWORD *v12; // $s2
  int v13; // $s1
  int v14; // $s7
  int *v16; // $s3
  int v17[4]; // [sp+28h] [-20h] BYREF
  int v18[4]; // [sp+38h] [-10h] BYREF

  inited = pstm_init_size(a1, v17, ((unsigned int)a2[2] >> 12) & 0xFFF);
  v9 = -8;
  if ( inited >= 0 )
  {
    if ( pstm_init_size(a1, v18, ((unsigned int)a2[2] >> 12) & 0xFFF) < 0 )
    {
      pstm_clear(v17);
      return -8;
    }
    else
    {
      v10 = 8 * (a3[2] & 0xFFF) + 4;
      v11 = (_DWORD *)malloc(v10);
      v12 = v11;
      v13 = -8;
      if ( v11 )
      {
        v14 = (int)(a2 + 6);
        v13 = pstm_montgomery_reduce(a1, a2 + 6, a3, *a4, v11, v10);
        if ( !v13 )
        {
          v13 = pstm_invmod(a1, (int)(a2 + 6), a3, v17);
          if ( !v13 )
          {
            v13 = pstm_sqr_comba(a1, v17, v18, (int)v12, v10);
            if ( !v13 )
            {
              v13 = pstm_mod(a1, (int)v18, (int)a3, v18);
              if ( !v13 )
              {
                v13 = pstm_mul_comba(a1, v17, v18, v17, (int)v12, v10);
                if ( !v13 )
                {
                  v13 = pstm_mod(a1, (int)v17, (int)a3, v17);
                  if ( !v13 )
                  {
                    v13 = pstm_mul_comba(a1, a2, v18, a2, (int)v12, v10);
                    if ( !v13 )
                    {
                      v13 = pstm_montgomery_reduce(a1, a2, a3, *a4, v12, v10);
                      if ( !v13 )
                      {
                        v16 = a2 + 3;
                        v13 = pstm_mul_comba(a1, v16, v17, v16, (int)v12, v10);
                        if ( !v13 )
                        {
                          v13 = pstm_montgomery_reduce(a1, v16, a3, *a4, v12, v10);
                          if ( !v13 )
                            pstm_set(v14, 1);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      pstm_clear_multi(v17, v18, 0, 0, 0, 0, 0, 0);
      v9 = v13;
      if ( v12 )
      {
        free2(v12);
        return v13;
      }
    }
  }
  return v9;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (00489B40) --------------------------------------------------------
int   sub_489B40(int a1, int a2, int *a3, int *a4, int a5, unsigned __int8 a6, int *a7)
{
  int inited; // $v1
  int v12; // $s0
  int v13; // $s1
  int **v14; // $s0
  int *v15; // $v0
  int *v16; // $s0
  int v17; // $s3
  int v18; // $v0
  int v19; // $s2
  int *v20; // $s1
  int v21; // $s1
  unsigned int v22; // $s2
  int v23; // $fp
  unsigned int v25; // $v1
  unsigned int v26; // $v1
  int v27; // $t9
  int v28; // $s1
  int **v29; // $s1
  int v30; // $s2
  int *v31; // $s0
  int **v32; // $s2
  int *v33; // $s0
  int **v34; // $s1
  int v35; // $v0
  int *v36[8]; // [sp+28h] [-58h] BYREF
  unsigned int *v37; // [sp+48h] [-38h] BYREF
  int v38; // [sp+4Ch] [-34h] BYREF
  int v39; // [sp+58h] [-28h] BYREF
  int v40; // [sp+5Ch] [-24h]
  int v41; // [sp+60h] [-20h]
  unsigned int v42; // [sp+64h] [-1Ch]
  int v43; // [sp+68h] [-18h]
  int v44; // [sp+6Ch] [-14h]
  int *v45; // [sp+70h] [-10h]
  int *v46; // [sp+74h] [-Ch]
  int v47; // [sp+78h] [-8h]

  v40 = a6;
  inited = pstm_montgomery_setup((int **)a5, &v39);
  if ( inited )
    return inited;
  inited = pstm_init_size(a1, (int *)&v37, (*(_DWORD *)(a5 + 8) >> 12) & 0xFFF);
  if ( inited )
    return inited;
  v12 = pstm_montgomery_calc_normalization((int *)&v37, (int *)a5);
  if ( v12 )
  {
    pstm_clear(&v37);
    return v12;
  }
  v13 = 0;
  v14 = v36;
  do
  {
    v15 = sub_48695C(a1, 2 * (a3[2] & 0xFFF) + 1);
    *v14++ = v15;
    if ( !v15 )
    {
      v32 = v36;
      if ( v13 > 0 )
      {
        do
        {
          v33 = *v32;
          --v13;
          ++v32;
          if ( v33 )
          {
            pstm_clear(v33);
            pstm_clear(v33 + 3);
            pstm_clear(v33 + 6);
            free2(v33);
          }
        }
        while ( v13 );
      }
      pstm_clear(&v37);
      return -8;
    }
    ++v13;
  }
  while ( v13 < 8 );
  v16 = sub_48695C(a1, ((unsigned int)a3[2] >> 12) & 0xFFF);
  v17 = -8;
  if ( !v16 )
    goto LABEL_38;
  if ( pstm_cmp_d(&v37, 1u) )
  {
    v17 = pstm_mulmod(a1, a3, (int *)&v37, a5, v16);
    if ( v17 )
      goto LABEL_38;
    v45 = v16 + 3;
    v17 = pstm_mulmod(a1, a3 + 3, (int *)&v37, a5, v16 + 3);
    if ( v17 )
      goto LABEL_38;
    v46 = v16 + 6;
    v18 = pstm_mulmod(a1, a3 + 6, (int *)&v37, a5, v16 + 6);
  }
  else
  {
    v17 = pstm_copy((int)a3, v16);
    if ( v17 )
      goto LABEL_38;
    v45 = v16 + 3;
    v17 = pstm_copy((int)(a3 + 3), v16 + 3);
    if ( v17 )
      goto LABEL_38;
    v46 = v16 + 6;
    v18 = pstm_copy((int)(a3 + 6), v16 + 6);
  }
  v17 = v18;
  if ( v18 )
    goto LABEL_38;
  pstm_clear(&v37);
  v17 = sub_487E0C(a1, (int)v16, v36[0], (int *)a5, &v39, a7);
  if ( v17 )
    goto LABEL_38;
  v17 = sub_487E0C(a1, (int)v36[0], v36[0], (int *)a5, &v39, a7);
  if ( v17 )
    goto LABEL_38;
  v17 = sub_487E0C(a1, (int)v36[0], v36[0], (int *)a5, &v39, a7);
  if ( v17 )
    goto LABEL_38;
  v19 = 9;
  v20 = &v38;
  do
  {
    ++v19;
    v17 = sub_4889CC(a1, (_DWORD *)*(v20 - 9), v16, (int *)*(v20 - 8), (int *)a5, &v39, a7);
    ++v20;
    if ( v17 )
      goto LABEL_38;
  }
  while ( v19 < 16 );
  v21 = 0;
  v44 = *(unsigned __int8 *)(a2 + 8) - 1;
  v43 = 1;
  v22 = 0;
  v42 = 0;
  v23 = 0;
  v41 = 1;
LABEL_21:
  while ( v43-- != 1 )
  {
LABEL_26:
    __SET_PAIR__(v26, v22, 2LL * v22);
    if ( v21 || v26 )
    {
      if ( v21 != 1 || v26 )
      {
        v27 = v42 | (v26 << (4 - ++v23));
        v42 = v27;
        v21 = 2;
        if ( v23 == 4 )
        {
          v28 = 0;
          if ( v41 != 1 )
          {
            while ( 1 )
            {
              ++v28;
              v17 = sub_487E0C(a1, (int)a4, a4, (int *)a5, &v39, a7);
              if ( v17 )
                goto LABEL_38;
              if ( v28 >= 4 )
              {
                v17 = sub_4889CC(a1, a4, v36[v42 - 8], a4, (int *)a5, &v39, a7);
                if ( v17 )
                  goto LABEL_38;
                v23 = 0;
                v21 = 1;
                v42 = 0;
                goto LABEL_21;
              }
            }
          }
          v34 = &v36[v27];
          v17 = pstm_copy((int)*(v34 - 8), a4);
          if ( v17 )
            goto LABEL_38;
          v17 = pstm_copy((int)(*(v34 - 8) + 3), a4 + 3);
          if ( v17 )
            goto LABEL_38;
          v17 = pstm_copy((int)(*(v34 - 8) + 6), a4 + 6);
          if ( v17 )
            goto LABEL_38;
          v23 = 0;
          v21 = 1;
          v41 = 0;
          v42 = 0;
        }
      }
      else
      {
        v17 = sub_487E0C(a1, (int)a4, a4, (int *)a5, &v39, a7);
        if ( v17 )
          goto LABEL_38;
      }
    }
  }
  if ( v44 != -1 )
  {
    v25 = 0;
    if ( (unsigned __int8)v44 < (*(_DWORD *)(a2 + 8) & 0xFFF) )
      v25 = *(_DWORD *)(4 * (unsigned __int8)v44 + *(_DWORD *)a2);
    v22 = v25;
    --v44;
    v43 = 32;
    goto LABEL_26;
  }
  if ( v21 == 2 && v23 > 0 )
  {
    v47 = 0;
    while ( 1 )
    {
      v42 *= 2;
      if ( !v41 )
      {
        v17 = sub_487E0C(a1, (int)a4, a4, (int *)a5, &v39, a7);
        if ( v17 )
          break;
      }
      if ( ((v42 >> 4) & 1) != 0 )
      {
        if ( v41 == 1 )
        {
          v17 = pstm_copy((int)v16, a4);
          v41 = 0;
          if ( v17 )
            break;
          v17 = pstm_copy((int)v45, a4 + 3);
          if ( v17 )
            break;
          v35 = pstm_copy((int)v46, a4 + 6);
        }
        else
        {
          v35 = sub_4889CC(a1, a4, v16, a4, (int *)a5, &v39, a7);
        }
        v17 = v35;
        if ( v35 )
          break;
      }
      if ( ++v47 >= v23 )
        goto LABEL_36;
    }
  }
  else
  {
LABEL_36:
    v17 = 0;
    if ( v40 )
      v17 = sub_489818(a1, a4, (int *)a5, &v39);
  }
LABEL_38:
  pstm_clear(&v37);
  v29 = v36;
  if ( v16 )
  {
    pstm_clear(v16);
    pstm_clear(v16 + 3);
    pstm_clear(v16 + 6);
    free2(v16);
    v29 = v36;
  }
  v30 = 7;
  do
  {
    v31 = *v29;
    --v30;
    ++v29;
    if ( v31 )
    {
      pstm_clear(v31);
      pstm_clear(v31 + 3);
      pstm_clear(v31 + 6);
      free2(v31);
    }
    inited = v17;
  }
  while ( v30 >= 0 );
  return inited;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (0048A428) --------------------------------------------------------
int   psEccGenSharedSecret(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int *v9; // $s3
  int v10; // $a0
  int v11; // $v1
  int *v12; // $s0
  unsigned __int8 *v13; // $v1
  int *v14; // $v0
  int radix; // $s2
  int *v16; // $a0
  unsigned int v18; // $s1
  int v19; // $v0
  int *v20; // $a0
  int v21[4]; // [sp+28h] [-10h] BYREF

  v9 = 0;
  v10 = -6;
  if ( *(_BYTE *)(a2 + 60) == 2 )
  {
    v11 = *(_DWORD *)(a3 + 52);
    if ( !v11 || *(_DWORD *)(a2 + 52) == v11 )
    {
      v12 = sub_48695C(a1, 2 * (*(_DWORD *)(a2 + 8) & 0xFFF) + 1);
      v10 = -8;
      if ( v12 )
      {
        v13 = *(unsigned __int8 **)(a2 + 52);
        if ( v13[4] )
          goto LABEL_10;
        v14 = (int *)malloc(12);
        v9 = v14;
        if ( v14 )
        {
          if ( pstm_init_for_read_unsigned_bin(a1, v14, **(unsigned __int8 **)(a2 + 52)) >= 0 )
          {
            radix = pstm_read_radix(
                      a1,
                      v9,
                      *(unsigned __int8 **)(*(_DWORD *)(a2 + 52) + 20),
                      2 * **(unsigned __int8 **)(a2 + 52),
                      0x10u);
            if ( radix )
            {
              pstm_clear(v9);
              free2(v9);
              v16 = v12;
LABEL_14:
              pstm_clear(v16);
              pstm_clear(v12 + 3);
              pstm_clear(v12 + 6);
              free2(v12);
              return radix;
            }
            v13 = *(unsigned __int8 **)(a2 + 52);
LABEL_10:
            radix = pstm_init_for_read_unsigned_bin(a1, v21, *v13);
            if ( radix )
            {
              if ( v9 )
              {
                pstm_clear(v9);
                free2(v9);
              }
            }
            else
            {
              radix = pstm_read_radix(
                        a1,
                        v21,
                        *(unsigned __int8 **)(*(_DWORD *)(a2 + 52) + 16),
                        2 * **(unsigned __int8 **)(a2 + 52),
                        0x10u);
              if ( !radix )
              {
                radix = sub_489B40(a1, a2, (int *)(a3 + 12), v12, (int)v21, 1u, v9);
                if ( !radix )
                {
                  v18 = pstm_unsigned_bin_size(v21);
                  radix = -9;
                  if ( (unsigned __int16)*a5 < v18
                    || (memset(a4, 0, v18),
                        v19 = pstm_unsigned_bin_size(v12),
                        (radix = pstm_to_unsigned_bin(a1, v12, v18 - v19 + a4)) == 0) )
                  {
                    *a5 = v18;
                  }
                }
              }
              if ( v9 )
              {
                pstm_clear(v9);
                free2(v9);
              }
              pstm_clear(v21);
            }
            v16 = v12;
            goto LABEL_14;
          }
          free2(v9);
          v20 = v12;
        }
        else
        {
          v20 = v12;
        }
        pstm_clear(v20);
        pstm_clear(v12 + 3);
        pstm_clear(v12 + 6);
        free2(v12);
        return -8;
      }
    }
  }
  return v10;
}
// 48A5B8: conditional instruction was optimized away because $s0.4!=0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (0048A848) --------------------------------------------------------
int   psEccGenKey(int a1, int a2, unsigned __int8 *a3)
{
  int v6; // $s1
  _BYTE *v7; // $s6
  int radix; // $s5
  _DWORD *v9; // $s1
  _DWORD *v10; // $s0
  _DWORD *v12; // $s2
  int *v13; // $s7
  unsigned __int8 *v14; // $a2
  int v15[4]; // [sp+28h] [-38h] BYREF
  int v16[4]; // [sp+38h] [-28h] BYREF
  int v17[4]; // [sp+48h] [-18h] BYREF
  int *v18; // [sp+58h] [-8h]
  _DWORD *v19; // [sp+5Ch] [-4h]

  v18 = 0;
  if ( !a2 || !a3 )
    return -10;
  memset(a2, 0, 64);
  *(_DWORD *)(a2 + 56) = a1;
  *(_DWORD *)(a2 + 48) = a1;
  *(_DWORD *)(a2 + 52) = a3;
  v6 = *a3;
  v7 = (_BYTE *)malloc(132);
  if ( !v7 )
  {
    psTraceStr("psError %s", (int)"pubkey/ecc.c");
    psTraceInt(":%d ", 506);
    radix = -8;
    psError((int)"Memory allocation error in psEccGenKey\n");
    v12 = (_DWORD *)(a2 + 12);
    v9 = (_DWORD *)(a2 + 24);
    v10 = (_DWORD *)(a2 + 36);
    goto LABEL_16;
  }
  if ( pstm_init_for_read_unsigned_bin(a1, v16, v6) < 0 )
    goto LABEL_20;
  radix = pstm_read_radix(a1, v16, *(unsigned __int8 **)(*(_DWORD *)(a2 + 52) + 28), 2 * v6, 0x10u);
  if ( radix )
  {
    pstm_clear(v16);
    v12 = (_DWORD *)(a2 + 12);
    goto LABEL_13;
  }
  while ( 1 )
  {
    if ( psGetPrngLocked((int)v7, v6) != v6 )
    {
      pstm_clear(v16);
      radix = -7;
      v12 = (_DWORD *)(a2 + 12);
      goto LABEL_13;
    }
    if ( pstm_init_for_read_unsigned_bin(a1, v17, v6) < 0 )
    {
      pstm_clear(v16);
      goto LABEL_20;
    }
    radix = pstm_read_unsigned_bin(v17, v7, v6);
    if ( radix )
    {
      pstm_clear(v16);
      v12 = (_DWORD *)(a2 + 12);
      pstm_clear(v17);
      v9 = (_DWORD *)(a2 + 24);
      goto LABEL_14;
    }
    if ( pstm_cmp(v17, v16) != 1 )
      break;
    pstm_clear(v17);
  }
  pstm_clear(v17);
  pstm_clear(v16);
  if ( *(_BYTE *)(*(_DWORD *)(a2 + 52) + 4) )
    goto LABEL_24;
  v18 = (int *)malloc(12);
  if ( !v18 )
  {
LABEL_20:
    radix = -8;
    v12 = (_DWORD *)(a2 + 12);
    goto LABEL_13;
  }
  if ( pstm_init_for_read_unsigned_bin(a1, v18, v6) < 0 )
  {
    radix = -8;
    free2(v18);
    v12 = (_DWORD *)(a2 + 12);
LABEL_13:
    v9 = (_DWORD *)(a2 + 24);
LABEL_14:
    v10 = (_DWORD *)(a2 + 36);
    goto LABEL_15;
  }
  radix = pstm_read_radix(a1, v18, *(unsigned __int8 **)(*(_DWORD *)(a2 + 52) + 20), 2 * v6, 0x10u);
  if ( radix )
    goto LABEL_42;
LABEL_24:
  radix = -8;
  if ( pstm_init_for_read_unsigned_bin(a1, v15, v6) < 0 )
  {
LABEL_42:
    v12 = (_DWORD *)(a2 + 12);
    v9 = (_DWORD *)(a2 + 24);
    v10 = (_DWORD *)(a2 + 36);
    goto LABEL_43;
  }
  v13 = sub_48695C(a1, ((unsigned int)v15[2] >> 12) & 0xFFF);
  if ( !v13 )
  {
    radix = -8;
    v12 = (_DWORD *)(a2 + 12);
    v9 = (_DWORD *)(a2 + 24);
    v10 = (_DWORD *)(a2 + 36);
    goto LABEL_49;
  }
  radix = pstm_read_radix(a1, v15, *(unsigned __int8 **)(*(_DWORD *)(a2 + 52) + 16), 2 * v6, 0x10u);
  if ( radix
    || (radix = pstm_read_radix(a1, v13, *(unsigned __int8 **)(*(_DWORD *)(a2 + 52) + 32), 2 * v6, 0x10u)) != 0
    || (v14 = *(unsigned __int8 **)(*(_DWORD *)(a2 + 52) + 36),
        v19 = v13 + 3,
        (radix = pstm_read_radix(a1, v13 + 3, v14, 2 * v6, 0x10u)) != 0)
    || (pstm_set((int)(v13 + 6), 1), radix = -8, pstm_init_for_read_unsigned_bin(a1, (int *)a2, v6) < 0)
    || (radix = pstm_read_unsigned_bin((int *)a2, v7, v6)) != 0 )
  {
    v12 = (_DWORD *)(a2 + 12);
    goto LABEL_46;
  }
  v12 = (_DWORD *)(a2 + 12);
  radix = -8;
  if ( pstm_init_size(a1, (int *)(a2 + 12), 2 * (*(_WORD *)(a2 + 8) & 0xFFF) + 1) < 0 )
  {
LABEL_46:
    v9 = (_DWORD *)(a2 + 24);
    goto LABEL_47;
  }
  v9 = (_DWORD *)(a2 + 24);
  radix = -8;
  if ( pstm_init_size(a1, (int *)(a2 + 24), 2 * (*(_DWORD *)(a2 + 8) & 0xFFF) + 1) < 0 )
  {
LABEL_47:
    v10 = (_DWORD *)(a2 + 36);
LABEL_48:
    pstm_clear(v13);
    pstm_clear(v13 + 3);
    pstm_clear(v13 + 6);
    free2(v13);
LABEL_49:
    pstm_clear(v15);
LABEL_43:
    if ( v18 )
    {
      pstm_clear(v18);
      free2(v18);
    }
LABEL_15:
    free2(v7);
LABEL_16:
    if ( !a2 )
    {
      psTraceStr("psAssert %s", (int)"pubkey/ecc.c");
      psTraceInt(":%d ", 255);
      psError((int)"key");
    }
    pstm_clear((_DWORD *)a2);
    pstm_clear_multi(v12, v9, v10, 0, 0, 0, 0, 0);
    *(_BYTE *)(a2 + 60) = 0;
    *(_DWORD *)(a2 + 52) = 0;
    *(_DWORD *)(a2 + 56) = 0;
    *(_DWORD *)(a2 + 48) = 0;
    return radix;
  }
  v10 = (_DWORD *)(a2 + 36);
  radix = -8;
  if ( pstm_init_size(a1, (int *)(a2 + 36), 2 * (*(_WORD *)(a2 + 8) & 0xFFF) + 1) < 0 )
    goto LABEL_48;
  radix = sub_489B40(a1, a2, v13, (int *)(a2 + 12), (int)v15, 1u, v18);
  if ( radix )
    goto LABEL_48;
  *(_BYTE *)(a2 + 60) = 2;
  pstm_clear(v13);
  pstm_clear(v19);
  pstm_clear(v13 + 6);
  free2(v13);
  pstm_clear(v15);
  if ( v18 )
  {
    pstm_clear(v18);
    free2(v18);
  }
  free2(v7);
  return 0;
}
// 48AFCC: conditional instruction was optimized away because $s7.4!=0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (0048B080) --------------------------------------------------------
int   psEccDsaVerify(
        int a1,
        int a2,
        _BYTE *a3,
        unsigned __int16 a4,
        unsigned __int8 *a5,
        unsigned __int16 a6,
        _DWORD *a7)
{
  __int16 v9; // $s0
  unsigned int v10; // $s2
  int *v11; // $fp
  int AsnSequence; // $v1
  int v13; // $s0
  unsigned __int8 *v14; // $t3
  unsigned __int16 v15; // $a2
  int radix; // $s4
  int *v17; // $s5
  int *v18; // $s0
  unsigned __int8 *v19; // $a2
  int *v21; // $v0
  int v22[4]; // [sp+28h] [-A8h] BYREF
  int v23[2]; // [sp+38h] [-98h] BYREF
  unsigned int v24; // [sp+40h] [-90h]
  int v25[4]; // [sp+48h] [-88h] BYREF
  int v26[4]; // [sp+58h] [-78h] BYREF
  int v27[4]; // [sp+68h] [-68h] BYREF
  int v28[4]; // [sp+78h] [-58h] BYREF
  int *v29[4]; // [sp+88h] [-48h] BYREF
  int v30[2]; // [sp+98h] [-38h] BYREF
  unsigned int v31; // [sp+A0h] [-30h]
  int v32[2]; // [sp+A8h] [-28h] BYREF
  unsigned int v33; // [sp+B0h] [-20h]
  __int16 v34; // [sp+B8h] [-18h] BYREF
  unsigned __int8 *v35; // [sp+BCh] [-14h] BYREF
  int v36; // [sp+C0h] [-10h] BYREF
  int v37; // [sp+C4h] [-Ch]
  int v38; // [sp+C8h] [-8h]

  *a7 = -1;
  v35 = a5;
  v9 = a6 + (_WORD)a5;
  v10 = a4;
  v11 = 0;
  AsnSequence = getAsnSequence(&v35, a6, &v34);
  if ( AsnSequence >= 0 )
  {
    AsnSequence = pstm_read_asn(a1, &v35, v9 - (_WORD)v35, v30);
    if ( AsnSequence >= 0 )
    {
      v13 = pstm_read_asn(a1, &v35, v9 - (_WORD)v35, v32);
      if ( v13 < 0 )
      {
        pstm_clear(v30);
        return v13;
      }
      v14 = *(unsigned __int8 **)(a2 + 52);
      v15 = *v14;
      v37 = 2 * *v14;
      if ( pstm_init_for_read_unsigned_bin(a1, v28, v15) < 0 )
      {
        pstm_clear(v32);
        pstm_clear(v30);
        return -8;
      }
      radix = -8;
      if ( pstm_init_for_read_unsigned_bin(a1, (int *)v29, **(unsigned __int8 **)(a2 + 52)) < 0 )
        goto LABEL_24;
      if ( pstm_init_size(a1, v22, (*(_DWORD *)(a2 + 20) >> 12) & 0xFFF) < 0 )
      {
LABEL_23:
        pstm_clear(v29);
LABEL_24:
        pstm_clear(v28);
        pstm_clear(v32);
        pstm_clear(v30);
        return radix;
      }
      if ( pstm_init_size(a1, v23, (v33 >> 12) & 0xFFF) < 0 )
      {
LABEL_22:
        pstm_clear(v22);
        goto LABEL_23;
      }
      if ( **(unsigned __int8 **)(a2 + 52) < v10 )
        LOWORD(v10) = **(unsigned __int8 **)(a2 + 52);
      if ( pstm_init_for_read_unsigned_bin(a1, v27, v10) < 0 )
      {
LABEL_21:
        pstm_clear(v23);
        goto LABEL_22;
      }
      if ( pstm_init_size(a1, v25, (((unsigned int)v27[2] >> 12) & 0xFFF) + ((v24 >> 12) & 0xFFF)) < 0 )
      {
LABEL_20:
        pstm_clear(v27);
        goto LABEL_21;
      }
      if ( pstm_init_size(a1, v26, ((v31 >> 12) & 0xFFF) + ((v24 >> 12) & 0xFFF)) < 0 )
      {
LABEL_19:
        pstm_clear(v25);
        goto LABEL_20;
      }
      v17 = sub_48695C(a1, (*(_DWORD *)(a2 + 20) >> 11) & 0x1FFE);
      if ( !v17 )
      {
LABEL_18:
        pstm_clear(v26);
        goto LABEL_19;
      }
      v18 = sub_48695C(a1, (*(_DWORD *)(a2 + 20) >> 11) & 0x1FFE);
      if ( !v18 )
      {
LABEL_17:
        pstm_clear(v17);
        pstm_clear(v17 + 3);
        pstm_clear(v17 + 6);
        free2(v17);
        goto LABEL_18;
      }
      v19 = *(unsigned __int8 **)(*(_DWORD *)(a2 + 52) + 28);
      v38 = (unsigned __int16)v37;
      radix = pstm_read_radix(a1, v28, v19, v37, 0x10u);
      if ( !radix )
      {
        radix = pstm_read_radix(a1, (int *)v29, *(unsigned __int8 **)(*(_DWORD *)(a2 + 52) + 16), v38, 0x10u);
        if ( !radix )
        {
          if ( (v31 & 0xFFF) != 0 && (v33 & 0xFFF) != 0 && pstm_cmp(v30, v28) == -1 )
          {
            radix = -31;
            if ( pstm_cmp(v32, v28) == -1 )
            {
              radix = pstm_read_unsigned_bin(v27, a3, v10);
              if ( !radix )
              {
                radix = pstm_invmod(a1, (int)v32, v28, v23);
                if ( !radix )
                {
                  radix = pstm_mulmod(a1, v27, v23, (int)v28, v25);
                  if ( !radix )
                  {
                    radix = pstm_mulmod(a1, v30, v23, (int)v28, v26);
                    if ( !radix )
                    {
                      radix = pstm_read_radix(a1, v17, *(unsigned __int8 **)(*(_DWORD *)(a2 + 52) + 32), v38, 0x10u);
                      if ( !radix )
                      {
                        radix = pstm_read_radix(
                                  a1,
                                  v17 + 3,
                                  *(unsigned __int8 **)(*(_DWORD *)(a2 + 52) + 36),
                                  v38,
                                  0x10u);
                        if ( !radix )
                        {
                          pstm_set((int)(v17 + 6), 1);
                          radix = pstm_copy(a2 + 12, v18);
                          if ( !radix )
                          {
                            radix = pstm_copy(a2 + 24, v18 + 3);
                            if ( !radix )
                            {
                              radix = pstm_copy(a2 + 36, v18 + 6);
                              if ( !radix )
                              {
                                if ( *(_BYTE *)(*(_DWORD *)(a2 + 52) + 4) )
                                  goto LABEL_46;
                                v21 = (int *)malloc(12);
                                v11 = v21;
                                if ( v21 )
                                {
                                  if ( pstm_init_for_read_unsigned_bin(a1, v21, **(unsigned __int8 **)(a2 + 52)) < 0
                                    || (radix = pstm_read_radix(
                                                  a1,
                                                  v11,
                                                  *(unsigned __int8 **)(*(_DWORD *)(a2 + 52) + 20),
                                                  2 * **(unsigned __int8 **)(a2 + 52),
                                                  0x10u)) != 0 )
                                  {
LABEL_54:
                                    if ( v11 )
                                    {
                                      pstm_clear(v11);
                                      free2(v11);
                                    }
                                    goto LABEL_16;
                                  }
LABEL_46:
                                  radix = sub_489B40(a1, (int)v25, v17, v17, (int)v29, 0, v11);
                                  if ( !radix )
                                  {
                                    radix = sub_489B40(a1, (int)v26, v18, v18, (int)v29, 0, v11);
                                    if ( !radix )
                                    {
                                      radix = pstm_montgomery_setup(v29, &v36);
                                      if ( !radix )
                                      {
                                        radix = sub_4889CC(a1, v18, v17, v17, (int *)v29, &v36, v11);
                                        if ( !radix )
                                        {
                                          radix = sub_489818(a1, v17, (int *)v29, &v36);
                                          if ( !radix )
                                          {
                                            radix = pstm_mod(a1, (int)v17, (int)v28, v22);
                                            if ( !radix && !pstm_cmp(v22, v30) )
                                              *a7 = 1;
                                          }
                                        }
                                      }
                                    }
                                  }
                                  goto LABEL_54;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          else
          {
            radix = -31;
          }
        }
      }
LABEL_16:
      pstm_clear(v18);
      pstm_clear(v18 + 3);
      pstm_clear(v18 + 6);
      free2(v18);
      goto LABEL_17;
    }
  }
  return AsnSequence;
}
// 48B344: conditional instruction was optimized away because $s0.4!=0
// 48B3A8: conditional instruction was optimized away because $s5.4!=0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (0048B96C) --------------------------------------------------------
int   psEccDsaSign(int a1, int a2, _BYTE *a3, unsigned __int16 a4, _BYTE *a5, _WORD *a6, unsigned __int8 a7)
{
  int v7; // $v1
  unsigned int v10; // $s1
  int radix; // $s0
  int v13; // $a1
  unsigned int v14; // $a3
  int unsigned_bin; // $v0
  unsigned __int16 v16; // $s3
  unsigned int v17; // $s3
  BOOL v18; // $t7
  int v21; // $s1
  int v22; // $s5
  int v23; // $v1
  unsigned int v24; // $a0
  _BYTE *v25; // $a2
  _BYTE *v26; // $s3
  _BYTE *v27; // $a2
  int v28; // $v0
  int v29[3]; // [sp+28h] [-90h] BYREF
  _DWORD v30[3]; // [sp+34h] [-84h] BYREF
  _DWORD v31[3]; // [sp+40h] [-78h] BYREF
  _DWORD v32[3]; // [sp+4Ch] [-6Ch] BYREF
  int v33; // [sp+58h] [-60h]
  int v34; // [sp+5Ch] [-5Ch]
  int v35; // [sp+60h] [-58h]
  char v36; // [sp+64h] [-54h]
  int v37[2]; // [sp+68h] [-50h] BYREF
  int v38; // [sp+70h] [-48h]
  int v39[2]; // [sp+78h] [-40h] BYREF
  int v40; // [sp+80h] [-38h]
  int v41[4]; // [sp+88h] [-30h] BYREF
  int v42[2]; // [sp+98h] [-20h] BYREF
  unsigned int v43; // [sp+A0h] [-18h]
  int v44; // [sp+A8h] [-10h]
  int v45; // [sp+ACh] [-Ch]
  int v46; // [sp+B0h] [-8h]

  v7 = *(unsigned __int8 *)(a2 + 60);
  v44 = a7;
  v10 = a4;
  radix = -8;
  v46 = 0;
  v45 = 0;
  v13 = -6;
  if ( v7 == 2 )
  {
    v14 = **(unsigned __int8 **)(a2 + 52);
    if ( v14 < v10 )
      LOWORD(v10) = **(unsigned __int8 **)(a2 + 52);
    v16 = 2 * v14;
    unsigned_bin = pstm_init_for_read_unsigned_bin(a1, v42, **(unsigned __int8 **)(a2 + 52));
    v13 = -8;
    if ( unsigned_bin >= 0 )
    {
      if ( pstm_init_for_read_unsigned_bin(a1, v41, v10) < 0 )
      {
LABEL_20:
        pstm_clear(v42);
        return radix;
      }
      if ( pstm_init_size(a1, v37, (v43 >> 12) & 0xFFF) < 0 )
      {
LABEL_19:
        pstm_clear(v41);
        goto LABEL_20;
      }
      if ( pstm_init_size(a1, v39, (v43 >> 12) & 0xFFF) < 0 )
      {
LABEL_18:
        pstm_clear(v37);
        goto LABEL_19;
      }
      radix = pstm_read_radix(a1, v42, *(unsigned __int8 **)(*(_DWORD *)(a2 + 52) + 28), v16, 0x10u);
      if ( !radix )
      {
        radix = pstm_read_unsigned_bin(v41, a3, v10);
        v17 = 0;
        if ( !radix )
        {
          while ( 2 )
          {
            v18 = v17 < 0x64;
            do
            {
              ++v17;
              if ( !v18 )
              {
LABEL_16:
                radix = -7;
                goto LABEL_17;
              }
              while ( 1 )
              {
                radix = psEccGenKey(a1, (int)v29, *(unsigned __int8 **)(a2 + 52));
                if ( radix )
                  goto LABEL_17;
                radix = pstm_mod(a1, (int)v30, (int)v42, v37);
                if ( radix )
                  goto LABEL_50;
                if ( (v38 & 0xFFF) != 0 )
                  break;
                pstm_clear(v29);
                pstm_clear_multi(v30, v31, v32, 0, 0, 0, 0, 0);
                v34 = 0;
                v35 = 0;
                v33 = 0;
                v36 = 0;
                if ( v17++ >= 0x64 )
                  goto LABEL_16;
              }
              radix = pstm_invmod(a1, (int)v29, v42, v29);
              if ( radix )
                goto LABEL_50;
              radix = pstm_mulmod(a1, (int *)a2, v37, (int)v42, v39);
              if ( radix )
                goto LABEL_50;
              radix = pstm_add(v41, v39, v39);
              if ( radix )
                goto LABEL_50;
              radix = pstm_mod(a1, (int)v39, (int)v42, v39);
              if ( radix )
                goto LABEL_50;
              radix = pstm_mulmod(a1, v39, v29, (int)v42, v39);
              if ( radix )
                goto LABEL_50;
              pstm_clear(v29);
              pstm_clear_multi(v30, v31, v32, 0, 0, 0, 0, 0);
              v34 = 0;
              v35 = 0;
              v33 = 0;
              v36 = 0;
              v21 = pstm_unsigned_bin_size(v37);
              v22 = pstm_unsigned_bin_size(v39);
              v23 = **(unsigned __int8 **)(a2 + 52);
              v18 = v17 < 0x64;
            }
            while ( v21 + 6 < v23 || v22 + 6 < v23 );
            if ( (v40 & 0xFFF) == 0 )
              continue;
            break;
          }
          if ( *(char *)(v21 + v37[0] - 1) < 0 )
          {
            v21 = (unsigned __int16)(v21 + 1);
            v45 = 1;
          }
          if ( *(char *)(v22 + v39[0] - 1) < 0 )
          {
            LOWORD(v22) = v22 + 1;
            v46 = 1;
          }
          v24 = (unsigned __int16)(v21 + v22 + 6);
          if ( (int)(v24 - 3) >= 128 )
            v24 = (unsigned __int16)(v21 + v22 + 7);
          if ( v44 )
          {
            radix = -1;
            if ( (unsigned __int16)*a6 < (int)(v24 + 2) )
              goto LABEL_17;
            *a5 = BYTE1(v24);
            a5[1] = v24;
            a5 += 2;
LABEL_39:
            *a5 = 48;
            if ( (int)(v24 - 3) < 128 )
            {
              a5[1] = v24 - 2;
              v25 = a5 + 2;
              *a6 = 0;
            }
            else
            {
              a5[1] = -127;
              a5[2] = v24 - 3;
              v25 = a5 + 3;
              *a6 = 1;
            }
            *v25 = 2;
            v25[1] = v21;
            v26 = v25 + 2;
            if ( v44 )
              *a6 += 6;
            else
              *a6 += 4;
            if ( v45 )
            {
              *v26 = 0;
              v26 = v25 + 3;
            }
            radix = pstm_to_unsigned_bin(a1, v37, (int)v26);
            if ( !radix )
            {
              v27 = &v26[v21 - v45];
              *a6 += v21;
              *v27 = 2;
              v27[1] = v22;
              v28 = (int)(v27 + 2);
              if ( v46 )
              {
                v27[2] = 0;
                v28 = (int)(v27 + 3);
              }
              radix = pstm_to_unsigned_bin(a1, v39, v28);
              if ( !radix )
              {
                *a6 += v22 + 2;
                goto LABEL_17;
              }
LABEL_50:
              pstm_clear(v29);
              pstm_clear_multi(v30, v31, v32, 0, 0, 0, 0, 0);
              v34 = 0;
              v35 = 0;
              v33 = 0;
              v36 = 0;
              goto LABEL_17;
            }
            goto LABEL_17;
          }
          radix = -1;
          if ( (unsigned __int16)*a6 >= v24 )
            goto LABEL_39;
        }
      }
LABEL_17:
      pstm_clear(v39);
      goto LABEL_18;
    }
  }
  return v13;
}

//----- (0048C04C) --------------------------------------------------------
int   psInitPubKey(int a1, int a2, char a3)
{
  int result; // $v0

  result = -6;
  if ( a2 )
  {
    if ( a3 == 1 )
    {
      psRsaInitKey(a1, a2);
      *(_DWORD *)(a2 + 104) = a1;
    }
    else if ( a3 == 3 )
    {
      psEccInitKey(a1, (_DWORD *)a2, 0);
      *(_DWORD *)(a2 + 104) = a1;
    }
    else
    {
      *(_DWORD *)(a2 + 104) = a1;
    }
    *(_BYTE *)(a2 + 110) = a3;
    *(_WORD *)(a2 + 108) = 0;
    return 0;
  }
  return result;
}

//----- (0048C0F4) --------------------------------------------------------
void   psClearPubKey(int a1)
{
  int v2; // $v1
  void (  *v3)(int); // $t9

  if ( a1 )
  {
    v2 = *(unsigned __int8 *)(a1 + 110);
    v3 = psRsaClearKey;
    if ( v2 != 1 )
    {
      if ( v2 != 3 )
      {
        *(_BYTE *)(a1 + 110) = 0;
LABEL_5:
        *(_DWORD *)(a1 + 104) = 0;
        *(_WORD *)(a1 + 108) = 0;
        return;
      }
      v3 = psEccClearKey;
    }
    v3(a1);
    *(_BYTE *)(a1 + 110) = 0;
    goto LABEL_5;
  }
}

//----- (0048C16C) --------------------------------------------------------
int   psHashLenToSigAlg(unsigned __int16 a1, unsigned __int8 a2)
{
  int v2; // $s0
  int v3; // $s1
  int v4; // $v1
  int result; // $v0

  v2 = a2;
  v3 = a1;
  if ( a2 != 1 && a2 != 3 )
  {
    psTraceStr("psAssert %s", (int)"pubkey/pubkey.c");
    psTraceInt(":%d ", 356);
    psError((int)"key_type == PS_RSA || key_type == PS_ECC");
  }
  switch ( v3 )
  {
    case 16:
      v4 = -6;
      if ( v2 == 1 )
        goto LABEL_7;
      goto LABEL_6;
    case 20:
      v4 = 1673;
      if ( v2 == 1 )
        goto LABEL_7;
      result = 520;
      break;
    case 32:
      v4 = 1679;
      if ( v2 == 1 )
        goto LABEL_7;
      result = 524;
      break;
    case 48:
      v4 = 1680;
      if ( v2 == 1 )
        goto LABEL_7;
      result = 525;
      break;
    case 64:
      v4 = 1681;
      if ( v2 == 1 )
        goto LABEL_7;
      result = 526;
      break;
    default:
LABEL_6:
      v4 = -10;
LABEL_7:
      result = v4;
      break;
  }
  return result;
}

//----- (0048C2F8) --------------------------------------------------------
int   psVerifySig(
        int a1,
        _BYTE *a2,
        unsigned __int16 a3,
        unsigned __int8 *a4,
        unsigned __int16 a5,
        int a6,
        int a7,
        _DWORD *a8)
{
  int v9; // $s2
  int v11; // $v1
  int result; // $v0
  _BYTE v14[64]; // [sp+28h] [-48h] BYREF
  int v15; // [sp+68h] [-8h] BYREF

  v9 = a3;
  memset(v14, 0, sizeof(v14));
  *a8 = 0;
  v11 = *(unsigned __int8 *)(a6 + 110);
  if ( v11 == 1 )
  {
    if ( pubRsaDecryptSignedElementExt(a1, a6, a4, a5, (int)v14, v9) >= 0 )
    {
      if ( memcmpct((int)a2, (int)v14, v9) )
        goto LABEL_7;
      goto LABEL_10;
    }
    return -1;
  }
  if ( v11 != 3 )
    return -10;
  if ( psEccDsaVerify(a1, a6, a2, v9, a4, a5, &v15) < 0 )
    return -1;
  if ( v15 != 1 )
  {
LABEL_7:
    result = -21;
    *a8 = 0;
    return result;
  }
LABEL_10:
  result = 0;
  *a8 = 1;
  return result;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (0048C4D8) --------------------------------------------------------
int   psRsaInitKey(int a1, int a2)
{
  int result; // $v0

  result = -8;
  if ( a2 )
  {
    memset(a2, 0, 104);
    *(_DWORD *)(a2 + 96) = a1;
    return 0;
  }
  return result;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (0048C540) --------------------------------------------------------
void   psRsaClearKey(int a1)
{
  pstm_clear((_DWORD *)(a1 + 24));
  pstm_clear((_DWORD *)a1);
  pstm_clear((_DWORD *)(a1 + 12));
  pstm_clear((_DWORD *)(a1 + 72));
  pstm_clear((_DWORD *)(a1 + 84));
  pstm_clear((_DWORD *)(a1 + 48));
  pstm_clear((_DWORD *)(a1 + 60));
  pstm_clear((_DWORD *)(a1 + 36));
  *(_DWORD *)(a1 + 96) = 0;
  *(_WORD *)(a1 + 100) = 0;
  *(_BYTE *)(a1 + 102) = 0;
}

//----- (0048C634) --------------------------------------------------------
int   psRsaCopyKey(int a1, int a2)
{
  int inited; // $s0
  __int16 v6; // $v1
  char v7; // $a0

  inited = pstm_init_copy(*(_DWORD *)(a2 + 96), (int *)(a1 + 24), a2 + 24, 0);
  if ( !inited )
  {
    inited = pstm_init_copy(*(_DWORD *)(a2 + 96), (int *)a1, a2, 0);
    if ( !inited )
    {
      inited = pstm_init_copy(*(_DWORD *)(a2 + 96), (int *)(a1 + 12), a2 + 12, 0);
      if ( !inited )
      {
        inited = pstm_init_copy(*(_DWORD *)(a2 + 96), (int *)(a1 + 72), a2 + 72, 0);
        if ( !inited )
        {
          inited = pstm_init_copy(*(_DWORD *)(a2 + 96), (int *)(a1 + 84), a2 + 84, 0);
          if ( !inited )
          {
            inited = pstm_init_copy(*(_DWORD *)(a2 + 96), (int *)(a1 + 48), a2 + 48, 0);
            if ( !inited )
            {
              inited = pstm_init_copy(*(_DWORD *)(a2 + 96), (int *)(a1 + 60), a2 + 60, 0);
              if ( !inited )
              {
                inited = pstm_init_copy(*(_DWORD *)(a2 + 96), (int *)(a1 + 36), a2 + 36, 0);
                if ( !inited )
                {
                  v6 = *(_WORD *)(a2 + 100);
                  v7 = *(_BYTE *)(a2 + 102);
                  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a2 + 96);
                  *(_WORD *)(a1 + 100) = v6;
                  *(_BYTE *)(a1 + 102) = v7;
                  return inited;
                }
              }
            }
          }
        }
      }
    }
  }
  if ( inited >= 0 )
    return inited;
  psRsaClearKey(a1);
  return inited;
}

//----- (0048C7F0) --------------------------------------------------------
int   psRsaSize(int a1)
{
  return *(unsigned __int16 *)(a1 + 100);
}

//----- (0048C7FC) --------------------------------------------------------
int   psRsaCmpPubKey(_DWORD *a1, _DWORD *a2)
{
  int v4; // $v0
  int v5; // $v1

  if ( pstm_cmp(a1 + 6, a2 + 6) )
    return -1;
  v4 = pstm_cmp(a1, a2);
  v5 = 0;
  if ( v4 )
    return -1;
  return v5;
}

//----- (0048C878) --------------------------------------------------------
int   psRsaParseAsnPubKey(int a1, unsigned __int8 **a2, unsigned __int16 a3, int a4, int a5)
{
  unsigned __int8 *v5; // $v1
  int v9; // $v0
  int v10; // $a0
  int v12; // $s0
  int AsnLength; // $v0
  __int16 v15; // $s0
  __int16 v16; // $v0
  unsigned __int8 *v17; // $t6
  __int64 v18[26]; // [sp+18h] [-D8h] BYREF
  unsigned __int16 v19; // [sp+E8h] [-8h] BYREF
  unsigned __int16 v20; // [sp+EAh] [-6h] BYREF
  unsigned __int8 *v21; // [sp+ECh] [-4h] BYREF

  v5 = *a2;
  v21 = *a2;
  if ( a3 )
  {
    v9 = *v5;
    v21 = v5 + 1;
    if ( v9 == 3 )
    {
      v12 = a3 - 1;
      AsnLength = getAsnLength(&v21, a3 - 1, &v19);
      v10 = -31;
      if ( AsnLength < 0 )
        return v10;
      if ( v12 >= v19 && !*v21++ )
      {
        v10 = -31;
        if ( !v19 )
          return v10;
        psSha1Init(v18);
        psSha1Update((int *)v18, (int)v21, v19 - 1);
        psSha1Final(v18, a5);
        if ( getAsnSequence(&v21, v19, &v20) >= 0 )
        {
          v15 = v20 + (_WORD)v21;
          if ( pstm_read_asn(a1, &v21, v20, (int *)(a4 + 24)) >= 0
            && pstm_read_asn(a1, &v21, v15 - (_WORD)v21, (int *)a4) >= 0 )
          {
            v16 = pstm_unsigned_bin_size((_DWORD *)(a4 + 24));
            v17 = v21;
            v10 = 0;
            *(_DWORD *)(a4 + 96) = a1;
            *a2 = v17;
            *(_WORD *)(a4 + 100) = v16;
            return v10;
          }
        }
      }
    }
  }
  return -31;
}

//----- (0048CA4C) --------------------------------------------------------
int   psRsaParsePkcs1PrivKey(int a1, unsigned __int8 *a2, unsigned __int16 a3, int a4)
{
  int v6; // $s0
  int result; // $v0
  unsigned __int8 *v8; // $v0
  unsigned __int16 v9; // $a1
  unsigned __int8 *v10; // $s0
  __int16 v11; // $s3
  __int16 v12; // $v0
  unsigned __int8 *v13; // $a0
  bool v14; // dc
  unsigned __int8 *v15; // $v1
  unsigned __int16 v16; // [sp+18h] [-8h] BYREF
  int v17; // [sp+1Ch] [-4h] BYREF
  unsigned __int8 *v18; // [sp+3Ch] [+1Ch] BYREF

  v18 = a2;
  v6 = a3;
  result = -8;
  if ( a4 )
  {
    memset(a4, 0, 104);
    v8 = v18;
    v9 = v6;
    *(_DWORD *)(a4 + 96) = a1;
    v10 = &v8[v6];
    if ( getAsnSequence(&v18, v9, &v16) < 0
      || (v11 = (__int16)v18, getAsnInteger((char **)&v18, (unsigned __int16)((_WORD)v10 - (_WORD)v18), &v17) < 0)
      || v17
      || pstm_read_asn(a1, &v18, (_WORD)v10 - (_WORD)v18, (int *)(a4 + 24)) < 0
      || pstm_read_asn(a1, &v18, (_WORD)v10 - (_WORD)v18, (int *)a4) < 0
      || pstm_read_asn(a1, &v18, (_WORD)v10 - (_WORD)v18, (int *)(a4 + 12)) < 0
      || pstm_read_asn(a1, &v18, (_WORD)v10 - (_WORD)v18, (int *)(a4 + 72)) < 0
      || pstm_read_asn(a1, &v18, (_WORD)v10 - (_WORD)v18, (int *)(a4 + 84)) < 0
      || pstm_read_asn(a1, &v18, (_WORD)v10 - (_WORD)v18, (int *)(a4 + 48)) < 0
      || pstm_read_asn(a1, &v18, (_WORD)v10 - (_WORD)v18, (int *)(a4 + 60)) < 0
      || pstm_read_asn(a1, &v18, (_WORD)v10 - (_WORD)v18, (int *)(a4 + 36)) < 0
      || v16 != (unsigned __int16)((_WORD)v18 - v11) )
    {
      psRsaClearKey(a4);
      return -31;
    }
    else
    {
      *(_BYTE *)(a4 + 102) = 1;
      v12 = pstm_unsigned_bin_size((_DWORD *)(a4 + 24));
      v13 = v18;
      v14 = v10 == v18;
      *(_WORD *)(a4 + 100) = v12;
      if ( !v14 )
      {
        v16 = (_WORD)v10 - (_WORD)v13;
        if ( v13 < v10 )
        {
          do
            v15 = ++v13;
          while ( v13 < v10 );
          v18 = v15;
        }
      }
      return 0;
    }
  }
  return result;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (0048CCE8) --------------------------------------------------------
int   psRsaCrypt(int a1, int a2, _BYTE *a3, unsigned __int16 a4, _BYTE *a5, _WORD *a6, char a7)
{
  _BYTE *v10; // $s2
  int v12; // $v1
  int unsigned_bin; // $v0
  int v14; // $s1
  int v16; // $v0
  unsigned int v17; // $v0
  unsigned int v18; // $s0
  BOOL v19; // $v0
  int v20; // $v0
  int v21[4]; // [sp+28h] [-38h] BYREF
  int v22[4]; // [sp+38h] [-28h] BYREF
  int v23[4]; // [sp+48h] [-18h] BYREF
  int *v24; // [sp+58h] [-8h]

  v10 = a5;
  if ( !a3 )
    return -6;
  v12 = -6;
  if ( !a5 )
    return v12;
  if ( !a6 )
    return v12;
  if ( !a2 )
    return v12;
  v23[0] = 0;
  v22[0] = 0;
  v21[0] = 0;
  unsigned_bin = pstm_init_for_read_unsigned_bin(a1, v21, a4 + 4);
  v12 = -1;
  if ( unsigned_bin )
    return v12;
  if ( pstm_read_unsigned_bin(v21, a3, a4) )
  {
    pstm_clear(v21);
    return -1;
  }
  v14 = -9;
  if ( pstm_cmp((_DWORD *)(a2 + 24), v21) != -1 )
  {
    if ( a7 == 2 )
    {
      if ( *(_BYTE *)(a2 + 102) )
      {
        v14 = -1;
        if ( pstm_init_size(a1, v22, (*(_DWORD *)(a2 + 80) >> 12) & 0xFFF) )
          goto LABEL_11;
        if ( pstm_init_size(a1, v23, (*(_DWORD *)(a2 + 92) >> 12) & 0xFFF) )
        {
          pstm_clear(v22);
          goto LABEL_11;
        }
        if ( pstm_exptmod(a1, v21, (_DWORD *)(a2 + 48), (int *)(a2 + 72), v22) )
          goto LABEL_10;
        v24 = (int *)(a2 + 84);
        if ( pstm_exptmod(a1, v21, (_DWORD *)(a2 + 60), (int *)(a2 + 84), v23)
          || pstm_sub(v22, v23, v21)
          || pstm_mulmod(a1, v21, (int *)(a2 + 36), a2 + 72, v21) )
        {
          goto LABEL_10;
        }
        v14 = -1;
        if ( pstm_mul_comba(a1, v21, v24, v21, 0, 0) )
          goto LABEL_11;
        v16 = pstm_add(v21, v23, v21);
      }
      else
      {
        v16 = pstm_exptmod(a1, v21, (_DWORD *)(a2 + 12), (int *)(a2 + 24), v21);
      }
    }
    else
    {
      if ( a7 != 1 )
      {
LABEL_10:
        v14 = -1;
        goto LABEL_11;
      }
      v16 = pstm_exptmod(a1, v21, (_DWORD *)a2, (int *)(a2 + 24), v21);
    }
    v14 = -1;
    if ( !v16 )
    {
      v17 = pstm_unsigned_bin_size((_DWORD *)(a2 + 24));
      v18 = v17;
      v14 = -1;
      if ( (unsigned __int16)*a6 >= v17 )
      {
        v19 = v17 < *(unsigned __int16 *)(a2 + 100);
        while ( v19 )
        {
          *v10 = 0;
          v19 = ++v18 < *(unsigned __int16 *)(a2 + 100);
          ++v10;
        }
        *a6 = v18;
        memset(v10, 0, v18);
        v20 = pstm_unsigned_bin_size(v21);
        v14 = 0;
        if ( pstm_to_unsigned_bin(a1, v21, (int)&v10[v18 - v20]) )
          v14 = -1;
      }
    }
  }
LABEL_11:
  if ( a7 == 2 )
  {
    if ( *(_BYTE *)(a2 + 102) )
      pstm_clear_multi(v22, v23, 0, 0, 0, 0, 0, 0);
  }
  pstm_clear(v21);
  return v14;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (0048D108) --------------------------------------------------------
int   psRsaEncryptPub(int a1, int a2, int a3, unsigned __int16 a4, _BYTE *a5, unsigned __int16 a6)
{
  unsigned int v6; // $s0
  int v9; // $t0
  _WORD v11[4]; // [sp+28h] [-8h] BYREF

  v6 = *(unsigned __int16 *)(a2 + 100);
  v11[0] = a6;
  v9 = -6;
  if ( a6 >= v6 )
  {
    v9 = pkcs1Pad(a3, a4, a5, v6, 2);
    if ( v9 >= 0 )
    {
      v9 = psRsaCrypt(a1, a2, a5, v6, a5, v11, 1);
      if ( v9 >= 0 )
        return (v11[0] == v6) - 1;
    }
  }
  return v9;
}

//----- (0048D200) --------------------------------------------------------
int   psRsaDecryptPub(int a1, int a2, _BYTE *a3, unsigned __int16 a4, _BYTE *a5, unsigned __int16 a6)
{
  int v6; // $s0
  int v8; // $v1
  unsigned __int16 v10[4]; // [sp+28h] [-8h] BYREF

  v6 = a4;
  v8 = -6;
  if ( *(unsigned __int16 *)(a2 + 100) == a4 )
  {
    v10[0] = a4;
    v8 = psRsaCrypt(a1, a2, a3, a4, a3, v10, 1);
    if ( v8 >= 0 )
    {
      v8 = -1;
      if ( v10[0] == v6 )
      {
        v8 = pkcs1Unpad(a3, v6, a5, a6, 1);
        if ( v8 >= 0 )
          return 0;
      }
    }
  }
  return v8;
}

//----- (0048D2D0) --------------------------------------------------------
int   psRsaEncryptPriv(int a1, int a2, int a3, unsigned __int16 a4, unsigned __int8 *a5, unsigned __int16 a6)
{
  unsigned int v6; // $s1
  unsigned __int8 *v8; // $s6
  unsigned __int8 *v9; // $s5
  int v10; // $a0
  unsigned int v11; // $s0
  int v12; // $v0
  int v13; // $s0
  int v15; // $v1
  int v16; // $v1
  unsigned __int16 v17; // [sp+28h] [-8h] BYREF
  unsigned __int16 v18[3]; // [sp+2Ah] [-6h] BYREF

  v6 = a4;
  v17 = a6;
  v8 = 0;
  v9 = 0;
  v10 = -6;
  if ( a4 >= 0x1Cu )
  {
    v11 = *(unsigned __int16 *)(a2 + 100);
    if ( a6 >= v11 )
    {
      v10 = pkcs1Pad(a3, a4, a5, v11, 1);
      if ( v10 >= 0 )
      {
        v10 = psRsaCrypt(a1, a2, a5, v11, a5, &v17, 2);
        if ( v10 >= 0 )
        {
          if ( v17 != v11 )
            goto LABEL_9;
          v8 = (unsigned __int8 *)malloc(v6);
          if ( !v8 )
            goto LABEL_9;
          v12 = malloc(v17);
          v9 = (unsigned __int8 *)v12;
          if ( v12
            && (memcpy(v12, a5, v17), v13 = *(unsigned __int16 *)(a2 + 100), v13 == v17)
            && (v18[0] = v17, v15 = psRsaCrypt(a1, a2, v9, v17, v9, v18, 1), v15 >= 0)
            && v18[0] == v13
            && (v16 = pkcs1Unpad(v9, v18[0], v8, v6, 1), v16 >= 0)
            && !memcmpct(a3, (int)v8, v6) )
          {
            memset_s(v8, v6, 0, v6);
            free2(v8);
            memset_s(v9, v17, 0, v17);
            free2(v9);
            return 0;
          }
          else
          {
LABEL_9:
            memset_s(a5, a6, 0, a6);
            if ( v9 )
            {
              memset_s(v9, v17, 0, v17);
              free2(v9);
            }
            if ( v8 )
            {
              memset_s(v8, v6, 0, v6);
              free2(v8);
            }
            return -1;
          }
        }
      }
    }
  }
  return v10;
}
// 48D5E0: conditional instruction was optimized away because $v1.4<0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0048D5F0) --------------------------------------------------------
int   privRsaEncryptSignedElement(
        int a1,
        int a2,
        int a3,
        unsigned __int16 a4,
        unsigned __int8 *a5,
        unsigned __int16 a6)
{
  int v8; // $a1
  int result; // $v0
  char *v10; // $a0
  int v11; // $a2
  unsigned __int16 v12; // $s0
  int v13; // [sp+28h] [-58h] BYREF
  int v14; // [sp+2Ch] [-54h]
  int v15; // [sp+30h] [-50h]
  int v16; // [sp+34h] [-4Ch] BYREF
  __int16 v17; // [sp+38h] [-48h]
  char v18; // [sp+3Ah] [-46h]
  _BYTE v19[69]; // [sp+3Bh] [-45h] BYREF

  if ( a4 == 32 )
  {
    v16 = 83952132;
    v8 = a3;
    v10 = v19;
    v11 = 32;
    v12 = 51;
    v13 = 221262128;
    v14 = -2040526586;
    v15 = 56951112;
    v17 = 1024;
    v18 = 32;
  }
  else if ( a4 >= 0x21u )
  {
    result = -10;
    if ( a4 != 48 )
      return result;
    v14 = -2040526586;
    v16 = 84017668;
    v8 = a3;
    v10 = v19;
    v11 = 48;
    v12 = 67;
    v13 = 221266224;
    v15 = 56951112;
    v17 = 1024;
    v18 = 48;
  }
  else
  {
    v8 = a3;
    if ( a4 != 20 )
      return -10;
    v13 = 154149168;
    LOWORD(v16) = 1024;
    v14 = 237700358;
    v15 = 85590531;
    BYTE2(v16) = 20;
    v10 = (char *)&v16 + 3;
    v11 = 20;
    v12 = 35;
  }
  memcpy(v10, v8, v11);
  if ( psRsaEncryptPriv(a1, a2, (int)&v13, v12, a5, a6) < 0 )
  {
    memset_s((unsigned __int8 *)&v13, 0x53u, 0, 0x53u);
    return -7;
  }
  else
  {
    memset_s((unsigned __int8 *)&v13, 0x53u, 0, 0x53u);
    return 0;
  }
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0048D7F0) --------------------------------------------------------
int   pubRsaDecryptSignedElementExt(
        int a1,
        int a2,
        _BYTE *a3,
        unsigned __int16 a4,
        int a5,
        unsigned __int16 a6)
{
  int v9; // $s1
  int v10; // $s2
  unsigned __int8 *v11; // $s3
  int result; // $v0
  int v13; // $s0
  unsigned __int8 *v14; // $s0
  char *v15; // $a0
  int v16; // $fp
  __int16 v17; // $a0
  __int16 v18; // [sp+28h] [-10h] BYREF
  __int16 v19; // [sp+2Ah] [-Eh] BYREF
  unsigned __int16 v20; // [sp+2Ch] [-Ch] BYREF
  unsigned __int8 *v21; // [sp+30h] [-8h] BYREF
  int v22; // [sp+34h] [-4h] BYREF

  v9 = a4;
  v10 = 51;
  if ( a6 != 32 )
  {
    v10 = 35;
    if ( a6 != 20 )
    {
      v10 = 67;
      if ( a6 != 48 )
      {
        v10 = 83;
        if ( a6 != 64 )
          return -1;
      }
    }
  }
  v11 = (unsigned __int8 *)malloc(v10);
  v21 = v11;
  result = -8;
  if ( v11 )
  {
    v13 = -6;
    if ( *(unsigned __int16 *)(a2 + 100) == v9 )
    {
      v20 = v9;
      v13 = psRsaCrypt(a1, a2, a3, v9, a3, &v20, 1);
      if ( v13 >= 0 )
      {
        v13 = -1;
        if ( v20 == v9 )
        {
          v13 = pkcs1Unpad(a3, v9, v11, v10, 1);
          if ( v13 >= 0 )
          {
            v14 = &v21[v10];
            if ( getAsnSequence(&v21, v10, &v18) < 0
              || getAsnAlgorithmIdentifier(
                   (unsigned int **)&v21,
                   (unsigned __int16)((_WORD)v14 - (_WORD)v21),
                   &v22,
                   &v19) < 0 )
            {
LABEL_23:
              free2(v11);
              return -1;
            }
            switch ( v22 )
            {
              case 414:
                if ( a6 == 32 )
                  goto LABEL_21;
                psTraceStr("psAssert %s", (int)"pubkey/rsa.c");
                psTraceInt(":%d ", 142);
                v15 = "outlen == SHA256_HASH_SIZE";
                break;
              case 88:
                if ( a6 == 20 )
                  goto LABEL_21;
                psTraceStr("psAssert %s", (int)"pubkey/rsa.c");
                psTraceInt(":%d ", 146);
                v15 = "outlen == SHA1_HASH_SIZE";
                break;
              case 415:
                if ( a6 == 48 )
                  goto LABEL_21;
                psTraceStr("psAssert %s", (int)"pubkey/rsa.c");
                psTraceInt(":%d ", 150);
                v15 = "outlen == SHA384_HASH_SIZE";
                break;
              case 649:
                if ( a6 == 16 )
                  goto LABEL_21;
                psTraceStr("psAssert %s", (int)"pubkey/rsa.c");
                psTraceInt(":%d ", 161);
                v15 = "outlen == MD5_HASH_SIZE";
                break;
              default:
                if ( a6 == 64 )
                {
LABEL_21:
                  if ( v14 - v21 > 0 )
                  {
                    v16 = *v21;
                    v17 = (_WORD)v21++ + 1;
                    if ( v16 == 4 && getAsnLength(&v21, (_WORD)v14 - v17, &v18) >= 0 && v14 - v21 == a6 )
                    {
                      memcpy(a5, v21, a6);
                      free2(v11);
                      return 0;
                    }
                  }
                  goto LABEL_23;
                }
                psTraceStr("psAssert %s", (int)"pubkey/rsa.c");
                psTraceInt(":%d ", 166);
                v15 = "outlen == SHA512_HASH_SIZE";
                break;
            }
            psError((int)v15);
            goto LABEL_21;
          }
        }
      }
    }
    free2(v11);
    return v13;
  }
  return result;
}
// 48DA7C: conditional instruction was optimized away because $s0.4<0
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0048DC58) --------------------------------------------------------
int   pubRsaDecryptSignedElement(int a1, int a2, _BYTE *a3, unsigned __int16 a4, int a5, unsigned __int16 a6)
{
  int result; // $v0

  result = psHashLenToSigAlg(a6, 1u);
  if ( result >= 0 )
    return pubRsaDecryptSignedElementExt(a1, a2, a3, a4, a5, a6);
  return result;
}

//----- (0048DD34) --------------------------------------------------------
int   psRsaDecryptPriv(int a1, int a2, _BYTE *a3, unsigned __int16 a4, _BYTE *a5, unsigned __int16 a6)
{
  int v6; // $s1
  int v8; // $s0
  unsigned __int16 v10[4]; // [sp+28h] [-8h] BYREF

  v6 = a4;
  v8 = -6;
  if ( *(unsigned __int16 *)(a2 + 100) == a4 )
  {
    v10[0] = a4;
    v8 = psRsaCrypt(a1, a2, a3, a4, a3, v10, 2);
    if ( v8 >= 0 )
    {
      v8 = -1;
      if ( v10[0] == v6 )
      {
        v8 = pkcs1Unpad(a3, v6, a5, a6, 2);
        memset(a3, 0, v6);
      }
    }
  }
  return v8;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (0048DE1C) --------------------------------------------------------
int   psAesEncryptBlock(int a1, unsigned int *a2, _BYTE *a3)
{
  _DWORD *v3; // $t7
  unsigned int v4; // $s1
  unsigned int v5; // $s2
  unsigned int v6; // $s0
  unsigned int v7; // $t0
  unsigned int v8; // $t3
  unsigned __int64 v9; // kr08_8
  int v10; // $a1
  int v11; // $t8
  int v12; // $s3
  int v13; // $t5
  unsigned int v14; // $s5
  unsigned int v15; // $s3
  int v16; // $t4
  int v17; // $t1
  unsigned int v18; // $s4
  int v19; // $v1
  unsigned int v20; // $t1
  int v21; // $s4
  int v22; // $t8
  unsigned int v23; // $a0
  int v24; // $t3
  int v25; // $a0
  int v26; // $t3
  int v27; // $t1
  int v28; // $t5
  unsigned int v29; // $s4
  int v30; // $t8
  int v31; // $s2
  int i; // [sp+1Ch] [-14h]

  v3 = (_DWORD *)a1;
  v4 = _byteswap_ulong(*a2) ^ *(_DWORD *)a1;
  v5 = _byteswap_ulong(a2[1]) ^ *(_DWORD *)(a1 + 4);
  v6 = _byteswap_ulong(a2[2]) ^ *(_DWORD *)(a1 + 8);
  v7 = _byteswap_ulong(a2[3]) ^ *(_DWORD *)(a1 + 12);
  for ( i = 0; ; ++i )
  {
    v8 = dword_4A1E10[(unsigned __int8)v4];
    v3 += 4;
    v9 = (unsigned __int64)dword_4A1E10[(unsigned __int8)v6] << 8;
    v10 = dword_4A1E10[HIBYTE(v4)]
        ^ ((*(unsigned int *)((char *)dword_4A1E10 + ((v5 >> 14) & 0x3FC)) << 24)
         | (*(unsigned int *)((char *)dword_4A1E10 + ((v5 >> 14) & 0x3FC)) >> 8))
        ^ ((*(unsigned int *)((char *)dword_4A1E10 + ((v6 >> 6) & 0x3FC)) << 16)
         | HIWORD(*(unsigned int *)((char *)dword_4A1E10 + ((v6 >> 6) & 0x3FC))))
        ^ ((dword_4A1E10[(unsigned __int8)v7] << 8) | HIBYTE(dword_4A1E10[(unsigned __int8)v7]));
    v11 = dword_4A1E10[HIBYTE(v5)]
        ^ ((*(unsigned int *)((char *)dword_4A1E10 + ((v6 >> 14) & 0x3FC)) << 24)
         | (*(unsigned int *)((char *)dword_4A1E10 + ((v6 >> 14) & 0x3FC)) >> 8))
        ^ ((*(unsigned int *)((char *)dword_4A1E10 + ((v7 >> 6) & 0x3FC)) << 16)
         | HIWORD(*(unsigned int *)((char *)dword_4A1E10 + ((v7 >> 6) & 0x3FC))));
    v12 = v3[3];
    v6 = dword_4A1E10[HIBYTE(v6)]
       ^ ((*(unsigned int *)((char *)dword_4A1E10 + ((v7 >> 14) & 0x3FC)) << 24)
        | (*(unsigned int *)((char *)dword_4A1E10 + ((v7 >> 14) & 0x3FC)) >> 8))
       ^ ((*(unsigned int *)((char *)dword_4A1E10 + ((v4 >> 6) & 0x3FC)) << 16)
        | HIWORD(*(unsigned int *)((char *)dword_4A1E10 + ((v4 >> 6) & 0x3FC))))
       ^ ((dword_4A1E10[(unsigned __int8)v5] << 8) | HIBYTE(dword_4A1E10[(unsigned __int8)v5]))
       ^ v3[2];
    v13 = dword_4A1E10[HIBYTE(v7)]
        ^ ((*(unsigned int *)((char *)dword_4A1E10 + ((v4 >> 14) & 0x3FC)) << 24)
         | (*(unsigned int *)((char *)dword_4A1E10 + ((v4 >> 14) & 0x3FC)) >> 8))
        ^ ((*(unsigned int *)((char *)dword_4A1E10 + ((v5 >> 6) & 0x3FC)) << 16)
         | HIWORD(*(unsigned int *)((char *)dword_4A1E10 + ((v5 >> 6) & 0x3FC))))
        ^ (v9 | HIDWORD(v9));
    v4 = v10 ^ *v3;
    v5 = v11 ^ ((v8 << 8) | HIBYTE(v8)) ^ v3[1];
    v14 = v13 ^ v12;
    if ( *(unsigned __int16 *)(a1 + 256) - 2 == i )
      break;
    v7 = v13 ^ v12;
  }
  v15 = *(_DWORD *)&byte_4A1A10[4 * HIBYTE(v4)]
      & 0xFF000000
      ^ *(_DWORD *)&byte_4A1A10[(v5 >> 14) & 0x3FC]
      & 0xFF0000
      ^ *(_DWORD *)&byte_4A1A10[(v6 >> 6) & 0x3FC]
      & 0xFF00
      ^ byte_4A1A10[4 * (unsigned __int8)(v13 ^ v12)]
      ^ v3[4];
  v16 = *(_DWORD *)&byte_4A1A10[(v14 >> 6) & 0x3FC];
  v17 = *(_DWORD *)&byte_4A1A10[(v6 >> 14) & 0x3FC] & 0xFF0000;
  v18 = *(_DWORD *)&byte_4A1A10[4 * HIBYTE(v5)] & 0xFF000000;
  *a3 = HIBYTE(v15);
  a3[1] = BYTE2(v15);
  a3[2] = BYTE1(v15);
  a3[3] = v15;
  v19 = v18 ^ v17;
  v20 = v3[5];
  v21 = v19 ^ v16 & 0xFF00 ^ byte_4A1A10[4 * (unsigned __int8)v4];
  v22 = *(_DWORD *)&byte_4A1A10[(v4 >> 6) & 0x3FC];
  v23 = *(_DWORD *)&byte_4A1A10[4 * HIBYTE(v6)] & 0xFF000000;
  v24 = *(_DWORD *)&byte_4A1A10[(v14 >> 14) & 0x3FC] & 0xFF0000;
  a3[4] = (v21 ^ v20) >> 24;
  a3[5] = (v21 ^ v20) >> 16;
  a3[6] = (unsigned __int16)(v21 ^ v20) >> 8;
  a3[7] = v21 ^ v20;
  v25 = v23 ^ v24 ^ v22 & 0xFF00 ^ byte_4A1A10[4 * (unsigned __int8)v5];
  v26 = *(_DWORD *)&byte_4A1A10[(v4 >> 14) & 0x3FC];
  v27 = v25 ^ v3[6];
  v28 = *(_DWORD *)&byte_4A1A10[(v5 >> 6) & 0x3FC];
  v29 = *(_DWORD *)&byte_4A1A10[4 * HIBYTE(v14)] & 0xFF000000;
  a3[9] = BYTE2(v27);
  a3[10] = BYTE1(v27);
  v30 = byte_4A1A10[4 * (unsigned __int8)v6];
  a3[8] = HIBYTE(v27);
  a3[11] = v27;
  v31 = v29 ^ v26 & 0xFF0000 ^ v28 & 0xFF00 ^ v30 ^ v3[7];
  a3[12] = HIBYTE(v31);
  a3[13] = BYTE2(v31);
  a3[15] = v31;
  a3[14] = BYTE1(v31);
  return psBurnStack(0x2Cu);
}
// 4A1A10: using guessed type unsigned __int8 byte_4A1A10[1024];
// 4A1E10: using guessed type unsigned int dword_4A1E10[256];

//----- (0048E37C) --------------------------------------------------------
int   psAesDecryptBlock(int a1, unsigned int *a2, _BYTE *a3)
{
  _DWORD *v3; // $t7
  unsigned int v4; // $t0
  unsigned int v5; // $a3
  unsigned int v6; // $s0
  unsigned int v7; // $s1
  unsigned int v8; // $t8
  unsigned int v9; // $t3
  unsigned __int64 v10; // kr00_8
  unsigned __int64 v11; // kr08_8
  int v12; // $a1
  int v13; // $s3
  int v14; // $t5
  unsigned int v15; // $a0
  unsigned int v16; // $s2
  unsigned int v17; // $s1
  unsigned int v18; // $s5
  unsigned int v19; // $a1
  int v20; // $t0
  int v21; // $t8
  unsigned int v22; // $t4
  int v23; // $v1
  int v24; // $t1
  unsigned int v25; // $a0
  int v26; // $t3
  int v27; // $s7
  int v28; // $v0
  int v29; // $t3
  int v30; // $t4
  int v31; // $t5
  int v32; // $t8
  unsigned int v33; // $s1
  int i; // [sp+1Ch] [-14h]
  int v36; // [sp+2Ch] [-4h]

  v3 = (_DWORD *)a1;
  v4 = _byteswap_ulong(*a2) ^ *(_DWORD *)a1;
  v5 = _byteswap_ulong(a2[1]) ^ *(_DWORD *)(a1 + 4);
  v6 = _byteswap_ulong(a2[2]) ^ *(_DWORD *)(a1 + 8);
  v7 = _byteswap_ulong(a2[3]) ^ *(_DWORD *)(a1 + 12);
  v36 = *(unsigned __int16 *)(a1 + 256) - 2;
  for ( i = 0; ; ++i )
  {
    v8 = *(unsigned int *)((char *)dword_4A1610 + ((v6 >> 14) & 0x3FC));
    v9 = dword_4A1610[(unsigned __int8)v6];
    v3 += 4;
    v10 = (unsigned __int64)dword_4A1610[(unsigned __int8)v5] << 8;
    v11 = (unsigned __int64)dword_4A1610[(unsigned __int8)v4] << 8;
    v12 = dword_4A1610[HIBYTE(v4)]
        ^ ((*(unsigned int *)((char *)dword_4A1610 + ((v7 >> 14) & 0x3FC)) << 24)
         | (*(unsigned int *)((char *)dword_4A1610 + ((v7 >> 14) & 0x3FC)) >> 8))
        ^ ((*(unsigned int *)((char *)dword_4A1610 + ((v6 >> 6) & 0x3FC)) << 16)
         | HIWORD(*(unsigned int *)((char *)dword_4A1610 + ((v6 >> 6) & 0x3FC))))
        ^ (v10 | HIDWORD(v10));
    v13 = v3[3];
    v6 = dword_4A1610[HIBYTE(v6)]
       ^ ((*(unsigned int *)((char *)dword_4A1610 + ((v5 >> 14) & 0x3FC)) << 24)
        | (*(unsigned int *)((char *)dword_4A1610 + ((v5 >> 14) & 0x3FC)) >> 8))
       ^ ((*(unsigned int *)((char *)dword_4A1610 + ((v4 >> 6) & 0x3FC)) << 16)
        | HIWORD(*(unsigned int *)((char *)dword_4A1610 + ((v4 >> 6) & 0x3FC))))
       ^ ((dword_4A1610[(unsigned __int8)v7] << 8) | HIBYTE(dword_4A1610[(unsigned __int8)v7]))
       ^ v3[2];
    v14 = dword_4A1610[HIBYTE(v7)]
        ^ ((v8 << 24) | (v8 >> 8))
        ^ ((*(unsigned int *)((char *)dword_4A1610 + ((v5 >> 6) & 0x3FC)) << 16)
         | HIWORD(*(unsigned int *)((char *)dword_4A1610 + ((v5 >> 6) & 0x3FC))))
        ^ (v11 | HIDWORD(v11));
    v15 = dword_4A1610[HIBYTE(v5)]
        ^ ((*(unsigned int *)((char *)dword_4A1610 + ((v4 >> 14) & 0x3FC)) << 24)
         | (*(unsigned int *)((char *)dword_4A1610 + ((v4 >> 14) & 0x3FC)) >> 8))
        ^ ((*(unsigned int *)((char *)dword_4A1610 + ((v7 >> 6) & 0x3FC)) << 16)
         | HIWORD(*(unsigned int *)((char *)dword_4A1610 + ((v7 >> 6) & 0x3FC))))
        ^ ((v9 << 8) | HIBYTE(v9));
    v16 = v12 ^ *v3;
    v17 = v15 ^ v3[1];
    v18 = v14 ^ v13;
    if ( v36 == i )
      break;
    v5 = v15 ^ v3[1];
    v4 = v12 ^ *v3;
    v7 = v14 ^ v13;
  }
  v19 = *(_DWORD *)&byte_4A1200[4 * HIBYTE(v16)]
      & 0xFF000000
      ^ *(_DWORD *)&byte_4A1200[(v18 >> 14) & 0x3FC]
      & 0xFF0000
      ^ *(_DWORD *)&byte_4A1200[(v6 >> 6) & 0x3FC]
      & 0xFF00
      ^ byte_4A1200[4 * (unsigned __int8)(v15 ^ *((_BYTE *)v3 + 4))]
      ^ v3[4];
  v20 = *(_DWORD *)&byte_4A1200[(v18 >> 6) & 0x3FC];
  v21 = *(_DWORD *)&byte_4A1200[(v16 >> 14) & 0x3FC] & 0xFF0000;
  v22 = *(_DWORD *)&byte_4A1200[4 * HIBYTE(v17)] & 0xFF000000;
  *a3 = HIBYTE(v19);
  a3[1] = BYTE2(v19);
  a3[2] = BYTE1(v19);
  a3[3] = v19;
  v23 = v22 ^ v21 ^ v20 & 0xFF00 ^ byte_4A1200[4 * (unsigned __int8)v6] ^ v3[5];
  v24 = *(_DWORD *)&byte_4A1200[(v16 >> 6) & 0x3FC];
  v25 = *(_DWORD *)&byte_4A1200[4 * HIBYTE(v6)] & 0xFF000000;
  v26 = *(_DWORD *)&byte_4A1200[(v17 >> 14) & 0x3FC] & 0xFF0000;
  a3[4] = HIBYTE(v23);
  a3[5] = BYTE2(v23);
  a3[6] = BYTE1(v23);
  a3[7] = v23;
  v27 = v25 ^ v26 ^ v24 & 0xFF00;
  v28 = *(_DWORD *)&byte_4A1200[4 * HIBYTE(v18)];
  v29 = *(_DWORD *)&byte_4A1200[(v6 >> 14) & 0x3FC];
  v30 = v27 ^ byte_4A1200[4 * (unsigned __int8)(v14 ^ v13)] ^ v3[6];
  v31 = *(_DWORD *)&byte_4A1200[(v17 >> 6) & 0x3FC];
  a3[9] = BYTE2(v30);
  a3[10] = BYTE1(v30);
  v32 = byte_4A1200[4 * (unsigned __int8)v16];
  a3[8] = HIBYTE(v30);
  a3[11] = v30;
  v33 = v28 & 0xFF000000 ^ v29 & 0xFF0000 ^ v31 & 0xFF00 ^ v32 ^ v3[7];
  a3[12] = HIBYTE(v33);
  a3[13] = BYTE2(v33);
  a3[15] = v33;
  a3[14] = BYTE1(v33);
  return psBurnStack(0x2Cu);
}
// 4A1200: using guessed type unsigned __int8 byte_4A1200[1040];
// 4A1610: using guessed type unsigned int dword_4A1610[256];

//----- (0048E8E4) --------------------------------------------------------
int   psAesInitBlockKey(int a1, unsigned int *a2, unsigned __int8 a3, int a4)
{
  unsigned int v4; // $t5
  unsigned int v6; // $t4
  unsigned int v7; // $t3
  unsigned int v8; // $t0
  int v10; // $t7
  int v11; // $t2
  unsigned __int16 v12; // $s3
  int result; // $v0
  _DWORD *v14; // $t9
  unsigned int v15; // $a2
  int v16; // $t5
  int v17; // $t4
  unsigned int v18; // $t6
  unsigned int v19; // $a3
  int v20; // $t1
  int v21; // $ra
  unsigned int v22; // $a2
  unsigned int v23; // $v0
  int v24; // $a1
  int v25; // $v0
  unsigned __int8 *v26; // $a1
  int *v27; // $a2
  unsigned __int8 *v28; // $a3
  int v29; // $t9
  int v30; // $s0
  int v31; // $t6
  int v32; // $s2
  char *v33; // $a1
  _DWORD *v34; // $t4
  char *v35; // $t3
  int v36; // $t5
  unsigned __int64 v37; // kr08_8
  unsigned __int64 v38; // kr10_8
  unsigned __int64 v39; // kr18_8
  unsigned int v40; // $v0
  unsigned __int64 v41; // kr20_8
  unsigned __int64 v42; // kr28_8
  unsigned __int64 v43; // kr30_8
  unsigned int v44; // $s4
  unsigned __int64 v45; // kr38_8
  unsigned __int64 v46; // $a2
  unsigned __int64 v47; // kr40_8
  unsigned int v48; // $t7
  unsigned __int64 v49; // kr48_8
  unsigned __int64 v50; // kr50_8
  unsigned __int64 v51; // kr58_8
  _DWORD *v52; // $t1
  int v53; // $s0
  unsigned int v54; // $a3
  unsigned int v55; // $v1
  int v56; // $a0
  int v57; // $ra
  int v58; // $a1
  _DWORD *v59; // $t1
  unsigned int v60; // $v0
  int v61; // $s1
  int v62; // $t4
  unsigned __int8 v63[160]; // [sp+18h] [-100h] BYREF
  char v64; // [sp+B8h] [-60h] BYREF
  char v65; // [sp+D8h] [-40h] BYREF
  char v66; // [sp+F8h] [-20h] BYREF

  v4 = _byteswap_ulong(*a2);
  *(_DWORD *)a1 = v4;
  v6 = _byteswap_ulong(a2[1]);
  *(_DWORD *)(a1 + 4) = v6;
  v7 = _byteswap_ulong(a2[2]);
  *(_DWORD *)(a1 + 8) = v7;
  v8 = _byteswap_ulong(a2[3]);
  *(_DWORD *)(a1 + 12) = v8;
  v10 = 0;
  v11 = a1;
  if ( a3 == 24 )
  {
    v12 = 12;
    *(_WORD *)(a1 + 256) = 12;
    *(_DWORD *)(a1 + 16) = _byteswap_ulong(a2[4]);
    *(_DWORD *)(a1 + 20) = _byteswap_ulong(a2[5]);
    v52 = &unk_4A2210;
    while ( 1 )
    {
      v54 = *(_DWORD *)(v11 + 20);
      v55 = *(_DWORD *)v11
          ^ *(_DWORD *)&byte_4A1A10[4 * *(unsigned __int8 *)(v11 + 22)]
          & 0xFF000000
          ^ *(_DWORD *)&byte_4A1A10[4 * *(unsigned __int8 *)(v11 + 21)]
          & 0xFF0000
          ^ *(_DWORD *)&byte_4A1A10[4 * (unsigned __int8)v54]
          & 0xFF00
          ^ byte_4A1A10[4 * HIBYTE(v54)]
          ^ *v52;
      v56 = *(_DWORD *)(v11 + 4) ^ v55;
      v57 = *(_DWORD *)(v11 + 8) ^ v56;
      v58 = *(_DWORD *)(v11 + 12) ^ v57;
      ++v10;
      *(_DWORD *)(v11 + 24) = v55;
      *(_DWORD *)(v11 + 28) = v56;
      *(_DWORD *)(v11 + 32) = v57;
      *(_DWORD *)(v11 + 36) = v58;
      ++v52;
      if ( v10 == 8 )
        break;
      v53 = *(_DWORD *)(v11 + 16) ^ v58;
      *(_DWORD *)(v11 + 44) = v54 ^ v53;
      *(_DWORD *)(v11 + 40) = v53;
      v11 += 24;
    }
    result = 0;
    if ( a4 != 1 )
      goto LABEL_11;
LABEL_27:
    *(_WORD *)(a1 + 258) = a4;
    return result;
  }
  if ( a3 >= 0x19u )
  {
    result = -21;
    if ( a3 != 32 )
      return result;
    v12 = 14;
    *(_WORD *)(a1 + 256) = 14;
    *(_DWORD *)(a1 + 16) = _byteswap_ulong(a2[4]);
    *(_DWORD *)(a1 + 20) = _byteswap_ulong(a2[5]);
    *(_DWORD *)(a1 + 24) = _byteswap_ulong(a2[6]);
    v14 = &unk_4A2210;
    *(_DWORD *)(a1 + 28) = _byteswap_ulong(a2[7]);
    while ( 1 )
    {
      v18 = *(_DWORD *)(v11 + 28);
      v19 = *(_DWORD *)v11
          ^ *(_DWORD *)&byte_4A1A10[4 * *(unsigned __int8 *)(v11 + 30)]
          & 0xFF000000
          ^ *(_DWORD *)&byte_4A1A10[4 * *(unsigned __int8 *)(v11 + 29)]
          & 0xFF0000
          ^ *(_DWORD *)&byte_4A1A10[4 * (unsigned __int8)v18]
          & 0xFF00
          ^ byte_4A1A10[4 * HIBYTE(v18)]
          ^ *v14;
      v20 = *(_DWORD *)(v11 + 4) ^ v19;
      v21 = *(_DWORD *)(v11 + 8) ^ v20;
      v22 = *(_DWORD *)(v11 + 12) ^ v21;
      v23 = (v22 << 24) | (v22 >> 8);
      v24 = (v23 >> 6) & 0x3FC;
      v25 = 4 * HIBYTE(v23);
      ++v10;
      v26 = &byte_4A1A10[v24];
      *(_DWORD *)(v11 + 32) = v19;
      *(_DWORD *)(v11 + 36) = v20;
      *(_DWORD *)(v11 + 40) = v21;
      *(_DWORD *)(v11 + 44) = v22;
      ++v14;
      if ( v10 == 7 )
        break;
      v15 = *(_DWORD *)(v11 + 16)
          ^ *(_DWORD *)&byte_4A1A10[4 * HIBYTE(v22)]
          & 0xFF000000
          ^ *(_DWORD *)v26
          & 0xFF0000
          ^ *(_DWORD *)&byte_4A1A10[4 * BYTE1(v22)]
          & 0xFF00
          ^ byte_4A1A10[v25];
      v16 = *(_DWORD *)(v11 + 20) ^ v15;
      v17 = *(_DWORD *)(v11 + 24) ^ v16;
      *(_DWORD *)(v11 + 60) = v18 ^ v17;
      *(_DWORD *)(v11 + 48) = v15;
      *(_DWORD *)(v11 + 52) = v16;
      *(_DWORD *)(v11 + 56) = v17;
      v11 += 32;
    }
  }
  else
  {
    v12 = 10;
    if ( a3 != 16 )
      return -21;
    v59 = &unk_4A2210;
    *(_WORD *)(a1 + 256) = 10;
    while ( 1 )
    {
      v60 = v4
          ^ *(_DWORD *)&byte_4A1A10[(v8 >> 14) & 0x3FC]
          & 0xFF000000
          ^ *(_DWORD *)&byte_4A1A10[(v8 >> 6) & 0x3FC]
          & 0xFF0000
          ^ *(_DWORD *)&byte_4A1A10[4 * (unsigned __int8)v8]
          & 0xFF00
          ^ byte_4A1A10[4 * HIBYTE(v8)]
          ^ *v59;
      v61 = v6 ^ v60;
      v62 = v7 ^ v6 ^ v60;
      ++v10;
      *(_DWORD *)(v11 + 28) = v8 ^ v62;
      *(_DWORD *)(v11 + 16) = v60;
      *(_DWORD *)(v11 + 20) = v61;
      *(_DWORD *)(v11 + 24) = v62;
      ++v59;
      v11 += 16;
      if ( v10 == 10 )
        break;
      v6 = *(_DWORD *)(v11 + 4);
      v7 = *(_DWORD *)(v11 + 8);
      v8 = *(_DWORD *)(v11 + 12);
      v4 = v60;
    }
  }
  result = 0;
  if ( a4 == 1 )
    goto LABEL_27;
LABEL_11:
  v27 = (int *)a1;
  if ( a4 != 2 )
    return -6;
  *(_WORD *)(a1 + 258) = 2;
  v28 = v63;
  do
  {
    v29 = *v27;
    v30 = v27[1];
    v31 = v27[2];
    v32 = v27[3];
    v27 += 4;
    *(_DWORD *)v28 = v29;
    *((_DWORD *)v28 + 1) = v30;
    *((_DWORD *)v28 + 2) = v31;
    *((_DWORD *)v28 + 3) = v32;
    v28 += 16;
  }
  while ( v27 != (int *)(a1 + 256) );
  if ( v12 == 12 )
  {
    v33 = &v65;
  }
  else if ( v12 >= 0xDu )
  {
    result = 0;
    if ( v12 != 14 )
      return result;
    v33 = &v66;
  }
  else
  {
    result = 0;
    if ( v12 != 10 )
      return result;
    v33 = &v64;
  }
  *(_DWORD *)a1 = *(_DWORD *)v33;
  *(_DWORD *)(a1 + 4) = *((_DWORD *)v33 + 1);
  *(_DWORD *)(a1 + 8) = *((_DWORD *)v33 + 2);
  v34 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 12) = *((_DWORD *)v33 + 3);
  v35 = v33;
  if ( v12 > 1u )
  {
    v36 = v12 - 1;
    do
    {
      v35 -= 16;
      v34 += 4;
      v37 = (unsigned __int64)dword_4A1610[byte_4A1A10[(*(_DWORD *)v35 >> 14) & 0x3FC]] << 24;
      v38 = (unsigned __int64)dword_4A1610[byte_4A1A10[(*(_DWORD *)v35 >> 6) & 0x3FC]] << 16;
      v39 = (unsigned __int64)dword_4A1610[byte_4A1A10[4 * (unsigned __int8)*(_DWORD *)v35]] << 8;
      *v34 = dword_4A1610[byte_4A1A10[4 * HIBYTE(*(_DWORD *)v35)]]
           ^ (v37 | HIDWORD(v37))
           ^ (v38 | HIDWORD(v38))
           ^ (v39 | HIDWORD(v39));
      v40 = *((_DWORD *)v35 + 1);
      --v36;
      v41 = (unsigned __int64)dword_4A1610[byte_4A1A10[(v40 >> 14) & 0x3FC]] << 24;
      v42 = (unsigned __int64)dword_4A1610[byte_4A1A10[(v40 >> 6) & 0x3FC]] << 16;
      v43 = (unsigned __int64)dword_4A1610[byte_4A1A10[4 * (unsigned __int8)v40]] << 8;
      v34[1] = dword_4A1610[byte_4A1A10[4 * HIBYTE(v40)]]
             ^ (v41 | HIDWORD(v41))
             ^ (v42 | HIDWORD(v42))
             ^ (v43 | HIDWORD(v43));
      v44 = *((_DWORD *)v35 + 2);
      v45 = (unsigned __int64)dword_4A1610[byte_4A1A10[(v44 >> 14) & 0x3FC]] << 24;
      v46 = (unsigned __int64)dword_4A1610[byte_4A1A10[(v44 >> 6) & 0x3FC]] << 16;
      v47 = (unsigned __int64)dword_4A1610[byte_4A1A10[4 * (unsigned __int8)v44]] << 8;
      v34[2] = dword_4A1610[byte_4A1A10[4 * HIBYTE(v44)]]
             ^ (v45 | HIDWORD(v45))
             ^ (v46 | HIDWORD(v46))
             ^ (v47 | HIDWORD(v47));
      v48 = *((_DWORD *)v35 + 3);
      v49 = (unsigned __int64)dword_4A1610[byte_4A1A10[(v48 >> 14) & 0x3FC]] << 24;
      v50 = (unsigned __int64)dword_4A1610[byte_4A1A10[(v48 >> 6) & 0x3FC]] << 16;
      v51 = (unsigned __int64)dword_4A1610[byte_4A1A10[4 * (unsigned __int8)v48]] << 8;
      v34[3] = dword_4A1610[byte_4A1A10[4 * HIBYTE(v48)]]
             ^ (v49 | HIDWORD(v49))
             ^ (v50 | HIDWORD(v50))
             ^ (v51 | HIDWORD(v51));
    }
    while ( v36 );
  }
  v34[4] = *((_DWORD *)v35 - 4);
  v34[5] = *((_DWORD *)v35 - 3);
  v34[6] = *((_DWORD *)v35 - 2);
  v34[7] = *((_DWORD *)v35 - 1);
  memset_s(v63, 0x100u, 0, 0x100u);
  return 0;
}
// 4A1610: using guessed type unsigned int dword_4A1610[256];
// 4A1A10: using guessed type unsigned __int8 byte_4A1A10[1024];

//----- (0048F248) --------------------------------------------------------
int   sub_48F248(int a1, int a2, _DWORD *a3)
{
  unsigned int i; // $a3
  unsigned int v7; // $a0
  _BYTE *v8; // $a2
  unsigned int j; // $t4
  int v10; // $a0
  int v11; // $a2
  int v12; // $a3
  int v13; // $t0
  _DWORD *v14; // $v1
  int *v15; // $a0
  _BYTE *v16; // $v1
  unsigned int k; // $a1
  int v18; // $a2
  unsigned int v19; // $a1
  _BYTE *v20; // $a0
  int *v21; // $v1
  _DWORD *v22; // $a0
  unsigned int v23; // $a2
  _DWORD *v24; // $a3
  char *v25; // $a1
  int v26; // $v0
  _DWORD *v27; // $a2
  _DWORD *v28; // $a3
  int v29; // $t0
  int v30; // $t6
  unsigned int *v31; // $t4
  int v32; // $a0
  unsigned int v33; // $t8
  int v34; // $v1
  int v35; // $t8
  unsigned int v36; // $t6
  int *v37; // $a3
  _DWORD *v38; // $a2
  int v39; // $t1
  int v40; // $t3
  int v41; // $s0
  int v42; // $t2
  _BYTE v44[184]; // [sp+18h] [-170h] BYREF
  int v45; // [sp+D0h] [-B8h] BYREF
  int v46; // [sp+ECh] [-9Ch] BYREF
  _BYTE v47[128]; // [sp+108h] [-80h] BYREF
  int vars0; // [sp+188h] [+0h] BYREF

  for ( i = 0; i < 0x38; ++i )
  {
    v7 = byte_4A2B08[i];
    v8 = &v44[i];
    v8[128] = (*(unsigned __int8 *)((v7 >> 3) + a1) & dword_4A2AE8[v7 & 7]) == dword_4A2AE8[v7 & 7];
  }
  for ( j = 0; j < 0x10; ++j )
  {
    v10 = 2 * j;
    if ( a2 == 1 )
      v10 = 2 * (15 - j);
    v11 = byte_4A2AD8[j];
    v12 = 4 * v10;
    v13 = 4 * (v10 + 1);
    v14 = &v44[4 * v10];
    *(_DWORD *)&v44[v13] = 0;
    v15 = &v45;
    *v14 = 0;
    v16 = &v44[v11 + 100];
    for ( k = 0; k < 0x1C; ++k )
    {
      while ( v11 + k < 0x1C )
      {
        ++k;
        *(_BYTE *)v15 = v16[28];
        ++v16;
        v15 = (int *)((char *)v15 + 1);
        if ( k >= 0x1C )
          goto LABEL_10;
      }
      *(_BYTE *)v15 = *v16++;
      v15 = (int *)((char *)v15 + 1);
    }
LABEL_10:
    v18 = byte_4A2AD8[j];
    v19 = 28;
    v20 = &v44[v18 + 128];
    v21 = &v46;
    do
    {
      while ( v18 + v19 < 0x38 )
      {
        ++v19;
        *(_BYTE *)v21 = v20[28];
        ++v20;
        v21 = (int *)((char *)v21 + 1);
        if ( v19 >= 0x38 )
          goto LABEL_14;
      }
      ++v19;
      *(_BYTE *)v21 = *v20++;
      v21 = (int *)((char *)v21 + 1);
    }
    while ( v19 < 0x38 );
LABEL_14:
    v22 = &v44[v12];
    v23 = 0;
    v24 = &unk_4A2A48;
    do
    {
      v25 = (char *)&byte_4A2AA8[v23];
      v26 = byte_4A2AA8[v23++];
      if ( v44[v26 + 184] )
        *v22 |= *v24;
      if ( v44[(unsigned __int8)v25[24] + 184] )
        *(_DWORD *)&v44[v13] |= *v24;
      ++v24;
    }
    while ( v23 < 0x18 );
  }
  v27 = v44;
  v28 = v47;
  v29 = 15;
  do
  {
    --v29;
    v30 = (*v27 & 0xFC0000) << 6;
    *v28 = v30;
    v31 = v28 + 1;
    v32 = v30 | ((*v27 & 0xFC0) << 10);
    *v28 = v32;
    v33 = v32 | ((v27[1] & 0xFC0000u) >> 10);
    *v28 = v33;
    *v28 = v33 | ((v27[1] & 0xFC0u) >> 6);
    v34 = (*v27 & 0x3F000) << 12;
    v28[1] = v34;
    v35 = v34 | ((*v27 & 0x3F) << 16);
    v28[1] = v35;
    v36 = v35 | ((v27[1] & 0x3F000u) >> 4);
    v28[1] = v36;
    v28 += 2;
    *v31 = v36 | v27[1] & 0x3F;
    v27 += 2;
  }
  while ( v29 >= 0 );
  v37 = (int *)v47;
  v38 = a3;
  do
  {
    v39 = *v37;
    v40 = v37[1];
    v41 = v37[2];
    v42 = v37[3];
    v37 += 4;
    *v38 = v39;
    v38[1] = v40;
    v38[2] = v41;
    v38[3] = v42;
    v38 += 4;
  }
  while ( v37 != &vars0 );
  psBurnStack(0x8Cu);
  return psBurnStack(0x104u);
}
// 4A2AA8: using guessed type unsigned __int8 byte_4A2AA8[48];
// 4A2AD8: using guessed type unsigned __int8 byte_4A2AD8[16];
// 4A2AE8: using guessed type _DWORD dword_4A2AE8[8];
// 4A2B08: using guessed type unsigned __int8 byte_4A2B08[56];

//----- (0048F5CC) --------------------------------------------------------
int   sub_48F5CC(unsigned int *a1, _DWORD *a2)
{
  unsigned int v2; // $s5
  int v3; // $s6
  int v4; // $t7
  int v5; // $s1
  unsigned int v6; // $a2
  int v7; // $a3
  int v8; // $t1
  unsigned int v9; // $t8
  int v11; // $s4
  int v12; // $t7
  unsigned int v13; // $t5
  unsigned int v14; // $t4
  unsigned int v16; // $t7
  unsigned int v17; // $t6
  int i; // $t9
  unsigned int v19; // $t4
  unsigned int v20; // $t3
  unsigned int v21; // $t4
  unsigned int v22; // $t3
  int v23; // $s6
  unsigned int v24; // $s7
  unsigned int v25; // $a0
  int v26; // $s0
  unsigned int v27; // $t0
  int v28; // $a2
  int v29; // $t5
  int v30; // $t4
  int v31; // $a1
  int v32; // $t2
  unsigned int v33; // $s2
  int v34; // $s0
  int v35; // $s1

  v2 = a1[1];
  v3 = ((*a1 >> 4) ^ v2) & 0xF0F0F0F;
  v4 = *a1 ^ (16 * v3);
  v5 = (unsigned __int16)(HIWORD(v4) ^ v2 ^ v3);
  v6 = v2 ^ v3 ^ v5;
  v7 = v4 ^ (v5 << 16);
  v8 = ((v6 >> 2) ^ v7) & 0x33333333;
  v9 = v6 ^ (4 * v8);
  v11 = ((v9 >> 8) ^ v7 ^ v8) & 0xFF00FF;
  v12 = v7 ^ v8 ^ v11;
  v13 = (2 * (v9 ^ (v11 << 8))) | ((v9 ^ (v11 << 8)) >> 31);
  v14 = (v12 ^ v13) & 0xAAAAAAAA;
  v16 = (2 * (v12 ^ v14)) | ((v12 ^ v14) >> 31);
  v17 = v13 ^ v14;
  for ( i = 7; i >= 0; --i )
  {
    v19 = ((v17 << 28) | (v17 >> 4)) ^ *a2;
    v20 = a2[1] ^ v17;
    v16 ^= dword_4A2948[v19 & 0x3F]
         ^ *(_DWORD *)((char *)&unk_4A2848 + ((v19 >> 6) & 0xFC))
         ^ *(_DWORD *)((char *)&unk_4A2748 + ((v19 >> 14) & 0xFC))
         ^ *(_DWORD *)((char *)&unk_4A2648 + ((v19 >> 22) & 0xFC))
         ^ dword_4A2538[v20 & 0x3F]
         ^ *(_DWORD *)((char *)&unk_4A2438 + ((v20 >> 6) & 0xFC))
         ^ *(_DWORD *)((char *)&unk_4A2338 + ((v20 >> 14) & 0xFC))
         ^ *(_DWORD *)((char *)&unk_4A2238 + ((v20 >> 22) & 0xFC));
    v21 = ((v16 << 28) | (v16 >> 4)) ^ a2[2];
    v22 = a2[3] ^ v16;
    v17 ^= dword_4A2948[v21 & 0x3F]
         ^ *(_DWORD *)((char *)&unk_4A2848 + ((v21 >> 6) & 0xFC))
         ^ *(_DWORD *)((char *)&unk_4A2748 + ((v21 >> 14) & 0xFC))
         ^ *(_DWORD *)((char *)&unk_4A2648 + ((v21 >> 22) & 0xFC))
         ^ dword_4A2538[v22 & 0x3F]
         ^ *(_DWORD *)((char *)&unk_4A2438 + ((v22 >> 6) & 0xFC))
         ^ *(_DWORD *)((char *)&unk_4A2338 + ((v22 >> 14) & 0xFC))
         ^ *(_DWORD *)((char *)&unk_4A2238 + ((v22 >> 22) & 0xFC));
    a2 += 4;
  }
  v23 = (v17 << 31) | (v17 >> 1);
  v24 = (v16 ^ v23) & 0xAAAAAAAA;
  v25 = ((v16 ^ v24) << 31) | ((v16 ^ v24) >> 1);
  v26 = ((v25 >> 8) ^ v23 ^ v24) & 0xFF00FF;
  v27 = v25 ^ (v26 << 8);
  v28 = v23 ^ v24 ^ v26;
  v29 = (v27 >> 2) ^ v28;
  v30 = v28 ^ v29 & 0x33333333;
  v31 = 4 * (v29 & 0x33333333);
  v32 = (unsigned __int16)(HIWORD(v30) ^ v27 ^ v31);
  v33 = v30 ^ (v32 << 16);
  v34 = v27 ^ v31 ^ v32;
  v35 = ((v33 >> 4) ^ v34) & 0xF0F0F0F;
  a1[1] = v34 ^ v35;
  *a1 = v33 ^ (16 * v35);
  return psBurnStack(0x14u);
}
// 4A2538: using guessed type _DWORD dword_4A2538[68];
// 4A2948: using guessed type _DWORD dword_4A2948[64];

//----- (0048F964) --------------------------------------------------------
int   psDes3Init(_DWORD *a1, int a2, int a3)
{
  int i; // $a1
  char *v7; // $v1
  char v8; // $a0

  memset(a1, 0, 776);
  if ( !a3 || !a1 )
    return -6;
  sub_48F248(a3, 0, a1);
  sub_48F248(a3 + 8, 1, a1 + 32);
  sub_48F248(a3 + 16, 0, a1 + 64);
  sub_48F248(a3, 1, a1 + 160);
  sub_48F248(a3 + 8, 0, a1 + 128);
  sub_48F248(a3 + 16, 1, a1 + 96);
  for ( i = 0; i < 8; ++i )
  {
    v7 = (char *)a1 + i;
    v8 = *(_BYTE *)(a2 + i);
    v7[768] = v8;
  }
  return 0;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (0048FAC0) --------------------------------------------------------
int   psDes3Decrypt(_DWORD *a1, int a2, int a3, unsigned int a4)
{
  unsigned int v7; // $s6
  _DWORD *v8; // $fp
  _DWORD *v9; // $s7
  int v10; // $t7
  int v11; // $t6
  unsigned int i; // $t0
  unsigned __int8 *v13; // $t8
  char v14; // $t1
  unsigned __int8 v15; // $v1
  unsigned __int8 v16; // $ra
  _BYTE *v17; // $v0
  unsigned int j; // $a1
  char *v19; // $a2
  unsigned __int8 v20; // $t9
  unsigned __int8 v22[8]; // [sp+18h] [-20h] BYREF
  unsigned __int8 v23[8]; // [sp+20h] [-18h] BYREF
  unsigned int v24; // [sp+28h] [-10h] BYREF
  int v25; // [sp+2Ch] [-Ch]
  _DWORD *v26; // [sp+30h] [-8h]

  v7 = 0;
  if ( a4 )
  {
    v26 = a1 + 96;
    v8 = a1 + 128;
    v9 = a1 + 160;
    do
    {
      v10 = *(unsigned __int8 *)(a2 + 7);
      v11 = (*(unsigned __int8 *)(a2 + 4) << 24)
          | (*(unsigned __int8 *)(a2 + 5) << 16)
          | (*(unsigned __int8 *)(a2 + 6) << 8);
      v24 = _byteswap_ulong(*(_DWORD *)a2);
      v25 = v11 | v10;
      sub_48F5CC(&v24, v26);
      sub_48F5CC(&v24, v8);
      sub_48F5CC(&v24, v9);
      v22[5] = BYTE2(v25);
      v22[0] = HIBYTE(v24);
      v22[1] = BYTE2(v24);
      v22[2] = BYTE1(v24);
      v22[3] = v24;
      v22[4] = HIBYTE(v25);
      v22[6] = BYTE1(v25);
      v22[7] = v25;
      for ( i = 0; i < 8; ++i )
      {
        v13 = &v22[i];
        v14 = *((_BYTE *)a1 + i + 768);
        v15 = v22[i];
        v16 = *(_BYTE *)(a2 + i);
        v17 = (_BYTE *)(a3 + i);
        *v17 = v15 ^ v14;
        v13[8] = v16;
      }
      for ( j = 0; j < 8; ++j )
      {
        v19 = (char *)a1 + j;
        v20 = v22[j + 8];
        v19[768] = v20;
      }
      v7 += 8;
      a2 += 8;
      a3 += 8;
    }
    while ( v7 < a4 );
  }
  memset_s(v22, 8u, 0, 8u);
  return memset_s(v23, 8u, 0, 8u);
}

//----- (0048FCD8) --------------------------------------------------------
int   getAsnTagLenUnsafe(_BYTE *a1)
{
  unsigned int v1; // $a2
  BOOL v2; // $t0
  int result; // $v0
  unsigned int v4; // $s0
  _BYTE *v5; // $a1
  char *v6; // $a0
  unsigned int v7; // $a2
  int v8; // [sp+0h] [-20h] BYREF
  __int16 v9; // [sp+18h] [-8h]
  unsigned __int8 v10; // [sp+1Ah] [-6h]

  if ( !a1 || !*a1 )
    return 0;
  v1 = (unsigned __int8)a1[1];
  v2 = v1 - 129 < 3;
  result = v1 + 2;
  if ( v1 < 0x80 )
    return result;
  v4 = v1 - 128;
  v5 = a1 + 2;
  v9 = 0;
  v10 = 0;
  v6 = (char *)&v8 - v1 + 155;
  v7 = v1 - 128;
  if ( !v2 )
    return 0;
  memcpy(v6, v5, v7);
  return (((unsigned __int8)v9 << 16) | (HIBYTE(v9) << 8) | v10) + v4 + 2;
}
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (0048FDA8) --------------------------------------------------------
int   getAsnLength32(unsigned __int8 **a1, int a2, unsigned int *a3, int a4)
{
  unsigned __int8 *v5; // $a0
  unsigned __int8 *v6; // $t3
  int v7; // $v1
  int v8; // $v0
  unsigned int *v9; // $t1
  unsigned int v10; // $t0
  int result; // $v0

  v5 = *a1;
  *a3 = 0;
  v6 = &v5[a2];
  v7 = -9;
  if ( a2 <= 0 )
    return v7;
  v8 = (char)*v5;
  v9 = (unsigned int *)(v5 + 1);
  v10 = v8 & 0x7F;
  if ( v8 >= 0 )
  {
LABEL_3:
    if ( a4 || (v7 = -9, v6 - (unsigned __int8 *)v9 >= v10) )
    {
      *a1 = (unsigned __int8 *)v9;
      *a3 = v10;
      return 0;
    }
    return v7;
  }
  v7 = -9;
  if ( v6 - (unsigned __int8 *)v9 < v10 )
    return v7;
  switch ( v8 & 0x7F )
  {
    case 0:
      v7 = -9;
      if ( !a4 )
        return v7;
      result = 65533;
      *a1 = (unsigned __int8 *)v9;
      *a3 = a2 - 1;
      break;
    case 1:
      v10 = *(unsigned __int8 *)v9;
      v9 = (unsigned int *)(v5 + 2);
      goto LABEL_3;
    case 2:
      v10 = (v5[1] << 8) | v5[2];
      v9 = (unsigned int *)(v5 + 3);
      goto LABEL_3;
    case 3:
      v10 = (v5[1] << 16) | (v5[2] << 8) | v5[3];
      v9 = (unsigned int *)(v5 + 4);
      goto LABEL_3;
    case 4:
      v10 = _byteswap_ulong(*v9);
      v9 = (unsigned int *)(v5 + 5);
      goto LABEL_3;
    default:
      return v7;
  }
  return result;
}

//----- (0048FEE0) --------------------------------------------------------
int   getAsnLength(unsigned __int8 **a1, unsigned __int16 a2, _WORD *a3)
{
  unsigned __int8 *v4; // $a0
  unsigned __int8 *v5; // $t0
  int v6; // $v0
  unsigned int *v7; // $a3
  unsigned int v8; // $a1
  int result; // $v0

  v4 = *a1;
  v5 = &v4[a2];
  if ( !a2 )
    return -9;
  v6 = (char)*v4;
  v7 = (unsigned int *)(v4 + 1);
  v8 = v6 & 0x7F;
  if ( v6 < 0 )
  {
    if ( v5 - (unsigned __int8 *)v7 < v8 )
      return -9;
    result = -9;
    switch ( v8 )
    {
      case 0u:
        return -9;
      case 1u:
        v8 = *(unsigned __int8 *)v7;
        v7 = (unsigned int *)(v4 + 2);
        goto LABEL_3;
      case 2u:
        v8 = (v4[1] << 8) | v4[2];
        v7 = (unsigned int *)(v4 + 3);
        goto LABEL_3;
      case 3u:
        v8 = (v4[1] << 16) | (v4[2] << 8) | v4[3];
        v7 = (unsigned int *)(v4 + 4);
        goto LABEL_3;
      case 4u:
        v8 = _byteswap_ulong(*v7);
        v7 = (unsigned int *)(v4 + 5);
        goto LABEL_3;
      default:
        return result;
    }
  }
  else
  {
LABEL_3:
    result = 0;
    if ( v5 - (unsigned __int8 *)v7 < v8 )
      return -9;
    *a1 = (unsigned __int8 *)v7;
    *a3 = v8;
  }
  return result;
}

//----- (00490008) --------------------------------------------------------
int   getAsnSequence32(unsigned __int8 **a1, int a2, unsigned int *a3, int a4)
{
  unsigned __int8 *v4; // $t0
  int v6; // $t1
  int v7; // $a0
  unsigned __int8 *v9; // $t6
  int v10; // $t8
  unsigned __int8 *v11; // $t3
  unsigned int v12; // $a0
  int v13; // $t1
  unsigned __int8 *v14; // [sp+8h] [-8h]

  v4 = *a1;
  v6 = -31;
  if ( !a2 )
    return v6;
  if ( *v4 != 48 )
    return v6;
  *a3 = 0;
  v9 = &v4[a2];
  v6 = -9;
  if ( a2 - 1 <= 0 )
    return v6;
  v10 = (char)v4[1];
  v11 = v4 + 2;
  v12 = v10 & 0x7F;
  if ( v10 >= 0 )
  {
LABEL_7:
    if ( !a4 && v9 - v11 < v12 )
      return -9;
    v13 = 0;
    v14 = v11;
    *a3 = v12;
    goto LABEL_9;
  }
  if ( v9 - v11 < v12 )
    return v6;
  switch ( v10 & 0x7F )
  {
    case 0:
      v6 = -9;
      if ( !a4 )
        return v6;
      v13 = 65533;
      v14 = v4 + 2;
      *a3 = a2 - 2;
      break;
    case 1:
      v12 = *v11;
      v11 = v4 + 3;
      goto LABEL_7;
    case 2:
      v12 = (*v11 << 8) | v4[3];
      v11 = v4 + 4;
      goto LABEL_7;
    case 3:
      v12 = (*v11 << 16) | (v4[3] << 8) | v4[4];
      v11 = v4 + 5;
      goto LABEL_7;
    case 4:
      v12 = _byteswap_ulong(*(_DWORD *)(v4 + 2));
      v11 = v4 + 6;
      goto LABEL_7;
    default:
      return v6;
  }
LABEL_9:
  if ( a4 )
  {
    *a1 = v14;
    return v13;
  }
  v7 = -9;
  if ( a2 - (v14 - v4) >= *a3 )
  {
    *a1 = v14;
    return v13;
  }
  return v7;
}

//----- (004901AC) --------------------------------------------------------
int   getAsnSequence(_DWORD *a1, unsigned __int16 a2, _WORD *a3)
{
  unsigned __int8 *v4; // $a0
  int v5; // $t0
  int v6; // $v1
  int result; // $v0
  int v8; // $v1
  unsigned __int8 *v9; // $t3
  int v10; // $t4
  unsigned __int8 *v11; // $a3
  unsigned int v12; // $t1
  __int16 v13; // [sp+8h] [-8h]

  v4 = (unsigned __int8 *)*a1;
  v13 = 0;
  v5 = -31;
  if ( !a2 )
    goto LABEL_3;
  if ( *v4 != 48 )
    goto LABEL_3;
  v9 = &v4[a2];
  v5 = -9;
  if ( a2 - 1 <= 0 )
    goto LABEL_3;
  v10 = (char)v4[1];
  v11 = v4 + 2;
  v12 = v10 & 0x7F;
  if ( v10 < 0 )
  {
    v6 = -9;
    if ( v9 - v11 >= v12 )
    {
      switch ( v10 & 0x7F )
      {
        case 0:
          goto LABEL_13;
        case 1:
          v12 = *v11;
          v11 = v4 + 3;
          goto LABEL_10;
        case 2:
          v12 = (*v11 << 8) | v4[3];
          v11 = v4 + 4;
          goto LABEL_10;
        case 3:
          v12 = (v4[2] << 16) | (v4[3] << 8) | v4[4];
          v11 = v4 + 5;
          goto LABEL_10;
        case 4:
          v12 = _byteswap_ulong(*(_DWORD *)(v4 + 2));
          v11 = v4 + 6;
          goto LABEL_10;
        default:
          goto LABEL_4;
      }
    }
    goto LABEL_4;
  }
LABEL_10:
  if ( v9 - v11 < v12 )
  {
LABEL_13:
    v5 = -9;
LABEL_3:
    v6 = v5;
    goto LABEL_4;
  }
  v13 = v12;
  v8 = -9;
  if ( a2 - (unsigned int)&v11[-*a1] < v12 )
    return v8;
  v6 = 0;
  *a1 = v11;
LABEL_4:
  result = v6;
  if ( v6 < 0 )
    return result;
  v8 = 0;
  *a3 = v13;
  return v8;
}

//----- (00490330) --------------------------------------------------------
int   sub_490330(unsigned __int8 **a1, unsigned int a2, unsigned int *a3, int a4)
{
  unsigned __int8 *v4; // $t0
  int v6; // $t1
  int v7; // $a0
  unsigned __int8 *v9; // $t6
  int v10; // $t8
  unsigned __int8 *v11; // $t3
  unsigned int v12; // $a0
  int v13; // $t1
  unsigned __int8 *v14; // [sp+8h] [-8h]

  v4 = *a1;
  v6 = -31;
  if ( !a2 )
    return v6;
  if ( *v4 != 49 )
    return v6;
  *a3 = 0;
  v9 = &v4[a2];
  v6 = -9;
  if ( (int)(a2 - 1) <= 0 )
    return v6;
  v10 = (char)v4[1];
  v11 = v4 + 2;
  v12 = v10 & 0x7F;
  if ( v10 >= 0 )
  {
LABEL_7:
    if ( !a4 && v9 - v11 < v12 )
      return -9;
    v13 = 0;
    v14 = v11;
    *a3 = v12;
    goto LABEL_9;
  }
  if ( v9 - v11 < v12 )
    return v6;
  switch ( v10 & 0x7F )
  {
    case 0:
      v6 = -9;
      if ( !a4 )
        return v6;
      v13 = 65533;
      v14 = v4 + 2;
      *a3 = a2 - 2;
      break;
    case 1:
      v12 = *v11;
      v11 = v4 + 3;
      goto LABEL_7;
    case 2:
      v12 = (*v11 << 8) | v4[3];
      v11 = v4 + 4;
      goto LABEL_7;
    case 3:
      v12 = (*v11 << 16) | (v4[3] << 8) | v4[4];
      v11 = v4 + 5;
      goto LABEL_7;
    case 4:
      v12 = _byteswap_ulong(*(_DWORD *)(v4 + 2));
      v11 = v4 + 6;
      goto LABEL_7;
    default:
      return v6;
  }
LABEL_9:
  v7 = -9;
  if ( a2 >= v14 - v4 + *a3 )
  {
    v7 = v13;
    *a1 = v14;
  }
  return v7;
}

//----- (004904C0) --------------------------------------------------------
int   getAsnSet(unsigned __int8 **a1, unsigned __int16 a2, _WORD *a3)
{
  unsigned __int8 *v4; // $a0
  int v5; // $t0
  int v6; // $v1
  int result; // $v0
  int v8; // $v1
  unsigned __int8 *v9; // $t3
  int v10; // $t4
  unsigned __int8 *v11; // $a3
  unsigned int v12; // $t1
  __int16 v13; // [sp+8h] [-8h]

  v4 = *a1;
  v13 = 0;
  v5 = -31;
  if ( !a2 )
    goto LABEL_3;
  if ( *v4 != 49 )
    goto LABEL_3;
  v9 = &v4[a2];
  v5 = -9;
  if ( a2 - 1 <= 0 )
    goto LABEL_3;
  v10 = (char)v4[1];
  v11 = v4 + 2;
  v12 = v10 & 0x7F;
  if ( v10 < 0 )
  {
    v6 = -9;
    if ( v9 - v11 >= v12 )
    {
      switch ( v10 & 0x7F )
      {
        case 0:
          goto LABEL_13;
        case 1:
          v12 = *v11;
          v11 = v4 + 3;
          goto LABEL_10;
        case 2:
          v12 = (*v11 << 8) | v4[3];
          v11 = v4 + 4;
          goto LABEL_10;
        case 3:
          v12 = (v4[2] << 16) | (v4[3] << 8) | v4[4];
          v11 = v4 + 5;
          goto LABEL_10;
        case 4:
          v12 = _byteswap_ulong(*(_DWORD *)(v4 + 2));
          v11 = v4 + 6;
          goto LABEL_10;
        default:
          goto LABEL_4;
      }
    }
    goto LABEL_4;
  }
LABEL_10:
  if ( v9 - v11 < v12 )
  {
LABEL_13:
    v5 = -9;
LABEL_3:
    v6 = v5;
    goto LABEL_4;
  }
  v13 = v12;
  v8 = -9;
  if ( a2 < v11 - *a1 + v12 )
    return v8;
  v6 = 0;
  *a1 = v11;
LABEL_4:
  result = v6;
  if ( v6 < 0 )
    return result;
  v8 = 0;
  *a3 = v13;
  return v8;
}

//----- (00490644) --------------------------------------------------------
int   getAsnEnumerated(char **a1, int a2, int *a3)
{
  char *v4; // $a0
  int v5; // $t0
  char *v6; // $t1
  int result; // $v0
  char *v8; // $t3
  int v9; // $t5
  char *v10; // $a3
  unsigned int v11; // $a1
  int v12; // $t0
  int v13; // $t9
  int v15; // $t7

  v4 = *a1;
  v5 = -31;
  v6 = &v4[a2];
  if ( !a2 )
    return v5;
  if ( *v4 != 10 )
    return v5;
  v8 = &v4[a2];
  v5 = -9;
  if ( a2 - 1 <= 0 )
    return v5;
  v9 = v4[1];
  v10 = v4 + 2;
  v11 = v9 & 0x7F;
  if ( v9 < 0 )
  {
    result = -9;
    if ( v8 - v10 >= v11 )
    {
      switch ( v9 & 0x7F )
      {
        case 0:
          return -9;
        case 1:
          v11 = (unsigned __int8)*v10;
          v10 = v4 + 3;
          goto LABEL_7;
        case 2:
          v11 = ((unsigned __int8)*v10 << 8) | (unsigned __int8)v4[3];
          v10 = v4 + 4;
          goto LABEL_7;
        case 3:
          v11 = ((unsigned __int8)v4[2] << 16) | ((unsigned __int8)v4[3] << 8) | (unsigned __int8)v4[4];
          v10 = v4 + 5;
          goto LABEL_7;
        case 4:
          v11 = _byteswap_ulong(*(_DWORD *)(v4 + 2));
          v10 = v4 + 6;
          goto LABEL_7;
        default:
          return result;
      }
    }
  }
  else
  {
LABEL_7:
    if ( v8 - v10 < v11 )
    {
      return -9;
    }
    else if ( v11 >= 5 || v6 - v10 < v11 )
    {
      return -9;
    }
    else
    {
      v12 = 0;
      if ( *v10 < 0 )
      {
        while ( v11 )
        {
          v15 = (unsigned __int8)~*v10++;
          --v11;
          v12 = (v12 << 8) | v15;
        }
        result = 0;
        *a3 = ~v12;
        *a1 = v10;
      }
      else
      {
        if ( v11 )
        {
          do
          {
            v13 = (unsigned __int8)*v10++;
            v12 = (v12 << 8) | v13;
          }
          while ( v11-- != 1 );
        }
        *a3 = v12;
        *a1 = v10;
        return 0;
      }
    }
  }
  return result;
}

//----- (00490844) --------------------------------------------------------
int   getAsnInteger(char **a1, int a2, int *a3)
{
  char *v4; // $a0
  int v5; // $t0
  char *v6; // $t1
  int result; // $v0
  char *v8; // $t3
  int v9; // $t5
  char *v10; // $a3
  unsigned int v11; // $a1
  int v12; // $t0
  int v13; // $t9
  int v15; // $t7

  v4 = *a1;
  v5 = -31;
  v6 = &v4[a2];
  if ( !a2 )
    return v5;
  if ( *v4 != 2 )
    return v5;
  v8 = &v4[a2];
  v5 = -9;
  if ( a2 - 1 <= 0 )
    return v5;
  v9 = v4[1];
  v10 = v4 + 2;
  v11 = v9 & 0x7F;
  if ( v9 < 0 )
  {
    result = -9;
    if ( v8 - v10 >= v11 )
    {
      switch ( v9 & 0x7F )
      {
        case 0:
          return -9;
        case 1:
          v11 = (unsigned __int8)*v10;
          v10 = v4 + 3;
          goto LABEL_7;
        case 2:
          v11 = ((unsigned __int8)*v10 << 8) | (unsigned __int8)v4[3];
          v10 = v4 + 4;
          goto LABEL_7;
        case 3:
          v11 = ((unsigned __int8)v4[2] << 16) | ((unsigned __int8)v4[3] << 8) | (unsigned __int8)v4[4];
          v10 = v4 + 5;
          goto LABEL_7;
        case 4:
          v11 = _byteswap_ulong(*(_DWORD *)(v4 + 2));
          v10 = v4 + 6;
          goto LABEL_7;
        default:
          return result;
      }
    }
  }
  else
  {
LABEL_7:
    if ( v8 - v10 < v11 )
    {
      return -9;
    }
    else if ( v11 >= 5 || v6 - v10 < v11 )
    {
      return -9;
    }
    else
    {
      v12 = 0;
      if ( *v10 < 0 )
      {
        while ( v11 )
        {
          v15 = (unsigned __int8)~*v10++;
          --v11;
          v12 = (v12 << 8) | v15;
        }
        result = 0;
        *a3 = ~v12;
        *a1 = v10;
      }
      else
      {
        if ( v11 )
        {
          do
          {
            v13 = (unsigned __int8)*v10++;
            v12 = (v12 << 8) | v13;
          }
          while ( v11-- != 1 );
        }
        *a3 = v12;
        *a1 = v10;
        return 0;
      }
    }
  }
  return result;
}

//----- (00490A44) --------------------------------------------------------
unsigned int   asnParseOid(_BYTE *a1, unsigned __int16 a2, unsigned int *a3)
{
  unsigned int result; // $v0
  char *v4; // $a1
  char *v5; // $t1
  unsigned int v6; // $a3
  int v7; // $v1
  unsigned __int8 v8; // $a0
  int v9; // $t8
  int v10; // $t4
  int *v11; // $t0
  int v12; // $v1
  unsigned int v13; // $t3
  BOOL v14; // $t2
  int v15; // $v0
  int v16; // $v1

  result = 0;
  if ( a2 )
  {
    v4 = &a1[a2];
    v5 = a1 + 1;
    v6 = 15;
    *a3 = (unsigned __int8)*a1 / 0x28u;
    a3[1] = *a1 % 0x28u;
    do
    {
      v7 = v6;
      v6 = (unsigned __int8)(v6 - 1);
      a3[v7] = 0;
    }
    while ( v6 >= 3 );
LABEL_4:
    if ( v5 >= v4 )
    {
LABEL_8:
      result = v6;
      if ( v6 >= 0x10 )
        return 0;
    }
    else
    {
      while ( 1 )
      {
        result = 0;
        if ( v6 >= 0x10 )
          break;
        v8 = *v5;
        v9 = v6;
        if ( *v5 < 0 )
        {
          v10 = v6;
          v11 = (int *)&a3[v6];
          v12 = *v11 | v8 & 0x7F;
          *v11 = v12;
          LOBYTE(v13) = 1;
          v14 = 1;
          v15 = v12 << 7;
          if ( *v5 >= 0 )
          {
LABEL_15:
            ++v5;
            v6 = (unsigned __int8)(v6 + 1);
            goto LABEL_4;
          }
          while ( 1 )
          {
            ++v5;
            if ( !v14 )
              return 0;
            *v11 = v15;
            if ( v5 < v4 )
            {
              v11 = (int *)&a3[v10];
              v16 = a3[v10] | *v5 & 0x7F;
              a3[v10] = v16;
              v13 = (unsigned __int8)(v13 + 1);
              v14 = v13 < 5;
              v15 = v16 << 7;
              if ( *v5 < 0 )
                continue;
            }
            goto LABEL_15;
          }
        }
        ++v5;
        v6 = (unsigned __int8)(v6 + 1);
        a3[v9] = v8;
        if ( v5 >= v4 )
          goto LABEL_8;
      }
    }
  }
  return result;
}

//----- (00490BB8) --------------------------------------------------------
int   sub_490BB8(int *a1, int a2, int a3)
{
  int v4; // $s0
  BOOL v7; // $v1
  int result; // $v0
  char *v9; // $a1
  int v10; // $a1

  v4 = *a1;
  if ( *a1 == 645 )
    goto LABEL_17;
  v7 = v4 < 646;
LABEL_3:
  result = 670;
  if ( !v7 )
  {
    if ( v4 == 670 )
    {
      v9 = (char *)&unk_4A2E20;
      goto LABEL_14;
    }
    if ( v4 >= 671 )
    {
      if ( v4 == 1673 )
      {
        v9 = (char *)&unk_4A2E3C;
        goto LABEL_14;
      }
      if ( v4 >= 1674 )
      {
        if ( v4 == 1681 )
        {
          v9 = (char *)&unk_4A2E6C;
          goto LABEL_14;
        }
        if ( v4 >= 1682 )
        {
          if ( v4 == 1684 )
          {
            v9 = (char *)&unk_4A2F44;
            goto LABEL_14;
          }
          if ( v4 >= 1685 )
          {
            if ( v4 == 1685 )
            {
              v9 = (char *)&unk_4A2F90;
              goto LABEL_14;
            }
            if ( v4 == 2700 )
            {
              v9 = (char *)&unk_4A2D6C;
              goto LABEL_14;
            }
          }
          else if ( v4 == 1682 )
          {
            v9 = (char *)&unk_4A2D54;
            goto LABEL_14;
          }
        }
        else
        {
          if ( v4 == 1678 )
          {
            v9 = (char *)&unk_4A2EFC;
            goto LABEL_14;
          }
          if ( v4 >= 1679 )
          {
            if ( v4 == 1679 )
              v9 = (char *)&unk_4A2FC8;
            else
              v9 = (char *)&unk_4A2DF8;
            goto LABEL_14;
          }
          if ( v4 == 1676 )
          {
            v9 = (char *)&unk_4A2CEC;
            goto LABEL_14;
          }
        }
      }
      else
      {
        if ( v4 == 676 )
        {
          v9 = (char *)&unk_4A2E94;
          goto LABEL_14;
        }
        if ( v4 >= 677 )
        {
          if ( v4 == 1438 )
          {
            v9 = (char *)&unk_4A2F08;
            goto LABEL_14;
          }
          if ( v4 >= 1439 )
          {
            if ( v4 == 1441 )
            {
              v9 = (char *)&unk_4A2F6C;
              goto LABEL_14;
            }
            if ( v4 == 1670 )
            {
              v9 = (char *)&unk_4A2D60;
              goto LABEL_14;
            }
          }
          else
          {
            result = 687;
            if ( v4 == 687 )
            {
              v9 = (char *)&unk_4A2D04;
              goto LABEL_14;
            }
          }
        }
        else
        {
          if ( v4 == 672 )
          {
            v9 = (char *)&unk_4A2EEC;
            goto LABEL_14;
          }
          if ( v4 < 672 )
          {
            v9 = (char *)&unk_4A2DB4;
            goto LABEL_14;
          }
          if ( v4 == 675 )
          {
            v9 = (char *)&unk_4A2CCC;
            goto LABEL_14;
          }
        }
      }
    }
    else
    {
      if ( v4 == 656 )
      {
        v9 = (char *)&unk_4A2E30;
        goto LABEL_14;
      }
      if ( v4 >= 657 )
      {
        if ( v4 == 661 )
        {
          v9 = (char *)&unk_4A2E78;
          goto LABEL_14;
        }
        if ( v4 < 662 )
        {
          if ( v4 == 658 )
          {
            v9 = (char *)&unk_4A2EB8;
          }
          else if ( v4 < 658 )
          {
            v9 = (char *)&unk_4A2DD0;
          }
          else if ( v4 == 659 )
          {
            v9 = (char *)&unk_4A2FAC;
          }
          else
          {
            v9 = (char *)&unk_4A2CDC;
          }
          goto LABEL_14;
        }
        if ( v4 == 667 )
        {
          v9 = (char *)&unk_4A2F50;
          goto LABEL_14;
        }
        if ( v4 >= 668 )
        {
          if ( v4 == 668 )
            v9 = (char *)&unk_4A2F9C;
          else
            v9 = (char *)&unk_4A2E04;
          goto LABEL_14;
        }
        if ( v4 == 662 )
        {
          v9 = (char *)&unk_4A2D44;
          goto LABEL_14;
        }
      }
      else
      {
        if ( v4 == 651 )
        {
          v9 = (char *)&unk_4A2E54;
          goto LABEL_14;
        }
        if ( v4 >= 652 )
        {
          if ( v4 == 653 )
          {
            v9 = (char *)&unk_4A2F20;
          }
          else if ( v4 < 653 )
          {
            v9 = (char *)&unk_4A2DC4;
          }
          else if ( v4 == 654 )
          {
            v9 = (char *)&unk_4A2F78;
          }
          else
          {
            v9 = (char *)&unk_4A2D2C;
          }
          goto LABEL_14;
        }
        if ( v4 == 648 )
        {
          v9 = (char *)&unk_4A2EE0;
          goto LABEL_14;
        }
        if ( v4 >= 649 )
        {
          if ( v4 == 649 )
          {
            v9 = (char *)&unk_4A2D9C;
            goto LABEL_14;
          }
        }
        else if ( v4 == 646 )
        {
          v9 = (char *)&unk_4A2CB4;
          goto LABEL_14;
        }
      }
    }
LABEL_176:
    *a1 = v4 | 0x8000;
    return result;
  }
  if ( v4 == 418 )
  {
    v9 = (char *)&unk_4A2E14;
    goto LABEL_14;
  }
  if ( v4 >= 419 )
  {
    if ( v4 == 478 )
    {
      v9 = (char *)&unk_4A2C28;
      goto LABEL_14;
    }
    if ( v4 >= 479 )
    {
      if ( v4 == 523 )
      {
        v9 = (char *)&unk_4A2EA4;
        goto LABEL_14;
      }
      if ( v4 >= 524 )
      {
        if ( v4 == 525 )
        {
          v9 = (char *)&unk_4A2F2C;
          goto LABEL_14;
        }
        if ( v4 < 525 )
        {
          v9 = (char *)&unk_4A2DA8;
          goto LABEL_14;
        }
        if ( v4 == 526 )
        {
          v9 = (char *)&unk_4A2FBC;
          goto LABEL_14;
        }
        if ( v4 == 612 )
        {
          v9 = (char *)&unk_4A2D20;
          goto LABEL_14;
        }
      }
      else
      {
        if ( v4 == 517 )
        {
          v9 = (char *)&unk_4A2F14;
          goto LABEL_14;
        }
        if ( v4 >= 518 )
        {
          if ( v4 == 518 )
          {
            v9 = (char *)&unk_4A2F84;
            goto LABEL_14;
          }
          if ( v4 == 520 )
          {
            v9 = (char *)&unk_4A2D78;
            goto LABEL_14;
          }
        }
        else if ( v4 == 515 )
        {
          v9 = (char *)&unk_4A2CF8;
          goto LABEL_14;
        }
      }
    }
    else
    {
      if ( v4 == 454 )
      {
        v9 = (char *)&unk_4A2E48;
        goto LABEL_14;
      }
      if ( v4 >= 455 )
      {
        if ( v4 == 458 )
        {
          v9 = (char *)&unk_4A2F38;
          goto LABEL_14;
        }
        if ( v4 >= 459 )
        {
          if ( v4 == 464 )
          {
            v9 = (char *)&unk_4A2C4C;
            goto LABEL_14;
          }
          if ( v4 == 465 )
          {
            v9 = (char *)&unk_4A2BFC;
            goto LABEL_14;
          }
        }
        else if ( v4 == 457 )
        {
          v9 = (char *)&unk_4A2D14;
          goto LABEL_14;
        }
      }
      else
      {
        if ( v4 == 437 )
        {
          v9 = (char *)&unk_4A2ED4;
          goto LABEL_14;
        }
        result = 438;
        if ( v4 >= 438 )
        {
          if ( v4 == 438 )
          {
            v9 = (char *)&unk_4A2D90;
            goto LABEL_14;
          }
        }
        else if ( v4 == 434 )
        {
          v9 = (char *)&unk_4A2CC0;
          goto LABEL_14;
        }
      }
    }
    goto LABEL_176;
  }
  if ( v4 == 151 )
  {
    v9 = (char *)&unk_4A2C18;
    goto LABEL_14;
  }
  result = 191;
  if ( v4 >= 152 )
  {
    if ( v4 == 191 )
    {
      v9 = (char *)&unk_4A2E88;
      goto LABEL_14;
    }
    if ( v4 >= 192 )
    {
      if ( v4 == 415 )
      {
        v9 = (char *)&unk_4A2F60;
        goto LABEL_14;
      }
      if ( v4 >= 416 )
      {
        if ( v4 == 416 )
          v9 = (char *)&unk_4A2FD4;
        else
          v9 = (char *)&unk_4A2DE0;
        goto LABEL_14;
      }
      if ( v4 == 414 )
      {
        v9 = (char *)&unk_4A2D38;
        goto LABEL_14;
      }
    }
    else
    {
      if ( v4 == 189 )
      {
        v9 = (char *)&unk_4A2EC8;
        goto LABEL_14;
      }
      if ( v4 >= 190 )
      {
        v9 = (char *)&unk_4A2DEC;
        goto LABEL_14;
      }
      if ( v4 == 152 )
      {
        v9 = (char *)&unk_4A2BE0;
        goto LABEL_14;
      }
    }
    goto LABEL_176;
  }
  if ( v4 == 117 )
  {
    v9 = (char *)&unk_4A2E60;
    goto LABEL_14;
  }
  if ( v4 >= 118 )
  {
    if ( v4 == 144 )
    {
      v9 = (char *)&unk_4A2C34;
      goto LABEL_14;
    }
    if ( v4 >= 145 )
    {
      if ( v4 == 145 )
      {
        v9 = (char *)&unk_4A2C40;
        goto LABEL_14;
      }
      if ( v4 == 150 )
      {
        v9 = (char *)&unk_4A2C08;
        goto LABEL_14;
      }
    }
    else if ( v4 == 143 )
    {
      v9 = (char *)&unk_4A2BF0;
      goto LABEL_14;
    }
    goto LABEL_176;
  }
  if ( v4 == 91 )
  {
    v9 = (char *)&unk_4A2EB0;
    goto LABEL_14;
  }
  if ( v4 >= 92 )
  {
    if ( v4 == 116 )
    {
      v9 = (char *)&unk_4A2D84;
      goto LABEL_14;
    }
    goto LABEL_176;
  }
  if ( v4 != 88 )
    goto LABEL_176;
  v9 = (char *)&unk_4A2CA0;
LABEL_14:
  if ( v9[1] != a3 )
  {
LABEL_15:
    v4 += 1024;
    *a1 = v4;
    goto LABEL_16;
  }
  while ( 1 )
  {
    result = memcmp(a2, v9 + 2, a3);
    v10 = v4 + 1024;
    if ( !result )
      return result;
    v4 += 1024;
    *a1 = v10;
LABEL_16:
    v7 = v4 < 646;
    if ( v4 != 645 )
      goto LABEL_3;
LABEL_17:
    v9 = (char *)&unk_4A2CA8;
    if ( a3 != 9 )
      goto LABEL_15;
  }
}
// 490E4C: conditional instruction was optimized away because $s0.4==294
// 490F6C: conditional instruction was optimized away because $s0.4==28F
// 491104: conditional instruction was optimized away because $s0.4==1A1
// 491148: conditional instruction was optimized away because $s0.4==690
// 491164: conditional instruction was optimized away because $s0.4==29D
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);

//----- (00491388) --------------------------------------------------------
int   getAsnOID(unsigned __int8 **a1, int a2, int *a3, unsigned __int8 a4, _WORD *a5)
{
  unsigned __int8 *v6; // $a0
  __int16 v7; // $s5
  unsigned __int8 *v8; // $s0
  int v9; // $s2
  int v11; // $a3
  __int16 v12; // $s3
  int v13; // $v1
  int v15; // $t3
  unsigned __int8 *v16; // $a1
  unsigned int v17; // $t0
  int v18; // $a2
  BOOL v19; // $t4
  int v20; // $t0
  int v21; // $a3
  int v22; // $t9
  __int16 v24; // $a1
  unsigned __int8 *v25; // [sp+18h] [-8h]

  v6 = *a1;
  v7 = a2;
  v8 = &v6[a2];
  v9 = a4;
  v11 = -31;
  v12 = a2;
  if ( *v6 != 6 )
    return v11;
  v11 = -9;
  if ( a2 - 1 <= 0 )
    return v11;
  v15 = (char)v6[1];
  v16 = v6 + 2;
  v17 = v15 & 0x7F;
  if ( v15 >= 0 )
  {
LABEL_6:
    v11 = -9;
    if ( v8 - v16 >= v17 )
    {
      v18 = v17;
      v19 = v8 - v16 < v17;
      v25 = v16;
      v20 = (int)v16;
      v21 = v18;
      v13 = -9;
      if ( !v19 && v8 - v16 >= 2 )
      {
        *a3 = 0;
        if ( v18 )
        {
          do
          {
            v22 = *v16++;
            *a3 += v22;
            v25 = v16;
          }
          while ( v21-- != 1 );
        }
        sub_490BB8(a3, v20, v18);
        v13 = 0;
        if ( v9 )
        {
          v24 = v7 - (v12 - ((_WORD)v8 - (_WORD)v25));
          *a5 = v24;
          if ( *v25 == 5 )
          {
            v13 = -9;
            if ( v8 - v25 >= 2 && (unsigned __int16)(v7 - (v12 - ((_WORD)v8 - (_WORD)v25))) >= 2u )
            {
              v13 = 0;
              *a5 = v24 - 2;
              *a1 = v25 + 2;
            }
          }
          else
          {
            *a1 = v25;
          }
        }
        else
        {
          *a5 = 0;
          *a1 = v25;
        }
      }
      return v13;
    }
    return v11;
  }
  v13 = -9;
  if ( v8 - v16 >= v17 )
  {
    switch ( v15 & 0x7F )
    {
      case 0:
        return -9;
      case 1:
        v17 = *v16;
        v16 = v6 + 3;
        goto LABEL_6;
      case 2:
        v17 = (v6[2] << 8) | v6[3];
        v16 = v6 + 4;
        goto LABEL_6;
      case 3:
        v17 = (*v16 << 16) | (v6[3] << 8) | v6[4];
        v16 = v6 + 5;
        goto LABEL_6;
      case 4:
        v17 = _byteswap_ulong(*(_DWORD *)(v6 + 2));
        v16 = v6 + 6;
        goto LABEL_6;
      default:
        return v13;
    }
  }
  return v13;
}

//----- (00491604) --------------------------------------------------------
int   getAsnAlgorithmIdentifier(unsigned int **a1, int a2, int *a3, _WORD *a4)
{
  unsigned int *v5; // $a0
  int v8; // $v1
  int v9; // $t0
  int v10; // $v0
  _BYTE *v11; // $s0
  int v12; // $a1
  _BYTE *v14; // $t4
  int v15; // $t5
  unsigned int *v16; // $a3
  unsigned int v17; // $t1
  int v18; // $t9
  unsigned int *v19; // $a0
  unsigned int v20; // $t0
  int v21; // $t1
  int v22; // $a0
  int v23; // $a2
  unsigned int *v24; // $a1
  int v25; // $a0
  unsigned int *v27; // $a3
  unsigned __int8 *v28; // $a2
  unsigned int *v29; // [sp+18h] [-18h]
  unsigned int v30; // [sp+1Ch] [-14h]
  unsigned int *v31; // [sp+24h] [-Ch]

  v5 = *a1;
  v29 = v5;
  v8 = -31;
  if ( !a2 )
    return v8;
  v9 = -31;
  if ( *(_BYTE *)v5 != 48 )
    goto LABEL_3;
  v30 = 0;
  v14 = (char *)v5 + a2;
  v9 = -9;
  if ( a2 - 1 <= 0 )
    goto LABEL_3;
  v15 = *((char *)v5 + 1);
  v16 = (unsigned int *)((char *)v5 + 2);
  v17 = v15 & 0x7F;
  if ( v15 < 0 )
  {
    v28 = (unsigned __int8 *)v5 + 2;
    v10 = -9;
    if ( v14 - (_BYTE *)v16 >= v17 )
    {
      switch ( v15 & 0x7F )
      {
        case 0:
          goto LABEL_25;
        case 1:
          v17 = *v28;
          v16 = (unsigned int *)((char *)v5 + 3);
          goto LABEL_12;
        case 2:
          v17 = (*v28 << 8) | *((unsigned __int8 *)v5 + 3);
          v16 = v5 + 1;
          goto LABEL_12;
        case 3:
          v17 = (*v28 << 16) | (*((unsigned __int8 *)v5 + 3) << 8) | *((unsigned __int8 *)v5 + 4);
          v16 = (unsigned int *)((char *)v5 + 5);
          goto LABEL_12;
        case 4:
          v17 = _byteswap_ulong(*(unsigned int *)((char *)v5 + 2));
          v16 = (unsigned int *)((char *)v5 + 6);
          goto LABEL_12;
        default:
          goto LABEL_4;
      }
    }
    goto LABEL_4;
  }
LABEL_12:
  if ( v14 - (_BYTE *)v16 < v17 )
  {
LABEL_25:
    v9 = -9;
LABEL_3:
    v10 = v9;
    goto LABEL_4;
  }
  v30 = v17;
  v8 = -9;
  if ( a2 - ((char *)v16 - (char *)v5) < v17 )
    return v8;
  v10 = 0;
  v29 = v16;
LABEL_4:
  v8 = v10;
  if ( v10 < 0 )
    return v8;
  v8 = -9;
  if ( (char *)v5 + a2 - (char *)v29 <= 0 )
    return v8;
  v11 = (char *)v29 + v30;
  v12 = -31;
  if ( *(_BYTE *)v29 != 6 )
    goto LABEL_7;
  v12 = -9;
  if ( (int)(v30 - 1) <= 0 )
    goto LABEL_7;
  v18 = *((char *)v29 + 1);
  v19 = (unsigned int *)((char *)v29 + 2);
  v20 = v18 & 0x7F;
  if ( v18 < 0 )
  {
    if ( v11 - (_BYTE *)v19 >= v20 )
    {
      v8 = -9;
      switch ( v18 & 0x7F )
      {
        case 0:
          goto LABEL_26;
        case 1:
          v20 = *(unsigned __int8 *)v19;
          v19 = (unsigned int *)((char *)v29 + 3);
          goto LABEL_17;
        case 2:
          v20 = (*((unsigned __int8 *)v29 + 2) << 8) | *((unsigned __int8 *)v29 + 3);
          v19 = v29 + 1;
          goto LABEL_17;
        case 3:
          v20 = (*((unsigned __int8 *)v29 + 2) << 16)
              | (*((unsigned __int8 *)v29 + 3) << 8)
              | *((unsigned __int8 *)v29 + 4);
          v19 = (unsigned int *)((char *)v29 + 5);
          goto LABEL_17;
        case 4:
          v20 = _byteswap_ulong(*v19);
          v19 = (unsigned int *)((char *)v29 + 6);
          goto LABEL_17;
        default:
          goto LABEL_8;
      }
    }
LABEL_7:
    v8 = v12;
LABEL_8:
    *a1 = v29;
    return v8;
  }
LABEL_17:
  if ( v11 - (_BYTE *)v19 < v20 )
  {
LABEL_26:
    v8 = -9;
    goto LABEL_8;
  }
  v21 = (int)v19;
  v31 = v19;
  v22 = v11 - (_BYTE *)v19;
  v23 = v20;
  v24 = (unsigned int *)v21;
  v8 = -9;
  if ( v22 < v20 || v22 < 2 )
    goto LABEL_8;
  *a3 = 0;
  if ( v20 )
  {
    do
    {
      v25 = *(unsigned __int8 *)v24;
      v24 = (unsigned int *)((char *)v24 + 1);
      *a3 += v25;
      v31 = v24;
    }
    while ( v20-- != 1 );
  }
  sub_490BB8(a3, v21, v23);
  *a4 = (_WORD)v11 - (_WORD)v31;
  v8 = 0;
  if ( *(_BYTE *)v31 == 5 )
  {
    if ( v11 - (_BYTE *)v31 < 2 || (unsigned __int16)((_WORD)v11 - (_WORD)v31) < 2u )
    {
      v8 = -9;
      *a1 = v29;
      return v8;
    }
    v27 = (unsigned int *)((char *)v31 + 2);
    v8 = 0;
    *a4 = (_WORD)v11 - (_WORD)v31 - 2;
  }
  else
  {
    v27 = v31;
  }
  *a1 = v27;
  return v8;
}
// 4916A0: variable 'v30' is possibly undefined

//----- (004919F8) --------------------------------------------------------
int   psBase64decode(int a1, unsigned __int16 a2, int a3, _WORD *a4)
{
  unsigned int v5; // $t1
  int v6; // $t3
  int v7; // $t4
  int v8; // $t2
  int v9; // $a1
  unsigned int v10; // $t0
  unsigned int v11; // $v0
  bool v12; // dc
  unsigned __int8 *v13; // $v0
  int v14; // $a0
  __int16 v15; // $v1
  int result; // $v0
  __int16 v17; // $v1
  unsigned __int16 v18; // $v0

  v5 = a2;
  if ( !a1 )
    return -6;
  if ( !a3 )
    return -6;
  v6 = 3;
  if ( !a4 )
    return -6;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( v5 )
  {
    do
    {
      while ( 1 )
      {
        v11 = *(unsigned __int8 *)(v10 + a1);
        v12 = v11 >= 0x7B;
        v13 = (unsigned __int8 *)&unk_4A2FE0 + v11;
        if ( !v12 )
        {
          v14 = *v13;
          if ( v14 != 255 )
          {
            v15 = v6 - 1;
            if ( v14 == 254 )
            {
              v6 = v15;
              v14 = 0;
              if ( v15 < 0 )
                return -9;
            }
            else
            {
              result = -31;
              if ( v6 != 3 )
                return result;
            }
            v9 = (unsigned __int16)(v9 + 1);
            v7 = (v7 << 6) | v14;
            if ( v9 == 4 )
              break;
          }
        }
        v10 = (unsigned __int16)(v10 + 1);
        if ( v10 >= v5 )
          goto LABEL_18;
      }
      v17 = v8;
      if ( (unsigned __int16)*a4 < v8 + v6 )
        return -9;
      *(_BYTE *)(v8 + a3) = BYTE2(v7);
      v8 = (unsigned __int16)(v8 + 1);
      if ( v6 >= 2 )
      {
        *(_BYTE *)(v8 + a3) = BYTE1(v7);
        v8 = (unsigned __int16)(v17 + 2);
      }
      v18 = v10 + 1;
      if ( v6 >= 3 )
      {
        *(_BYTE *)(v8 + a3) = v7;
        v8 = (unsigned __int16)(v8 + 1);
        v18 = v10 + 1;
      }
      v10 = v18;
      v7 = 0;
      v9 = 0;
    }
    while ( v18 < v5 );
LABEL_18:
    result = -31;
    if ( v9 )
      return result;
  }
  *a4 = v8;
  return 0;
}

//----- (00491B8C) --------------------------------------------------------
int psCrlOpen()
{
  psCreateMutex((int)&unk_4E9E9C, 0);
  return 0;
}

//----- (00491BCC) --------------------------------------------------------
int   sub_491BCC(int a1)
{
  int result; // $v0
  int v2; // $s0
  int v3; // $s1
  int v4; // $v0
  int v5; // $v1
  _BYTE *v6; // $s3
  int v7; // $s1
  unsigned int v8; // $v0
  int v9; // $v0
  int *v10; // $a2
  int *v11; // $a3
  int v12; // $t1
  int v13; // $t0
  int v14; // $a0
  int v15; // $a1
  int v16; // $t3
  int v17; // $t2
  bool v18; // dc
  _DWORD v19[12]; // [sp+18h] [-90h] BYREF
  int v20[8]; // [sp+48h] [-60h] BYREF
  char v21; // [sp+68h] [-40h] BYREF
  _DWORD v22[12]; // [sp+78h] [-30h] BYREF

  result = 0;
  if ( a1 )
  {
    v2 = dword_4E6960;
    v3 = a1 + 196;
    if ( dword_4E6960 )
    {
      while ( 1 )
      {
        v4 = memcmpct(v2 + 216, v3, 20);
        v5 = -33;
        if ( !v4 )
          v5 = 1;
        if ( v5 == 1 )
          break;
        v2 = *(_DWORD *)(v2 + 548);
        if ( !v2 )
          return 0;
      }
      v6 = *(_BYTE **)(v2 + 168);
      v7 = *(_DWORD *)(v2 + 164);
      if ( psGetBrokenDownGMTime(v19, 0) )
        goto LABEL_14;
      v8 = strlen(v6);
      v9 = psBrokenDownTimeImport(v20, v6, v8, 2 * (v7 == 0x17));
      v10 = v20;
      if ( v9 )
        goto LABEL_14;
      v11 = v22;
      do
      {
        v12 = *v10;
        v13 = v10[1];
        v14 = v10[2];
        v15 = v10[3];
        v10 += 4;
        *v11 = v12;
        v11[1] = v13;
        v11[2] = v14;
        v11[3] = v15;
        v11 += 4;
      }
      while ( v10 != (int *)&v21 );
      v16 = *v10;
      v17 = v10[1];
      v11[2] = v10[2];
      *v11 = v16;
      v11[1] = v17;
      if ( psBrokenDownTimeAdd(v22, 86400) )
      {
LABEL_14:
        *(_WORD *)(v2 + 182) = 1;
        return v2;
      }
      else
      {
        v18 = psBrokenDownTimeCmp((int)v19, (int)v22) <= 0;
        result = v2;
        if ( !v18 )
          *(_WORD *)(v2 + 182) = 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 4E6960: using guessed type int dword_4E6960;
// 4E9F24: using guessed type int   strlen(_DWORD);

//----- (00491DB4) --------------------------------------------------------
int   sub_491DB4(_DWORD *a1)
{
  _DWORD *v2; // $s1
  _DWORD *v3; // $s0
  _DWORD *v4; // $a0
  int v5; // $a0
  int result; // $v0

  if ( a1 )
  {
    psX509FreeDNStruct(a1 + 46);
    x509FreeExtensions(a1 + 79);
    v2 = (_DWORD *)a1[136];
    if ( v2 )
    {
      do
      {
        v3 = (_DWORD *)v2[13];
        free2(*v2);
        v4 = v2;
        v2 = v3;
        free2(v4);
      }
      while ( v3 );
    }
    v5 = a1[44];
    a1[136] = 0;
    free2(v5);
    free2(a1[42]);
    memset(a1, 0, 552);
    return free2(a1);
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (00491ED8) --------------------------------------------------------
int psCrlClose()
{
  _DWORD *v0; // $a0
  int v1; // $v0
  _DWORD *v2; // $s2
  int v3; // $s1
  int v4; // $s0

  psLockMutex();
  v0 = (_DWORD *)dword_4E6960;
  if ( dword_4E6960 )
  {
    while ( 1 )
    {
      v1 = dword_4E6960;
      v2 = (_DWORD *)v0[137];
      if ( !dword_4E6960 )
        goto LABEL_10;
      v3 = 0;
      if ( !v0 )
        goto LABEL_10;
      v4 = *(_DWORD *)(dword_4E6960 + 548);
      while ( (_DWORD *)v1 != v0 )
      {
        v3 = v1;
        v1 = *(_DWORD *)(v1 + 548);
        if ( !v1 )
          goto LABEL_10;
        v4 = *(_DWORD *)(v1 + 548);
      }
      sub_491DB4(v0);
      if ( v3 )
      {
        *(_DWORD *)(v3 + 548) = v4;
LABEL_10:
        v0 = v2;
        if ( !v2 )
          break;
      }
      else
      {
        dword_4E6960 = v4;
        v0 = v2;
        if ( !v2 )
          break;
      }
    }
  }
  if ( dword_4E6960 )
  {
    psTraceStr("psAssert %s", (int)"keyformat/crl.c");
    psTraceInt(":%d ", 255);
    psError((int)"g_CRL == NULL");
  }
  psUnlockMutex();
  return psDestroyMutex();
}
// 4E6960: using guessed type int dword_4E6960;

//----- (0049209C) --------------------------------------------------------
int   psCRL_determineRevokedStatusBDT(int a1, _DWORD *a2)
{
  int result; // $v0
  int v5; // $v0
  int v6; // $s1
  int v7; // $a0
  int v8; // $v0
  int v9; // $v0
  int v10; // $s0
  _DWORD *v11; // $a3
  int *v12; // $t0
  int *v13; // $a2
  int v14; // $t8
  int v15; // $s5
  int v16; // $s4
  int v17; // $s0
  int v18; // $v1
  int v19; // $ra
  int v20; // $s0
  unsigned __int16 v21; // $t4
  unsigned __int16 v22; // $a2
  unsigned __int8 *v23; // $a3
  int v24; // $v1
  int v25; // $v0
  _DWORD v26[2]; // [sp+30h] [-8h] BYREF

  result = 0;
  if ( a1 )
  {
    psLockMutex();
    v5 = sub_491BCC(a1);
    v6 = v5;
    if ( !v5 )
    {
      if ( *(_DWORD *)(a1 + 676) )
        *(_DWORD *)(a1 + 696) = 5;
      else
        *(_DWORD *)(a1 + 696) = 6;
      goto LABEL_18;
    }
    if ( *(_WORD *)(v5 + 182) )
    {
      *(_DWORD *)(a1 + 696) = 11;
LABEL_18:
      psUnlockMutex();
      return *(_DWORD *)(a1 + 696);
    }
    if ( !*(_DWORD *)(v5 + 4) )
    {
      v20 = *(_DWORD *)(a1 + 796);
      if ( v20 )
      {
        v26[0] = 0;
        *(_DWORD *)(v5 + 4) = 0;
        if ( ((*(_DWORD *)(v20 + 484) >> 1) & 1) != 0 && !memcmpct(v5 + 216, v20 + 328, 20) )
        {
          v21 = *(_WORD *)(v6 + 180);
          v22 = *(_WORD *)(v6 + 72);
          v23 = *(unsigned __int8 **)(v6 + 176);
          v26[1] = 0;
          if ( !psVerifySig(0, (_BYTE *)(v6 + 8), v22, v23, v21, v20 + 40, *(_DWORD *)(v6 + 172), v26) && v26[0] == 1 )
            *(_DWORD *)(v6 + 4) = 1;
        }
      }
    }
    v7 = -1;
    if ( a1 )
    {
      v8 = v6;
      if ( v6 || (v8 = sub_491BCC(a1), v7 = -1, v8) )
      {
        v9 = *(_DWORD *)(v8 + 544);
        v7 = 0;
        if ( v9 )
        {
          v10 = v9;
          while ( *(unsigned __int16 *)(a1 + 160) != *(unsigned __int16 *)(v10 + 4)
               || memcmpct(*(_DWORD *)(a1 + 156), *(_DWORD *)v10, *(unsigned __int16 *)(a1 + 160)) )
          {
            v10 = *(_DWORD *)(v10 + 52);
            v7 = 0;
            if ( !v10 )
              goto LABEL_26;
          }
          v11 = a2;
          if ( a2 )
          {
            v12 = (int *)(v10 + 40);
            v13 = (int *)(v10 + 8);
            do
            {
              v14 = *v13;
              v15 = v13[1];
              v16 = v13[2];
              v17 = v13[3];
              v13 += 4;
              *v11 = v14;
              v11[1] = v15;
              v11[2] = v16;
              v11[3] = v17;
              v11 += 4;
            }
            while ( v13 != v12 );
            v18 = *v13;
            v19 = v13[1];
            v11[2] = v13[2];
            *v11 = v18;
            v11[1] = v19;
          }
          v7 = 1;
        }
        else
        {
LABEL_26:
          v24 = *(_DWORD *)(v6 + 4);
          if ( v24 == 1 )
          {
            *(_DWORD *)(a1 + 696) = 7;
            goto LABEL_18;
          }
          v25 = 8;
          if ( !v24 )
            goto LABEL_32;
        }
      }
    }
    if ( v7 == 1 && *(_DWORD *)(v6 + 4) == 1 )
    {
      *(_DWORD *)(a1 + 696) = 9;
      goto LABEL_18;
    }
    if ( v7 != 1 )
      goto LABEL_18;
    v25 = 10;
    if ( *(_DWORD *)(v6 + 4) )
      goto LABEL_18;
LABEL_32:
    *(_DWORD *)(a1 + 696) = v25;
    goto LABEL_18;
  }
  return result;
}

//----- (00492398) --------------------------------------------------------
int   psCRL_determineRevokedStatus(int a1)
{
  return psCRL_determineRevokedStatusBDT(a1, 0);
}

//----- (004923B4) --------------------------------------------------------
int   memset_s(unsigned __int8 *a1, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v6; // [sp+2Ch] [+2Ch]

  v6 = a4;
  if ( a2 < a4 )
    v6 = a2;
  memset(a1, a3, v6);
  return *a1;
}
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);

//----- (00492450) --------------------------------------------------------
void psCoreClose()
{
  if ( byte_4E6964 == 89 )
  {
    byte_4E6964 = 78;
    psDestroyMutex();
    osdepMutexClose();
    osdepEntropyClose();
    osdepTimeClose();
  }
}
// 4E6964: using guessed type char byte_4E6964;

//----- (004924E8) --------------------------------------------------------
int   memcmpct(int a1, int a2, int a3)
{
  int i; // $a3
  int result; // $v0

  for ( i = 0; ; i |= (unsigned __int8)(*(_BYTE *)(a1 + a3) ^ *(_BYTE *)(a2 + a3)) )
  {
    result = i;
    if ( !a3 )
      break;
    --a3;
  }
  return result;
}

//----- (0049252C) --------------------------------------------------------
int   psErrorStr(char *a1, int a2)
{
  psTraceStr(a1, a2);
  return psTrace((int)"\n");
}

//----- (00492570) --------------------------------------------------------
int   psCoreOpen(int a1)
{
  int v2; // $a0
  int v3; // $v0
  int Mutex; // $v0

  v2 = 1;
  if ( byte_4E6964 != 89 )
  {
    strncpy(&byte_4E6964, "YYNY", 31);
    if ( strncmp(&byte_4E6964, a1, 4) )
    {
      psTraceStr("psError %s", (int)"corelib.c");
      psTraceInt(":%d ", 65);
      psTraceStr("Core config mismatch.\nLibrary: YYNY\nCurrent: %s\n", a1);
      psTrace((int)"\n");
      return -1;
    }
    v3 = osdepTimeOpen();
    v2 = -1;
    if ( v3 >= 0 )
    {
      if ( osdepEntropyOpen() >= 0 )
      {
        if ( osdepMutexOpen() >= 0 )
        {
          Mutex = psCreateMutex((int)&unk_4E9EB4, 0);
          v2 = 0;
          if ( Mutex >= 0 )
            return v2;
          osdepMutexClose();
        }
        osdepEntropyClose();
      }
      osdepTimeClose();
      return -1;
    }
  }
  return v2;
}
// 4E6964: using guessed type char byte_4E6964;
// 4E9FD8: using guessed type int   strncpy(_DWORD, _DWORD, _DWORD);
// 4E9FDC: using guessed type int   strncmp(_DWORD, _DWORD, _DWORD);

//----- (00492734) --------------------------------------------------------
int   psError(int a1)
{
  psTrace(a1);
  return psTrace((int)"\n");
}

//----- (00492778) --------------------------------------------------------
int   psErrorInt(char *a1, int a2)
{
  psTraceInt(a1, a2);
  return psTrace((int)"\n");
}

//----- (004927BC) --------------------------------------------------------
int   psFreeList(_DWORD *a1)
{
  _DWORD *v1; // $s0
  int result; // $v0
  _DWORD *v3; // $s1
  _DWORD *v4; // $a0

  v1 = a1;
  if ( a1 )
  {
    do
    {
      while ( 1 )
      {
        v3 = (_DWORD *)v1[1];
        if ( *v1 )
          break;
        result = free2(v1);
        v1 = v3;
        if ( !v3 )
          return result;
      }
      free2(*v1);
      v4 = v1;
      v1 = v3;
      result = free2(v4);
    }
    while ( v3 );
  }
  return result;
}
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00492854) --------------------------------------------------------
int   psParseList(int a1, char *a2, int a3, _DWORD *a4)
{
  int v4; // $s6
  char *v5; // $s0
  int v6; // $v0
  int v8; // $s6
  int *v9; // $s3
  int v10; // $s2
  int v11; // $v1
  _DWORD *v12; // $v0
  _DWORD *v13; // $s5
  int *v14; // $s1
  int v15; // $s4
  char *v16; // $s7
  int i; // $v0
  int v18; // $v0
  int *v20; // $v0
  _DWORD *v21; // $s0
  _DWORD *v22; // $s1
  _DWORD *v23; // $a0
  _DWORD *v24; // $s0
  _DWORD *v25; // $s1

  *a4 = 0;
  v4 = a3 << 24;
  v5 = a2;
  v6 = strlen(a2);
  v8 = v4 >> 24;
  v9 = 0;
  v10 = v6 + 1;
  v11 = -6;
  if ( !v6 )
    return v11;
  v12 = (_DWORD *)malloc(12);
  v13 = v12;
  v14 = v12;
  v11 = -8;
  if ( !v12 )
    return v11;
  *v12 = 0;
  v12[1] = 0;
  v12[2] = 0;
  if ( !v10 )
  {
LABEL_10:
    *a4 = v13;
    return 0;
  }
  while ( 1 )
  {
    v15 = 0;
    v16 = v5;
    if ( !v14 )
    {
      v20 = (int *)malloc(12);
      v14 = v20;
      if ( !v20 )
      {
        v24 = v13;
        do
        {
          v25 = (_DWORD *)v24[1];
          if ( *v24 )
            free2(*v24);
          free2(v24);
          v24 = v25;
        }
        while ( v25 );
        return -8;
      }
      *v20 = 0;
      v20[1] = 0;
      v20[2] = 0;
      v9[1] = (int)v20;
    }
    for ( i = *v5; i != v8; --v10 )
    {
      if ( !i )
        break;
      i = *++v5;
      ++v15;
    }
    v18 = malloc(v15 + 1);
    *v14 = v18;
    if ( !v18 )
      break;
    *((_WORD *)v14 + 4) = v15;
    memset(v18, 0, v15 + 1);
    memcpy(*v14, v16, v15);
    v9 = v14;
    --v10;
    v14 = (int *)v14[1];
    ++v5;
    if ( !v10 )
      goto LABEL_10;
  }
  v21 = v13;
  do
  {
    while ( 1 )
    {
      v22 = (_DWORD *)v21[1];
      if ( *v21 )
        break;
      free2(v21);
      v21 = v22;
      if ( !v22 )
        return -8;
    }
    free2(*v21);
    v23 = v21;
    v21 = v22;
    free2(v23);
  }
  while ( v22 );
  return -8;
}
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F24: using guessed type int   strlen(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00492AE0) --------------------------------------------------------
int   psBurnStack(unsigned int a1)
{
  int result; // $v0
  unsigned __int8 v3[32]; // [sp+18h] [-20h] BYREF

  result = memset_s(v3, 0x20u, 0, 0x20u);
  if ( a1 >= 0x21 )
    return psBurnStack(a1 - 32);
  return result;
}

//----- (00492B5C) --------------------------------------------------------
int   psBrokenDownTimeAdd(_DWORD *a1, int a2)
{
  int result; // $v0
  int v4; // $a0
  int v5; // $a3
  int v6; // $a2
  int v7; // $t0
  int v8; // $a2
  int v9; // $t2
  int v10; // $a3
  int v11; // $a1
  int v12; // $v1
  int v13; // $a0
  int v14; // $v1
  int v15; // $a0
  int v16; // $a0
  int v17; // $a2
  char v18; // $t4
  bool v19; // dc
  unsigned __int8 v20; // $a2
  int v21; // $a2
  char v22; // $t4
  unsigned __int8 v23; // $a2

  result = -1;
  if ( a2 >= 0 )
  {
    if ( a2 > 883612800 )
    {
      v4 = a1[5];
      do
      {
        a2 -= 883612800;
        v4 += 28;
      }
      while ( a2 > 883612800 );
      a1[5] = v4;
    }
    result = 0;
    if ( a2 )
    {
      v5 = *a1 + a2;
      if ( v5 < 60 )
      {
        v6 = a1[1];
        *a1 = v5;
        if ( v6 >= 60 )
        {
LABEL_9:
          v7 = a1[2] + v6 / 60;
          a1[1] = v6 % 60;
          a1[2] = v7;
          if ( v7 >= 24 )
          {
LABEL_10:
            v8 = v7 / 24;
            v9 = a1[6] + v7 / 24;
            v7 %= 24;
            v10 = a1[3] + v8;
            a1[3] = v10;
            a1[2] = v7;
            a1[6] = v9 % 7;
LABEL_11:
            v11 = a1[4];
            while ( 1 )
            {
              v12 = -1;
              if ( v11 >= 12 )
                goto LABEL_15;
              v13 = byte_4E6984[v11];
              if ( v13 == 28 )
                break;
LABEL_14:
              v12 = v13;
LABEL_15:
              result = 0;
              if ( v12 >= v10 )
                return result;
              v14 = -1;
              if ( v11 < 12 )
              {
                v15 = byte_4E6984[v11];
                if ( v15 != 28 )
                {
LABEL_18:
                  v14 = v15;
                  goto LABEL_19;
                }
                v21 = a1[5] + 1900;
                v22 = 0;
                if ( (v21 & 3) != 0 )
                {
LABEL_32:
                  v23 = v22 + 28;
                }
                else if ( v21 != 100 * (v21 / 100) || (v19 = v21 != 400 * (v21 / 400), v23 = byte_4E6984[v11], !v19) )
                {
                  v22 = 1;
                  goto LABEL_32;
                }
                v15 = v23;
                goto LABEL_18;
              }
LABEL_19:
              v16 = v11++;
              v10 -= v14;
              a1[3] = v10;
              if ( v11 >= 12 )
              {
                v11 = v16 - 11;
                ++a1[5];
              }
              a1[4] = v11;
              v7 %= 60;
              a1[2] = v7;
            }
            v17 = a1[5] + 1900;
            v18 = 0;
            if ( (v17 & 3) == 0 )
            {
              if ( v17 == 100 * (v17 / 100) )
              {
                v19 = v17 != 400 * (v17 / 400);
                v20 = byte_4E6984[v11];
                if ( v19 )
                  goto LABEL_27;
              }
              v18 = 1;
            }
            v20 = v18 + 28;
LABEL_27:
            v13 = v20;
            goto LABEL_14;
          }
LABEL_37:
          v10 = a1[3];
          goto LABEL_11;
        }
      }
      else
      {
        v6 = a1[1] + v5 / 60;
        *a1 = v5 % 60;
        a1[1] = v6;
        if ( v6 >= 60 )
          goto LABEL_9;
      }
      v7 = a1[2];
      if ( v7 >= 24 )
        goto LABEL_10;
      goto LABEL_37;
    }
  }
  return result;
}
// 4E6984: using guessed type unsigned __int8 byte_4E6984[12];

//----- (00492EC8) --------------------------------------------------------
int   psGetBrokenDownGMTime(_DWORD *a1, int a2)
{
  int v4; // $v1
  int v5; // $a0
  int v6; // $a0
  int v7; // $s3
  int v8; // $v0
  int v10; // [sp+18h] [-8h] BYREF

  v4 = time(0);
  v5 = -1;
  if ( v4 != -1 )
  {
    v6 = v4 + a2;
    if ( a2 < 0 && v4 < v6 || a2 > 0 )
      v6 = v4;
    v10 = v6;
    v7 = -1;
    if ( gmtime_r(&v10, a1) )
      v7 = 0;
    if ( v10 < 0 && (int)a1[5] < 70 )
    {
      psBrokenDownTimeAdd(a1, 1767225600);
      psBrokenDownTimeAdd(a1, 1767225600);
      psBrokenDownTimeAdd(a1, 760516096);
    }
    v8 = v7;
    if ( !v7 && a2 > 0 )
      return psBrokenDownTimeAdd(a1, a2);
    return v8;
  }
  return v5;
}
// 4E9F90: using guessed type int   time(_DWORD);
// 4EA034: using guessed type int   gmtime_r(_DWORD, _DWORD);

//----- (0049301C) --------------------------------------------------------
int   psBrokenDownTimeImport(int *a1, _BYTE *a2, unsigned int a3, unsigned int a4)
{
  int v4; // $v1
  int v5; // $v1
  int *v6; // $t0
  int v7; // $a3
  int v8; // $a1
  BOOL v10; // $t1
  _BYTE *v11; // $a1
  int v12; // $a2
  unsigned int v13; // $a0
  unsigned int v14; // $t5
  int v15; // $t3
  unsigned int v16; // $v1
  unsigned int v17; // $t1
  _BYTE *v18; // $a1
  int v19; // $a2
  unsigned int v20; // $a0
  unsigned int v21; // $t5
  int v22; // $t2
  unsigned int v23; // $a0
  _BYTE *v24; // $a1
  int v25; // $a2
  unsigned int v26; // $t5
  int v27; // $t3
  unsigned int v28; // $a0
  _BYTE *v29; // $a1
  int v30; // $a2
  unsigned int v31; // $t7
  int v32; // $t6
  unsigned int v33; // $a0
  _BYTE *v34; // $a1
  int v35; // $a2
  unsigned int v36; // $t9
  int v37; // $t5
  unsigned int v38; // $a0
  _BYTE *v39; // $a1
  int v40; // $a2
  unsigned int v41; // $t7
  int v42; // $a1
  int v43; // $v1
  int v44; // $a0
  signed int v45; // $a1
  BOOL v46; // $t2
  _BYTE *v47; // $a1
  int v48; // $a2
  unsigned int v49; // $a0
  unsigned int v50; // $t6
  int v51; // $t5
  char v52; // $t1
  _BYTE v53[48]; // [sp+8h] [-38h] BYREF
  _BYTE *v54; // [sp+38h] [-8h]

  v4 = -1;
  if ( a3 < 0x100 )
  {
    v5 = 2;
    if ( ((a4 >> 1) & 1) != 0 )
    {
      v6 = a1;
      v54 = a2;
      v7 = a4 & 1;
      if ( a1 )
        goto LABEL_4;
    }
    else
    {
      v5 = 4;
      v6 = a1;
      v54 = a2;
      v7 = a4 & 1;
      if ( a1 )
      {
LABEL_4:
        *v6 = 0;
        v6[1] = 0;
        v6[2] = 0;
        v6[3] = 0;
        v6[4] = 0;
        v6[5] = 0;
        v6[6] = 0;
        v6[7] = 0;
        v6[8] = 0;
        v6[9] = 0;
        v6[10] = 0;
        if ( v5 != 4 )
        {
LABEL_61:
          v46 = a3 < 0xC;
          if ( a3 != 13 )
          {
            v8 = -1;
            if ( v7 )
              return v8;
            v46 = a3 < 0xC;
          }
          if ( v46 && !v7 )
            return -1;
          v47 = v54;
          v48 = 2;
          v49 = 0;
          while ( 1 )
          {
            v50 = (unsigned __int8)(*v47 - 48);
            v51 = (unsigned __int8)*v47 + 10 * v49;
            --v48;
            v49 = v51 - 48;
            ++v47;
            if ( v50 >= 0xA )
              break;
            if ( !v48 )
            {
              v54 = v47;
              v16 = -1;
              if ( v49 <= 0x63 )
                v16 = v51 - 48;
              goto LABEL_21;
            }
          }
LABEL_72:
          v16 = -1;
LABEL_21:
          v8 = -1;
          v17 = v16;
          if ( v16 == -1 )
            return v8;
          v18 = v54;
          v19 = 2;
          v20 = 0;
          do
          {
            v21 = (unsigned __int8)(*v18 - 48);
            --v19;
            v20 = (unsigned __int8)*v18++ + 10 * v20 - 48;
            if ( v21 >= 0xA )
              goto LABEL_71;
          }
          while ( v19 );
          v54 = v18;
          if ( !v20 || (v22 = v20, v20 > 0xC) )
LABEL_71:
            v22 = -1;
          v8 = -1;
          v23 = 0;
          if ( v22 == -1 )
            return v8;
          v24 = v54;
          v25 = 2;
          do
          {
            v26 = (unsigned __int8)(*v24 - 48);
            --v25;
            v23 = (unsigned __int8)*v24++ + 10 * v23 - 48;
            if ( v26 >= 0xA )
              goto LABEL_73;
          }
          while ( v25 );
          v54 = v24;
          if ( !v23 || (v27 = v23, v23 > 0x1F) )
LABEL_73:
            v27 = -1;
          v28 = 0;
          if ( v27 != -1 )
          {
            v29 = v54;
            v30 = 2;
            do
            {
              v31 = (unsigned __int8)(*v29 - 48);
              --v30;
              v28 = (unsigned __int8)*v29++ + 10 * v28 - 48;
              if ( v31 >= 0xA )
              {
                v32 = -1;
                goto LABEL_39;
              }
            }
            while ( v30 );
            v54 = v29;
            v32 = -1;
            if ( v28 <= 0x17 )
              v32 = v28;
LABEL_39:
            v8 = -1;
            v33 = 0;
            if ( v32 == -1 )
              return v8;
            v34 = v54;
            v35 = 2;
            do
            {
              v36 = (unsigned __int8)(*v34 - 48);
              --v35;
              v33 = (unsigned __int8)*v34++ + 10 * v33 - 48;
              if ( v36 >= 0xA )
              {
                v37 = -1;
                goto LABEL_45;
              }
            }
            while ( v35 );
            v54 = v34;
            v37 = -1;
            if ( v33 <= 0x3B )
              v37 = v33;
LABEL_45:
            v8 = -1;
            v38 = 0;
            if ( v37 == -1 )
              return v8;
            v39 = v54;
            v40 = 2;
            do
            {
              v41 = (unsigned __int8)(*v39 - 48);
              --v40;
              v38 = (unsigned __int8)*v39++ + 10 * v38 - 48;
              if ( v41 >= 0xA )
              {
                v42 = -1;
                goto LABEL_51;
              }
            }
            while ( v40 );
            v54 = v39;
            v42 = -1;
            if ( v38 <= 0x3C )
              v42 = v38;
LABEL_51:
            if ( v42 != -1 && (!v7 || *v54 == 90) )
            {
              if ( v16 < 0x32 )
              {
                v17 = v16 + 100;
LABEL_56:
                v43 = v22 - 1;
                goto LABEL_57;
              }
              if ( v16 >= 0x76C )
              {
                v17 = v16 - 1900;
                goto LABEL_56;
              }
              v43 = v22 - 1;
              if ( v17 < 0x64 )
              {
LABEL_57:
                v6[2] = v32;
                v6[1] = v37;
                *v6 = v42;
                v6[5] = v17;
                v6[4] = v43;
                v6[3] = v27;
                v44 = -1;
                if ( v43 < 12 )
                {
                  v44 = byte_4E6984[v43];
                  v45 = v17 + 1900;
                  if ( v44 == 28 )
                  {
                    v52 = 0;
                    if ( (v45 & 3) == 0 && (v45 != 100 * (v45 / 100) || v45 == 400 * (v45 / 400)) )
                      v52 = 1;
                    v44 = (unsigned __int8)(v52 + 28);
                  }
                }
                v8 = 0;
                if ( v44 < v27 )
                {
                  v8 = -1;
                  v6[10] = 0;
                  *v6 = 0;
                  v6[1] = 0;
                  v6[2] = 0;
                  v6[3] = 0;
                  v6[4] = 0;
                  v6[5] = 0;
                  v6[6] = 0;
                  v6[7] = 0;
                  v6[8] = 0;
                  v6[9] = 0;
                }
                return v8;
              }
              return -1;
            }
          }
          return -1;
        }
LABEL_11:
        v10 = a3 < 0xE;
        if ( a3 != 15 )
        {
          v8 = -1;
          if ( v7 )
            return v8;
          v10 = a3 < 0xE;
        }
        if ( v10 && !v7 )
          return -1;
        v11 = v54;
        v12 = 4;
        v13 = 0;
        while ( 1 )
        {
          v14 = (unsigned __int8)(*v11 - 48);
          v15 = (unsigned __int8)*v11 + 10 * v13;
          --v12;
          v13 = v15 - 48;
          ++v11;
          if ( v14 >= 0xA )
            goto LABEL_72;
          if ( !v12 )
          {
            v54 = v11;
            if ( v13 < 0x76C )
              goto LABEL_72;
            v16 = v15 - 48;
            if ( v13 > 0xBB7 )
              goto LABEL_72;
            goto LABEL_21;
          }
        }
      }
    }
    v6 = (int *)v53;
    memset(v53, 0, 44);
    if ( v5 != 4 )
      goto LABEL_61;
    goto LABEL_11;
  }
  return v4;
}
// 493090: conditional instruction was optimized away because $v1.4==2
// 4E6984: using guessed type unsigned __int8 byte_4E6984[12];

//----- (00493594) --------------------------------------------------------
int   psBrokenDownTimeCmp(int a1, int a2)
{
  _DWORD v4[4]; // [sp+18h] [-20h] BYREF
  _DWORD v5[4]; // [sp+28h] [-10h] BYREF

  v4[0] = 33;
  memset(&v4[1], 0, 12);
  memset(v5, 0, sizeof(v5));
  strftime(v4, 16, "%Y%m%d%H%M%SZ", a1);
  strftime(v5, 16, "%Y%m%d%H%M%SZ", a2);
  return memcmp(v4, v5, 16);
}
// 4E9F5C: using guessed type int   strftime(_DWORD, _DWORD, _DWORD, _DWORD);
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);

//----- (00493680) --------------------------------------------------------
int   psToUtf8String(int a1, int a2, int a3, unsigned int a4, int *a5, int *a6, int a7)
{
  int *v9; // $s3
  int v10; // $s0
  int v11; // $v1
  int v12; // $s2
  int v14; // $v0
  int v15; // $t5
  int v16; // $v1
  _BYTE *appended; // $v0
  char v18; // $s0
  _BYTE *v19; // $v0
  int v20; // $v0
  int v21; // $a0
  int v22; // $a1
  int v23; // $v0
  _BYTE *v24; // $v0
  int v25; // [sp+18h] [-58h] BYREF
  _BYTE *v26; // [sp+1Ch] [-54h]
  _BYTE *v27; // [sp+20h] [-50h]
  int v28; // [sp+2Ch] [-44h]
  unsigned int v29[8]; // [sp+38h] [-38h] BYREF
  _BYTE v30[8]; // [sp+58h] [-18h] BYREF
  _BYTE v31[8]; // [sp+60h] [-10h] BYREF
  char v32; // [sp+68h] [-8h] BYREF

  v9 = a6;
  v10 = 1;
  v11 = -10;
  if ( (a7 & 0xFFFFFFFD) != 0 )
    return v11;
  if ( a4 >= 0x12 )
  {
    if ( a4 < 0x14 || (v10 = 2, a4 == 30) )
    {
      if ( v10 != 2 || (v11 = -1, (a3 & 1) == 0) )
      {
        v12 = psParseBufFromStaticData(&v25, a2, a3);
        v11 = v12;
        if ( !v12 )
        {
          v14 = psDynBufInit(a1, (int *)v29, a3 + 2);
          v11 = -8;
          if ( v14 )
          {
            if ( v10 == 1 )
            {
              while ( !v28 && v27 != v26 )
              {
                v30[0] = *v26;
                v18 = v30[0];
                if ( v30[0] > 0 )
                {
                  appended = (_BYTE *)psDynBufAppendSize(v29, 1u);
                  if ( appended )
                    *appended = v18;
                }
                else
                {
                  v12 = -9;
                }
                psParseBufSkipBytes(&v25, (int)v30, 1u);
              }
            }
            else
            {
              while ( !v28 && (unsigned int)(v27 - v26) >= 2 )
              {
                v31[0] = *v26;
                v15 = (unsigned __int8)v26[1];
                v16 = v15 | (v31[0] << 8);
                v31[1] = v26[1];
                if ( v16 && (unsigned __int16)(v16 + 10240) >= 0x800u )
                  psDynBufAppendUtf8(v29, v15 | (v31[0] << 8));
                else
                  v12 = -9;
                psParseBufSkipBytes(&v25, (int)v31, 2u);
              }
            }
            if ( !a6 )
              v9 = (int *)&v32;
            v19 = (_BYTE *)psDynBufAppendSize(v29, 1u);
            if ( v19 )
              *v19 = 0;
            if ( (a7 & 2) != 0 )
            {
              v24 = (_BYTE *)psDynBufAppendSize(v29, 1u);
              if ( v24 )
                *v24 = 0;
            }
            if ( v12 )
            {
              psDynBufUninit((int)v29);
              return v12;
            }
            else
            {
              v20 = psDynBufDetach(v29, v9);
              v21 = *v9;
              v22 = v20;
              *a5 = v20;
              v23 = v21 - 2;
              if ( (a7 & 2) == 0 )
                v23 = v21 - 1;
              *v9 = v23;
              v11 = -8;
              if ( v22 )
                return 0;
            }
          }
        }
      }
      return v11;
    }
  }
  return -10;
}

//----- (00493998) --------------------------------------------------------
__int64   psDynBufInit(int a1, int *a2, int a3)
{
  int v5; // $v0
  __int64 result; // $v0

  v5 = malloc(a3);
  *a2 = v5;
  a2[1] = v5;
  a2[2] = v5;
  if ( v5 )
  {
    LODWORD(result) = *a2;
    a2[3] = a3;
    HIDWORD(result) = result == 0;
  }
  else
  {
    LODWORD(result) = *a2;
    HIDWORD(result) = *a2 == 0;
    a2[3] = 0;
  }
  a2[4] = a1;
  a2[5] = HIDWORD(result);
  a2[6] = 0;
  return result;
}
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (00493A4C) --------------------------------------------------------
_UNKNOWN **  psDynBufUninit(int a1)
{
  _UNKNOWN **result; // $v0

  result = &psStaticAllocationsPool;
  if ( *(_UNKNOWN ***)(a1 + 16) != &psStaticAllocationsPool )
    result = (_UNKNOWN **)free2(*(_DWORD *)a1);
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}
// 4E6990: using guessed type _UNKNOWN *psStaticAllocationsPool;
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00493AB8) --------------------------------------------------------
int   psDynBufDetach(_DWORD *a1, _DWORD *a2)
{
  int v4; // $a2
  int v5; // $a1
  _UNKNOWN **v6; // $s3
  int v7; // $s0
  int v8; // $a0
  int v9; // $v0
  int v10; // $s2
  int result; // $v0

  if ( a1[5] )
  {
    if ( (_UNKNOWN **)a1[4] != &psStaticAllocationsPool )
      free2(*a1);
    a1[6] = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    a1[3] = 0;
    a1[5] = 0;
    a1[4] = 0;
    return 0;
  }
  else
  {
    v4 = a1[2];
    v5 = a1[1];
    v6 = (_UNKNOWN **)a1[4];
    v7 = v4 - v5;
    v8 = v4 - v5;
    if ( v4 == v5 )
      v8 = 1;
    v9 = malloc(v8);
    v10 = v9;
    if ( v9 )
    {
      memcpy(v9, a1[1], v7);
      *a2 = v7;
    }
    result = v10;
    if ( v6 != &psStaticAllocationsPool )
    {
      free2(*a1);
      result = v10;
    }
    a1[4] = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    a1[3] = 0;
  }
  return result;
}
// 4E6990: using guessed type _UNKNOWN *psStaticAllocationsPool;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);

//----- (00493C10) --------------------------------------------------------
unsigned int   sub_493C10(unsigned int *a1)
{
  unsigned int v1; // $s0
  unsigned int result; // $v0
  unsigned int v3; // $v1
  unsigned int v4; // $a1
  unsigned int v5; // $a0

  v1 = a1[6];
  if ( !v1 )
    _assert("sub->master != ((void *)0)", "psbuf.c", 292, "assert_subbuf");
  result = a1[4];
  if ( result )
    _assert("sub->pool == ((void *)0)", "psbuf.c", 297, "assert_subbuf");
  v3 = *a1;
  v4 = *(_DWORD *)(v1 + 4);
  if ( *a1 < v4 || *(_DWORD *)(v1 + 8) < v3 )
    _assert("sub->buf.buf >= db->buf.start && sub->buf.buf <= db->buf.end", "psbuf.c", 300, "assert_subbuf");
  v5 = v3 + a1[3];
  if ( v5 < v4 || *(_DWORD *)(v1 + 8) < v5 )
    _assert(
      "sub->buf.buf + sub->buf.size >= db->buf.start && sub->buf.buf + sub->buf.size <= db->buf.end",
      "psbuf.c",
      302,
      "assert_subbuf");
  return result;
}
// 4E9F18: using guessed type void   __noreturn _assert(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00493D8C) --------------------------------------------------------
int   sub_493D8C(unsigned int *a1, int a2, unsigned int a3)
{
  unsigned int v3; // $v1
  unsigned int v4; // $a3
  int v5; // $t2
  unsigned int v7; // $s6
  int v8; // $s0
  int v9; // $s2
  unsigned int v10; // $s5
  unsigned int v11; // $fp
  int result; // $v0
  unsigned int v13; // $v0
  unsigned int v14; // $s3
  int v15; // $s4
  int v16; // $s7
  unsigned int v17; // $v1
  int v18; // $v0
  int v19; // $s3
  unsigned int v20; // $v1
  int v21; // $s0
  int v22; // $v0
  int v23; // $a0
  unsigned int v24; // $a1
  unsigned int v25; // $a2
  unsigned int v26; // $v1
  int v27; // $s0
  int v28; // $s2
  int v29; // [sp+18h] [-18h]
  int v30; // [sp+1Ch] [-14h]
  unsigned int v31; // [sp+20h] [-10h]
  int v32; // [sp+24h] [-Ch]
  int v33; // [sp+28h] [-8h]

  v3 = a1[1];
  v4 = a1[2];
  v5 = *a1 + a1[3];
  v7 = v4 - v3;
  v8 = a2;
  v9 = a3;
  v10 = v3 - *a1;
  v11 = v5 - v4;
  result = 0;
  if ( a1[5] )
    return result;
  if ( (unsigned int)(a2 - 1) < 0xFF )
    v8 = 256;
  if ( a3 < 0x100 )
    v9 = 256;
  v13 = a1[6];
  v14 = v8 + v10;
  if ( v13 )
  {
    v33 = *a1 - *(_DWORD *)(v13 + 4);
    v15 = *(_DWORD *)(v13 + 8) - v5;
    sub_493C10(a1);
    v16 = sub_493D8C(a1[6], 0, v8 + v9);
    if ( v16 )
    {
      v17 = a1[6];
      v18 = *(_DWORD *)(v17 + 8) + v8 + v9;
      *(_DWORD *)(v17 + 8) = v18;
      if ( v15 )
      {
        memmove(v18 - v15);
        v17 = a1[6];
      }
      v19 = *(_DWORD *)(v17 + 4) + v33;
      *a1 = v19;
      a1[1] = v19 + v10 + v8;
      if ( v8 )
      {
        memmove(v19 + v10 + v8);
        v20 = v8 + v10;
      }
      else
      {
        v20 = v10;
      }
      a1[2] = a1[1] + v7;
      a1[3] = v20 + v7 + v11 + v9;
    }
    else
    {
      ++a1[5];
    }
    sub_493C10(a1);
    return v16;
  }
  v21 = v14 + v7 + v9 + v11;
  v22 = malloc(v21);
  v23 = v22;
  v29 = v22;
  v30 = v22;
  if ( !v22 )
    v21 = 0;
  v32 = v21;
  if ( !v22 )
  {
    result = 0;
    ++a1[5];
    return result;
  }
  v24 = v22 + v14;
  v25 = v22 + v21;
  v26 = v22 + v7;
  if ( v22 + v21 >= v22 + v14 )
  {
    v23 = v22 + v14;
    v26 = v24 + v7;
    v30 = v22 + v14;
    v27 = v22 + v14;
    if ( v25 < v24 + v7 )
      goto LABEL_20;
  }
  else
  {
    v27 = v22;
    if ( v25 < v26 )
      goto LABEL_20;
  }
  v28 = v23;
  v31 = v26;
  if ( !v23 )
LABEL_20:
    _assert("loc != ((void *)0)", "psbuf.c", 405, "psDynBufGrow");
  memcpy(v27, a1[1], v7);
  if ( (_UNKNOWN **)a1[4] != &psStaticAllocationsPool )
    free2(*a1);
  *a1 = v29;
  a1[3] = v32;
  a1[1] = v30;
  a1[2] = v31;
  return v28;
}
// 4E6990: using guessed type _UNKNOWN *psStaticAllocationsPool;
// 4E9EF0: using guessed type int   free2(_DWORD);
// 4E9F18: using guessed type void   __noreturn _assert(_DWORD, _DWORD, _DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);
// 4EA080: using guessed type int   memcpy(_DWORD, _DWORD, _DWORD);
// 4EA0A8: using guessed type int   memmove(_DWORD);

//----- (0049411C) --------------------------------------------------------
unsigned int   psDynBufAppendSize(unsigned int *a1, unsigned int a2)
{
  unsigned int v3; // $a3
  unsigned int v5; // $s1
  unsigned int result; // $v0
  bool v7; // dc
  unsigned int v8; // $t0

  v3 = a1[2];
  v5 = 0;
  if ( *a1 + a1[3] >= v3 + a2 )
  {
    v5 = a1[2];
    a1[2] = v3 + a2;
    if ( v3 )
      return v5;
  }
  v7 = sub_493D8C(a1, 0, a2) == 0;
  result = v5;
  if ( !v7 )
  {
    v8 = a1[2];
    if ( *a1 + a1[3] < v8 + a2 || (v5 = a1[2], a1[2] = v8 + a2, !v8) )
      _assert("loc != ((void *)0)", "psbuf.c", 431, "psDynBufAppendSize");
    return v5;
  }
  return result;
}
// 4E9F18: using guessed type void   __noreturn _assert(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00494230) --------------------------------------------------------
_BYTE *  psDynBufAppendUtf8(unsigned int *a1, unsigned int a2)
{
  _BYTE *v3; // $t0
  _BYTE *result; // $v0
  _BYTE *appended; // $v0
  _BYTE *v6; // $v0
  _BYTE *v7; // $v0

  if ( a2 > 0x1FFFF )
  {
    result = 0;
    ++a1[5];
  }
  else
  {
    if ( a2 < 0x80 )
    {
      appended = (_BYTE *)psDynBufAppendSize(a1, 1u);
      v3 = appended;
      if ( appended )
        *appended = a2;
    }
    else if ( a2 < 0x800 )
    {
      v7 = (_BYTE *)psDynBufAppendSize(a1, 2u);
      v3 = v7;
      if ( v7 )
      {
        *v7 = (a2 >> 6) | 0xC0;
        v7[1] = a2 & 0x3F | 0x80;
      }
    }
    else if ( a2 > 0xFFFF )
    {
      v6 = (_BYTE *)psDynBufAppendSize(a1, 4u);
      v3 = v6;
      if ( v6 )
      {
        *v6 = (a2 >> 18) | 0xF0;
        v6[1] = (a2 >> 12) & 0x3F | 0x80;
        v6[2] = (a2 >> 6) & 0x3F | 0x80;
        v6[3] = a2 & 0x3F | 0x80;
      }
    }
    else
    {
      v3 = (_BYTE *)psDynBufAppendSize(a1, 3u);
      if ( v3 )
      {
        *v3 = (a2 >> 12) | 0xE0;
        v3[1] = (a2 >> 6) & 0x3F | 0x80;
        v3[2] = a2 & 0x3F | 0x80;
      }
    }
    return v3;
  }
  return result;
}

//----- (004943D0) --------------------------------------------------------
int   psParseBufFromStaticData(_DWORD *a1, int a2, int a3)
{
  int result; // $v0

  if ( a2 )
  {
    a1[3] = a3;
    a1[1] = a2;
    a1[2] = a2 + a3;
    *a1 = a2;
    result = 0;
    a1[4] = &psStaticAllocationsPool;
    a1[6] = 0;
    a1[5] = 0;
  }
  else
  {
    a1[3] = 0;
    a1[1] = 0;
    a1[2] = 0;
    *a1 = 0;
    result = -6;
    a1[4] = &psStaticAllocationsPool;
    a1[6] = 0;
    a1[5] = 1;
  }
  return result;
}
// 4E6990: using guessed type _UNKNOWN *psStaticAllocationsPool;

//----- (00494454) --------------------------------------------------------
unsigned int   psParseBufTrySkipBytes(_DWORD *a1, int a2, unsigned int a3)
{
  int v5; // $s0
  int v6; // $a0
  unsigned int result; // $v0
  int v8; // $v0

  if ( a1[5] )
  {
    v5 = a1[1];
LABEL_3:
    v6 = v5;
LABEL_4:
    result = 0;
    a1[1] = v6;
    return result;
  }
  v5 = a1[1];
  if ( a1[2] - v5 < a3 )
    goto LABEL_3;
  v8 = memcmp(a2, a1[1], a3);
  v6 = v5;
  if ( v8 )
    goto LABEL_4;
  result = a3;
  a1[1] = v5 + a3;
  return result;
}
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);

//----- (00494524) --------------------------------------------------------
unsigned int   psParseBufSkipBytes(_DWORD *a1, int a2, unsigned int a3)
{
  unsigned int v4; // $s2
  int v6; // $s0
  int v7; // $a0
  unsigned int result; // $v0
  int v9; // $v0

  v4 = 0;
  if ( a1[5] )
  {
    v6 = a1[1];
LABEL_3:
    v7 = v6 + v4;
    goto LABEL_4;
  }
  v6 = a1[1];
  if ( a1[2] - v6 < a3 )
    goto LABEL_3;
  v9 = memcmp(a2, a1[1], a3);
  v7 = v6;
  if ( !v9 )
  {
    v4 = a3;
    goto LABEL_3;
  }
LABEL_4:
  result = v4;
  a1[1] = v7;
  if ( !v4 )
    ++a1[5];
  return result;
}
// 4E9FC8: using guessed type int   memcmp(_DWORD, _DWORD, _DWORD);

//----- (004945E4) --------------------------------------------------------
unsigned int   psParseBufTryReadTagSub(int a1, char *a2, unsigned __int8 a3)
{
  unsigned __int8 *v3; // $t0
  unsigned int v4; // $t1
  int v6; // $a3
  int v7; // $t3
  unsigned int v8; // $t5
  unsigned int result; // $v0
  int v10; // $a2
  unsigned int v11; // $a0
  int v12; // $v1
  unsigned int v13; // $a2
  char v14; // [sp+8h] [-28h] BYREF
  int v15; // [sp+28h] [-8h] BYREF

  v3 = *(unsigned __int8 **)(a1 + 4);
  v4 = *(_DWORD *)(a1 + 8) - (_DWORD)v3;
  v6 = 1;
  v7 = 2;
  v8 = 0;
  if ( v4 < 2 || a3 && *v3 != a3 )
    goto LABEL_4;
  v11 = v3[1];
  v12 = 1;
  if ( (v11 & 0x80u) != 0 )
  {
    v8 = 0;
    if ( v4 < 0x83 || v11 == 129 && (v3[2] & 0x80u) == 0 )
      goto LABEL_4;
    if ( v11 == 130 )
    {
      v8 = 0;
      if ( !v3[2] )
        goto LABEL_4;
    }
    if ( v11 == 131 )
    {
      v8 = 0;
      if ( !v3[2] )
        goto LABEL_4;
    }
    if ( v11 == 132 )
    {
      v8 = 0;
      if ( !v3[2] )
        goto LABEL_4;
    }
    v8 = 0;
    if ( v11 == 128 || v11 >= 0x85 )
      goto LABEL_4;
    v12 = (unsigned __int8)(v11 + 0x80);
    v6 = 2;
    v7 = v12 + 2;
  }
  v13 = 0;
  while ( v12 )
  {
    v12 = (unsigned __int8)(v12 - 1);
    v13 = (v13 << 8) + v3[v6++];
  }
  v8 = 0;
  if ( v13 <= 0x40000000 && v4 >= v13 + v7 )
  {
    if ( &v15 )
      v15 = v7;
    v8 = v13 + v7;
  }
LABEL_4:
  if ( !a2 )
    a2 = &v14;
  if ( v8 )
  {
    v10 = v15;
    *((_DWORD *)a2 + 6) = a1;
    result = v8;
    *((_DWORD *)a2 + 2) = &v3[v8];
    *((_DWORD *)a2 + 5) = 0;
    *(_DWORD *)a2 = &v3[v10];
    *((_DWORD *)a2 + 1) = &v3[v10];
    *((_DWORD *)a2 + 3) = v8 - v10;
  }
  else
  {
    result = 0;
    *((_DWORD *)a2 + 6) = a1;
    *((_DWORD *)a2 + 5) = 1;
    *((_DWORD *)a2 + 2) = 0;
    *((_DWORD *)a2 + 1) = 0;
    *(_DWORD *)a2 = 0;
    *((_DWORD *)a2 + 3) = 0;
  }
  *((_DWORD *)a2 + 4) = 0;
  return result;
}

//----- (004947E0) --------------------------------------------------------
unsigned int   psParseBufReadTagSub(int *a1, char *a2, unsigned __int8 a3)
{
  unsigned __int8 *v3; // $t1
  unsigned int v4; // $t3
  char *v7; // $a3
  int v8; // $t0
  int v9; // $t5
  unsigned int v10; // $t7
  int v11; // $a2
  unsigned int v12; // $t3
  int v13; // $t4
  unsigned int result; // $v0
  int v15; // $a0
  int v16; // $t8
  int v17; // $t5
  int v18; // $a3
  unsigned int v19; // $a0
  int v20; // $v1
  unsigned int v21; // $a1
  char v22; // [sp+8h] [-28h] BYREF
  int v23; // [sp+28h] [-8h] BYREF

  v3 = (unsigned __int8 *)a1[1];
  v4 = a1[2] - (_DWORD)v3;
  v7 = a2;
  v8 = 1;
  v9 = 2;
  v10 = 0;
  if ( v4 < 2 || a3 && *v3 != a3 )
    goto LABEL_4;
  v19 = v3[1];
  v20 = 1;
  if ( (v19 & 0x80u) != 0 )
  {
    v10 = 0;
    if ( v4 < 0x83 || v19 == 129 && (v3[2] & 0x80u) == 0 )
      goto LABEL_4;
    if ( v19 == 130 )
    {
      v10 = 0;
      if ( !v3[2] )
        goto LABEL_4;
    }
    if ( v19 == 131 )
    {
      v10 = 0;
      if ( !v3[2] )
        goto LABEL_4;
    }
    if ( v19 == 132 )
    {
      v10 = 0;
      if ( !v3[2] )
        goto LABEL_4;
    }
    v10 = 0;
    if ( v19 == 128 || v19 >= 0x85 )
      goto LABEL_4;
    v20 = (unsigned __int8)(v19 + 0x80);
    v8 = 2;
    v9 = v20 + 2;
  }
  v21 = 0;
  while ( v20 )
  {
    v20 = (unsigned __int8)(v20 - 1);
    v21 = (v21 << 8) + v3[v8++];
  }
  v10 = 0;
  if ( v21 <= 0x40000000 && v4 >= v21 + v9 )
  {
    if ( &v23 )
      v23 = v9;
    v10 = v21 + v9;
  }
LABEL_4:
  if ( !a2 )
    v7 = &v22;
  if ( v10 )
  {
    v11 = a1[1];
    v12 = v10 - v23;
    v13 = v11 + v23;
    result = v10;
    *((_DWORD *)v7 + 2) = v11 + v10;
    *((_DWORD *)v7 + 6) = a1;
    *((_DWORD *)v7 + 5) = 0;
    *(_DWORD *)v7 = v13;
    *((_DWORD *)v7 + 1) = v13;
    *((_DWORD *)v7 + 3) = v12;
    *((_DWORD *)v7 + 4) = 0;
  }
  else
  {
    *((_DWORD *)v7 + 5) = 1;
    *((_DWORD *)v7 + 6) = a1;
    *((_DWORD *)v7 + 2) = 0;
    *((_DWORD *)v7 + 1) = 0;
    *(_DWORD *)v7 = 0;
    *((_DWORD *)v7 + 3) = 0;
    *((_DWORD *)v7 + 4) = 0;
    v15 = a1[3];
    v16 = *a1;
    v17 = a1[1];
    v18 = a1[2];
    result = 0;
    ++a1[5];
    *((_DWORD *)a2 + 3) = v15;
    *(_DWORD *)a2 = v16;
    *((_DWORD *)a2 + 1) = v17;
    *((_DWORD *)a2 + 2) = v18;
  }
  return result;
}

//----- (00494A14) --------------------------------------------------------
unsigned int   psParseBufReadTagRef(int *a1, _DWORD *a2, unsigned __int8 a3)
{
  unsigned __int8 *v3; // $t0
  unsigned int v4; // $t3
  int *v7; // $t1
  int v8; // $a3
  int v9; // $t5
  unsigned int v10; // $t8
  int v11; // $t6
  int v12; // $t3
  int v13; // $t1
  int v14; // $t7
  unsigned int result; // $v0
  int v16; // $t5
  unsigned int v17; // $a3
  int v18; // $a1
  int v19; // $t0
  int v20; // $a2
  int v21; // $v1
  unsigned int v22; // $a0
  int v23; // $v1
  unsigned int v24; // $a1
  int v25; // [sp+8h] [-48h] BYREF
  int v26; // [sp+Ch] [-44h]
  int v27; // [sp+10h] [-40h]
  int v28; // [sp+14h] [-3Ch]
  char v29; // [sp+28h] [-28h] BYREF
  int v30; // [sp+48h] [-8h] BYREF

  v3 = (unsigned __int8 *)a1[1];
  v4 = a1[2] - (_DWORD)v3;
  v7 = &v25;
  v8 = 1;
  v9 = 2;
  v10 = 0;
  if ( v4 < 2 || a3 && *v3 != a3 )
    goto LABEL_4;
  v22 = v3[1];
  v23 = 1;
  if ( (v22 & 0x80u) != 0 )
  {
    v10 = 0;
    if ( v4 < 0x83 || v22 == 129 && (v3[2] & 0x80u) == 0 )
      goto LABEL_4;
    if ( v22 == 130 )
    {
      v10 = 0;
      if ( !v3[2] )
        goto LABEL_4;
    }
    if ( v22 == 131 )
    {
      v10 = 0;
      if ( !v3[2] )
        goto LABEL_4;
    }
    if ( v22 == 132 )
    {
      v10 = 0;
      if ( !v3[2] )
        goto LABEL_4;
    }
    if ( v22 == 128 || v22 >= 0x85 )
    {
      v10 = 0;
      goto LABEL_4;
    }
    v23 = (unsigned __int8)(v22 + 0x80);
    v8 = 2;
    v9 = v23 + 2;
  }
  v24 = 0;
  while ( v23 )
  {
    v23 = (unsigned __int8)(v23 - 1);
    v24 = (v24 << 8) + v3[v8++];
  }
  v10 = 0;
  if ( v24 <= 0x40000000 && v4 >= v24 + v9 )
  {
    if ( &v30 )
      v30 = v9;
    v10 = v24 + v9;
  }
LABEL_4:
  if ( !&v25 )
    v7 = (int *)&v29;
  if ( v10 )
  {
    v16 = a1[1];
    v17 = v10 - v30;
    v18 = v16 + v30;
    v7[1] = v16 + v30;
    v7[3] = v17;
    v7[5] = 0;
    v7[2] = v16 + v10;
    *v7 = v18;
    v7[4] = 0;
    v7[6] = (int)a1;
    v19 = v26;
    v20 = v27;
    v21 = v28;
    *a2 = v25;
    a2[3] = v21;
    a2[1] = v19;
    a2[2] = v20;
    result = v10;
    a1[1] += v10;
  }
  else
  {
    v7[5] = 1;
    v7[6] = (int)a1;
    v7[2] = 0;
    v7[1] = 0;
    *v7 = 0;
    v7[3] = 0;
    v7[4] = 0;
    v11 = *a1;
    v12 = a1[1];
    v13 = a1[2];
    v14 = a1[5] + 1;
    result = 0;
    v28 = a1[3];
    a1[5] = v14;
    v25 = v11;
    v26 = v12;
    v27 = v13;
  }
  return result;
}

//----- (00494C78) --------------------------------------------------------
int   psParseBufFinish(int *a1)
{
  int v2; // $a0
  int v3; // $a1
  int v4; // $v1
  int v5; // $s1
  int result; // $v0
  int v7; // $a3
  int v8; // $t0

  v2 = a1[6];
  if ( v2 )
  {
    v3 = a1[5];
    if ( v3 )
    {
      v4 = *(_DWORD *)(v2 + 20);
      *a1 = 0;
      *(_DWORD *)(v2 + 20) = v4 + 1;
      v3 = a1[5];
    }
    else
    {
      v7 = *a1;
      v8 = a1[3];
      *a1 = 0;
      *(_DWORD *)(v2 + 4) = v7 + v8;
    }
  }
  else
  {
    v3 = a1[5];
  }
  v5 = -(v3 != 0);
  if ( (_UNKNOWN **)a1[4] != &psStaticAllocationsPool )
    free2(*a1);
  result = v5;
  a1[4] = 0;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[6] = 0;
  a1[5] = 0;
  return result;
}
// 4E6990: using guessed type _UNKNOWN *psStaticAllocationsPool;
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (00494D50) --------------------------------------------------------
unsigned int   psParseBufTrySkipTag(int a1, unsigned __int8 a2)
{
  unsigned __int8 *v2; // $a3
  unsigned int v3; // $t1
  char *v5; // $t0
  int v6; // $a2
  int v7; // $t3
  unsigned int v8; // $t5
  unsigned int result; // $v0
  int v10; // $t9
  int v11; // $ra
  int v12; // $a1
  unsigned int v13; // $s1
  int v14; // $v0
  unsigned int v15; // $a0
  int v16; // $v1
  unsigned int v17; // $a1
  int v18; // $a0
  _DWORD v19[3]; // [sp+18h] [-48h] BYREF
  int v20; // [sp+24h] [-3Ch]
  _UNKNOWN **v21; // [sp+28h] [-38h]
  int v22; // [sp+2Ch] [-34h]
  int v23; // [sp+30h] [-30h]
  char v24; // [sp+38h] [-28h] BYREF
  int v25; // [sp+58h] [-8h] BYREF

  v2 = *(unsigned __int8 **)(a1 + 4);
  v3 = *(_DWORD *)(a1 + 8) - (_DWORD)v2;
  v5 = (char *)v19;
  v6 = 1;
  v7 = 2;
  v8 = 0;
  if ( v3 < 2 || a2 && *v2 != a2 )
    goto LABEL_4;
  v15 = v2[1];
  v16 = 1;
  if ( (v15 & 0x80u) != 0 )
  {
    v8 = 0;
    if ( v3 < 0x83 || v15 == 129 && (v2[2] & 0x80u) == 0 )
      goto LABEL_4;
    if ( v15 == 130 )
    {
      v8 = 0;
      if ( !v2[2] )
        goto LABEL_4;
    }
    if ( v15 == 131 )
    {
      v8 = 0;
      if ( !v2[2] )
        goto LABEL_4;
    }
    if ( v15 == 132 )
    {
      v8 = 0;
      if ( !v2[2] )
        goto LABEL_4;
    }
    if ( v15 == 128 || v15 >= 0x85 )
    {
      v8 = 0;
      goto LABEL_4;
    }
    v16 = (unsigned __int8)(v15 + 0x80);
    v6 = 2;
    v7 = v16 + 2;
  }
  v17 = 0;
  while ( v16 )
  {
    v16 = (unsigned __int8)(v16 - 1);
    v17 = (v17 << 8) + v2[v6++];
  }
  v8 = 0;
  if ( v17 <= 0x40000000 && v3 >= v17 + v7 )
  {
    if ( &v25 )
      v25 = v7;
    v8 = v17 + v7;
  }
LABEL_4:
  if ( !v19 )
    v5 = &v24;
  if ( v8 )
  {
    v10 = v25;
    v11 = *(_DWORD *)(a1 + 4);
    *((_DWORD *)v5 + 6) = a1;
    v12 = v23;
    *((_DWORD *)v5 + 2) = v11 + v8;
    *((_DWORD *)v5 + 5) = 0;
    *(_DWORD *)v5 = v11 + v10;
    *((_DWORD *)v5 + 1) = v11 + v10;
    *((_DWORD *)v5 + 3) = v8 - v10;
    *((_DWORD *)v5 + 4) = 0;
    v13 = v8;
    if ( v12 )
    {
      if ( v22 )
      {
        v14 = *(_DWORD *)(v12 + 20);
        v19[0] = 0;
        *(_DWORD *)(v12 + 20) = v14 + 1;
      }
      else
      {
        v18 = v19[0];
        v19[0] = 0;
        *(_DWORD *)(v12 + 4) = v18 + v20;
      }
    }
    result = v8;
    if ( v21 != &psStaticAllocationsPool )
    {
      free2(v19[0]);
      result = v13;
    }
    v21 = 0;
    memset(v19, 0, sizeof(v19));
    v20 = 0;
    v23 = 0;
    v22 = 0;
  }
  else
  {
    result = 0;
    *((_DWORD *)v5 + 6) = a1;
    *((_DWORD *)v5 + 5) = 1;
    *((_DWORD *)v5 + 2) = 0;
    *((_DWORD *)v5 + 1) = 0;
    *(_DWORD *)v5 = 0;
    *((_DWORD *)v5 + 3) = 0;
    *((_DWORD *)v5 + 4) = 0;
  }
  return result;
}
// 4E6990: using guessed type _UNKNOWN *psStaticAllocationsPool;
// 4E9EF0: using guessed type int   free2(_DWORD);

//----- (0049500C) --------------------------------------------------------
int osdepTimeOpen()
{
  char v1; // [sp+18h] [-8h] BYREF

  return -(gettimeofday(&v1, 0) < 0);
}
// 4E9FAC: using guessed type int   gettimeofday(_DWORD, _DWORD);

//----- (0049504C) --------------------------------------------------------
void osdepTimeClose()
{
  ;
}

//----- (00495054) --------------------------------------------------------
int   psGetTime(int a1)
{
  int v2; // $v0
  int v3; // $v1
  int v5; // $v0
  int v6; // [sp+18h] [-8h] BYREF

  if ( a1 )
  {
    v2 = gettimeofday(a1, 0);
    v3 = -1;
    if ( v2 >= 0 )
      return *(_DWORD *)a1;
    return v3;
  }
  v5 = gettimeofday(&v6, 0);
  v3 = -1;
  if ( v5 < 0 )
    return v3;
  return v6;
}
// 4E9FAC: using guessed type int   gettimeofday(_DWORD, _DWORD);

//----- (004950D8) --------------------------------------------------------
int   psDiffMsecs(int a1, int a2, int a3, int a4)
{
  if ( a4 >= a2 )
    return 1000 * (a3 - a1) + (a4 - a2) / 1000;
  else
    return 1000 * (a3 - 1 - a1) + (a4 + 1000000 - a2) / 1000;
}

//----- (004951A0) --------------------------------------------------------
int osdepMutexOpen()
{
  return 0;
}

//----- (004951A8) --------------------------------------------------------
void osdepMutexClose()
{
  ;
}

//----- (004951B0) --------------------------------------------------------
int psLockMutex()
{
  int result; // $v0

  result = pthread_mutex_lock();
  if ( result )
    abort();
  return result;
}
// 4E9F44: using guessed type int pthread_mutex_lock(void);
// 4EA038: using guessed type void __noreturn abort(void);

//----- (00495204) --------------------------------------------------------
int psUnlockMutex()
{
  int result; // $v0

  result = pthread_mutex_unlock();
  if ( result )
    abort();
  return result;
}
// 4E9F7C: using guessed type int pthread_mutex_unlock(void);
// 4EA038: using guessed type void __noreturn abort(void);

//----- (00495258) --------------------------------------------------------
int psDestroyMutex()
{
  return pthread_mutex_destroy();
}
// 4E9F4C: using guessed type int pthread_mutex_destroy(void);

//----- (00495274) --------------------------------------------------------
int osdepEntropyClose()
{
  int v0; // $v0

  v0 = dword_4E6994;
  if ( dword_4E6998 != dword_4E6994 )
  {
    close(dword_4E6998);
    v0 = dword_4E6994;
  }
  return close(v0);
}
// 4E6994: using guessed type int dword_4E6994;
// 4E6998: using guessed type int dword_4E6998;
// 4E9EF8: using guessed type int   close(_DWORD);

//----- (004952D4) --------------------------------------------------------
int   psGetEntropy(int a1, int a2)
{
  int v2; // $s0
  int v4; // $s4
  int v5; // $s5
  int v6; // $s2
  int v7; // $v0
  bool v8; // dc
  int v9; // $s5
  int v10; // $v1
  int v11; // $s2
  int v12; // $v0
  BOOL v13; // $a3
  int result; // $v0
  int v15; // $v0

  v2 = a2;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  if ( !a2 )
    return v4;
  do
  {
    while ( 1 )
    {
      v10 = read(dword_4E6998, a1, v2);
      if ( v10 < 0 || v6 >= 1025 )
        break;
      v2 -= v10;
      v4 += v10;
      a1 += v10;
      if ( !v2 )
        goto LABEL_12;
    }
    v7 = *(_DWORD *)_errno_location();
    if ( v7 == 4 )
    {
      v8 = v6++ >= 1025;
      if ( v8 )
        return -7;
      continue;
    }
    if ( v7 != 9 )
      break;
    v8 = v5 != 0;
    v9 = 0;
    if ( v8 )
      goto LABEL_13;
    close(dword_4E6998);
    dword_4E6998 = open("/dev/random", 128);
    if ( dword_4E6998 < 0 )
      break;
    v5 = 1;
  }
  while ( v2 );
LABEL_12:
  v9 = 0;
LABEL_13:
  v11 = 0;
  if ( !v2 )
    return v4;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v15 = read(dword_4E6994, a1, v2);
        if ( v15 < 0 || v11 >= 1025 )
          break;
        v2 -= v15;
        v4 += v15;
        a1 += v15;
        if ( !v2 )
          return v4;
      }
      v12 = *(_DWORD *)_errno_location();
      v13 = v11 < 1025;
      if ( v12 != 4 )
        break;
      ++v11;
      if ( !v13 )
        return -7;
    }
    v8 = v12 != 9;
    result = -7;
    if ( v8 || v9 )
      break;
    close(dword_4E6994);
    dword_4E6994 = open("/dev/urandom", 128);
    if ( dword_4E6994 < 0 )
      return -7;
    v9 = 1;
  }
  return result;
}
// 495480: conditional instruction was optimized away because $s0.4!=0
// 4E6994: using guessed type int dword_4E6994;
// 4E6998: using guessed type int dword_4E6998;
// 4E9EF8: using guessed type int   close(_DWORD);
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4E9F40: using guessed type int _errno_location(void);
// 4E9FE0: using guessed type int   read(_DWORD, _DWORD, _DWORD);

//----- (00495518) --------------------------------------------------------
int psGetTraceFile()
{
  int result; // $v0
  int v1; // $a0
  int v2; // $a1
  int v3; // $v0
  char *v4; // $s1

  result = dword_4E699C;
  if ( !dword_4E699C )
  {
    pthread_mutex_lock(&unk_4E69A0);
    if ( !dword_4E699C )
    {
      v3 = getenv("PSCORE_DEBUG_FILE");
      v4 = (char *)v3;
      if ( v3 )
      {
        dword_4E699C = fopen(v3, "w");
        if ( !dword_4E699C )
        {
          fprintf(
            stderr,
            "%s: Unable to open file %s, %s.\n",
            "_psGetTraceFile",
            v4,
            "producing log to standard output");
          dword_4E699C = stdout;
        }
      }
      else
      {
        v4 = (char *)getenv("PSCORE_DEBUG_FILE_APPEND");
      }
      if ( !dword_4E699C && v4 )
      {
        dword_4E699C = fopen(v4, "a");
        if ( !dword_4E699C )
        {
          fprintf(
            stderr,
            "%s: Unable to open file %s, %s.\n",
            "_psGetTraceFile",
            v4,
            "producing log to standard output");
          dword_4E699C = stdout;
        }
      }
      v1 = dword_4E699C;
      if ( dword_4E699C )
        goto LABEL_14;
      dword_4E699C = stdout;
    }
    v1 = dword_4E699C;
    v2 = 0;
    if ( !dword_4E699C )
    {
LABEL_4:
      pthread_mutex_unlock(&unk_4E69A0, v2);
      return dword_4E699C;
    }
LABEL_14:
    setvbuf(v1, 0, 2, 0);
    goto LABEL_4;
  }
  return result;
}
// 4955A8: variable 'v2' is possibly undefined
// 4E699C: using guessed type int dword_4E699C;
// 4E9F44: using guessed type int   pthread_mutex_lock(_DWORD);
// 4E9F70: using guessed type int stderr;
// 4E9F7C: using guessed type int   pthread_mutex_unlock(_DWORD, _DWORD);
// 4E9FA8: using guessed type int   fopen(_DWORD, _DWORD);
// 4EA014: using guessed type int fprintf(_DWORD, char *, ...);
// 4EA07C: using guessed type int   setvbuf(_DWORD, _DWORD, _DWORD, _DWORD);
// 4EA094: using guessed type int   getenv(_DWORD);
// 4EA0B8: using guessed type int stdout;

//----- (00495740) --------------------------------------------------------
int   psTraceInt(char *a1, int a2)
{
  int result; // $v0

  result = psGetTraceFile();
  if ( result )
    return fprintf(result, a1, a2);
  return result;
}
// 4EA014: using guessed type int fprintf(_DWORD, char *, ...);

//----- (004957B0) --------------------------------------------------------
int   psTraceStr(char *a1, int a2)
{
  int result; // $v0

  result = psGetTraceFile();
  if ( a2 )
  {
    if ( result )
      return fprintf(result, a1, a2);
  }
  else if ( result )
  {
    return fputs(a1, result);
  }
  return result;
}
// 4E9F10: using guessed type int   fputs(_DWORD, _DWORD);
// 4EA014: using guessed type int fprintf(_DWORD, char *, ...);

//----- (00495848) --------------------------------------------------------
int osdepEntropyOpen()
{
  int v0; // $v0
  int TraceFile; // $a0
  int v3; // $a0

  dword_4E6994 = open("/dev/urandom", 0);
  if ( dword_4E6994 < 0 )
  {
    TraceFile = psGetTraceFile();
    if ( TraceFile )
      fprintf(TraceFile, "psError %s", "POSIX/osdep.c");
    v3 = psGetTraceFile();
    if ( v3 )
      fprintf(v3, ":%d ", 341);
    psErrorInt("open of urandom failed %d\n", dword_4E6994);
    return -7;
  }
  else
  {
    v0 = open("/dev/random", 128);
    if ( v0 < 0 )
      v0 = dword_4E6994;
    dword_4E6998 = v0;
    return 0;
  }
}
// 4E6994: using guessed type int dword_4E6994;
// 4E6998: using guessed type int dword_4E6998;
// 4E9F20: using guessed type int   open(_DWORD, _DWORD);
// 4EA014: using guessed type int fprintf(_DWORD, char *, ...);

//----- (0049596C) --------------------------------------------------------
int   psCreateMutex(int a1, int a2)
{
  int v4; // $s1
  int v5; // $s0
  int v7; // $s0
  int v8; // $a0
  int v9; // $v0
  char *v10; // $a0
  int v11; // $a1
  int TraceFile; // $a0
  int v13; // $v0
  int v14; // $a0
  int v15; // $v0
  int v16; // $a0
  int v17; // $v0
  _BYTE v18[8]; // [sp+18h] [-8h] BYREF

  if ( (a2 & 0xFFFFFFFE) != 0 )
  {
    TraceFile = psGetTraceFile();
    if ( TraceFile )
      fprintf(TraceFile, "psError %s", "POSIX/osdep.c");
    v13 = psGetTraceFile();
    if ( v13 )
      fprintf(v13, ":%d ", 267);
    v10 = "psCreateMutex unsupported flag %u\n";
    v11 = a2;
    goto LABEL_13;
  }
  v4 = pthread_mutexattr_init(v18);
  if ( v4 < 0 )
  {
    v16 = psGetTraceFile();
    if ( v16 )
      fprintf(v16, "psError %s", "POSIX/osdep.c");
    v17 = psGetTraceFile();
    if ( v17 )
      fprintf(v17, ":%d ", 272);
    psErrorInt("pthread_mutexattr_init failed %d\n", v4);
    return -7;
  }
  else
  {
    if ( (a2 & 1) != 0 )
    {
      v7 = pthread_mutexattr_setpshared(v18, 1);
      if ( v7 < 0 )
      {
        pthread_mutexattr_destroy(v18);
        v8 = psGetTraceFile();
        if ( v8 )
          fprintf(v8, "psError %s", "POSIX/osdep.c");
        v9 = psGetTraceFile();
        if ( v9 )
          fprintf(v9, ":%d ", 280);
        v10 = "pthread_mutexattr shared failed %d\n";
        v11 = v7;
LABEL_13:
        psErrorInt(v10, v11);
        return -7;
      }
    }
    v5 = pthread_mutex_init(a1, v18);
    if ( v5 )
    {
      pthread_mutexattr_destroy(v18);
      v14 = psGetTraceFile();
      if ( v14 )
        fprintf(v14, "psError %s", "POSIX/osdep.c");
      v15 = psGetTraceFile();
      if ( v15 )
        fprintf(v15, ":%d ", 286);
      v10 = "pthread_mutex_init failed %d\n";
      v11 = v5;
      goto LABEL_13;
    }
    pthread_mutexattr_destroy(v18);
    return 0;
  }
}
// 4E9F28: using guessed type int   pthread_mutex_init(_DWORD, _DWORD);
// 4E9F60: using guessed type int   pthread_mutexattr_init(_DWORD);
// 4E9F88: using guessed type int   pthread_mutexattr_setpshared(_DWORD, _DWORD);
// 4EA014: using guessed type int fprintf(_DWORD, char *, ...);
// 4EA078: using guessed type int   pthread_mutexattr_destroy(_DWORD);

//----- (00495CB0) --------------------------------------------------------
int   psTrace(int a1)
{
  int result; // $v0

  result = psGetTraceFile();
  if ( result )
    return fputs(a1, result);
  return result;
}
// 4E9F10: using guessed type int   fputs(_DWORD, _DWORD);

//----- (00495D10) --------------------------------------------------------
int   psGetFileBufFp(int a1, int a2, int *a3, int *a4)
{
  int v6; // $v0
  int v8; // $a1
  int v9; // $v0
  int v10; // $a1
  int i; // $a1
  int v12; // $v0
  char v14[56]; // [sp+18h] [-98h] BYREF
  int v15; // [sp+50h] [-60h]

  v6 = fileno(a2);
  if ( fstat(v6, v14) )
  {
    fclose(a2);
    return -7;
  }
  else
  {
    v9 = malloc(v15 + 1);
    *a3 = v9;
    if ( v9 )
    {
      memset(v9, 0, v15 + 1);
      for ( i = *a4; ; *a4 = i )
      {
        v12 = fread(*a3 + i, 1, 512, a2);
        if ( !v12 )
          break;
        i = *a4 + v12;
        if ( *a4 >= v15 )
          break;
      }
      fclose(a2);
      return 0;
    }
    else
    {
      fclose(a2);
      return -8;
    }
  }
}
// 495E04: variable 'i' is possibly undefined
// 495E34: variable 'v8' is possibly undefined
// 495E50: variable 'v10' is possibly undefined
// 4E9F34: using guessed type int   fileno(_DWORD);
// 4E9F98: using guessed type int   fclose(_DWORD);
// 4E9FA0: using guessed type int   memset(_DWORD, _DWORD, _DWORD);
// 4E9FB4: using guessed type int   fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 4EA018: using guessed type int   fstat(_DWORD, _DWORD);
// 4EA068: using guessed type int   malloc(_DWORD);

//----- (00495E64) --------------------------------------------------------
int   psGetFileBuf(int a1, int a2, int *a3, int *a4)
{
  int v7; // $v1
  int v8; // $v0

  *a4 = 0;
  *a3 = 0;
  v7 = -6;
  if ( a2 && (v8 = fopen(a2, "r"), v7 = -7, v8) )
    return psGetFileBufFp(a1, v8, a3, a4);
  else
    return v7;
}
// 4E9FA8: using guessed type int   fopen(_DWORD, _DWORD);

//----- (00495F20) --------------------------------------------------------
int sub_495F20()
{
  int (*v0)(void); // $t9
  int result; // $v0
  int (**v2)(void); // $s0

  v0 = (int (*)(void))dword_4E33E8;
  result = -1;
  if ( dword_4E33E8 != -1 )
  {
    v2 = (int (**)(void))0x4E33E4;
    do
    {
      result = v0();
      v0 = *v2;
    }
    while ( *v2-- != (int (*)(void))-1 );
  }
  return result;
}
// 4E33E8: using guessed type int dword_4E33E8;

//----- (004966B0) --------------------------------------------------------
int term_proc()
{
  return sub_408C40();
}

// nfuncs=1343 queued=1116 decompiled=1116 lumina nreq=0 worse=0 better=0
// ALL OK, 1116 function(s) have been successfully decompiled